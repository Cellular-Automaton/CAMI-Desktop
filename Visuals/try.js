(function(){"use strict";try{if(typeof document<"u"){var t=document.createElement("style");t.appendChild(document.createTextNode('/*! tailwindcss v4.1.13 | MIT License | https://tailwindcss.com */@layer properties{@supports (((-webkit-hyphens:none)) and (not (margin-trim:inline))) or ((-moz-orient:inline) and (not (color:rgb(from red r g b)))){*,:before,:after,::backdrop{--tw-translate-x:0;--tw-translate-y:0;--tw-translate-z:0;--tw-rotate-x:initial;--tw-rotate-y:initial;--tw-rotate-z:initial;--tw-skew-x:initial;--tw-skew-y:initial;--tw-font-weight:initial;--tw-shadow:0 0 #0000;--tw-shadow-color:initial;--tw-shadow-alpha:100%;--tw-inset-shadow:0 0 #0000;--tw-inset-shadow-color:initial;--tw-inset-shadow-alpha:100%;--tw-ring-color:initial;--tw-ring-shadow:0 0 #0000;--tw-inset-ring-color:initial;--tw-inset-ring-shadow:0 0 #0000;--tw-ring-inset:initial;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-offset-shadow:0 0 #0000;--tw-backdrop-blur:initial;--tw-backdrop-brightness:initial;--tw-backdrop-contrast:initial;--tw-backdrop-grayscale:initial;--tw-backdrop-hue-rotate:initial;--tw-backdrop-invert:initial;--tw-backdrop-opacity:initial;--tw-backdrop-saturate:initial;--tw-backdrop-sepia:initial}}}@layer theme{:root,:host{--font-sans:ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";--font-mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;--color-black:#000;--color-white:#fff;--spacing:.25rem;--text-2xl:1.5rem;--text-2xl--line-height:calc(2/1.5);--font-weight-bold:700;--radius-md:.375rem;--blur-md:12px;--default-font-family:var(--font-sans);--default-mono-font-family:var(--font-mono)}}@layer base{*,:after,:before,::backdrop{box-sizing:border-box;border:0 solid;margin:0;padding:0}::file-selector-button{box-sizing:border-box;border:0 solid;margin:0;padding:0}html,:host{-webkit-text-size-adjust:100%;tab-size:4;line-height:1.5;font-family:var(--default-font-family,ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji");font-feature-settings:var(--default-font-feature-settings,normal);font-variation-settings:var(--default-font-variation-settings,normal);-webkit-tap-highlight-color:transparent}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;-webkit-text-decoration:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:var(--default-mono-font-family,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace);font-feature-settings:var(--default-mono-font-feature-settings,normal);font-variation-settings:var(--default-mono-font-variation-settings,normal);font-size:1em}small{font-size:80%}sub,sup{vertical-align:baseline;font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}:-moz-focusring{outline:auto}progress{vertical-align:baseline}summary{display:list-item}ol,ul,menu{list-style:none}img,svg,video,canvas,audio,iframe,embed,object{vertical-align:middle;display:block}img,video{max-width:100%;height:auto}button,input,select,optgroup,textarea{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}::file-selector-button{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}:where(select:is([multiple],[size])) optgroup{font-weight:bolder}:where(select:is([multiple],[size])) optgroup option{padding-inline-start:20px}::file-selector-button{margin-inline-end:4px}::placeholder{opacity:1}@supports (not ((-webkit-appearance:-apple-pay-button))) or (contain-intrinsic-size:1px){::placeholder{color:currentColor}@supports (color:color-mix(in lab,red,red)){::placeholder{color:color-mix(in oklab,currentcolor 50%,transparent)}}}textarea{resize:vertical}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-date-and-time-value{min-height:1lh;text-align:inherit}::-webkit-datetime-edit{display:inline-flex}::-webkit-datetime-edit-fields-wrapper{padding:0}::-webkit-datetime-edit{padding-block:0}::-webkit-datetime-edit-year-field{padding-block:0}::-webkit-datetime-edit-month-field{padding-block:0}::-webkit-datetime-edit-day-field{padding-block:0}::-webkit-datetime-edit-hour-field{padding-block:0}::-webkit-datetime-edit-minute-field{padding-block:0}::-webkit-datetime-edit-second-field{padding-block:0}::-webkit-datetime-edit-millisecond-field{padding-block:0}::-webkit-datetime-edit-meridiem-field{padding-block:0}::-webkit-calendar-picker-indicator{line-height:1}:-moz-ui-invalid{box-shadow:none}button,input:where([type=button],[type=reset],[type=submit]){appearance:button}::file-selector-button{appearance:button}::-webkit-inner-spin-button{height:auto}::-webkit-outer-spin-button{height:auto}[hidden]:where(:not([hidden=until-found])){display:none!important}}@layer components;@layer utilities{.absolute{position:absolute}.relative{position:relative}.top-1\\/2{top:50%}.right-2{right:calc(var(--spacing)*2)}.bottom-4{bottom:calc(var(--spacing)*4)}.left-1\\/2{left:50%}.z-10{z-index:10}.container{width:100%}@media (min-width:40rem){.container{max-width:40rem}}@media (min-width:48rem){.container{max-width:48rem}}@media (min-width:64rem){.container{max-width:64rem}}@media (min-width:80rem){.container{max-width:80rem}}@media (min-width:96rem){.container{max-width:96rem}}.mb-2{margin-bottom:calc(var(--spacing)*2)}.mb-4{margin-bottom:calc(var(--spacing)*4)}.contents{display:contents}.flex{display:flex}.grid{display:grid}.table{display:table}.h-full{height:100%}.w-1\\/2{width:50%}.w-1\\/5{width:20%}.w-full{width:100%}.min-w-80{min-width:calc(var(--spacing)*80)}.-translate-x-1\\/2{--tw-translate-x: -50% ;translate:var(--tw-translate-x)var(--tw-translate-y)}.-translate-y-1\\/2{--tw-translate-y: -50% ;translate:var(--tw-translate-x)var(--tw-translate-y)}.transform{transform:var(--tw-rotate-x,)var(--tw-rotate-y,)var(--tw-rotate-z,)var(--tw-skew-x,)var(--tw-skew-y,)}.resize{resize:both}.flex-col{flex-direction:column}.items-center{align-items:center}.justify-center{justify-content:center}.justify-end{justify-content:flex-end}.justify-start{justify-content:flex-start}.gap-2{gap:calc(var(--spacing)*2)}.gap-4{gap:calc(var(--spacing)*4)}.rounded-md{border-radius:var(--radius-md)}.border-white{border-color:var(--color-white)}.bg-white\\/80{background-color:#fffc}@supports (color:color-mix(in lab,red,red)){.bg-white\\/80{background-color:color-mix(in oklab,var(--color-white)80%,transparent)}}.p-2{padding:calc(var(--spacing)*2)}.px-5{padding-inline:calc(var(--spacing)*5)}.py-2{padding-block:calc(var(--spacing)*2)}.text-center{text-align:center}.text-2xl{font-size:var(--text-2xl);line-height:var(--tw-leading,var(--text-2xl--line-height))}.font-bold{--tw-font-weight:var(--font-weight-bold);font-weight:var(--font-weight-bold)}.text-black{color:var(--color-black)}.text-white{color:var(--color-white)}.shadow-md{--tw-shadow:0 4px 6px -1px var(--tw-shadow-color,#0000001a),0 2px 4px -2px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.backdrop-blur-md{--tw-backdrop-blur:blur(var(--blur-md));-webkit-backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,);backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,)}}@property --tw-translate-x{syntax:"*";inherits:false;initial-value:0}@property --tw-translate-y{syntax:"*";inherits:false;initial-value:0}@property --tw-translate-z{syntax:"*";inherits:false;initial-value:0}@property --tw-rotate-x{syntax:"*";inherits:false}@property --tw-rotate-y{syntax:"*";inherits:false}@property --tw-rotate-z{syntax:"*";inherits:false}@property --tw-skew-x{syntax:"*";inherits:false}@property --tw-skew-y{syntax:"*";inherits:false}@property --tw-font-weight{syntax:"*";inherits:false}@property --tw-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-shadow-color{syntax:"*";inherits:false}@property --tw-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-inset-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-inset-shadow-color{syntax:"*";inherits:false}@property --tw-inset-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-ring-color{syntax:"*";inherits:false}@property --tw-ring-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-inset-ring-color{syntax:"*";inherits:false}@property --tw-inset-ring-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-ring-inset{syntax:"*";inherits:false}@property --tw-ring-offset-width{syntax:"<length>";inherits:false;initial-value:0}@property --tw-ring-offset-color{syntax:"*";inherits:false;initial-value:#fff}@property --tw-ring-offset-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-backdrop-blur{syntax:"*";inherits:false}@property --tw-backdrop-brightness{syntax:"*";inherits:false}@property --tw-backdrop-contrast{syntax:"*";inherits:false}@property --tw-backdrop-grayscale{syntax:"*";inherits:false}@property --tw-backdrop-hue-rotate{syntax:"*";inherits:false}@property --tw-backdrop-invert{syntax:"*";inherits:false}@property --tw-backdrop-opacity{syntax:"*";inherits:false}@property --tw-backdrop-saturate{syntax:"*";inherits:false}@property --tw-backdrop-sepia{syntax:"*";inherits:false}')),document.head.appendChild(t)}}catch(e){console.error("vite-plugin-css-injected-by-js",e)}})();
function gM(n, t) {
  for (var e = 0; e < t.length; e++) {
    const i = t[e];
    if (typeof i != "string" && !Array.isArray(i)) {
      for (const s in i)
        if (s !== "default" && !(s in n)) {
          const o = Object.getOwnPropertyDescriptor(i, s);
          o && Object.defineProperty(n, s, o.get ? o : {
            enumerable: !0,
            get: () => i[s]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
function xh(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
var ip = { exports: {} }, el = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var qx;
function yM() {
  if (qx) return el;
  qx = 1;
  var n = Symbol.for("react.transitional.element"), t = Symbol.for("react.fragment");
  function e(i, s, o) {
    var l = null;
    if (o !== void 0 && (l = "" + o), s.key !== void 0 && (l = "" + s.key), "key" in s) {
      o = {};
      for (var c in s)
        c !== "key" && (o[c] = s[c]);
    } else o = s;
    return s = o.ref, {
      $$typeof: n,
      type: i,
      key: l,
      ref: s !== void 0 ? s : null,
      props: o
    };
  }
  return el.Fragment = t, el.jsx = e, el.jsxs = e, el;
}
var Kx;
function bM() {
  return Kx || (Kx = 1, ip.exports = yM()), ip.exports;
}
var et = bM(), rp = { exports: {} }, nl = {}, sp = { exports: {} }, ap = {};
/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Zx;
function vM() {
  return Zx || (Zx = 1, (function(n) {
    function t(B, I) {
      var rt = B.length;
      B.push(I);
      t: for (; 0 < rt; ) {
        var J = rt - 1 >>> 1, D = B[J];
        if (0 < s(D, I))
          B[J] = I, B[rt] = D, rt = J;
        else break t;
      }
    }
    function e(B) {
      return B.length === 0 ? null : B[0];
    }
    function i(B) {
      if (B.length === 0) return null;
      var I = B[0], rt = B.pop();
      if (rt !== I) {
        B[0] = rt;
        t: for (var J = 0, D = B.length, q = D >>> 1; J < q; ) {
          var ot = 2 * (J + 1) - 1, at = B[ot], lt = ot + 1, dt = B[lt];
          if (0 > s(at, rt))
            lt < D && 0 > s(dt, at) ? (B[J] = dt, B[lt] = rt, J = lt) : (B[J] = at, B[ot] = rt, J = ot);
          else if (lt < D && 0 > s(dt, rt))
            B[J] = dt, B[lt] = rt, J = lt;
          else break t;
        }
      }
      return I;
    }
    function s(B, I) {
      var rt = B.sortIndex - I.sortIndex;
      return rt !== 0 ? rt : B.id - I.id;
    }
    if (n.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
      var o = performance;
      n.unstable_now = function() {
        return o.now();
      };
    } else {
      var l = Date, c = l.now();
      n.unstable_now = function() {
        return l.now() - c;
      };
    }
    var d = [], f = [], m = 1, y = null, b = 3, v = !1, x = !1, S = !1, _ = !1, C = typeof setTimeout == "function" ? setTimeout : null, R = typeof clearTimeout == "function" ? clearTimeout : null, w = typeof setImmediate < "u" ? setImmediate : null;
    function E(B) {
      for (var I = e(f); I !== null; ) {
        if (I.callback === null) i(f);
        else if (I.startTime <= B)
          i(f), I.sortIndex = I.expirationTime, t(d, I);
        else break;
        I = e(f);
      }
    }
    function P(B) {
      if (S = !1, E(B), !x)
        if (e(d) !== null)
          x = !0, k || (k = !0, M());
        else {
          var I = e(f);
          I !== null && Q(P, I.startTime - B);
        }
    }
    var k = !1, G = -1, $ = 5, F = -1;
    function j() {
      return _ ? !0 : !(n.unstable_now() - F < $);
    }
    function H() {
      if (_ = !1, k) {
        var B = n.unstable_now();
        F = B;
        var I = !0;
        try {
          t: {
            x = !1, S && (S = !1, R(G), G = -1), v = !0;
            var rt = b;
            try {
              e: {
                for (E(B), y = e(d); y !== null && !(y.expirationTime > B && j()); ) {
                  var J = y.callback;
                  if (typeof J == "function") {
                    y.callback = null, b = y.priorityLevel;
                    var D = J(
                      y.expirationTime <= B
                    );
                    if (B = n.unstable_now(), typeof D == "function") {
                      y.callback = D, E(B), I = !0;
                      break e;
                    }
                    y === e(d) && i(d), E(B);
                  } else i(d);
                  y = e(d);
                }
                if (y !== null) I = !0;
                else {
                  var q = e(f);
                  q !== null && Q(
                    P,
                    q.startTime - B
                  ), I = !1;
                }
              }
              break t;
            } finally {
              y = null, b = rt, v = !1;
            }
            I = void 0;
          }
        } finally {
          I ? M() : k = !1;
        }
      }
    }
    var M;
    if (typeof w == "function")
      M = function() {
        w(H);
      };
    else if (typeof MessageChannel < "u") {
      var Y = new MessageChannel(), L = Y.port2;
      Y.port1.onmessage = H, M = function() {
        L.postMessage(null);
      };
    } else
      M = function() {
        C(H, 0);
      };
    function Q(B, I) {
      G = C(function() {
        B(n.unstable_now());
      }, I);
    }
    n.unstable_IdlePriority = 5, n.unstable_ImmediatePriority = 1, n.unstable_LowPriority = 4, n.unstable_NormalPriority = 3, n.unstable_Profiling = null, n.unstable_UserBlockingPriority = 2, n.unstable_cancelCallback = function(B) {
      B.callback = null;
    }, n.unstable_forceFrameRate = function(B) {
      0 > B || 125 < B ? console.error(
        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
      ) : $ = 0 < B ? Math.floor(1e3 / B) : 5;
    }, n.unstable_getCurrentPriorityLevel = function() {
      return b;
    }, n.unstable_next = function(B) {
      switch (b) {
        case 1:
        case 2:
        case 3:
          var I = 3;
          break;
        default:
          I = b;
      }
      var rt = b;
      b = I;
      try {
        return B();
      } finally {
        b = rt;
      }
    }, n.unstable_requestPaint = function() {
      _ = !0;
    }, n.unstable_runWithPriority = function(B, I) {
      switch (B) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          B = 3;
      }
      var rt = b;
      b = B;
      try {
        return I();
      } finally {
        b = rt;
      }
    }, n.unstable_scheduleCallback = function(B, I, rt) {
      var J = n.unstable_now();
      switch (typeof rt == "object" && rt !== null ? (rt = rt.delay, rt = typeof rt == "number" && 0 < rt ? J + rt : J) : rt = J, B) {
        case 1:
          var D = -1;
          break;
        case 2:
          D = 250;
          break;
        case 5:
          D = 1073741823;
          break;
        case 4:
          D = 1e4;
          break;
        default:
          D = 5e3;
      }
      return D = rt + D, B = {
        id: m++,
        callback: I,
        priorityLevel: B,
        startTime: rt,
        expirationTime: D,
        sortIndex: -1
      }, rt > J ? (B.sortIndex = rt, t(f, B), e(d) === null && B === e(f) && (S ? (R(G), G = -1) : S = !0, Q(P, rt - J))) : (B.sortIndex = D, t(d, B), x || v || (x = !0, k || (k = !0, M()))), B;
    }, n.unstable_shouldYield = j, n.unstable_wrapCallback = function(B) {
      var I = b;
      return function() {
        var rt = b;
        b = I;
        try {
          return B.apply(this, arguments);
        } finally {
          b = rt;
        }
      };
    };
  })(ap)), ap;
}
var Qx;
function xM() {
  return Qx || (Qx = 1, sp.exports = vM()), sp.exports;
}
var op = { exports: {} }, Ft = {};
/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Jx;
function _M() {
  if (Jx) return Ft;
  Jx = 1;
  var n = Symbol.for("react.transitional.element"), t = Symbol.for("react.portal"), e = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), s = Symbol.for("react.profiler"), o = Symbol.for("react.consumer"), l = Symbol.for("react.context"), c = Symbol.for("react.forward_ref"), d = Symbol.for("react.suspense"), f = Symbol.for("react.memo"), m = Symbol.for("react.lazy"), y = Symbol.iterator;
  function b(D) {
    return D === null || typeof D != "object" ? null : (D = y && D[y] || D["@@iterator"], typeof D == "function" ? D : null);
  }
  var v = {
    isMounted: function() {
      return !1;
    },
    enqueueForceUpdate: function() {
    },
    enqueueReplaceState: function() {
    },
    enqueueSetState: function() {
    }
  }, x = Object.assign, S = {};
  function _(D, q, ot) {
    this.props = D, this.context = q, this.refs = S, this.updater = ot || v;
  }
  _.prototype.isReactComponent = {}, _.prototype.setState = function(D, q) {
    if (typeof D != "object" && typeof D != "function" && D != null)
      throw Error(
        "takes an object of state variables to update or a function which returns an object of state variables."
      );
    this.updater.enqueueSetState(this, D, q, "setState");
  }, _.prototype.forceUpdate = function(D) {
    this.updater.enqueueForceUpdate(this, D, "forceUpdate");
  };
  function C() {
  }
  C.prototype = _.prototype;
  function R(D, q, ot) {
    this.props = D, this.context = q, this.refs = S, this.updater = ot || v;
  }
  var w = R.prototype = new C();
  w.constructor = R, x(w, _.prototype), w.isPureReactComponent = !0;
  var E = Array.isArray, P = { H: null, A: null, T: null, S: null, V: null }, k = Object.prototype.hasOwnProperty;
  function G(D, q, ot, at, lt, dt) {
    return ot = dt.ref, {
      $$typeof: n,
      type: D,
      key: q,
      ref: ot !== void 0 ? ot : null,
      props: dt
    };
  }
  function $(D, q) {
    return G(
      D.type,
      q,
      void 0,
      void 0,
      void 0,
      D.props
    );
  }
  function F(D) {
    return typeof D == "object" && D !== null && D.$$typeof === n;
  }
  function j(D) {
    var q = { "=": "=0", ":": "=2" };
    return "$" + D.replace(/[=:]/g, function(ot) {
      return q[ot];
    });
  }
  var H = /\/+/g;
  function M(D, q) {
    return typeof D == "object" && D !== null && D.key != null ? j("" + D.key) : q.toString(36);
  }
  function Y() {
  }
  function L(D) {
    switch (D.status) {
      case "fulfilled":
        return D.value;
      case "rejected":
        throw D.reason;
      default:
        switch (typeof D.status == "string" ? D.then(Y, Y) : (D.status = "pending", D.then(
          function(q) {
            D.status === "pending" && (D.status = "fulfilled", D.value = q);
          },
          function(q) {
            D.status === "pending" && (D.status = "rejected", D.reason = q);
          }
        )), D.status) {
          case "fulfilled":
            return D.value;
          case "rejected":
            throw D.reason;
        }
    }
    throw D;
  }
  function Q(D, q, ot, at, lt) {
    var dt = typeof D;
    (dt === "undefined" || dt === "boolean") && (D = null);
    var ht = !1;
    if (D === null) ht = !0;
    else
      switch (dt) {
        case "bigint":
        case "string":
        case "number":
          ht = !0;
          break;
        case "object":
          switch (D.$$typeof) {
            case n:
            case t:
              ht = !0;
              break;
            case m:
              return ht = D._init, Q(
                ht(D._payload),
                q,
                ot,
                at,
                lt
              );
          }
      }
    if (ht)
      return lt = lt(D), ht = at === "" ? "." + M(D, 0) : at, E(lt) ? (ot = "", ht != null && (ot = ht.replace(H, "$&/") + "/"), Q(lt, q, ot, "", function(Dt) {
        return Dt;
      })) : lt != null && (F(lt) && (lt = $(
        lt,
        ot + (lt.key == null || D && D.key === lt.key ? "" : ("" + lt.key).replace(
          H,
          "$&/"
        ) + "/") + ht
      )), q.push(lt)), 1;
    ht = 0;
    var Vt = at === "" ? "." : at + ":";
    if (E(D))
      for (var Rt = 0; Rt < D.length; Rt++)
        at = D[Rt], dt = Vt + M(at, Rt), ht += Q(
          at,
          q,
          ot,
          dt,
          lt
        );
    else if (Rt = b(D), typeof Rt == "function")
      for (D = Rt.call(D), Rt = 0; !(at = D.next()).done; )
        at = at.value, dt = Vt + M(at, Rt++), ht += Q(
          at,
          q,
          ot,
          dt,
          lt
        );
    else if (dt === "object") {
      if (typeof D.then == "function")
        return Q(
          L(D),
          q,
          ot,
          at,
          lt
        );
      throw q = String(D), Error(
        "Objects are not valid as a React child (found: " + (q === "[object Object]" ? "object with keys {" + Object.keys(D).join(", ") + "}" : q) + "). If you meant to render a collection of children, use an array instead."
      );
    }
    return ht;
  }
  function B(D, q, ot) {
    if (D == null) return D;
    var at = [], lt = 0;
    return Q(D, at, "", "", function(dt) {
      return q.call(ot, dt, lt++);
    }), at;
  }
  function I(D) {
    if (D._status === -1) {
      var q = D._result;
      q = q(), q.then(
        function(ot) {
          (D._status === 0 || D._status === -1) && (D._status = 1, D._result = ot);
        },
        function(ot) {
          (D._status === 0 || D._status === -1) && (D._status = 2, D._result = ot);
        }
      ), D._status === -1 && (D._status = 0, D._result = q);
    }
    if (D._status === 1) return D._result.default;
    throw D._result;
  }
  var rt = typeof reportError == "function" ? reportError : function(D) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
      var q = new window.ErrorEvent("error", {
        bubbles: !0,
        cancelable: !0,
        message: typeof D == "object" && D !== null && typeof D.message == "string" ? String(D.message) : String(D),
        error: D
      });
      if (!window.dispatchEvent(q)) return;
    } else if (typeof process == "object" && typeof process.emit == "function") {
      process.emit("uncaughtException", D);
      return;
    }
    console.error(D);
  };
  function J() {
  }
  return Ft.Children = {
    map: B,
    forEach: function(D, q, ot) {
      B(
        D,
        function() {
          q.apply(this, arguments);
        },
        ot
      );
    },
    count: function(D) {
      var q = 0;
      return B(D, function() {
        q++;
      }), q;
    },
    toArray: function(D) {
      return B(D, function(q) {
        return q;
      }) || [];
    },
    only: function(D) {
      if (!F(D))
        throw Error(
          "React.Children.only expected to receive a single React element child."
        );
      return D;
    }
  }, Ft.Component = _, Ft.Fragment = e, Ft.Profiler = s, Ft.PureComponent = R, Ft.StrictMode = i, Ft.Suspense = d, Ft.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = P, Ft.__COMPILER_RUNTIME = {
    __proto__: null,
    c: function(D) {
      return P.H.useMemoCache(D);
    }
  }, Ft.cache = function(D) {
    return function() {
      return D.apply(null, arguments);
    };
  }, Ft.cloneElement = function(D, q, ot) {
    if (D == null)
      throw Error(
        "The argument must be a React element, but you passed " + D + "."
      );
    var at = x({}, D.props), lt = D.key, dt = void 0;
    if (q != null)
      for (ht in q.ref !== void 0 && (dt = void 0), q.key !== void 0 && (lt = "" + q.key), q)
        !k.call(q, ht) || ht === "key" || ht === "__self" || ht === "__source" || ht === "ref" && q.ref === void 0 || (at[ht] = q[ht]);
    var ht = arguments.length - 2;
    if (ht === 1) at.children = ot;
    else if (1 < ht) {
      for (var Vt = Array(ht), Rt = 0; Rt < ht; Rt++)
        Vt[Rt] = arguments[Rt + 2];
      at.children = Vt;
    }
    return G(D.type, lt, void 0, void 0, dt, at);
  }, Ft.createContext = function(D) {
    return D = {
      $$typeof: l,
      _currentValue: D,
      _currentValue2: D,
      _threadCount: 0,
      Provider: null,
      Consumer: null
    }, D.Provider = D, D.Consumer = {
      $$typeof: o,
      _context: D
    }, D;
  }, Ft.createElement = function(D, q, ot) {
    var at, lt = {}, dt = null;
    if (q != null)
      for (at in q.key !== void 0 && (dt = "" + q.key), q)
        k.call(q, at) && at !== "key" && at !== "__self" && at !== "__source" && (lt[at] = q[at]);
    var ht = arguments.length - 2;
    if (ht === 1) lt.children = ot;
    else if (1 < ht) {
      for (var Vt = Array(ht), Rt = 0; Rt < ht; Rt++)
        Vt[Rt] = arguments[Rt + 2];
      lt.children = Vt;
    }
    if (D && D.defaultProps)
      for (at in ht = D.defaultProps, ht)
        lt[at] === void 0 && (lt[at] = ht[at]);
    return G(D, dt, void 0, void 0, null, lt);
  }, Ft.createRef = function() {
    return { current: null };
  }, Ft.forwardRef = function(D) {
    return { $$typeof: c, render: D };
  }, Ft.isValidElement = F, Ft.lazy = function(D) {
    return {
      $$typeof: m,
      _payload: { _status: -1, _result: D },
      _init: I
    };
  }, Ft.memo = function(D, q) {
    return {
      $$typeof: f,
      type: D,
      compare: q === void 0 ? null : q
    };
  }, Ft.startTransition = function(D) {
    var q = P.T, ot = {};
    P.T = ot;
    try {
      var at = D(), lt = P.S;
      lt !== null && lt(ot, at), typeof at == "object" && at !== null && typeof at.then == "function" && at.then(J, rt);
    } catch (dt) {
      rt(dt);
    } finally {
      P.T = q;
    }
  }, Ft.unstable_useCacheRefresh = function() {
    return P.H.useCacheRefresh();
  }, Ft.use = function(D) {
    return P.H.use(D);
  }, Ft.useActionState = function(D, q, ot) {
    return P.H.useActionState(D, q, ot);
  }, Ft.useCallback = function(D, q) {
    return P.H.useCallback(D, q);
  }, Ft.useContext = function(D) {
    return P.H.useContext(D);
  }, Ft.useDebugValue = function() {
  }, Ft.useDeferredValue = function(D, q) {
    return P.H.useDeferredValue(D, q);
  }, Ft.useEffect = function(D, q, ot) {
    var at = P.H;
    if (typeof ot == "function")
      throw Error(
        "useEffect CRUD overload is not enabled in this build of React."
      );
    return at.useEffect(D, q);
  }, Ft.useId = function() {
    return P.H.useId();
  }, Ft.useImperativeHandle = function(D, q, ot) {
    return P.H.useImperativeHandle(D, q, ot);
  }, Ft.useInsertionEffect = function(D, q) {
    return P.H.useInsertionEffect(D, q);
  }, Ft.useLayoutEffect = function(D, q) {
    return P.H.useLayoutEffect(D, q);
  }, Ft.useMemo = function(D, q) {
    return P.H.useMemo(D, q);
  }, Ft.useOptimistic = function(D, q) {
    return P.H.useOptimistic(D, q);
  }, Ft.useReducer = function(D, q, ot) {
    return P.H.useReducer(D, q, ot);
  }, Ft.useRef = function(D) {
    return P.H.useRef(D);
  }, Ft.useState = function(D) {
    return P.H.useState(D);
  }, Ft.useSyncExternalStore = function(D, q, ot) {
    return P.H.useSyncExternalStore(
      D,
      q,
      ot
    );
  }, Ft.useTransition = function() {
    return P.H.useTransition();
  }, Ft.version = "19.1.1", Ft;
}
var t_;
function Km() {
  return t_ || (t_ = 1, op.exports = _M()), op.exports;
}
var lp = { exports: {} }, vn = {};
/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var e_;
function SM() {
  if (e_) return vn;
  e_ = 1;
  var n = Km();
  function t(d) {
    var f = "https://react.dev/errors/" + d;
    if (1 < arguments.length) {
      f += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var m = 2; m < arguments.length; m++)
        f += "&args[]=" + encodeURIComponent(arguments[m]);
    }
    return "Minified React error #" + d + "; visit " + f + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function e() {
  }
  var i = {
    d: {
      f: e,
      r: function() {
        throw Error(t(522));
      },
      D: e,
      C: e,
      L: e,
      m: e,
      X: e,
      S: e,
      M: e
    },
    p: 0,
    findDOMNode: null
  }, s = Symbol.for("react.portal");
  function o(d, f, m) {
    var y = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
      $$typeof: s,
      key: y == null ? null : "" + y,
      children: d,
      containerInfo: f,
      implementation: m
    };
  }
  var l = n.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
  function c(d, f) {
    if (d === "font") return "";
    if (typeof f == "string")
      return f === "use-credentials" ? f : "";
  }
  return vn.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = i, vn.createPortal = function(d, f) {
    var m = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!f || f.nodeType !== 1 && f.nodeType !== 9 && f.nodeType !== 11)
      throw Error(t(299));
    return o(d, f, null, m);
  }, vn.flushSync = function(d) {
    var f = l.T, m = i.p;
    try {
      if (l.T = null, i.p = 2, d) return d();
    } finally {
      l.T = f, i.p = m, i.d.f();
    }
  }, vn.preconnect = function(d, f) {
    typeof d == "string" && (f ? (f = f.crossOrigin, f = typeof f == "string" ? f === "use-credentials" ? f : "" : void 0) : f = null, i.d.C(d, f));
  }, vn.prefetchDNS = function(d) {
    typeof d == "string" && i.d.D(d);
  }, vn.preinit = function(d, f) {
    if (typeof d == "string" && f && typeof f.as == "string") {
      var m = f.as, y = c(m, f.crossOrigin), b = typeof f.integrity == "string" ? f.integrity : void 0, v = typeof f.fetchPriority == "string" ? f.fetchPriority : void 0;
      m === "style" ? i.d.S(
        d,
        typeof f.precedence == "string" ? f.precedence : void 0,
        {
          crossOrigin: y,
          integrity: b,
          fetchPriority: v
        }
      ) : m === "script" && i.d.X(d, {
        crossOrigin: y,
        integrity: b,
        fetchPriority: v,
        nonce: typeof f.nonce == "string" ? f.nonce : void 0
      });
    }
  }, vn.preinitModule = function(d, f) {
    if (typeof d == "string")
      if (typeof f == "object" && f !== null) {
        if (f.as == null || f.as === "script") {
          var m = c(
            f.as,
            f.crossOrigin
          );
          i.d.M(d, {
            crossOrigin: m,
            integrity: typeof f.integrity == "string" ? f.integrity : void 0,
            nonce: typeof f.nonce == "string" ? f.nonce : void 0
          });
        }
      } else f == null && i.d.M(d);
  }, vn.preload = function(d, f) {
    if (typeof d == "string" && typeof f == "object" && f !== null && typeof f.as == "string") {
      var m = f.as, y = c(m, f.crossOrigin);
      i.d.L(d, m, {
        crossOrigin: y,
        integrity: typeof f.integrity == "string" ? f.integrity : void 0,
        nonce: typeof f.nonce == "string" ? f.nonce : void 0,
        type: typeof f.type == "string" ? f.type : void 0,
        fetchPriority: typeof f.fetchPriority == "string" ? f.fetchPriority : void 0,
        referrerPolicy: typeof f.referrerPolicy == "string" ? f.referrerPolicy : void 0,
        imageSrcSet: typeof f.imageSrcSet == "string" ? f.imageSrcSet : void 0,
        imageSizes: typeof f.imageSizes == "string" ? f.imageSizes : void 0,
        media: typeof f.media == "string" ? f.media : void 0
      });
    }
  }, vn.preloadModule = function(d, f) {
    if (typeof d == "string")
      if (f) {
        var m = c(f.as, f.crossOrigin);
        i.d.m(d, {
          as: typeof f.as == "string" && f.as !== "script" ? f.as : void 0,
          crossOrigin: m,
          integrity: typeof f.integrity == "string" ? f.integrity : void 0
        });
      } else i.d.m(d);
  }, vn.requestFormReset = function(d) {
    i.d.r(d);
  }, vn.unstable_batchedUpdates = function(d, f) {
    return d(f);
  }, vn.useFormState = function(d, f, m) {
    return l.H.useFormState(d, f, m);
  }, vn.useFormStatus = function() {
    return l.H.useHostTransitionStatus();
  }, vn.version = "19.1.1", vn;
}
var n_;
function YS() {
  if (n_) return lp.exports;
  n_ = 1;
  function n() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n);
      } catch (t) {
        console.error(t);
      }
  }
  return n(), lp.exports = SM(), lp.exports;
}
/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var i_;
function TM() {
  if (i_) return nl;
  i_ = 1;
  var n = xM(), t = Km(), e = YS();
  function i(r) {
    var a = "https://react.dev/errors/" + r;
    if (1 < arguments.length) {
      a += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var u = 2; u < arguments.length; u++)
        a += "&args[]=" + encodeURIComponent(arguments[u]);
    }
    return "Minified React error #" + r + "; visit " + a + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function s(r) {
    return !(!r || r.nodeType !== 1 && r.nodeType !== 9 && r.nodeType !== 11);
  }
  function o(r) {
    var a = r, u = r;
    if (r.alternate) for (; a.return; ) a = a.return;
    else {
      r = a;
      do
        a = r, (a.flags & 4098) !== 0 && (u = a.return), r = a.return;
      while (r);
    }
    return a.tag === 3 ? u : null;
  }
  function l(r) {
    if (r.tag === 13) {
      var a = r.memoizedState;
      if (a === null && (r = r.alternate, r !== null && (a = r.memoizedState)), a !== null) return a.dehydrated;
    }
    return null;
  }
  function c(r) {
    if (o(r) !== r)
      throw Error(i(188));
  }
  function d(r) {
    var a = r.alternate;
    if (!a) {
      if (a = o(r), a === null) throw Error(i(188));
      return a !== r ? null : r;
    }
    for (var u = r, h = a; ; ) {
      var p = u.return;
      if (p === null) break;
      var g = p.alternate;
      if (g === null) {
        if (h = p.return, h !== null) {
          u = h;
          continue;
        }
        break;
      }
      if (p.child === g.child) {
        for (g = p.child; g; ) {
          if (g === u) return c(p), r;
          if (g === h) return c(p), a;
          g = g.sibling;
        }
        throw Error(i(188));
      }
      if (u.return !== h.return) u = p, h = g;
      else {
        for (var T = !1, A = p.child; A; ) {
          if (A === u) {
            T = !0, u = p, h = g;
            break;
          }
          if (A === h) {
            T = !0, h = p, u = g;
            break;
          }
          A = A.sibling;
        }
        if (!T) {
          for (A = g.child; A; ) {
            if (A === u) {
              T = !0, u = g, h = p;
              break;
            }
            if (A === h) {
              T = !0, h = g, u = p;
              break;
            }
            A = A.sibling;
          }
          if (!T) throw Error(i(189));
        }
      }
      if (u.alternate !== h) throw Error(i(190));
    }
    if (u.tag !== 3) throw Error(i(188));
    return u.stateNode.current === u ? r : a;
  }
  function f(r) {
    var a = r.tag;
    if (a === 5 || a === 26 || a === 27 || a === 6) return r;
    for (r = r.child; r !== null; ) {
      if (a = f(r), a !== null) return a;
      r = r.sibling;
    }
    return null;
  }
  var m = Object.assign, y = Symbol.for("react.element"), b = Symbol.for("react.transitional.element"), v = Symbol.for("react.portal"), x = Symbol.for("react.fragment"), S = Symbol.for("react.strict_mode"), _ = Symbol.for("react.profiler"), C = Symbol.for("react.provider"), R = Symbol.for("react.consumer"), w = Symbol.for("react.context"), E = Symbol.for("react.forward_ref"), P = Symbol.for("react.suspense"), k = Symbol.for("react.suspense_list"), G = Symbol.for("react.memo"), $ = Symbol.for("react.lazy"), F = Symbol.for("react.activity"), j = Symbol.for("react.memo_cache_sentinel"), H = Symbol.iterator;
  function M(r) {
    return r === null || typeof r != "object" ? null : (r = H && r[H] || r["@@iterator"], typeof r == "function" ? r : null);
  }
  var Y = Symbol.for("react.client.reference");
  function L(r) {
    if (r == null) return null;
    if (typeof r == "function")
      return r.$$typeof === Y ? null : r.displayName || r.name || null;
    if (typeof r == "string") return r;
    switch (r) {
      case x:
        return "Fragment";
      case _:
        return "Profiler";
      case S:
        return "StrictMode";
      case P:
        return "Suspense";
      case k:
        return "SuspenseList";
      case F:
        return "Activity";
    }
    if (typeof r == "object")
      switch (r.$$typeof) {
        case v:
          return "Portal";
        case w:
          return (r.displayName || "Context") + ".Provider";
        case R:
          return (r._context.displayName || "Context") + ".Consumer";
        case E:
          var a = r.render;
          return r = r.displayName, r || (r = a.displayName || a.name || "", r = r !== "" ? "ForwardRef(" + r + ")" : "ForwardRef"), r;
        case G:
          return a = r.displayName || null, a !== null ? a : L(r.type) || "Memo";
        case $:
          a = r._payload, r = r._init;
          try {
            return L(r(a));
          } catch {
          }
      }
    return null;
  }
  var Q = Array.isArray, B = t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, I = e.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, rt = {
    pending: !1,
    data: null,
    method: null,
    action: null
  }, J = [], D = -1;
  function q(r) {
    return { current: r };
  }
  function ot(r) {
    0 > D || (r.current = J[D], J[D] = null, D--);
  }
  function at(r, a) {
    D++, J[D] = r.current, r.current = a;
  }
  var lt = q(null), dt = q(null), ht = q(null), Vt = q(null);
  function Rt(r, a) {
    switch (at(ht, a), at(dt, r), at(lt, null), a.nodeType) {
      case 9:
      case 11:
        r = (r = a.documentElement) && (r = r.namespaceURI) ? Tx(r) : 0;
        break;
      default:
        if (r = a.tagName, a = a.namespaceURI)
          a = Tx(a), r = wx(a, r);
        else
          switch (r) {
            case "svg":
              r = 1;
              break;
            case "math":
              r = 2;
              break;
            default:
              r = 0;
          }
    }
    ot(lt), at(lt, r);
  }
  function Dt() {
    ot(lt), ot(dt), ot(ht);
  }
  function gt(r) {
    r.memoizedState !== null && at(Vt, r);
    var a = lt.current, u = wx(a, r.type);
    a !== u && (at(dt, r), at(lt, u));
  }
  function Pt(r) {
    dt.current === r && (ot(lt), ot(dt)), Vt.current === r && (ot(Vt), Ko._currentValue = rt);
  }
  var Et = Object.prototype.hasOwnProperty, It = n.unstable_scheduleCallback, wt = n.unstable_cancelCallback, Yt = n.unstable_shouldYield, Ie = n.unstable_requestPaint, Gt = n.unstable_now, pe = n.unstable_getCurrentPriorityLevel, Je = n.unstable_ImmediatePriority, De = n.unstable_UserBlockingPriority, le = n.unstable_NormalPriority, xt = n.unstable_LowPriority, sn = n.unstable_IdlePriority, Me = n.log, ct = n.unstable_setDisableYieldValue, ut = null, yt = null;
  function Bt(r) {
    if (typeof Me == "function" && ct(r), yt && typeof yt.setStrictMode == "function")
      try {
        yt.setStrictMode(ut, r);
      } catch {
      }
  }
  var Ct = Math.clz32 ? Math.clz32 : We, kt = Math.log, Wt = Math.LN2;
  function We(r) {
    return r >>>= 0, r === 0 ? 32 : 31 - (kt(r) / Wt | 0) | 0;
  }
  var ue = 256, an = 4194304;
  function pt(r) {
    var a = r & 42;
    if (a !== 0) return a;
    switch (r & -r) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
        return 64;
      case 128:
        return 128;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return r & 4194048;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return r & 62914560;
      case 67108864:
        return 67108864;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 0;
      default:
        return r;
    }
  }
  function Jt(r, a, u) {
    var h = r.pendingLanes;
    if (h === 0) return 0;
    var p = 0, g = r.suspendedLanes, T = r.pingedLanes;
    r = r.warmLanes;
    var A = h & 134217727;
    return A !== 0 ? (h = A & ~g, h !== 0 ? p = pt(h) : (T &= A, T !== 0 ? p = pt(T) : u || (u = A & ~r, u !== 0 && (p = pt(u))))) : (A = h & ~g, A !== 0 ? p = pt(A) : T !== 0 ? p = pt(T) : u || (u = h & ~r, u !== 0 && (p = pt(u)))), p === 0 ? 0 : a !== 0 && a !== p && (a & g) === 0 && (g = p & -p, u = a & -a, g >= u || g === 32 && (u & 4194048) !== 0) ? a : p;
  }
  function xe(r, a) {
    return (r.pendingLanes & ~(r.suspendedLanes & ~r.pingedLanes) & a) === 0;
  }
  function Ai(r, a) {
    switch (r) {
      case 1:
      case 2:
      case 4:
      case 8:
      case 64:
        return a + 250;
      case 16:
      case 32:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return a + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return -1;
      case 67108864:
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function Vi() {
    var r = ue;
    return ue <<= 1, (ue & 4194048) === 0 && (ue = 256), r;
  }
  function Is() {
    var r = an;
    return an <<= 1, (an & 62914560) === 0 && (an = 4194304), r;
  }
  function so(r) {
    for (var a = [], u = 0; 31 > u; u++) a.push(r);
    return a;
  }
  function we(r, a) {
    r.pendingLanes |= a, a !== 268435456 && (r.suspendedLanes = 0, r.pingedLanes = 0, r.warmLanes = 0);
  }
  function tn(r, a, u, h, p, g) {
    var T = r.pendingLanes;
    r.pendingLanes = u, r.suspendedLanes = 0, r.pingedLanes = 0, r.warmLanes = 0, r.expiredLanes &= u, r.entangledLanes &= u, r.errorRecoveryDisabledLanes &= u, r.shellSuspendCounter = 0;
    var A = r.entanglements, U = r.expirationTimes, X = r.hiddenUpdates;
    for (u = T & ~u; 0 < u; ) {
      var nt = 31 - Ct(u), st = 1 << nt;
      A[nt] = 0, U[nt] = -1;
      var K = X[nt];
      if (K !== null)
        for (X[nt] = null, nt = 0; nt < K.length; nt++) {
          var Z = K[nt];
          Z !== null && (Z.lane &= -536870913);
        }
      u &= ~st;
    }
    h !== 0 && zs(r, h, 0), g !== 0 && p === 0 && r.tag !== 0 && (r.suspendedLanes |= g & ~(T & ~a));
  }
  function zs(r, a, u) {
    r.pendingLanes |= a, r.suspendedLanes &= ~a;
    var h = 31 - Ct(a);
    r.entangledLanes |= a, r.entanglements[h] = r.entanglements[h] | 1073741824 | u & 4194090;
  }
  function is(r, a) {
    var u = r.entangledLanes |= a;
    for (r = r.entanglements; u; ) {
      var h = 31 - Ct(u), p = 1 << h;
      p & a | r[h] & a && (r[h] |= a), u &= ~p;
    }
  }
  function zn(r) {
    switch (r) {
      case 2:
        r = 1;
        break;
      case 8:
        r = 4;
        break;
      case 32:
        r = 16;
        break;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        r = 128;
        break;
      case 268435456:
        r = 134217728;
        break;
      default:
        r = 0;
    }
    return r;
  }
  function Yh(r) {
    return r &= -r, 2 < r ? 8 < r ? (r & 134217727) !== 0 ? 32 : 268435456 : 8 : 2;
  }
  function cy() {
    var r = I.p;
    return r !== 0 ? r : (r = window.event, r === void 0 ? 32 : $x(r.type));
  }
  function sE(r, a) {
    var u = I.p;
    try {
      return I.p = r, a();
    } finally {
      I.p = u;
    }
  }
  var wr = Math.random().toString(36).slice(2), yn = "__reactFiber$" + wr, kn = "__reactProps$" + wr, Ls = "__reactContainer$" + wr, Xh = "__reactEvents$" + wr, aE = "__reactListeners$" + wr, oE = "__reactHandles$" + wr, hy = "__reactResources$" + wr, ao = "__reactMarker$" + wr;
  function qh(r) {
    delete r[yn], delete r[kn], delete r[Xh], delete r[aE], delete r[oE];
  }
  function Fs(r) {
    var a = r[yn];
    if (a) return a;
    for (var u = r.parentNode; u; ) {
      if (a = u[Ls] || u[yn]) {
        if (u = a.alternate, a.child !== null || u !== null && u.child !== null)
          for (r = Ax(r); r !== null; ) {
            if (u = r[yn]) return u;
            r = Ax(r);
          }
        return a;
      }
      r = u, u = r.parentNode;
    }
    return null;
  }
  function Hs(r) {
    if (r = r[yn] || r[Ls]) {
      var a = r.tag;
      if (a === 5 || a === 6 || a === 13 || a === 26 || a === 27 || a === 3)
        return r;
    }
    return null;
  }
  function oo(r) {
    var a = r.tag;
    if (a === 5 || a === 26 || a === 27 || a === 6) return r.stateNode;
    throw Error(i(33));
  }
  function $s(r) {
    var a = r[hy];
    return a || (a = r[hy] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() }), a;
  }
  function on(r) {
    r[ao] = !0;
  }
  var dy = /* @__PURE__ */ new Set(), fy = {};
  function rs(r, a) {
    Ws(r, a), Ws(r + "Capture", a);
  }
  function Ws(r, a) {
    for (fy[r] = a, r = 0; r < a.length; r++)
      dy.add(a[r]);
  }
  var lE = RegExp(
    "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
  ), py = {}, my = {};
  function uE(r) {
    return Et.call(my, r) ? !0 : Et.call(py, r) ? !1 : lE.test(r) ? my[r] = !0 : (py[r] = !0, !1);
  }
  function ou(r, a, u) {
    if (uE(a))
      if (u === null) r.removeAttribute(a);
      else {
        switch (typeof u) {
          case "undefined":
          case "function":
          case "symbol":
            r.removeAttribute(a);
            return;
          case "boolean":
            var h = a.toLowerCase().slice(0, 5);
            if (h !== "data-" && h !== "aria-") {
              r.removeAttribute(a);
              return;
            }
        }
        r.setAttribute(a, "" + u);
      }
  }
  function lu(r, a, u) {
    if (u === null) r.removeAttribute(a);
    else {
      switch (typeof u) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          r.removeAttribute(a);
          return;
      }
      r.setAttribute(a, "" + u);
    }
  }
  function ji(r, a, u, h) {
    if (h === null) r.removeAttribute(u);
    else {
      switch (typeof h) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          r.removeAttribute(u);
          return;
      }
      r.setAttributeNS(a, u, "" + h);
    }
  }
  var Kh, gy;
  function Vs(r) {
    if (Kh === void 0)
      try {
        throw Error();
      } catch (u) {
        var a = u.stack.trim().match(/\n( *(at )?)/);
        Kh = a && a[1] || "", gy = -1 < u.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < u.stack.indexOf("@") ? "@unknown:0:0" : "";
      }
    return `
` + Kh + r + gy;
  }
  var Zh = !1;
  function Qh(r, a) {
    if (!r || Zh) return "";
    Zh = !0;
    var u = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      var h = {
        DetermineComponentFrameRoot: function() {
          try {
            if (a) {
              var st = function() {
                throw Error();
              };
              if (Object.defineProperty(st.prototype, "props", {
                set: function() {
                  throw Error();
                }
              }), typeof Reflect == "object" && Reflect.construct) {
                try {
                  Reflect.construct(st, []);
                } catch (Z) {
                  var K = Z;
                }
                Reflect.construct(r, [], st);
              } else {
                try {
                  st.call();
                } catch (Z) {
                  K = Z;
                }
                r.call(st.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (Z) {
                K = Z;
              }
              (st = r()) && typeof st.catch == "function" && st.catch(function() {
              });
            }
          } catch (Z) {
            if (Z && K && typeof Z.stack == "string")
              return [Z.stack, K.stack];
          }
          return [null, null];
        }
      };
      h.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
      var p = Object.getOwnPropertyDescriptor(
        h.DetermineComponentFrameRoot,
        "name"
      );
      p && p.configurable && Object.defineProperty(
        h.DetermineComponentFrameRoot,
        "name",
        { value: "DetermineComponentFrameRoot" }
      );
      var g = h.DetermineComponentFrameRoot(), T = g[0], A = g[1];
      if (T && A) {
        var U = T.split(`
`), X = A.split(`
`);
        for (p = h = 0; h < U.length && !U[h].includes("DetermineComponentFrameRoot"); )
          h++;
        for (; p < X.length && !X[p].includes(
          "DetermineComponentFrameRoot"
        ); )
          p++;
        if (h === U.length || p === X.length)
          for (h = U.length - 1, p = X.length - 1; 1 <= h && 0 <= p && U[h] !== X[p]; )
            p--;
        for (; 1 <= h && 0 <= p; h--, p--)
          if (U[h] !== X[p]) {
            if (h !== 1 || p !== 1)
              do
                if (h--, p--, 0 > p || U[h] !== X[p]) {
                  var nt = `
` + U[h].replace(" at new ", " at ");
                  return r.displayName && nt.includes("<anonymous>") && (nt = nt.replace("<anonymous>", r.displayName)), nt;
                }
              while (1 <= h && 0 <= p);
            break;
          }
      }
    } finally {
      Zh = !1, Error.prepareStackTrace = u;
    }
    return (u = r ? r.displayName || r.name : "") ? Vs(u) : "";
  }
  function cE(r) {
    switch (r.tag) {
      case 26:
      case 27:
      case 5:
        return Vs(r.type);
      case 16:
        return Vs("Lazy");
      case 13:
        return Vs("Suspense");
      case 19:
        return Vs("SuspenseList");
      case 0:
      case 15:
        return Qh(r.type, !1);
      case 11:
        return Qh(r.type.render, !1);
      case 1:
        return Qh(r.type, !0);
      case 31:
        return Vs("Activity");
      default:
        return "";
    }
  }
  function yy(r) {
    try {
      var a = "";
      do
        a += cE(r), r = r.return;
      while (r);
      return a;
    } catch (u) {
      return `
Error generating stack: ` + u.message + `
` + u.stack;
    }
  }
  function ti(r) {
    switch (typeof r) {
      case "bigint":
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return r;
      case "object":
        return r;
      default:
        return "";
    }
  }
  function by(r) {
    var a = r.type;
    return (r = r.nodeName) && r.toLowerCase() === "input" && (a === "checkbox" || a === "radio");
  }
  function hE(r) {
    var a = by(r) ? "checked" : "value", u = Object.getOwnPropertyDescriptor(
      r.constructor.prototype,
      a
    ), h = "" + r[a];
    if (!r.hasOwnProperty(a) && typeof u < "u" && typeof u.get == "function" && typeof u.set == "function") {
      var p = u.get, g = u.set;
      return Object.defineProperty(r, a, {
        configurable: !0,
        get: function() {
          return p.call(this);
        },
        set: function(T) {
          h = "" + T, g.call(this, T);
        }
      }), Object.defineProperty(r, a, {
        enumerable: u.enumerable
      }), {
        getValue: function() {
          return h;
        },
        setValue: function(T) {
          h = "" + T;
        },
        stopTracking: function() {
          r._valueTracker = null, delete r[a];
        }
      };
    }
  }
  function uu(r) {
    r._valueTracker || (r._valueTracker = hE(r));
  }
  function vy(r) {
    if (!r) return !1;
    var a = r._valueTracker;
    if (!a) return !0;
    var u = a.getValue(), h = "";
    return r && (h = by(r) ? r.checked ? "true" : "false" : r.value), r = h, r !== u ? (a.setValue(r), !0) : !1;
  }
  function cu(r) {
    if (r = r || (typeof document < "u" ? document : void 0), typeof r > "u") return null;
    try {
      return r.activeElement || r.body;
    } catch {
      return r.body;
    }
  }
  var dE = /[\n"\\]/g;
  function ei(r) {
    return r.replace(
      dE,
      function(a) {
        return "\\" + a.charCodeAt(0).toString(16) + " ";
      }
    );
  }
  function Jh(r, a, u, h, p, g, T, A) {
    r.name = "", T != null && typeof T != "function" && typeof T != "symbol" && typeof T != "boolean" ? r.type = T : r.removeAttribute("type"), a != null ? T === "number" ? (a === 0 && r.value === "" || r.value != a) && (r.value = "" + ti(a)) : r.value !== "" + ti(a) && (r.value = "" + ti(a)) : T !== "submit" && T !== "reset" || r.removeAttribute("value"), a != null ? td(r, T, ti(a)) : u != null ? td(r, T, ti(u)) : h != null && r.removeAttribute("value"), p == null && g != null && (r.defaultChecked = !!g), p != null && (r.checked = p && typeof p != "function" && typeof p != "symbol"), A != null && typeof A != "function" && typeof A != "symbol" && typeof A != "boolean" ? r.name = "" + ti(A) : r.removeAttribute("name");
  }
  function xy(r, a, u, h, p, g, T, A) {
    if (g != null && typeof g != "function" && typeof g != "symbol" && typeof g != "boolean" && (r.type = g), a != null || u != null) {
      if (!(g !== "submit" && g !== "reset" || a != null))
        return;
      u = u != null ? "" + ti(u) : "", a = a != null ? "" + ti(a) : u, A || a === r.value || (r.value = a), r.defaultValue = a;
    }
    h = h ?? p, h = typeof h != "function" && typeof h != "symbol" && !!h, r.checked = A ? r.checked : !!h, r.defaultChecked = !!h, T != null && typeof T != "function" && typeof T != "symbol" && typeof T != "boolean" && (r.name = T);
  }
  function td(r, a, u) {
    a === "number" && cu(r.ownerDocument) === r || r.defaultValue === "" + u || (r.defaultValue = "" + u);
  }
  function js(r, a, u, h) {
    if (r = r.options, a) {
      a = {};
      for (var p = 0; p < u.length; p++)
        a["$" + u[p]] = !0;
      for (u = 0; u < r.length; u++)
        p = a.hasOwnProperty("$" + r[u].value), r[u].selected !== p && (r[u].selected = p), p && h && (r[u].defaultSelected = !0);
    } else {
      for (u = "" + ti(u), a = null, p = 0; p < r.length; p++) {
        if (r[p].value === u) {
          r[p].selected = !0, h && (r[p].defaultSelected = !0);
          return;
        }
        a !== null || r[p].disabled || (a = r[p]);
      }
      a !== null && (a.selected = !0);
    }
  }
  function _y(r, a, u) {
    if (a != null && (a = "" + ti(a), a !== r.value && (r.value = a), u == null)) {
      r.defaultValue !== a && (r.defaultValue = a);
      return;
    }
    r.defaultValue = u != null ? "" + ti(u) : "";
  }
  function Sy(r, a, u, h) {
    if (a == null) {
      if (h != null) {
        if (u != null) throw Error(i(92));
        if (Q(h)) {
          if (1 < h.length) throw Error(i(93));
          h = h[0];
        }
        u = h;
      }
      u == null && (u = ""), a = u;
    }
    u = ti(a), r.defaultValue = u, h = r.textContent, h === u && h !== "" && h !== null && (r.value = h);
  }
  function Ys(r, a) {
    if (a) {
      var u = r.firstChild;
      if (u && u === r.lastChild && u.nodeType === 3) {
        u.nodeValue = a;
        return;
      }
    }
    r.textContent = a;
  }
  var fE = new Set(
    "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
      " "
    )
  );
  function Ty(r, a, u) {
    var h = a.indexOf("--") === 0;
    u == null || typeof u == "boolean" || u === "" ? h ? r.setProperty(a, "") : a === "float" ? r.cssFloat = "" : r[a] = "" : h ? r.setProperty(a, u) : typeof u != "number" || u === 0 || fE.has(a) ? a === "float" ? r.cssFloat = u : r[a] = ("" + u).trim() : r[a] = u + "px";
  }
  function wy(r, a, u) {
    if (a != null && typeof a != "object")
      throw Error(i(62));
    if (r = r.style, u != null) {
      for (var h in u)
        !u.hasOwnProperty(h) || a != null && a.hasOwnProperty(h) || (h.indexOf("--") === 0 ? r.setProperty(h, "") : h === "float" ? r.cssFloat = "" : r[h] = "");
      for (var p in a)
        h = a[p], a.hasOwnProperty(p) && u[p] !== h && Ty(r, p, h);
    } else
      for (var g in a)
        a.hasOwnProperty(g) && Ty(r, g, a[g]);
  }
  function ed(r) {
    if (r.indexOf("-") === -1) return !1;
    switch (r) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var pE = /* @__PURE__ */ new Map([
    ["acceptCharset", "accept-charset"],
    ["htmlFor", "for"],
    ["httpEquiv", "http-equiv"],
    ["crossOrigin", "crossorigin"],
    ["accentHeight", "accent-height"],
    ["alignmentBaseline", "alignment-baseline"],
    ["arabicForm", "arabic-form"],
    ["baselineShift", "baseline-shift"],
    ["capHeight", "cap-height"],
    ["clipPath", "clip-path"],
    ["clipRule", "clip-rule"],
    ["colorInterpolation", "color-interpolation"],
    ["colorInterpolationFilters", "color-interpolation-filters"],
    ["colorProfile", "color-profile"],
    ["colorRendering", "color-rendering"],
    ["dominantBaseline", "dominant-baseline"],
    ["enableBackground", "enable-background"],
    ["fillOpacity", "fill-opacity"],
    ["fillRule", "fill-rule"],
    ["floodColor", "flood-color"],
    ["floodOpacity", "flood-opacity"],
    ["fontFamily", "font-family"],
    ["fontSize", "font-size"],
    ["fontSizeAdjust", "font-size-adjust"],
    ["fontStretch", "font-stretch"],
    ["fontStyle", "font-style"],
    ["fontVariant", "font-variant"],
    ["fontWeight", "font-weight"],
    ["glyphName", "glyph-name"],
    ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
    ["glyphOrientationVertical", "glyph-orientation-vertical"],
    ["horizAdvX", "horiz-adv-x"],
    ["horizOriginX", "horiz-origin-x"],
    ["imageRendering", "image-rendering"],
    ["letterSpacing", "letter-spacing"],
    ["lightingColor", "lighting-color"],
    ["markerEnd", "marker-end"],
    ["markerMid", "marker-mid"],
    ["markerStart", "marker-start"],
    ["overlinePosition", "overline-position"],
    ["overlineThickness", "overline-thickness"],
    ["paintOrder", "paint-order"],
    ["panose-1", "panose-1"],
    ["pointerEvents", "pointer-events"],
    ["renderingIntent", "rendering-intent"],
    ["shapeRendering", "shape-rendering"],
    ["stopColor", "stop-color"],
    ["stopOpacity", "stop-opacity"],
    ["strikethroughPosition", "strikethrough-position"],
    ["strikethroughThickness", "strikethrough-thickness"],
    ["strokeDasharray", "stroke-dasharray"],
    ["strokeDashoffset", "stroke-dashoffset"],
    ["strokeLinecap", "stroke-linecap"],
    ["strokeLinejoin", "stroke-linejoin"],
    ["strokeMiterlimit", "stroke-miterlimit"],
    ["strokeOpacity", "stroke-opacity"],
    ["strokeWidth", "stroke-width"],
    ["textAnchor", "text-anchor"],
    ["textDecoration", "text-decoration"],
    ["textRendering", "text-rendering"],
    ["transformOrigin", "transform-origin"],
    ["underlinePosition", "underline-position"],
    ["underlineThickness", "underline-thickness"],
    ["unicodeBidi", "unicode-bidi"],
    ["unicodeRange", "unicode-range"],
    ["unitsPerEm", "units-per-em"],
    ["vAlphabetic", "v-alphabetic"],
    ["vHanging", "v-hanging"],
    ["vIdeographic", "v-ideographic"],
    ["vMathematical", "v-mathematical"],
    ["vectorEffect", "vector-effect"],
    ["vertAdvY", "vert-adv-y"],
    ["vertOriginX", "vert-origin-x"],
    ["vertOriginY", "vert-origin-y"],
    ["wordSpacing", "word-spacing"],
    ["writingMode", "writing-mode"],
    ["xmlnsXlink", "xmlns:xlink"],
    ["xHeight", "x-height"]
  ]), mE = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
  function hu(r) {
    return mE.test("" + r) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : r;
  }
  var nd = null;
  function id(r) {
    return r = r.target || r.srcElement || window, r.correspondingUseElement && (r = r.correspondingUseElement), r.nodeType === 3 ? r.parentNode : r;
  }
  var Xs = null, qs = null;
  function Cy(r) {
    var a = Hs(r);
    if (a && (r = a.stateNode)) {
      var u = r[kn] || null;
      t: switch (r = a.stateNode, a.type) {
        case "input":
          if (Jh(
            r,
            u.value,
            u.defaultValue,
            u.defaultValue,
            u.checked,
            u.defaultChecked,
            u.type,
            u.name
          ), a = u.name, u.type === "radio" && a != null) {
            for (u = r; u.parentNode; ) u = u.parentNode;
            for (u = u.querySelectorAll(
              'input[name="' + ei(
                "" + a
              ) + '"][type="radio"]'
            ), a = 0; a < u.length; a++) {
              var h = u[a];
              if (h !== r && h.form === r.form) {
                var p = h[kn] || null;
                if (!p) throw Error(i(90));
                Jh(
                  h,
                  p.value,
                  p.defaultValue,
                  p.defaultValue,
                  p.checked,
                  p.defaultChecked,
                  p.type,
                  p.name
                );
              }
            }
            for (a = 0; a < u.length; a++)
              h = u[a], h.form === r.form && vy(h);
          }
          break t;
        case "textarea":
          _y(r, u.value, u.defaultValue);
          break t;
        case "select":
          a = u.value, a != null && js(r, !!u.multiple, a, !1);
      }
    }
  }
  var rd = !1;
  function Ey(r, a, u) {
    if (rd) return r(a, u);
    rd = !0;
    try {
      var h = r(a);
      return h;
    } finally {
      if (rd = !1, (Xs !== null || qs !== null) && (Ku(), Xs && (a = Xs, r = qs, qs = Xs = null, Cy(a), r)))
        for (a = 0; a < r.length; a++) Cy(r[a]);
    }
  }
  function lo(r, a) {
    var u = r.stateNode;
    if (u === null) return null;
    var h = u[kn] || null;
    if (h === null) return null;
    u = h[a];
    t: switch (a) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (h = !h.disabled) || (r = r.type, h = !(r === "button" || r === "input" || r === "select" || r === "textarea")), r = !h;
        break t;
      default:
        r = !1;
    }
    if (r) return null;
    if (u && typeof u != "function")
      throw Error(
        i(231, a, typeof u)
      );
    return u;
  }
  var Yi = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), sd = !1;
  if (Yi)
    try {
      var uo = {};
      Object.defineProperty(uo, "passive", {
        get: function() {
          sd = !0;
        }
      }), window.addEventListener("test", uo, uo), window.removeEventListener("test", uo, uo);
    } catch {
      sd = !1;
    }
  var Cr = null, ad = null, du = null;
  function My() {
    if (du) return du;
    var r, a = ad, u = a.length, h, p = "value" in Cr ? Cr.value : Cr.textContent, g = p.length;
    for (r = 0; r < u && a[r] === p[r]; r++) ;
    var T = u - r;
    for (h = 1; h <= T && a[u - h] === p[g - h]; h++) ;
    return du = p.slice(r, 1 < h ? 1 - h : void 0);
  }
  function fu(r) {
    var a = r.keyCode;
    return "charCode" in r ? (r = r.charCode, r === 0 && a === 13 && (r = 13)) : r = a, r === 10 && (r = 13), 32 <= r || r === 13 ? r : 0;
  }
  function pu() {
    return !0;
  }
  function Ay() {
    return !1;
  }
  function On(r) {
    function a(u, h, p, g, T) {
      this._reactName = u, this._targetInst = p, this.type = h, this.nativeEvent = g, this.target = T, this.currentTarget = null;
      for (var A in r)
        r.hasOwnProperty(A) && (u = r[A], this[A] = u ? u(g) : g[A]);
      return this.isDefaultPrevented = (g.defaultPrevented != null ? g.defaultPrevented : g.returnValue === !1) ? pu : Ay, this.isPropagationStopped = Ay, this;
    }
    return m(a.prototype, {
      preventDefault: function() {
        this.defaultPrevented = !0;
        var u = this.nativeEvent;
        u && (u.preventDefault ? u.preventDefault() : typeof u.returnValue != "unknown" && (u.returnValue = !1), this.isDefaultPrevented = pu);
      },
      stopPropagation: function() {
        var u = this.nativeEvent;
        u && (u.stopPropagation ? u.stopPropagation() : typeof u.cancelBubble != "unknown" && (u.cancelBubble = !0), this.isPropagationStopped = pu);
      },
      persist: function() {
      },
      isPersistent: pu
    }), a;
  }
  var ss = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(r) {
      return r.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0
  }, mu = On(ss), co = m({}, ss, { view: 0, detail: 0 }), gE = On(co), od, ld, ho, gu = m({}, co, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: cd,
    button: 0,
    buttons: 0,
    relatedTarget: function(r) {
      return r.relatedTarget === void 0 ? r.fromElement === r.srcElement ? r.toElement : r.fromElement : r.relatedTarget;
    },
    movementX: function(r) {
      return "movementX" in r ? r.movementX : (r !== ho && (ho && r.type === "mousemove" ? (od = r.screenX - ho.screenX, ld = r.screenY - ho.screenY) : ld = od = 0, ho = r), od);
    },
    movementY: function(r) {
      return "movementY" in r ? r.movementY : ld;
    }
  }), Ry = On(gu), yE = m({}, gu, { dataTransfer: 0 }), bE = On(yE), vE = m({}, co, { relatedTarget: 0 }), ud = On(vE), xE = m({}, ss, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), _E = On(xE), SE = m({}, ss, {
    clipboardData: function(r) {
      return "clipboardData" in r ? r.clipboardData : window.clipboardData;
    }
  }), TE = On(SE), wE = m({}, ss, { data: 0 }), Py = On(wE), CE = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, EE = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, ME = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
  };
  function AE(r) {
    var a = this.nativeEvent;
    return a.getModifierState ? a.getModifierState(r) : (r = ME[r]) ? !!a[r] : !1;
  }
  function cd() {
    return AE;
  }
  var RE = m({}, co, {
    key: function(r) {
      if (r.key) {
        var a = CE[r.key] || r.key;
        if (a !== "Unidentified") return a;
      }
      return r.type === "keypress" ? (r = fu(r), r === 13 ? "Enter" : String.fromCharCode(r)) : r.type === "keydown" || r.type === "keyup" ? EE[r.keyCode] || "Unidentified" : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: cd,
    charCode: function(r) {
      return r.type === "keypress" ? fu(r) : 0;
    },
    keyCode: function(r) {
      return r.type === "keydown" || r.type === "keyup" ? r.keyCode : 0;
    },
    which: function(r) {
      return r.type === "keypress" ? fu(r) : r.type === "keydown" || r.type === "keyup" ? r.keyCode : 0;
    }
  }), PE = On(RE), BE = m({}, gu, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
  }), By = On(BE), kE = m({}, co, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: cd
  }), OE = On(kE), DE = m({}, ss, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), GE = On(DE), UE = m({}, gu, {
    deltaX: function(r) {
      return "deltaX" in r ? r.deltaX : "wheelDeltaX" in r ? -r.wheelDeltaX : 0;
    },
    deltaY: function(r) {
      return "deltaY" in r ? r.deltaY : "wheelDeltaY" in r ? -r.wheelDeltaY : "wheelDelta" in r ? -r.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), NE = On(UE), IE = m({}, ss, {
    newState: 0,
    oldState: 0
  }), zE = On(IE), LE = [9, 13, 27, 32], hd = Yi && "CompositionEvent" in window, fo = null;
  Yi && "documentMode" in document && (fo = document.documentMode);
  var FE = Yi && "TextEvent" in window && !fo, ky = Yi && (!hd || fo && 8 < fo && 11 >= fo), Oy = " ", Dy = !1;
  function Gy(r, a) {
    switch (r) {
      case "keyup":
        return LE.indexOf(a.keyCode) !== -1;
      case "keydown":
        return a.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function Uy(r) {
    return r = r.detail, typeof r == "object" && "data" in r ? r.data : null;
  }
  var Ks = !1;
  function HE(r, a) {
    switch (r) {
      case "compositionend":
        return Uy(a);
      case "keypress":
        return a.which !== 32 ? null : (Dy = !0, Oy);
      case "textInput":
        return r = a.data, r === Oy && Dy ? null : r;
      default:
        return null;
    }
  }
  function $E(r, a) {
    if (Ks)
      return r === "compositionend" || !hd && Gy(r, a) ? (r = My(), du = ad = Cr = null, Ks = !1, r) : null;
    switch (r) {
      case "paste":
        return null;
      case "keypress":
        if (!(a.ctrlKey || a.altKey || a.metaKey) || a.ctrlKey && a.altKey) {
          if (a.char && 1 < a.char.length)
            return a.char;
          if (a.which) return String.fromCharCode(a.which);
        }
        return null;
      case "compositionend":
        return ky && a.locale !== "ko" ? null : a.data;
      default:
        return null;
    }
  }
  var WE = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
  };
  function Ny(r) {
    var a = r && r.nodeName && r.nodeName.toLowerCase();
    return a === "input" ? !!WE[r.type] : a === "textarea";
  }
  function Iy(r, a, u, h) {
    Xs ? qs ? qs.push(h) : qs = [h] : Xs = h, a = nc(a, "onChange"), 0 < a.length && (u = new mu(
      "onChange",
      "change",
      null,
      u,
      h
    ), r.push({ event: u, listeners: a }));
  }
  var po = null, mo = null;
  function VE(r) {
    bx(r, 0);
  }
  function yu(r) {
    var a = oo(r);
    if (vy(a)) return r;
  }
  function zy(r, a) {
    if (r === "change") return a;
  }
  var Ly = !1;
  if (Yi) {
    var dd;
    if (Yi) {
      var fd = "oninput" in document;
      if (!fd) {
        var Fy = document.createElement("div");
        Fy.setAttribute("oninput", "return;"), fd = typeof Fy.oninput == "function";
      }
      dd = fd;
    } else dd = !1;
    Ly = dd && (!document.documentMode || 9 < document.documentMode);
  }
  function Hy() {
    po && (po.detachEvent("onpropertychange", $y), mo = po = null);
  }
  function $y(r) {
    if (r.propertyName === "value" && yu(mo)) {
      var a = [];
      Iy(
        a,
        mo,
        r,
        id(r)
      ), Ey(VE, a);
    }
  }
  function jE(r, a, u) {
    r === "focusin" ? (Hy(), po = a, mo = u, po.attachEvent("onpropertychange", $y)) : r === "focusout" && Hy();
  }
  function YE(r) {
    if (r === "selectionchange" || r === "keyup" || r === "keydown")
      return yu(mo);
  }
  function XE(r, a) {
    if (r === "click") return yu(a);
  }
  function qE(r, a) {
    if (r === "input" || r === "change")
      return yu(a);
  }
  function KE(r, a) {
    return r === a && (r !== 0 || 1 / r === 1 / a) || r !== r && a !== a;
  }
  var Ln = typeof Object.is == "function" ? Object.is : KE;
  function go(r, a) {
    if (Ln(r, a)) return !0;
    if (typeof r != "object" || r === null || typeof a != "object" || a === null)
      return !1;
    var u = Object.keys(r), h = Object.keys(a);
    if (u.length !== h.length) return !1;
    for (h = 0; h < u.length; h++) {
      var p = u[h];
      if (!Et.call(a, p) || !Ln(r[p], a[p]))
        return !1;
    }
    return !0;
  }
  function Wy(r) {
    for (; r && r.firstChild; ) r = r.firstChild;
    return r;
  }
  function Vy(r, a) {
    var u = Wy(r);
    r = 0;
    for (var h; u; ) {
      if (u.nodeType === 3) {
        if (h = r + u.textContent.length, r <= a && h >= a)
          return { node: u, offset: a - r };
        r = h;
      }
      t: {
        for (; u; ) {
          if (u.nextSibling) {
            u = u.nextSibling;
            break t;
          }
          u = u.parentNode;
        }
        u = void 0;
      }
      u = Wy(u);
    }
  }
  function jy(r, a) {
    return r && a ? r === a ? !0 : r && r.nodeType === 3 ? !1 : a && a.nodeType === 3 ? jy(r, a.parentNode) : "contains" in r ? r.contains(a) : r.compareDocumentPosition ? !!(r.compareDocumentPosition(a) & 16) : !1 : !1;
  }
  function Yy(r) {
    r = r != null && r.ownerDocument != null && r.ownerDocument.defaultView != null ? r.ownerDocument.defaultView : window;
    for (var a = cu(r.document); a instanceof r.HTMLIFrameElement; ) {
      try {
        var u = typeof a.contentWindow.location.href == "string";
      } catch {
        u = !1;
      }
      if (u) r = a.contentWindow;
      else break;
      a = cu(r.document);
    }
    return a;
  }
  function pd(r) {
    var a = r && r.nodeName && r.nodeName.toLowerCase();
    return a && (a === "input" && (r.type === "text" || r.type === "search" || r.type === "tel" || r.type === "url" || r.type === "password") || a === "textarea" || r.contentEditable === "true");
  }
  var ZE = Yi && "documentMode" in document && 11 >= document.documentMode, Zs = null, md = null, yo = null, gd = !1;
  function Xy(r, a, u) {
    var h = u.window === u ? u.document : u.nodeType === 9 ? u : u.ownerDocument;
    gd || Zs == null || Zs !== cu(h) || (h = Zs, "selectionStart" in h && pd(h) ? h = { start: h.selectionStart, end: h.selectionEnd } : (h = (h.ownerDocument && h.ownerDocument.defaultView || window).getSelection(), h = {
      anchorNode: h.anchorNode,
      anchorOffset: h.anchorOffset,
      focusNode: h.focusNode,
      focusOffset: h.focusOffset
    }), yo && go(yo, h) || (yo = h, h = nc(md, "onSelect"), 0 < h.length && (a = new mu(
      "onSelect",
      "select",
      null,
      a,
      u
    ), r.push({ event: a, listeners: h }), a.target = Zs)));
  }
  function as(r, a) {
    var u = {};
    return u[r.toLowerCase()] = a.toLowerCase(), u["Webkit" + r] = "webkit" + a, u["Moz" + r] = "moz" + a, u;
  }
  var Qs = {
    animationend: as("Animation", "AnimationEnd"),
    animationiteration: as("Animation", "AnimationIteration"),
    animationstart: as("Animation", "AnimationStart"),
    transitionrun: as("Transition", "TransitionRun"),
    transitionstart: as("Transition", "TransitionStart"),
    transitioncancel: as("Transition", "TransitionCancel"),
    transitionend: as("Transition", "TransitionEnd")
  }, yd = {}, qy = {};
  Yi && (qy = document.createElement("div").style, "AnimationEvent" in window || (delete Qs.animationend.animation, delete Qs.animationiteration.animation, delete Qs.animationstart.animation), "TransitionEvent" in window || delete Qs.transitionend.transition);
  function os(r) {
    if (yd[r]) return yd[r];
    if (!Qs[r]) return r;
    var a = Qs[r], u;
    for (u in a)
      if (a.hasOwnProperty(u) && u in qy)
        return yd[r] = a[u];
    return r;
  }
  var Ky = os("animationend"), Zy = os("animationiteration"), Qy = os("animationstart"), QE = os("transitionrun"), JE = os("transitionstart"), t2 = os("transitioncancel"), Jy = os("transitionend"), tb = /* @__PURE__ */ new Map(), bd = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
    " "
  );
  bd.push("scrollEnd");
  function gi(r, a) {
    tb.set(r, a), rs(a, [r]);
  }
  var eb = /* @__PURE__ */ new WeakMap();
  function ni(r, a) {
    if (typeof r == "object" && r !== null) {
      var u = eb.get(r);
      return u !== void 0 ? u : (a = {
        value: r,
        source: a,
        stack: yy(a)
      }, eb.set(r, a), a);
    }
    return {
      value: r,
      source: a,
      stack: yy(a)
    };
  }
  var ii = [], Js = 0, vd = 0;
  function bu() {
    for (var r = Js, a = vd = Js = 0; a < r; ) {
      var u = ii[a];
      ii[a++] = null;
      var h = ii[a];
      ii[a++] = null;
      var p = ii[a];
      ii[a++] = null;
      var g = ii[a];
      if (ii[a++] = null, h !== null && p !== null) {
        var T = h.pending;
        T === null ? p.next = p : (p.next = T.next, T.next = p), h.pending = p;
      }
      g !== 0 && nb(u, p, g);
    }
  }
  function vu(r, a, u, h) {
    ii[Js++] = r, ii[Js++] = a, ii[Js++] = u, ii[Js++] = h, vd |= h, r.lanes |= h, r = r.alternate, r !== null && (r.lanes |= h);
  }
  function xd(r, a, u, h) {
    return vu(r, a, u, h), xu(r);
  }
  function ta(r, a) {
    return vu(r, null, null, a), xu(r);
  }
  function nb(r, a, u) {
    r.lanes |= u;
    var h = r.alternate;
    h !== null && (h.lanes |= u);
    for (var p = !1, g = r.return; g !== null; )
      g.childLanes |= u, h = g.alternate, h !== null && (h.childLanes |= u), g.tag === 22 && (r = g.stateNode, r === null || r._visibility & 1 || (p = !0)), r = g, g = g.return;
    return r.tag === 3 ? (g = r.stateNode, p && a !== null && (p = 31 - Ct(u), r = g.hiddenUpdates, h = r[p], h === null ? r[p] = [a] : h.push(a), a.lane = u | 536870912), g) : null;
  }
  function xu(r) {
    if (50 < Ho)
      throw Ho = 0, Mf = null, Error(i(185));
    for (var a = r.return; a !== null; )
      r = a, a = r.return;
    return r.tag === 3 ? r.stateNode : null;
  }
  var ea = {};
  function e2(r, a, u, h) {
    this.tag = r, this.key = u, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = a, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = h, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function Fn(r, a, u, h) {
    return new e2(r, a, u, h);
  }
  function _d(r) {
    return r = r.prototype, !(!r || !r.isReactComponent);
  }
  function Xi(r, a) {
    var u = r.alternate;
    return u === null ? (u = Fn(
      r.tag,
      a,
      r.key,
      r.mode
    ), u.elementType = r.elementType, u.type = r.type, u.stateNode = r.stateNode, u.alternate = r, r.alternate = u) : (u.pendingProps = a, u.type = r.type, u.flags = 0, u.subtreeFlags = 0, u.deletions = null), u.flags = r.flags & 65011712, u.childLanes = r.childLanes, u.lanes = r.lanes, u.child = r.child, u.memoizedProps = r.memoizedProps, u.memoizedState = r.memoizedState, u.updateQueue = r.updateQueue, a = r.dependencies, u.dependencies = a === null ? null : { lanes: a.lanes, firstContext: a.firstContext }, u.sibling = r.sibling, u.index = r.index, u.ref = r.ref, u.refCleanup = r.refCleanup, u;
  }
  function ib(r, a) {
    r.flags &= 65011714;
    var u = r.alternate;
    return u === null ? (r.childLanes = 0, r.lanes = a, r.child = null, r.subtreeFlags = 0, r.memoizedProps = null, r.memoizedState = null, r.updateQueue = null, r.dependencies = null, r.stateNode = null) : (r.childLanes = u.childLanes, r.lanes = u.lanes, r.child = u.child, r.subtreeFlags = 0, r.deletions = null, r.memoizedProps = u.memoizedProps, r.memoizedState = u.memoizedState, r.updateQueue = u.updateQueue, r.type = u.type, a = u.dependencies, r.dependencies = a === null ? null : {
      lanes: a.lanes,
      firstContext: a.firstContext
    }), r;
  }
  function _u(r, a, u, h, p, g) {
    var T = 0;
    if (h = r, typeof r == "function") _d(r) && (T = 1);
    else if (typeof r == "string")
      T = iM(
        r,
        u,
        lt.current
      ) ? 26 : r === "html" || r === "head" || r === "body" ? 27 : 5;
    else
      t: switch (r) {
        case F:
          return r = Fn(31, u, a, p), r.elementType = F, r.lanes = g, r;
        case x:
          return ls(u.children, p, g, a);
        case S:
          T = 8, p |= 24;
          break;
        case _:
          return r = Fn(12, u, a, p | 2), r.elementType = _, r.lanes = g, r;
        case P:
          return r = Fn(13, u, a, p), r.elementType = P, r.lanes = g, r;
        case k:
          return r = Fn(19, u, a, p), r.elementType = k, r.lanes = g, r;
        default:
          if (typeof r == "object" && r !== null)
            switch (r.$$typeof) {
              case C:
              case w:
                T = 10;
                break t;
              case R:
                T = 9;
                break t;
              case E:
                T = 11;
                break t;
              case G:
                T = 14;
                break t;
              case $:
                T = 16, h = null;
                break t;
            }
          T = 29, u = Error(
            i(130, r === null ? "null" : typeof r, "")
          ), h = null;
      }
    return a = Fn(T, u, a, p), a.elementType = r, a.type = h, a.lanes = g, a;
  }
  function ls(r, a, u, h) {
    return r = Fn(7, r, h, a), r.lanes = u, r;
  }
  function Sd(r, a, u) {
    return r = Fn(6, r, null, a), r.lanes = u, r;
  }
  function Td(r, a, u) {
    return a = Fn(
      4,
      r.children !== null ? r.children : [],
      r.key,
      a
    ), a.lanes = u, a.stateNode = {
      containerInfo: r.containerInfo,
      pendingChildren: null,
      implementation: r.implementation
    }, a;
  }
  var na = [], ia = 0, Su = null, Tu = 0, ri = [], si = 0, us = null, qi = 1, Ki = "";
  function cs(r, a) {
    na[ia++] = Tu, na[ia++] = Su, Su = r, Tu = a;
  }
  function rb(r, a, u) {
    ri[si++] = qi, ri[si++] = Ki, ri[si++] = us, us = r;
    var h = qi;
    r = Ki;
    var p = 32 - Ct(h) - 1;
    h &= ~(1 << p), u += 1;
    var g = 32 - Ct(a) + p;
    if (30 < g) {
      var T = p - p % 5;
      g = (h & (1 << T) - 1).toString(32), h >>= T, p -= T, qi = 1 << 32 - Ct(a) + p | u << p | h, Ki = g + r;
    } else
      qi = 1 << g | u << p | h, Ki = r;
  }
  function wd(r) {
    r.return !== null && (cs(r, 1), rb(r, 1, 0));
  }
  function Cd(r) {
    for (; r === Su; )
      Su = na[--ia], na[ia] = null, Tu = na[--ia], na[ia] = null;
    for (; r === us; )
      us = ri[--si], ri[si] = null, Ki = ri[--si], ri[si] = null, qi = ri[--si], ri[si] = null;
  }
  var En = null, ze = null, ie = !1, hs = null, Ri = !1, Ed = Error(i(519));
  function ds(r) {
    var a = Error(i(418, ""));
    throw xo(ni(a, r)), Ed;
  }
  function sb(r) {
    var a = r.stateNode, u = r.type, h = r.memoizedProps;
    switch (a[yn] = r, a[kn] = h, u) {
      case "dialog":
        Kt("cancel", a), Kt("close", a);
        break;
      case "iframe":
      case "object":
      case "embed":
        Kt("load", a);
        break;
      case "video":
      case "audio":
        for (u = 0; u < Wo.length; u++)
          Kt(Wo[u], a);
        break;
      case "source":
        Kt("error", a);
        break;
      case "img":
      case "image":
      case "link":
        Kt("error", a), Kt("load", a);
        break;
      case "details":
        Kt("toggle", a);
        break;
      case "input":
        Kt("invalid", a), xy(
          a,
          h.value,
          h.defaultValue,
          h.checked,
          h.defaultChecked,
          h.type,
          h.name,
          !0
        ), uu(a);
        break;
      case "select":
        Kt("invalid", a);
        break;
      case "textarea":
        Kt("invalid", a), Sy(a, h.value, h.defaultValue, h.children), uu(a);
    }
    u = h.children, typeof u != "string" && typeof u != "number" && typeof u != "bigint" || a.textContent === "" + u || h.suppressHydrationWarning === !0 || Sx(a.textContent, u) ? (h.popover != null && (Kt("beforetoggle", a), Kt("toggle", a)), h.onScroll != null && Kt("scroll", a), h.onScrollEnd != null && Kt("scrollend", a), h.onClick != null && (a.onclick = ic), a = !0) : a = !1, a || ds(r);
  }
  function ab(r) {
    for (En = r.return; En; )
      switch (En.tag) {
        case 5:
        case 13:
          Ri = !1;
          return;
        case 27:
        case 3:
          Ri = !0;
          return;
        default:
          En = En.return;
      }
  }
  function bo(r) {
    if (r !== En) return !1;
    if (!ie) return ab(r), ie = !0, !1;
    var a = r.tag, u;
    if ((u = a !== 3 && a !== 27) && ((u = a === 5) && (u = r.type, u = !(u !== "form" && u !== "button") || $f(r.type, r.memoizedProps)), u = !u), u && ze && ds(r), ab(r), a === 13) {
      if (r = r.memoizedState, r = r !== null ? r.dehydrated : null, !r) throw Error(i(317));
      t: {
        for (r = r.nextSibling, a = 0; r; ) {
          if (r.nodeType === 8)
            if (u = r.data, u === "/$") {
              if (a === 0) {
                ze = bi(r.nextSibling);
                break t;
              }
              a--;
            } else
              u !== "$" && u !== "$!" && u !== "$?" || a++;
          r = r.nextSibling;
        }
        ze = null;
      }
    } else
      a === 27 ? (a = ze, Fr(r.type) ? (r = Yf, Yf = null, ze = r) : ze = a) : ze = En ? bi(r.stateNode.nextSibling) : null;
    return !0;
  }
  function vo() {
    ze = En = null, ie = !1;
  }
  function ob() {
    var r = hs;
    return r !== null && (Un === null ? Un = r : Un.push.apply(
      Un,
      r
    ), hs = null), r;
  }
  function xo(r) {
    hs === null ? hs = [r] : hs.push(r);
  }
  var Md = q(null), fs = null, Zi = null;
  function Er(r, a, u) {
    at(Md, a._currentValue), a._currentValue = u;
  }
  function Qi(r) {
    r._currentValue = Md.current, ot(Md);
  }
  function Ad(r, a, u) {
    for (; r !== null; ) {
      var h = r.alternate;
      if ((r.childLanes & a) !== a ? (r.childLanes |= a, h !== null && (h.childLanes |= a)) : h !== null && (h.childLanes & a) !== a && (h.childLanes |= a), r === u) break;
      r = r.return;
    }
  }
  function Rd(r, a, u, h) {
    var p = r.child;
    for (p !== null && (p.return = r); p !== null; ) {
      var g = p.dependencies;
      if (g !== null) {
        var T = p.child;
        g = g.firstContext;
        t: for (; g !== null; ) {
          var A = g;
          g = p;
          for (var U = 0; U < a.length; U++)
            if (A.context === a[U]) {
              g.lanes |= u, A = g.alternate, A !== null && (A.lanes |= u), Ad(
                g.return,
                u,
                r
              ), h || (T = null);
              break t;
            }
          g = A.next;
        }
      } else if (p.tag === 18) {
        if (T = p.return, T === null) throw Error(i(341));
        T.lanes |= u, g = T.alternate, g !== null && (g.lanes |= u), Ad(T, u, r), T = null;
      } else T = p.child;
      if (T !== null) T.return = p;
      else
        for (T = p; T !== null; ) {
          if (T === r) {
            T = null;
            break;
          }
          if (p = T.sibling, p !== null) {
            p.return = T.return, T = p;
            break;
          }
          T = T.return;
        }
      p = T;
    }
  }
  function _o(r, a, u, h) {
    r = null;
    for (var p = a, g = !1; p !== null; ) {
      if (!g) {
        if ((p.flags & 524288) !== 0) g = !0;
        else if ((p.flags & 262144) !== 0) break;
      }
      if (p.tag === 10) {
        var T = p.alternate;
        if (T === null) throw Error(i(387));
        if (T = T.memoizedProps, T !== null) {
          var A = p.type;
          Ln(p.pendingProps.value, T.value) || (r !== null ? r.push(A) : r = [A]);
        }
      } else if (p === Vt.current) {
        if (T = p.alternate, T === null) throw Error(i(387));
        T.memoizedState.memoizedState !== p.memoizedState.memoizedState && (r !== null ? r.push(Ko) : r = [Ko]);
      }
      p = p.return;
    }
    r !== null && Rd(
      a,
      r,
      u,
      h
    ), a.flags |= 262144;
  }
  function wu(r) {
    for (r = r.firstContext; r !== null; ) {
      if (!Ln(
        r.context._currentValue,
        r.memoizedValue
      ))
        return !0;
      r = r.next;
    }
    return !1;
  }
  function ps(r) {
    fs = r, Zi = null, r = r.dependencies, r !== null && (r.firstContext = null);
  }
  function bn(r) {
    return lb(fs, r);
  }
  function Cu(r, a) {
    return fs === null && ps(r), lb(r, a);
  }
  function lb(r, a) {
    var u = a._currentValue;
    if (a = { context: a, memoizedValue: u, next: null }, Zi === null) {
      if (r === null) throw Error(i(308));
      Zi = a, r.dependencies = { lanes: 0, firstContext: a }, r.flags |= 524288;
    } else Zi = Zi.next = a;
    return u;
  }
  var n2 = typeof AbortController < "u" ? AbortController : function() {
    var r = [], a = this.signal = {
      aborted: !1,
      addEventListener: function(u, h) {
        r.push(h);
      }
    };
    this.abort = function() {
      a.aborted = !0, r.forEach(function(u) {
        return u();
      });
    };
  }, i2 = n.unstable_scheduleCallback, r2 = n.unstable_NormalPriority, en = {
    $$typeof: w,
    Consumer: null,
    Provider: null,
    _currentValue: null,
    _currentValue2: null,
    _threadCount: 0
  };
  function Pd() {
    return {
      controller: new n2(),
      data: /* @__PURE__ */ new Map(),
      refCount: 0
    };
  }
  function So(r) {
    r.refCount--, r.refCount === 0 && i2(r2, function() {
      r.controller.abort();
    });
  }
  var To = null, Bd = 0, ra = 0, sa = null;
  function s2(r, a) {
    if (To === null) {
      var u = To = [];
      Bd = 0, ra = Df(), sa = {
        status: "pending",
        value: void 0,
        then: function(h) {
          u.push(h);
        }
      };
    }
    return Bd++, a.then(ub, ub), a;
  }
  function ub() {
    if (--Bd === 0 && To !== null) {
      sa !== null && (sa.status = "fulfilled");
      var r = To;
      To = null, ra = 0, sa = null;
      for (var a = 0; a < r.length; a++) (0, r[a])();
    }
  }
  function a2(r, a) {
    var u = [], h = {
      status: "pending",
      value: null,
      reason: null,
      then: function(p) {
        u.push(p);
      }
    };
    return r.then(
      function() {
        h.status = "fulfilled", h.value = a;
        for (var p = 0; p < u.length; p++) (0, u[p])(a);
      },
      function(p) {
        for (h.status = "rejected", h.reason = p, p = 0; p < u.length; p++)
          (0, u[p])(void 0);
      }
    ), h;
  }
  var cb = B.S;
  B.S = function(r, a) {
    typeof a == "object" && a !== null && typeof a.then == "function" && s2(r, a), cb !== null && cb(r, a);
  };
  var ms = q(null);
  function kd() {
    var r = ms.current;
    return r !== null ? r : Ce.pooledCache;
  }
  function Eu(r, a) {
    a === null ? at(ms, ms.current) : at(ms, a.pool);
  }
  function hb() {
    var r = kd();
    return r === null ? null : { parent: en._currentValue, pool: r };
  }
  var wo = Error(i(460)), db = Error(i(474)), Mu = Error(i(542)), Od = { then: function() {
  } };
  function fb(r) {
    return r = r.status, r === "fulfilled" || r === "rejected";
  }
  function Au() {
  }
  function pb(r, a, u) {
    switch (u = r[u], u === void 0 ? r.push(a) : u !== a && (a.then(Au, Au), a = u), a.status) {
      case "fulfilled":
        return a.value;
      case "rejected":
        throw r = a.reason, gb(r), r;
      default:
        if (typeof a.status == "string") a.then(Au, Au);
        else {
          if (r = Ce, r !== null && 100 < r.shellSuspendCounter)
            throw Error(i(482));
          r = a, r.status = "pending", r.then(
            function(h) {
              if (a.status === "pending") {
                var p = a;
                p.status = "fulfilled", p.value = h;
              }
            },
            function(h) {
              if (a.status === "pending") {
                var p = a;
                p.status = "rejected", p.reason = h;
              }
            }
          );
        }
        switch (a.status) {
          case "fulfilled":
            return a.value;
          case "rejected":
            throw r = a.reason, gb(r), r;
        }
        throw Co = a, wo;
    }
  }
  var Co = null;
  function mb() {
    if (Co === null) throw Error(i(459));
    var r = Co;
    return Co = null, r;
  }
  function gb(r) {
    if (r === wo || r === Mu)
      throw Error(i(483));
  }
  var Mr = !1;
  function Dd(r) {
    r.updateQueue = {
      baseState: r.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, lanes: 0, hiddenCallbacks: null },
      callbacks: null
    };
  }
  function Gd(r, a) {
    r = r.updateQueue, a.updateQueue === r && (a.updateQueue = {
      baseState: r.baseState,
      firstBaseUpdate: r.firstBaseUpdate,
      lastBaseUpdate: r.lastBaseUpdate,
      shared: r.shared,
      callbacks: null
    });
  }
  function Ar(r) {
    return { lane: r, tag: 0, payload: null, callback: null, next: null };
  }
  function Rr(r, a, u) {
    var h = r.updateQueue;
    if (h === null) return null;
    if (h = h.shared, (ce & 2) !== 0) {
      var p = h.pending;
      return p === null ? a.next = a : (a.next = p.next, p.next = a), h.pending = a, a = xu(r), nb(r, null, u), a;
    }
    return vu(r, h, a, u), xu(r);
  }
  function Eo(r, a, u) {
    if (a = a.updateQueue, a !== null && (a = a.shared, (u & 4194048) !== 0)) {
      var h = a.lanes;
      h &= r.pendingLanes, u |= h, a.lanes = u, is(r, u);
    }
  }
  function Ud(r, a) {
    var u = r.updateQueue, h = r.alternate;
    if (h !== null && (h = h.updateQueue, u === h)) {
      var p = null, g = null;
      if (u = u.firstBaseUpdate, u !== null) {
        do {
          var T = {
            lane: u.lane,
            tag: u.tag,
            payload: u.payload,
            callback: null,
            next: null
          };
          g === null ? p = g = T : g = g.next = T, u = u.next;
        } while (u !== null);
        g === null ? p = g = a : g = g.next = a;
      } else p = g = a;
      u = {
        baseState: h.baseState,
        firstBaseUpdate: p,
        lastBaseUpdate: g,
        shared: h.shared,
        callbacks: h.callbacks
      }, r.updateQueue = u;
      return;
    }
    r = u.lastBaseUpdate, r === null ? u.firstBaseUpdate = a : r.next = a, u.lastBaseUpdate = a;
  }
  var Nd = !1;
  function Mo() {
    if (Nd) {
      var r = sa;
      if (r !== null) throw r;
    }
  }
  function Ao(r, a, u, h) {
    Nd = !1;
    var p = r.updateQueue;
    Mr = !1;
    var g = p.firstBaseUpdate, T = p.lastBaseUpdate, A = p.shared.pending;
    if (A !== null) {
      p.shared.pending = null;
      var U = A, X = U.next;
      U.next = null, T === null ? g = X : T.next = X, T = U;
      var nt = r.alternate;
      nt !== null && (nt = nt.updateQueue, A = nt.lastBaseUpdate, A !== T && (A === null ? nt.firstBaseUpdate = X : A.next = X, nt.lastBaseUpdate = U));
    }
    if (g !== null) {
      var st = p.baseState;
      T = 0, nt = X = U = null, A = g;
      do {
        var K = A.lane & -536870913, Z = K !== A.lane;
        if (Z ? (Zt & K) === K : (h & K) === K) {
          K !== 0 && K === ra && (Nd = !0), nt !== null && (nt = nt.next = {
            lane: 0,
            tag: A.tag,
            payload: A.payload,
            callback: null,
            next: null
          });
          t: {
            var Ot = r, Mt = A;
            K = a;
            var ye = u;
            switch (Mt.tag) {
              case 1:
                if (Ot = Mt.payload, typeof Ot == "function") {
                  st = Ot.call(ye, st, K);
                  break t;
                }
                st = Ot;
                break t;
              case 3:
                Ot.flags = Ot.flags & -65537 | 128;
              case 0:
                if (Ot = Mt.payload, K = typeof Ot == "function" ? Ot.call(ye, st, K) : Ot, K == null) break t;
                st = m({}, st, K);
                break t;
              case 2:
                Mr = !0;
            }
          }
          K = A.callback, K !== null && (r.flags |= 64, Z && (r.flags |= 8192), Z = p.callbacks, Z === null ? p.callbacks = [K] : Z.push(K));
        } else
          Z = {
            lane: K,
            tag: A.tag,
            payload: A.payload,
            callback: A.callback,
            next: null
          }, nt === null ? (X = nt = Z, U = st) : nt = nt.next = Z, T |= K;
        if (A = A.next, A === null) {
          if (A = p.shared.pending, A === null)
            break;
          Z = A, A = Z.next, Z.next = null, p.lastBaseUpdate = Z, p.shared.pending = null;
        }
      } while (!0);
      nt === null && (U = st), p.baseState = U, p.firstBaseUpdate = X, p.lastBaseUpdate = nt, g === null && (p.shared.lanes = 0), Nr |= T, r.lanes = T, r.memoizedState = st;
    }
  }
  function yb(r, a) {
    if (typeof r != "function")
      throw Error(i(191, r));
    r.call(a);
  }
  function bb(r, a) {
    var u = r.callbacks;
    if (u !== null)
      for (r.callbacks = null, r = 0; r < u.length; r++)
        yb(u[r], a);
  }
  var aa = q(null), Ru = q(0);
  function vb(r, a) {
    r = sr, at(Ru, r), at(aa, a), sr = r | a.baseLanes;
  }
  function Id() {
    at(Ru, sr), at(aa, aa.current);
  }
  function zd() {
    sr = Ru.current, ot(aa), ot(Ru);
  }
  var Pr = 0, jt = null, me = null, qe = null, Pu = !1, oa = !1, gs = !1, Bu = 0, Ro = 0, la = null, o2 = 0;
  function Ve() {
    throw Error(i(321));
  }
  function Ld(r, a) {
    if (a === null) return !1;
    for (var u = 0; u < a.length && u < r.length; u++)
      if (!Ln(r[u], a[u])) return !1;
    return !0;
  }
  function Fd(r, a, u, h, p, g) {
    return Pr = g, jt = a, a.memoizedState = null, a.updateQueue = null, a.lanes = 0, B.H = r === null || r.memoizedState === null ? nv : iv, gs = !1, g = u(h, p), gs = !1, oa && (g = _b(
      a,
      u,
      h,
      p
    )), xb(r), g;
  }
  function xb(r) {
    B.H = Nu;
    var a = me !== null && me.next !== null;
    if (Pr = 0, qe = me = jt = null, Pu = !1, Ro = 0, la = null, a) throw Error(i(300));
    r === null || ln || (r = r.dependencies, r !== null && wu(r) && (ln = !0));
  }
  function _b(r, a, u, h) {
    jt = r;
    var p = 0;
    do {
      if (oa && (la = null), Ro = 0, oa = !1, 25 <= p) throw Error(i(301));
      if (p += 1, qe = me = null, r.updateQueue != null) {
        var g = r.updateQueue;
        g.lastEffect = null, g.events = null, g.stores = null, g.memoCache != null && (g.memoCache.index = 0);
      }
      B.H = p2, g = a(u, h);
    } while (oa);
    return g;
  }
  function l2() {
    var r = B.H, a = r.useState()[0];
    return a = typeof a.then == "function" ? Po(a) : a, r = r.useState()[0], (me !== null ? me.memoizedState : null) !== r && (jt.flags |= 1024), a;
  }
  function Hd() {
    var r = Bu !== 0;
    return Bu = 0, r;
  }
  function $d(r, a, u) {
    a.updateQueue = r.updateQueue, a.flags &= -2053, r.lanes &= ~u;
  }
  function Wd(r) {
    if (Pu) {
      for (r = r.memoizedState; r !== null; ) {
        var a = r.queue;
        a !== null && (a.pending = null), r = r.next;
      }
      Pu = !1;
    }
    Pr = 0, qe = me = jt = null, oa = !1, Ro = Bu = 0, la = null;
  }
  function Dn() {
    var r = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null
    };
    return qe === null ? jt.memoizedState = qe = r : qe = qe.next = r, qe;
  }
  function Ke() {
    if (me === null) {
      var r = jt.alternate;
      r = r !== null ? r.memoizedState : null;
    } else r = me.next;
    var a = qe === null ? jt.memoizedState : qe.next;
    if (a !== null)
      qe = a, me = r;
    else {
      if (r === null)
        throw jt.alternate === null ? Error(i(467)) : Error(i(310));
      me = r, r = {
        memoizedState: me.memoizedState,
        baseState: me.baseState,
        baseQueue: me.baseQueue,
        queue: me.queue,
        next: null
      }, qe === null ? jt.memoizedState = qe = r : qe = qe.next = r;
    }
    return qe;
  }
  function Vd() {
    return { lastEffect: null, events: null, stores: null, memoCache: null };
  }
  function Po(r) {
    var a = Ro;
    return Ro += 1, la === null && (la = []), r = pb(la, r, a), a = jt, (qe === null ? a.memoizedState : qe.next) === null && (a = a.alternate, B.H = a === null || a.memoizedState === null ? nv : iv), r;
  }
  function ku(r) {
    if (r !== null && typeof r == "object") {
      if (typeof r.then == "function") return Po(r);
      if (r.$$typeof === w) return bn(r);
    }
    throw Error(i(438, String(r)));
  }
  function jd(r) {
    var a = null, u = jt.updateQueue;
    if (u !== null && (a = u.memoCache), a == null) {
      var h = jt.alternate;
      h !== null && (h = h.updateQueue, h !== null && (h = h.memoCache, h != null && (a = {
        data: h.data.map(function(p) {
          return p.slice();
        }),
        index: 0
      })));
    }
    if (a == null && (a = { data: [], index: 0 }), u === null && (u = Vd(), jt.updateQueue = u), u.memoCache = a, u = a.data[a.index], u === void 0)
      for (u = a.data[a.index] = Array(r), h = 0; h < r; h++)
        u[h] = j;
    return a.index++, u;
  }
  function Ji(r, a) {
    return typeof a == "function" ? a(r) : a;
  }
  function Ou(r) {
    var a = Ke();
    return Yd(a, me, r);
  }
  function Yd(r, a, u) {
    var h = r.queue;
    if (h === null) throw Error(i(311));
    h.lastRenderedReducer = u;
    var p = r.baseQueue, g = h.pending;
    if (g !== null) {
      if (p !== null) {
        var T = p.next;
        p.next = g.next, g.next = T;
      }
      a.baseQueue = p = g, h.pending = null;
    }
    if (g = r.baseState, p === null) r.memoizedState = g;
    else {
      a = p.next;
      var A = T = null, U = null, X = a, nt = !1;
      do {
        var st = X.lane & -536870913;
        if (st !== X.lane ? (Zt & st) === st : (Pr & st) === st) {
          var K = X.revertLane;
          if (K === 0)
            U !== null && (U = U.next = {
              lane: 0,
              revertLane: 0,
              action: X.action,
              hasEagerState: X.hasEagerState,
              eagerState: X.eagerState,
              next: null
            }), st === ra && (nt = !0);
          else if ((Pr & K) === K) {
            X = X.next, K === ra && (nt = !0);
            continue;
          } else
            st = {
              lane: 0,
              revertLane: X.revertLane,
              action: X.action,
              hasEagerState: X.hasEagerState,
              eagerState: X.eagerState,
              next: null
            }, U === null ? (A = U = st, T = g) : U = U.next = st, jt.lanes |= K, Nr |= K;
          st = X.action, gs && u(g, st), g = X.hasEagerState ? X.eagerState : u(g, st);
        } else
          K = {
            lane: st,
            revertLane: X.revertLane,
            action: X.action,
            hasEagerState: X.hasEagerState,
            eagerState: X.eagerState,
            next: null
          }, U === null ? (A = U = K, T = g) : U = U.next = K, jt.lanes |= st, Nr |= st;
        X = X.next;
      } while (X !== null && X !== a);
      if (U === null ? T = g : U.next = A, !Ln(g, r.memoizedState) && (ln = !0, nt && (u = sa, u !== null)))
        throw u;
      r.memoizedState = g, r.baseState = T, r.baseQueue = U, h.lastRenderedState = g;
    }
    return p === null && (h.lanes = 0), [r.memoizedState, h.dispatch];
  }
  function Xd(r) {
    var a = Ke(), u = a.queue;
    if (u === null) throw Error(i(311));
    u.lastRenderedReducer = r;
    var h = u.dispatch, p = u.pending, g = a.memoizedState;
    if (p !== null) {
      u.pending = null;
      var T = p = p.next;
      do
        g = r(g, T.action), T = T.next;
      while (T !== p);
      Ln(g, a.memoizedState) || (ln = !0), a.memoizedState = g, a.baseQueue === null && (a.baseState = g), u.lastRenderedState = g;
    }
    return [g, h];
  }
  function Sb(r, a, u) {
    var h = jt, p = Ke(), g = ie;
    if (g) {
      if (u === void 0) throw Error(i(407));
      u = u();
    } else u = a();
    var T = !Ln(
      (me || p).memoizedState,
      u
    );
    T && (p.memoizedState = u, ln = !0), p = p.queue;
    var A = Cb.bind(null, h, p, r);
    if (Bo(2048, 8, A, [r]), p.getSnapshot !== a || T || qe !== null && qe.memoizedState.tag & 1) {
      if (h.flags |= 2048, ua(
        9,
        Du(),
        wb.bind(
          null,
          h,
          p,
          u,
          a
        ),
        null
      ), Ce === null) throw Error(i(349));
      g || (Pr & 124) !== 0 || Tb(h, a, u);
    }
    return u;
  }
  function Tb(r, a, u) {
    r.flags |= 16384, r = { getSnapshot: a, value: u }, a = jt.updateQueue, a === null ? (a = Vd(), jt.updateQueue = a, a.stores = [r]) : (u = a.stores, u === null ? a.stores = [r] : u.push(r));
  }
  function wb(r, a, u, h) {
    a.value = u, a.getSnapshot = h, Eb(a) && Mb(r);
  }
  function Cb(r, a, u) {
    return u(function() {
      Eb(a) && Mb(r);
    });
  }
  function Eb(r) {
    var a = r.getSnapshot;
    r = r.value;
    try {
      var u = a();
      return !Ln(r, u);
    } catch {
      return !0;
    }
  }
  function Mb(r) {
    var a = ta(r, 2);
    a !== null && jn(a, r, 2);
  }
  function qd(r) {
    var a = Dn();
    if (typeof r == "function") {
      var u = r;
      if (r = u(), gs) {
        Bt(!0);
        try {
          u();
        } finally {
          Bt(!1);
        }
      }
    }
    return a.memoizedState = a.baseState = r, a.queue = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: Ji,
      lastRenderedState: r
    }, a;
  }
  function Ab(r, a, u, h) {
    return r.baseState = u, Yd(
      r,
      me,
      typeof h == "function" ? h : Ji
    );
  }
  function u2(r, a, u, h, p) {
    if (Uu(r)) throw Error(i(485));
    if (r = a.action, r !== null) {
      var g = {
        payload: p,
        action: r,
        next: null,
        isTransition: !0,
        status: "pending",
        value: null,
        reason: null,
        listeners: [],
        then: function(T) {
          g.listeners.push(T);
        }
      };
      B.T !== null ? u(!0) : g.isTransition = !1, h(g), u = a.pending, u === null ? (g.next = a.pending = g, Rb(a, g)) : (g.next = u.next, a.pending = u.next = g);
    }
  }
  function Rb(r, a) {
    var u = a.action, h = a.payload, p = r.state;
    if (a.isTransition) {
      var g = B.T, T = {};
      B.T = T;
      try {
        var A = u(p, h), U = B.S;
        U !== null && U(T, A), Pb(r, a, A);
      } catch (X) {
        Kd(r, a, X);
      } finally {
        B.T = g;
      }
    } else
      try {
        g = u(p, h), Pb(r, a, g);
      } catch (X) {
        Kd(r, a, X);
      }
  }
  function Pb(r, a, u) {
    u !== null && typeof u == "object" && typeof u.then == "function" ? u.then(
      function(h) {
        Bb(r, a, h);
      },
      function(h) {
        return Kd(r, a, h);
      }
    ) : Bb(r, a, u);
  }
  function Bb(r, a, u) {
    a.status = "fulfilled", a.value = u, kb(a), r.state = u, a = r.pending, a !== null && (u = a.next, u === a ? r.pending = null : (u = u.next, a.next = u, Rb(r, u)));
  }
  function Kd(r, a, u) {
    var h = r.pending;
    if (r.pending = null, h !== null) {
      h = h.next;
      do
        a.status = "rejected", a.reason = u, kb(a), a = a.next;
      while (a !== h);
    }
    r.action = null;
  }
  function kb(r) {
    r = r.listeners;
    for (var a = 0; a < r.length; a++) (0, r[a])();
  }
  function Ob(r, a) {
    return a;
  }
  function Db(r, a) {
    if (ie) {
      var u = Ce.formState;
      if (u !== null) {
        t: {
          var h = jt;
          if (ie) {
            if (ze) {
              e: {
                for (var p = ze, g = Ri; p.nodeType !== 8; ) {
                  if (!g) {
                    p = null;
                    break e;
                  }
                  if (p = bi(
                    p.nextSibling
                  ), p === null) {
                    p = null;
                    break e;
                  }
                }
                g = p.data, p = g === "F!" || g === "F" ? p : null;
              }
              if (p) {
                ze = bi(
                  p.nextSibling
                ), h = p.data === "F!";
                break t;
              }
            }
            ds(h);
          }
          h = !1;
        }
        h && (a = u[0]);
      }
    }
    return u = Dn(), u.memoizedState = u.baseState = a, h = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: Ob,
      lastRenderedState: a
    }, u.queue = h, u = Jb.bind(
      null,
      jt,
      h
    ), h.dispatch = u, h = qd(!1), g = ef.bind(
      null,
      jt,
      !1,
      h.queue
    ), h = Dn(), p = {
      state: a,
      dispatch: null,
      action: r,
      pending: null
    }, h.queue = p, u = u2.bind(
      null,
      jt,
      p,
      g,
      u
    ), p.dispatch = u, h.memoizedState = r, [a, u, !1];
  }
  function Gb(r) {
    var a = Ke();
    return Ub(a, me, r);
  }
  function Ub(r, a, u) {
    if (a = Yd(
      r,
      a,
      Ob
    )[0], r = Ou(Ji)[0], typeof a == "object" && a !== null && typeof a.then == "function")
      try {
        var h = Po(a);
      } catch (T) {
        throw T === wo ? Mu : T;
      }
    else h = a;
    a = Ke();
    var p = a.queue, g = p.dispatch;
    return u !== a.memoizedState && (jt.flags |= 2048, ua(
      9,
      Du(),
      c2.bind(null, p, u),
      null
    )), [h, g, r];
  }
  function c2(r, a) {
    r.action = a;
  }
  function Nb(r) {
    var a = Ke(), u = me;
    if (u !== null)
      return Ub(a, u, r);
    Ke(), a = a.memoizedState, u = Ke();
    var h = u.queue.dispatch;
    return u.memoizedState = r, [a, h, !1];
  }
  function ua(r, a, u, h) {
    return r = { tag: r, create: u, deps: h, inst: a, next: null }, a = jt.updateQueue, a === null && (a = Vd(), jt.updateQueue = a), u = a.lastEffect, u === null ? a.lastEffect = r.next = r : (h = u.next, u.next = r, r.next = h, a.lastEffect = r), r;
  }
  function Du() {
    return { destroy: void 0, resource: void 0 };
  }
  function Ib() {
    return Ke().memoizedState;
  }
  function Gu(r, a, u, h) {
    var p = Dn();
    h = h === void 0 ? null : h, jt.flags |= r, p.memoizedState = ua(
      1 | a,
      Du(),
      u,
      h
    );
  }
  function Bo(r, a, u, h) {
    var p = Ke();
    h = h === void 0 ? null : h;
    var g = p.memoizedState.inst;
    me !== null && h !== null && Ld(h, me.memoizedState.deps) ? p.memoizedState = ua(a, g, u, h) : (jt.flags |= r, p.memoizedState = ua(
      1 | a,
      g,
      u,
      h
    ));
  }
  function zb(r, a) {
    Gu(8390656, 8, r, a);
  }
  function Lb(r, a) {
    Bo(2048, 8, r, a);
  }
  function Fb(r, a) {
    return Bo(4, 2, r, a);
  }
  function Hb(r, a) {
    return Bo(4, 4, r, a);
  }
  function $b(r, a) {
    if (typeof a == "function") {
      r = r();
      var u = a(r);
      return function() {
        typeof u == "function" ? u() : a(null);
      };
    }
    if (a != null)
      return r = r(), a.current = r, function() {
        a.current = null;
      };
  }
  function Wb(r, a, u) {
    u = u != null ? u.concat([r]) : null, Bo(4, 4, $b.bind(null, a, r), u);
  }
  function Zd() {
  }
  function Vb(r, a) {
    var u = Ke();
    a = a === void 0 ? null : a;
    var h = u.memoizedState;
    return a !== null && Ld(a, h[1]) ? h[0] : (u.memoizedState = [r, a], r);
  }
  function jb(r, a) {
    var u = Ke();
    a = a === void 0 ? null : a;
    var h = u.memoizedState;
    if (a !== null && Ld(a, h[1]))
      return h[0];
    if (h = r(), gs) {
      Bt(!0);
      try {
        r();
      } finally {
        Bt(!1);
      }
    }
    return u.memoizedState = [h, a], h;
  }
  function Qd(r, a, u) {
    return u === void 0 || (Pr & 1073741824) !== 0 ? r.memoizedState = a : (r.memoizedState = u, r = qv(), jt.lanes |= r, Nr |= r, u);
  }
  function Yb(r, a, u, h) {
    return Ln(u, a) ? u : aa.current !== null ? (r = Qd(r, u, h), Ln(r, a) || (ln = !0), r) : (Pr & 42) === 0 ? (ln = !0, r.memoizedState = u) : (r = qv(), jt.lanes |= r, Nr |= r, a);
  }
  function Xb(r, a, u, h, p) {
    var g = I.p;
    I.p = g !== 0 && 8 > g ? g : 8;
    var T = B.T, A = {};
    B.T = A, ef(r, !1, a, u);
    try {
      var U = p(), X = B.S;
      if (X !== null && X(A, U), U !== null && typeof U == "object" && typeof U.then == "function") {
        var nt = a2(
          U,
          h
        );
        ko(
          r,
          a,
          nt,
          Vn(r)
        );
      } else
        ko(
          r,
          a,
          h,
          Vn(r)
        );
    } catch (st) {
      ko(
        r,
        a,
        { then: function() {
        }, status: "rejected", reason: st },
        Vn()
      );
    } finally {
      I.p = g, B.T = T;
    }
  }
  function h2() {
  }
  function Jd(r, a, u, h) {
    if (r.tag !== 5) throw Error(i(476));
    var p = qb(r).queue;
    Xb(
      r,
      p,
      a,
      rt,
      u === null ? h2 : function() {
        return Kb(r), u(h);
      }
    );
  }
  function qb(r) {
    var a = r.memoizedState;
    if (a !== null) return a;
    a = {
      memoizedState: rt,
      baseState: rt,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Ji,
        lastRenderedState: rt
      },
      next: null
    };
    var u = {};
    return a.next = {
      memoizedState: u,
      baseState: u,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Ji,
        lastRenderedState: u
      },
      next: null
    }, r.memoizedState = a, r = r.alternate, r !== null && (r.memoizedState = a), a;
  }
  function Kb(r) {
    var a = qb(r).next.queue;
    ko(r, a, {}, Vn());
  }
  function tf() {
    return bn(Ko);
  }
  function Zb() {
    return Ke().memoizedState;
  }
  function Qb() {
    return Ke().memoizedState;
  }
  function d2(r) {
    for (var a = r.return; a !== null; ) {
      switch (a.tag) {
        case 24:
        case 3:
          var u = Vn();
          r = Ar(u);
          var h = Rr(a, r, u);
          h !== null && (jn(h, a, u), Eo(h, a, u)), a = { cache: Pd() }, r.payload = a;
          return;
      }
      a = a.return;
    }
  }
  function f2(r, a, u) {
    var h = Vn();
    u = {
      lane: h,
      revertLane: 0,
      action: u,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, Uu(r) ? tv(a, u) : (u = xd(r, a, u, h), u !== null && (jn(u, r, h), ev(u, a, h)));
  }
  function Jb(r, a, u) {
    var h = Vn();
    ko(r, a, u, h);
  }
  function ko(r, a, u, h) {
    var p = {
      lane: h,
      revertLane: 0,
      action: u,
      hasEagerState: !1,
      eagerState: null,
      next: null
    };
    if (Uu(r)) tv(a, p);
    else {
      var g = r.alternate;
      if (r.lanes === 0 && (g === null || g.lanes === 0) && (g = a.lastRenderedReducer, g !== null))
        try {
          var T = a.lastRenderedState, A = g(T, u);
          if (p.hasEagerState = !0, p.eagerState = A, Ln(A, T))
            return vu(r, a, p, 0), Ce === null && bu(), !1;
        } catch {
        } finally {
        }
      if (u = xd(r, a, p, h), u !== null)
        return jn(u, r, h), ev(u, a, h), !0;
    }
    return !1;
  }
  function ef(r, a, u, h) {
    if (h = {
      lane: 2,
      revertLane: Df(),
      action: h,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, Uu(r)) {
      if (a) throw Error(i(479));
    } else
      a = xd(
        r,
        u,
        h,
        2
      ), a !== null && jn(a, r, 2);
  }
  function Uu(r) {
    var a = r.alternate;
    return r === jt || a !== null && a === jt;
  }
  function tv(r, a) {
    oa = Pu = !0;
    var u = r.pending;
    u === null ? a.next = a : (a.next = u.next, u.next = a), r.pending = a;
  }
  function ev(r, a, u) {
    if ((u & 4194048) !== 0) {
      var h = a.lanes;
      h &= r.pendingLanes, u |= h, a.lanes = u, is(r, u);
    }
  }
  var Nu = {
    readContext: bn,
    use: ku,
    useCallback: Ve,
    useContext: Ve,
    useEffect: Ve,
    useImperativeHandle: Ve,
    useLayoutEffect: Ve,
    useInsertionEffect: Ve,
    useMemo: Ve,
    useReducer: Ve,
    useRef: Ve,
    useState: Ve,
    useDebugValue: Ve,
    useDeferredValue: Ve,
    useTransition: Ve,
    useSyncExternalStore: Ve,
    useId: Ve,
    useHostTransitionStatus: Ve,
    useFormState: Ve,
    useActionState: Ve,
    useOptimistic: Ve,
    useMemoCache: Ve,
    useCacheRefresh: Ve
  }, nv = {
    readContext: bn,
    use: ku,
    useCallback: function(r, a) {
      return Dn().memoizedState = [
        r,
        a === void 0 ? null : a
      ], r;
    },
    useContext: bn,
    useEffect: zb,
    useImperativeHandle: function(r, a, u) {
      u = u != null ? u.concat([r]) : null, Gu(
        4194308,
        4,
        $b.bind(null, a, r),
        u
      );
    },
    useLayoutEffect: function(r, a) {
      return Gu(4194308, 4, r, a);
    },
    useInsertionEffect: function(r, a) {
      Gu(4, 2, r, a);
    },
    useMemo: function(r, a) {
      var u = Dn();
      a = a === void 0 ? null : a;
      var h = r();
      if (gs) {
        Bt(!0);
        try {
          r();
        } finally {
          Bt(!1);
        }
      }
      return u.memoizedState = [h, a], h;
    },
    useReducer: function(r, a, u) {
      var h = Dn();
      if (u !== void 0) {
        var p = u(a);
        if (gs) {
          Bt(!0);
          try {
            u(a);
          } finally {
            Bt(!1);
          }
        }
      } else p = a;
      return h.memoizedState = h.baseState = p, r = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: r,
        lastRenderedState: p
      }, h.queue = r, r = r.dispatch = f2.bind(
        null,
        jt,
        r
      ), [h.memoizedState, r];
    },
    useRef: function(r) {
      var a = Dn();
      return r = { current: r }, a.memoizedState = r;
    },
    useState: function(r) {
      r = qd(r);
      var a = r.queue, u = Jb.bind(null, jt, a);
      return a.dispatch = u, [r.memoizedState, u];
    },
    useDebugValue: Zd,
    useDeferredValue: function(r, a) {
      var u = Dn();
      return Qd(u, r, a);
    },
    useTransition: function() {
      var r = qd(!1);
      return r = Xb.bind(
        null,
        jt,
        r.queue,
        !0,
        !1
      ), Dn().memoizedState = r, [!1, r];
    },
    useSyncExternalStore: function(r, a, u) {
      var h = jt, p = Dn();
      if (ie) {
        if (u === void 0)
          throw Error(i(407));
        u = u();
      } else {
        if (u = a(), Ce === null)
          throw Error(i(349));
        (Zt & 124) !== 0 || Tb(h, a, u);
      }
      p.memoizedState = u;
      var g = { value: u, getSnapshot: a };
      return p.queue = g, zb(Cb.bind(null, h, g, r), [
        r
      ]), h.flags |= 2048, ua(
        9,
        Du(),
        wb.bind(
          null,
          h,
          g,
          u,
          a
        ),
        null
      ), u;
    },
    useId: function() {
      var r = Dn(), a = Ce.identifierPrefix;
      if (ie) {
        var u = Ki, h = qi;
        u = (h & ~(1 << 32 - Ct(h) - 1)).toString(32) + u, a = "" + a + "R" + u, u = Bu++, 0 < u && (a += "H" + u.toString(32)), a += "";
      } else
        u = o2++, a = "" + a + "r" + u.toString(32) + "";
      return r.memoizedState = a;
    },
    useHostTransitionStatus: tf,
    useFormState: Db,
    useActionState: Db,
    useOptimistic: function(r) {
      var a = Dn();
      a.memoizedState = a.baseState = r;
      var u = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: null,
        lastRenderedState: null
      };
      return a.queue = u, a = ef.bind(
        null,
        jt,
        !0,
        u
      ), u.dispatch = a, [r, a];
    },
    useMemoCache: jd,
    useCacheRefresh: function() {
      return Dn().memoizedState = d2.bind(
        null,
        jt
      );
    }
  }, iv = {
    readContext: bn,
    use: ku,
    useCallback: Vb,
    useContext: bn,
    useEffect: Lb,
    useImperativeHandle: Wb,
    useInsertionEffect: Fb,
    useLayoutEffect: Hb,
    useMemo: jb,
    useReducer: Ou,
    useRef: Ib,
    useState: function() {
      return Ou(Ji);
    },
    useDebugValue: Zd,
    useDeferredValue: function(r, a) {
      var u = Ke();
      return Yb(
        u,
        me.memoizedState,
        r,
        a
      );
    },
    useTransition: function() {
      var r = Ou(Ji)[0], a = Ke().memoizedState;
      return [
        typeof r == "boolean" ? r : Po(r),
        a
      ];
    },
    useSyncExternalStore: Sb,
    useId: Zb,
    useHostTransitionStatus: tf,
    useFormState: Gb,
    useActionState: Gb,
    useOptimistic: function(r, a) {
      var u = Ke();
      return Ab(u, me, r, a);
    },
    useMemoCache: jd,
    useCacheRefresh: Qb
  }, p2 = {
    readContext: bn,
    use: ku,
    useCallback: Vb,
    useContext: bn,
    useEffect: Lb,
    useImperativeHandle: Wb,
    useInsertionEffect: Fb,
    useLayoutEffect: Hb,
    useMemo: jb,
    useReducer: Xd,
    useRef: Ib,
    useState: function() {
      return Xd(Ji);
    },
    useDebugValue: Zd,
    useDeferredValue: function(r, a) {
      var u = Ke();
      return me === null ? Qd(u, r, a) : Yb(
        u,
        me.memoizedState,
        r,
        a
      );
    },
    useTransition: function() {
      var r = Xd(Ji)[0], a = Ke().memoizedState;
      return [
        typeof r == "boolean" ? r : Po(r),
        a
      ];
    },
    useSyncExternalStore: Sb,
    useId: Zb,
    useHostTransitionStatus: tf,
    useFormState: Nb,
    useActionState: Nb,
    useOptimistic: function(r, a) {
      var u = Ke();
      return me !== null ? Ab(u, me, r, a) : (u.baseState = r, [r, u.queue.dispatch]);
    },
    useMemoCache: jd,
    useCacheRefresh: Qb
  }, ca = null, Oo = 0;
  function Iu(r) {
    var a = Oo;
    return Oo += 1, ca === null && (ca = []), pb(ca, r, a);
  }
  function Do(r, a) {
    a = a.props.ref, r.ref = a !== void 0 ? a : null;
  }
  function zu(r, a) {
    throw a.$$typeof === y ? Error(i(525)) : (r = Object.prototype.toString.call(a), Error(
      i(
        31,
        r === "[object Object]" ? "object with keys {" + Object.keys(a).join(", ") + "}" : r
      )
    ));
  }
  function rv(r) {
    var a = r._init;
    return a(r._payload);
  }
  function sv(r) {
    function a(z, N) {
      if (r) {
        var V = z.deletions;
        V === null ? (z.deletions = [N], z.flags |= 16) : V.push(N);
      }
    }
    function u(z, N) {
      if (!r) return null;
      for (; N !== null; )
        a(z, N), N = N.sibling;
      return null;
    }
    function h(z) {
      for (var N = /* @__PURE__ */ new Map(); z !== null; )
        z.key !== null ? N.set(z.key, z) : N.set(z.index, z), z = z.sibling;
      return N;
    }
    function p(z, N) {
      return z = Xi(z, N), z.index = 0, z.sibling = null, z;
    }
    function g(z, N, V) {
      return z.index = V, r ? (V = z.alternate, V !== null ? (V = V.index, V < N ? (z.flags |= 67108866, N) : V) : (z.flags |= 67108866, N)) : (z.flags |= 1048576, N);
    }
    function T(z) {
      return r && z.alternate === null && (z.flags |= 67108866), z;
    }
    function A(z, N, V, it) {
      return N === null || N.tag !== 6 ? (N = Sd(V, z.mode, it), N.return = z, N) : (N = p(N, V), N.return = z, N);
    }
    function U(z, N, V, it) {
      var ft = V.type;
      return ft === x ? nt(
        z,
        N,
        V.props.children,
        it,
        V.key
      ) : N !== null && (N.elementType === ft || typeof ft == "object" && ft !== null && ft.$$typeof === $ && rv(ft) === N.type) ? (N = p(N, V.props), Do(N, V), N.return = z, N) : (N = _u(
        V.type,
        V.key,
        V.props,
        null,
        z.mode,
        it
      ), Do(N, V), N.return = z, N);
    }
    function X(z, N, V, it) {
      return N === null || N.tag !== 4 || N.stateNode.containerInfo !== V.containerInfo || N.stateNode.implementation !== V.implementation ? (N = Td(V, z.mode, it), N.return = z, N) : (N = p(N, V.children || []), N.return = z, N);
    }
    function nt(z, N, V, it, ft) {
      return N === null || N.tag !== 7 ? (N = ls(
        V,
        z.mode,
        it,
        ft
      ), N.return = z, N) : (N = p(N, V), N.return = z, N);
    }
    function st(z, N, V) {
      if (typeof N == "string" && N !== "" || typeof N == "number" || typeof N == "bigint")
        return N = Sd(
          "" + N,
          z.mode,
          V
        ), N.return = z, N;
      if (typeof N == "object" && N !== null) {
        switch (N.$$typeof) {
          case b:
            return V = _u(
              N.type,
              N.key,
              N.props,
              null,
              z.mode,
              V
            ), Do(V, N), V.return = z, V;
          case v:
            return N = Td(
              N,
              z.mode,
              V
            ), N.return = z, N;
          case $:
            var it = N._init;
            return N = it(N._payload), st(z, N, V);
        }
        if (Q(N) || M(N))
          return N = ls(
            N,
            z.mode,
            V,
            null
          ), N.return = z, N;
        if (typeof N.then == "function")
          return st(z, Iu(N), V);
        if (N.$$typeof === w)
          return st(
            z,
            Cu(z, N),
            V
          );
        zu(z, N);
      }
      return null;
    }
    function K(z, N, V, it) {
      var ft = N !== null ? N.key : null;
      if (typeof V == "string" && V !== "" || typeof V == "number" || typeof V == "bigint")
        return ft !== null ? null : A(z, N, "" + V, it);
      if (typeof V == "object" && V !== null) {
        switch (V.$$typeof) {
          case b:
            return V.key === ft ? U(z, N, V, it) : null;
          case v:
            return V.key === ft ? X(z, N, V, it) : null;
          case $:
            return ft = V._init, V = ft(V._payload), K(z, N, V, it);
        }
        if (Q(V) || M(V))
          return ft !== null ? null : nt(z, N, V, it, null);
        if (typeof V.then == "function")
          return K(
            z,
            N,
            Iu(V),
            it
          );
        if (V.$$typeof === w)
          return K(
            z,
            N,
            Cu(z, V),
            it
          );
        zu(z, V);
      }
      return null;
    }
    function Z(z, N, V, it, ft) {
      if (typeof it == "string" && it !== "" || typeof it == "number" || typeof it == "bigint")
        return z = z.get(V) || null, A(N, z, "" + it, ft);
      if (typeof it == "object" && it !== null) {
        switch (it.$$typeof) {
          case b:
            return z = z.get(
              it.key === null ? V : it.key
            ) || null, U(N, z, it, ft);
          case v:
            return z = z.get(
              it.key === null ? V : it.key
            ) || null, X(N, z, it, ft);
          case $:
            var Xt = it._init;
            return it = Xt(it._payload), Z(
              z,
              N,
              V,
              it,
              ft
            );
        }
        if (Q(it) || M(it))
          return z = z.get(V) || null, nt(N, z, it, ft, null);
        if (typeof it.then == "function")
          return Z(
            z,
            N,
            V,
            Iu(it),
            ft
          );
        if (it.$$typeof === w)
          return Z(
            z,
            N,
            V,
            Cu(N, it),
            ft
          );
        zu(N, it);
      }
      return null;
    }
    function Ot(z, N, V, it) {
      for (var ft = null, Xt = null, _t = N, At = N = 0, cn = null; _t !== null && At < V.length; At++) {
        _t.index > At ? (cn = _t, _t = null) : cn = _t.sibling;
        var te = K(
          z,
          _t,
          V[At],
          it
        );
        if (te === null) {
          _t === null && (_t = cn);
          break;
        }
        r && _t && te.alternate === null && a(z, _t), N = g(te, N, At), Xt === null ? ft = te : Xt.sibling = te, Xt = te, _t = cn;
      }
      if (At === V.length)
        return u(z, _t), ie && cs(z, At), ft;
      if (_t === null) {
        for (; At < V.length; At++)
          _t = st(z, V[At], it), _t !== null && (N = g(
            _t,
            N,
            At
          ), Xt === null ? ft = _t : Xt.sibling = _t, Xt = _t);
        return ie && cs(z, At), ft;
      }
      for (_t = h(_t); At < V.length; At++)
        cn = Z(
          _t,
          z,
          At,
          V[At],
          it
        ), cn !== null && (r && cn.alternate !== null && _t.delete(
          cn.key === null ? At : cn.key
        ), N = g(
          cn,
          N,
          At
        ), Xt === null ? ft = cn : Xt.sibling = cn, Xt = cn);
      return r && _t.forEach(function(jr) {
        return a(z, jr);
      }), ie && cs(z, At), ft;
    }
    function Mt(z, N, V, it) {
      if (V == null) throw Error(i(151));
      for (var ft = null, Xt = null, _t = N, At = N = 0, cn = null, te = V.next(); _t !== null && !te.done; At++, te = V.next()) {
        _t.index > At ? (cn = _t, _t = null) : cn = _t.sibling;
        var jr = K(z, _t, te.value, it);
        if (jr === null) {
          _t === null && (_t = cn);
          break;
        }
        r && _t && jr.alternate === null && a(z, _t), N = g(jr, N, At), Xt === null ? ft = jr : Xt.sibling = jr, Xt = jr, _t = cn;
      }
      if (te.done)
        return u(z, _t), ie && cs(z, At), ft;
      if (_t === null) {
        for (; !te.done; At++, te = V.next())
          te = st(z, te.value, it), te !== null && (N = g(te, N, At), Xt === null ? ft = te : Xt.sibling = te, Xt = te);
        return ie && cs(z, At), ft;
      }
      for (_t = h(_t); !te.done; At++, te = V.next())
        te = Z(_t, z, At, te.value, it), te !== null && (r && te.alternate !== null && _t.delete(te.key === null ? At : te.key), N = g(te, N, At), Xt === null ? ft = te : Xt.sibling = te, Xt = te);
      return r && _t.forEach(function(mM) {
        return a(z, mM);
      }), ie && cs(z, At), ft;
    }
    function ye(z, N, V, it) {
      if (typeof V == "object" && V !== null && V.type === x && V.key === null && (V = V.props.children), typeof V == "object" && V !== null) {
        switch (V.$$typeof) {
          case b:
            t: {
              for (var ft = V.key; N !== null; ) {
                if (N.key === ft) {
                  if (ft = V.type, ft === x) {
                    if (N.tag === 7) {
                      u(
                        z,
                        N.sibling
                      ), it = p(
                        N,
                        V.props.children
                      ), it.return = z, z = it;
                      break t;
                    }
                  } else if (N.elementType === ft || typeof ft == "object" && ft !== null && ft.$$typeof === $ && rv(ft) === N.type) {
                    u(
                      z,
                      N.sibling
                    ), it = p(N, V.props), Do(it, V), it.return = z, z = it;
                    break t;
                  }
                  u(z, N);
                  break;
                } else a(z, N);
                N = N.sibling;
              }
              V.type === x ? (it = ls(
                V.props.children,
                z.mode,
                it,
                V.key
              ), it.return = z, z = it) : (it = _u(
                V.type,
                V.key,
                V.props,
                null,
                z.mode,
                it
              ), Do(it, V), it.return = z, z = it);
            }
            return T(z);
          case v:
            t: {
              for (ft = V.key; N !== null; ) {
                if (N.key === ft)
                  if (N.tag === 4 && N.stateNode.containerInfo === V.containerInfo && N.stateNode.implementation === V.implementation) {
                    u(
                      z,
                      N.sibling
                    ), it = p(N, V.children || []), it.return = z, z = it;
                    break t;
                  } else {
                    u(z, N);
                    break;
                  }
                else a(z, N);
                N = N.sibling;
              }
              it = Td(V, z.mode, it), it.return = z, z = it;
            }
            return T(z);
          case $:
            return ft = V._init, V = ft(V._payload), ye(
              z,
              N,
              V,
              it
            );
        }
        if (Q(V))
          return Ot(
            z,
            N,
            V,
            it
          );
        if (M(V)) {
          if (ft = M(V), typeof ft != "function") throw Error(i(150));
          return V = ft.call(V), Mt(
            z,
            N,
            V,
            it
          );
        }
        if (typeof V.then == "function")
          return ye(
            z,
            N,
            Iu(V),
            it
          );
        if (V.$$typeof === w)
          return ye(
            z,
            N,
            Cu(z, V),
            it
          );
        zu(z, V);
      }
      return typeof V == "string" && V !== "" || typeof V == "number" || typeof V == "bigint" ? (V = "" + V, N !== null && N.tag === 6 ? (u(z, N.sibling), it = p(N, V), it.return = z, z = it) : (u(z, N), it = Sd(V, z.mode, it), it.return = z, z = it), T(z)) : u(z, N);
    }
    return function(z, N, V, it) {
      try {
        Oo = 0;
        var ft = ye(
          z,
          N,
          V,
          it
        );
        return ca = null, ft;
      } catch (_t) {
        if (_t === wo || _t === Mu) throw _t;
        var Xt = Fn(29, _t, null, z.mode);
        return Xt.lanes = it, Xt.return = z, Xt;
      } finally {
      }
    };
  }
  var ha = sv(!0), av = sv(!1), ai = q(null), Pi = null;
  function Br(r) {
    var a = r.alternate;
    at(nn, nn.current & 1), at(ai, r), Pi === null && (a === null || aa.current !== null || a.memoizedState !== null) && (Pi = r);
  }
  function ov(r) {
    if (r.tag === 22) {
      if (at(nn, nn.current), at(ai, r), Pi === null) {
        var a = r.alternate;
        a !== null && a.memoizedState !== null && (Pi = r);
      }
    } else kr();
  }
  function kr() {
    at(nn, nn.current), at(ai, ai.current);
  }
  function tr(r) {
    ot(ai), Pi === r && (Pi = null), ot(nn);
  }
  var nn = q(0);
  function Lu(r) {
    for (var a = r; a !== null; ) {
      if (a.tag === 13) {
        var u = a.memoizedState;
        if (u !== null && (u = u.dehydrated, u === null || u.data === "$?" || jf(u)))
          return a;
      } else if (a.tag === 19 && a.memoizedProps.revealOrder !== void 0) {
        if ((a.flags & 128) !== 0) return a;
      } else if (a.child !== null) {
        a.child.return = a, a = a.child;
        continue;
      }
      if (a === r) break;
      for (; a.sibling === null; ) {
        if (a.return === null || a.return === r) return null;
        a = a.return;
      }
      a.sibling.return = a.return, a = a.sibling;
    }
    return null;
  }
  function nf(r, a, u, h) {
    a = r.memoizedState, u = u(h, a), u = u == null ? a : m({}, a, u), r.memoizedState = u, r.lanes === 0 && (r.updateQueue.baseState = u);
  }
  var rf = {
    enqueueSetState: function(r, a, u) {
      r = r._reactInternals;
      var h = Vn(), p = Ar(h);
      p.payload = a, u != null && (p.callback = u), a = Rr(r, p, h), a !== null && (jn(a, r, h), Eo(a, r, h));
    },
    enqueueReplaceState: function(r, a, u) {
      r = r._reactInternals;
      var h = Vn(), p = Ar(h);
      p.tag = 1, p.payload = a, u != null && (p.callback = u), a = Rr(r, p, h), a !== null && (jn(a, r, h), Eo(a, r, h));
    },
    enqueueForceUpdate: function(r, a) {
      r = r._reactInternals;
      var u = Vn(), h = Ar(u);
      h.tag = 2, a != null && (h.callback = a), a = Rr(r, h, u), a !== null && (jn(a, r, u), Eo(a, r, u));
    }
  };
  function lv(r, a, u, h, p, g, T) {
    return r = r.stateNode, typeof r.shouldComponentUpdate == "function" ? r.shouldComponentUpdate(h, g, T) : a.prototype && a.prototype.isPureReactComponent ? !go(u, h) || !go(p, g) : !0;
  }
  function uv(r, a, u, h) {
    r = a.state, typeof a.componentWillReceiveProps == "function" && a.componentWillReceiveProps(u, h), typeof a.UNSAFE_componentWillReceiveProps == "function" && a.UNSAFE_componentWillReceiveProps(u, h), a.state !== r && rf.enqueueReplaceState(a, a.state, null);
  }
  function ys(r, a) {
    var u = a;
    if ("ref" in a) {
      u = {};
      for (var h in a)
        h !== "ref" && (u[h] = a[h]);
    }
    if (r = r.defaultProps) {
      u === a && (u = m({}, u));
      for (var p in r)
        u[p] === void 0 && (u[p] = r[p]);
    }
    return u;
  }
  var Fu = typeof reportError == "function" ? reportError : function(r) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
      var a = new window.ErrorEvent("error", {
        bubbles: !0,
        cancelable: !0,
        message: typeof r == "object" && r !== null && typeof r.message == "string" ? String(r.message) : String(r),
        error: r
      });
      if (!window.dispatchEvent(a)) return;
    } else if (typeof process == "object" && typeof process.emit == "function") {
      process.emit("uncaughtException", r);
      return;
    }
    console.error(r);
  };
  function cv(r) {
    Fu(r);
  }
  function hv(r) {
    console.error(r);
  }
  function dv(r) {
    Fu(r);
  }
  function Hu(r, a) {
    try {
      var u = r.onUncaughtError;
      u(a.value, { componentStack: a.stack });
    } catch (h) {
      setTimeout(function() {
        throw h;
      });
    }
  }
  function fv(r, a, u) {
    try {
      var h = r.onCaughtError;
      h(u.value, {
        componentStack: u.stack,
        errorBoundary: a.tag === 1 ? a.stateNode : null
      });
    } catch (p) {
      setTimeout(function() {
        throw p;
      });
    }
  }
  function sf(r, a, u) {
    return u = Ar(u), u.tag = 3, u.payload = { element: null }, u.callback = function() {
      Hu(r, a);
    }, u;
  }
  function pv(r) {
    return r = Ar(r), r.tag = 3, r;
  }
  function mv(r, a, u, h) {
    var p = u.type.getDerivedStateFromError;
    if (typeof p == "function") {
      var g = h.value;
      r.payload = function() {
        return p(g);
      }, r.callback = function() {
        fv(a, u, h);
      };
    }
    var T = u.stateNode;
    T !== null && typeof T.componentDidCatch == "function" && (r.callback = function() {
      fv(a, u, h), typeof p != "function" && (Ir === null ? Ir = /* @__PURE__ */ new Set([this]) : Ir.add(this));
      var A = h.stack;
      this.componentDidCatch(h.value, {
        componentStack: A !== null ? A : ""
      });
    });
  }
  function m2(r, a, u, h, p) {
    if (u.flags |= 32768, h !== null && typeof h == "object" && typeof h.then == "function") {
      if (a = u.alternate, a !== null && _o(
        a,
        u,
        p,
        !0
      ), u = ai.current, u !== null) {
        switch (u.tag) {
          case 13:
            return Pi === null ? Rf() : u.alternate === null && Le === 0 && (Le = 3), u.flags &= -257, u.flags |= 65536, u.lanes = p, h === Od ? u.flags |= 16384 : (a = u.updateQueue, a === null ? u.updateQueue = /* @__PURE__ */ new Set([h]) : a.add(h), Bf(r, h, p)), !1;
          case 22:
            return u.flags |= 65536, h === Od ? u.flags |= 16384 : (a = u.updateQueue, a === null ? (a = {
              transitions: null,
              markerInstances: null,
              retryQueue: /* @__PURE__ */ new Set([h])
            }, u.updateQueue = a) : (u = a.retryQueue, u === null ? a.retryQueue = /* @__PURE__ */ new Set([h]) : u.add(h)), Bf(r, h, p)), !1;
        }
        throw Error(i(435, u.tag));
      }
      return Bf(r, h, p), Rf(), !1;
    }
    if (ie)
      return a = ai.current, a !== null ? ((a.flags & 65536) === 0 && (a.flags |= 256), a.flags |= 65536, a.lanes = p, h !== Ed && (r = Error(i(422), { cause: h }), xo(ni(r, u)))) : (h !== Ed && (a = Error(i(423), {
        cause: h
      }), xo(
        ni(a, u)
      )), r = r.current.alternate, r.flags |= 65536, p &= -p, r.lanes |= p, h = ni(h, u), p = sf(
        r.stateNode,
        h,
        p
      ), Ud(r, p), Le !== 4 && (Le = 2)), !1;
    var g = Error(i(520), { cause: h });
    if (g = ni(g, u), Fo === null ? Fo = [g] : Fo.push(g), Le !== 4 && (Le = 2), a === null) return !0;
    h = ni(h, u), u = a;
    do {
      switch (u.tag) {
        case 3:
          return u.flags |= 65536, r = p & -p, u.lanes |= r, r = sf(u.stateNode, h, r), Ud(u, r), !1;
        case 1:
          if (a = u.type, g = u.stateNode, (u.flags & 128) === 0 && (typeof a.getDerivedStateFromError == "function" || g !== null && typeof g.componentDidCatch == "function" && (Ir === null || !Ir.has(g))))
            return u.flags |= 65536, p &= -p, u.lanes |= p, p = pv(p), mv(
              p,
              r,
              u,
              h
            ), Ud(u, p), !1;
      }
      u = u.return;
    } while (u !== null);
    return !1;
  }
  var gv = Error(i(461)), ln = !1;
  function dn(r, a, u, h) {
    a.child = r === null ? av(a, null, u, h) : ha(
      a,
      r.child,
      u,
      h
    );
  }
  function yv(r, a, u, h, p) {
    u = u.render;
    var g = a.ref;
    if ("ref" in h) {
      var T = {};
      for (var A in h)
        A !== "ref" && (T[A] = h[A]);
    } else T = h;
    return ps(a), h = Fd(
      r,
      a,
      u,
      T,
      g,
      p
    ), A = Hd(), r !== null && !ln ? ($d(r, a, p), er(r, a, p)) : (ie && A && wd(a), a.flags |= 1, dn(r, a, h, p), a.child);
  }
  function bv(r, a, u, h, p) {
    if (r === null) {
      var g = u.type;
      return typeof g == "function" && !_d(g) && g.defaultProps === void 0 && u.compare === null ? (a.tag = 15, a.type = g, vv(
        r,
        a,
        g,
        h,
        p
      )) : (r = _u(
        u.type,
        null,
        h,
        a,
        a.mode,
        p
      ), r.ref = a.ref, r.return = a, a.child = r);
    }
    if (g = r.child, !ff(r, p)) {
      var T = g.memoizedProps;
      if (u = u.compare, u = u !== null ? u : go, u(T, h) && r.ref === a.ref)
        return er(r, a, p);
    }
    return a.flags |= 1, r = Xi(g, h), r.ref = a.ref, r.return = a, a.child = r;
  }
  function vv(r, a, u, h, p) {
    if (r !== null) {
      var g = r.memoizedProps;
      if (go(g, h) && r.ref === a.ref)
        if (ln = !1, a.pendingProps = h = g, ff(r, p))
          (r.flags & 131072) !== 0 && (ln = !0);
        else
          return a.lanes = r.lanes, er(r, a, p);
    }
    return af(
      r,
      a,
      u,
      h,
      p
    );
  }
  function xv(r, a, u) {
    var h = a.pendingProps, p = h.children, g = r !== null ? r.memoizedState : null;
    if (h.mode === "hidden") {
      if ((a.flags & 128) !== 0) {
        if (h = g !== null ? g.baseLanes | u : u, r !== null) {
          for (p = a.child = r.child, g = 0; p !== null; )
            g = g | p.lanes | p.childLanes, p = p.sibling;
          a.childLanes = g & ~h;
        } else a.childLanes = 0, a.child = null;
        return _v(
          r,
          a,
          h,
          u
        );
      }
      if ((u & 536870912) !== 0)
        a.memoizedState = { baseLanes: 0, cachePool: null }, r !== null && Eu(
          a,
          g !== null ? g.cachePool : null
        ), g !== null ? vb(a, g) : Id(), ov(a);
      else
        return a.lanes = a.childLanes = 536870912, _v(
          r,
          a,
          g !== null ? g.baseLanes | u : u,
          u
        );
    } else
      g !== null ? (Eu(a, g.cachePool), vb(a, g), kr(), a.memoizedState = null) : (r !== null && Eu(a, null), Id(), kr());
    return dn(r, a, p, u), a.child;
  }
  function _v(r, a, u, h) {
    var p = kd();
    return p = p === null ? null : { parent: en._currentValue, pool: p }, a.memoizedState = {
      baseLanes: u,
      cachePool: p
    }, r !== null && Eu(a, null), Id(), ov(a), r !== null && _o(r, a, h, !0), null;
  }
  function $u(r, a) {
    var u = a.ref;
    if (u === null)
      r !== null && r.ref !== null && (a.flags |= 4194816);
    else {
      if (typeof u != "function" && typeof u != "object")
        throw Error(i(284));
      (r === null || r.ref !== u) && (a.flags |= 4194816);
    }
  }
  function af(r, a, u, h, p) {
    return ps(a), u = Fd(
      r,
      a,
      u,
      h,
      void 0,
      p
    ), h = Hd(), r !== null && !ln ? ($d(r, a, p), er(r, a, p)) : (ie && h && wd(a), a.flags |= 1, dn(r, a, u, p), a.child);
  }
  function Sv(r, a, u, h, p, g) {
    return ps(a), a.updateQueue = null, u = _b(
      a,
      h,
      u,
      p
    ), xb(r), h = Hd(), r !== null && !ln ? ($d(r, a, g), er(r, a, g)) : (ie && h && wd(a), a.flags |= 1, dn(r, a, u, g), a.child);
  }
  function Tv(r, a, u, h, p) {
    if (ps(a), a.stateNode === null) {
      var g = ea, T = u.contextType;
      typeof T == "object" && T !== null && (g = bn(T)), g = new u(h, g), a.memoizedState = g.state !== null && g.state !== void 0 ? g.state : null, g.updater = rf, a.stateNode = g, g._reactInternals = a, g = a.stateNode, g.props = h, g.state = a.memoizedState, g.refs = {}, Dd(a), T = u.contextType, g.context = typeof T == "object" && T !== null ? bn(T) : ea, g.state = a.memoizedState, T = u.getDerivedStateFromProps, typeof T == "function" && (nf(
        a,
        u,
        T,
        h
      ), g.state = a.memoizedState), typeof u.getDerivedStateFromProps == "function" || typeof g.getSnapshotBeforeUpdate == "function" || typeof g.UNSAFE_componentWillMount != "function" && typeof g.componentWillMount != "function" || (T = g.state, typeof g.componentWillMount == "function" && g.componentWillMount(), typeof g.UNSAFE_componentWillMount == "function" && g.UNSAFE_componentWillMount(), T !== g.state && rf.enqueueReplaceState(g, g.state, null), Ao(a, h, g, p), Mo(), g.state = a.memoizedState), typeof g.componentDidMount == "function" && (a.flags |= 4194308), h = !0;
    } else if (r === null) {
      g = a.stateNode;
      var A = a.memoizedProps, U = ys(u, A);
      g.props = U;
      var X = g.context, nt = u.contextType;
      T = ea, typeof nt == "object" && nt !== null && (T = bn(nt));
      var st = u.getDerivedStateFromProps;
      nt = typeof st == "function" || typeof g.getSnapshotBeforeUpdate == "function", A = a.pendingProps !== A, nt || typeof g.UNSAFE_componentWillReceiveProps != "function" && typeof g.componentWillReceiveProps != "function" || (A || X !== T) && uv(
        a,
        g,
        h,
        T
      ), Mr = !1;
      var K = a.memoizedState;
      g.state = K, Ao(a, h, g, p), Mo(), X = a.memoizedState, A || K !== X || Mr ? (typeof st == "function" && (nf(
        a,
        u,
        st,
        h
      ), X = a.memoizedState), (U = Mr || lv(
        a,
        u,
        U,
        h,
        K,
        X,
        T
      )) ? (nt || typeof g.UNSAFE_componentWillMount != "function" && typeof g.componentWillMount != "function" || (typeof g.componentWillMount == "function" && g.componentWillMount(), typeof g.UNSAFE_componentWillMount == "function" && g.UNSAFE_componentWillMount()), typeof g.componentDidMount == "function" && (a.flags |= 4194308)) : (typeof g.componentDidMount == "function" && (a.flags |= 4194308), a.memoizedProps = h, a.memoizedState = X), g.props = h, g.state = X, g.context = T, h = U) : (typeof g.componentDidMount == "function" && (a.flags |= 4194308), h = !1);
    } else {
      g = a.stateNode, Gd(r, a), T = a.memoizedProps, nt = ys(u, T), g.props = nt, st = a.pendingProps, K = g.context, X = u.contextType, U = ea, typeof X == "object" && X !== null && (U = bn(X)), A = u.getDerivedStateFromProps, (X = typeof A == "function" || typeof g.getSnapshotBeforeUpdate == "function") || typeof g.UNSAFE_componentWillReceiveProps != "function" && typeof g.componentWillReceiveProps != "function" || (T !== st || K !== U) && uv(
        a,
        g,
        h,
        U
      ), Mr = !1, K = a.memoizedState, g.state = K, Ao(a, h, g, p), Mo();
      var Z = a.memoizedState;
      T !== st || K !== Z || Mr || r !== null && r.dependencies !== null && wu(r.dependencies) ? (typeof A == "function" && (nf(
        a,
        u,
        A,
        h
      ), Z = a.memoizedState), (nt = Mr || lv(
        a,
        u,
        nt,
        h,
        K,
        Z,
        U
      ) || r !== null && r.dependencies !== null && wu(r.dependencies)) ? (X || typeof g.UNSAFE_componentWillUpdate != "function" && typeof g.componentWillUpdate != "function" || (typeof g.componentWillUpdate == "function" && g.componentWillUpdate(h, Z, U), typeof g.UNSAFE_componentWillUpdate == "function" && g.UNSAFE_componentWillUpdate(
        h,
        Z,
        U
      )), typeof g.componentDidUpdate == "function" && (a.flags |= 4), typeof g.getSnapshotBeforeUpdate == "function" && (a.flags |= 1024)) : (typeof g.componentDidUpdate != "function" || T === r.memoizedProps && K === r.memoizedState || (a.flags |= 4), typeof g.getSnapshotBeforeUpdate != "function" || T === r.memoizedProps && K === r.memoizedState || (a.flags |= 1024), a.memoizedProps = h, a.memoizedState = Z), g.props = h, g.state = Z, g.context = U, h = nt) : (typeof g.componentDidUpdate != "function" || T === r.memoizedProps && K === r.memoizedState || (a.flags |= 4), typeof g.getSnapshotBeforeUpdate != "function" || T === r.memoizedProps && K === r.memoizedState || (a.flags |= 1024), h = !1);
    }
    return g = h, $u(r, a), h = (a.flags & 128) !== 0, g || h ? (g = a.stateNode, u = h && typeof u.getDerivedStateFromError != "function" ? null : g.render(), a.flags |= 1, r !== null && h ? (a.child = ha(
      a,
      r.child,
      null,
      p
    ), a.child = ha(
      a,
      null,
      u,
      p
    )) : dn(r, a, u, p), a.memoizedState = g.state, r = a.child) : r = er(
      r,
      a,
      p
    ), r;
  }
  function wv(r, a, u, h) {
    return vo(), a.flags |= 256, dn(r, a, u, h), a.child;
  }
  var of = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0,
    hydrationErrors: null
  };
  function lf(r) {
    return { baseLanes: r, cachePool: hb() };
  }
  function uf(r, a, u) {
    return r = r !== null ? r.childLanes & ~u : 0, a && (r |= oi), r;
  }
  function Cv(r, a, u) {
    var h = a.pendingProps, p = !1, g = (a.flags & 128) !== 0, T;
    if ((T = g) || (T = r !== null && r.memoizedState === null ? !1 : (nn.current & 2) !== 0), T && (p = !0, a.flags &= -129), T = (a.flags & 32) !== 0, a.flags &= -33, r === null) {
      if (ie) {
        if (p ? Br(a) : kr(), ie) {
          var A = ze, U;
          if (U = A) {
            t: {
              for (U = A, A = Ri; U.nodeType !== 8; ) {
                if (!A) {
                  A = null;
                  break t;
                }
                if (U = bi(
                  U.nextSibling
                ), U === null) {
                  A = null;
                  break t;
                }
              }
              A = U;
            }
            A !== null ? (a.memoizedState = {
              dehydrated: A,
              treeContext: us !== null ? { id: qi, overflow: Ki } : null,
              retryLane: 536870912,
              hydrationErrors: null
            }, U = Fn(
              18,
              null,
              null,
              0
            ), U.stateNode = A, U.return = a, a.child = U, En = a, ze = null, U = !0) : U = !1;
          }
          U || ds(a);
        }
        if (A = a.memoizedState, A !== null && (A = A.dehydrated, A !== null))
          return jf(A) ? a.lanes = 32 : a.lanes = 536870912, null;
        tr(a);
      }
      return A = h.children, h = h.fallback, p ? (kr(), p = a.mode, A = Wu(
        { mode: "hidden", children: A },
        p
      ), h = ls(
        h,
        p,
        u,
        null
      ), A.return = a, h.return = a, A.sibling = h, a.child = A, p = a.child, p.memoizedState = lf(u), p.childLanes = uf(
        r,
        T,
        u
      ), a.memoizedState = of, h) : (Br(a), cf(a, A));
    }
    if (U = r.memoizedState, U !== null && (A = U.dehydrated, A !== null)) {
      if (g)
        a.flags & 256 ? (Br(a), a.flags &= -257, a = hf(
          r,
          a,
          u
        )) : a.memoizedState !== null ? (kr(), a.child = r.child, a.flags |= 128, a = null) : (kr(), p = h.fallback, A = a.mode, h = Wu(
          { mode: "visible", children: h.children },
          A
        ), p = ls(
          p,
          A,
          u,
          null
        ), p.flags |= 2, h.return = a, p.return = a, h.sibling = p, a.child = h, ha(
          a,
          r.child,
          null,
          u
        ), h = a.child, h.memoizedState = lf(u), h.childLanes = uf(
          r,
          T,
          u
        ), a.memoizedState = of, a = p);
      else if (Br(a), jf(A)) {
        if (T = A.nextSibling && A.nextSibling.dataset, T) var X = T.dgst;
        T = X, h = Error(i(419)), h.stack = "", h.digest = T, xo({ value: h, source: null, stack: null }), a = hf(
          r,
          a,
          u
        );
      } else if (ln || _o(r, a, u, !1), T = (u & r.childLanes) !== 0, ln || T) {
        if (T = Ce, T !== null && (h = u & -u, h = (h & 42) !== 0 ? 1 : zn(h), h = (h & (T.suspendedLanes | u)) !== 0 ? 0 : h, h !== 0 && h !== U.retryLane))
          throw U.retryLane = h, ta(r, h), jn(T, r, h), gv;
        A.data === "$?" || Rf(), a = hf(
          r,
          a,
          u
        );
      } else
        A.data === "$?" ? (a.flags |= 192, a.child = r.child, a = null) : (r = U.treeContext, ze = bi(
          A.nextSibling
        ), En = a, ie = !0, hs = null, Ri = !1, r !== null && (ri[si++] = qi, ri[si++] = Ki, ri[si++] = us, qi = r.id, Ki = r.overflow, us = a), a = cf(
          a,
          h.children
        ), a.flags |= 4096);
      return a;
    }
    return p ? (kr(), p = h.fallback, A = a.mode, U = r.child, X = U.sibling, h = Xi(U, {
      mode: "hidden",
      children: h.children
    }), h.subtreeFlags = U.subtreeFlags & 65011712, X !== null ? p = Xi(X, p) : (p = ls(
      p,
      A,
      u,
      null
    ), p.flags |= 2), p.return = a, h.return = a, h.sibling = p, a.child = h, h = p, p = a.child, A = r.child.memoizedState, A === null ? A = lf(u) : (U = A.cachePool, U !== null ? (X = en._currentValue, U = U.parent !== X ? { parent: X, pool: X } : U) : U = hb(), A = {
      baseLanes: A.baseLanes | u,
      cachePool: U
    }), p.memoizedState = A, p.childLanes = uf(
      r,
      T,
      u
    ), a.memoizedState = of, h) : (Br(a), u = r.child, r = u.sibling, u = Xi(u, {
      mode: "visible",
      children: h.children
    }), u.return = a, u.sibling = null, r !== null && (T = a.deletions, T === null ? (a.deletions = [r], a.flags |= 16) : T.push(r)), a.child = u, a.memoizedState = null, u);
  }
  function cf(r, a) {
    return a = Wu(
      { mode: "visible", children: a },
      r.mode
    ), a.return = r, r.child = a;
  }
  function Wu(r, a) {
    return r = Fn(22, r, null, a), r.lanes = 0, r.stateNode = {
      _visibility: 1,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null
    }, r;
  }
  function hf(r, a, u) {
    return ha(a, r.child, null, u), r = cf(
      a,
      a.pendingProps.children
    ), r.flags |= 2, a.memoizedState = null, r;
  }
  function Ev(r, a, u) {
    r.lanes |= a;
    var h = r.alternate;
    h !== null && (h.lanes |= a), Ad(r.return, a, u);
  }
  function df(r, a, u, h, p) {
    var g = r.memoizedState;
    g === null ? r.memoizedState = {
      isBackwards: a,
      rendering: null,
      renderingStartTime: 0,
      last: h,
      tail: u,
      tailMode: p
    } : (g.isBackwards = a, g.rendering = null, g.renderingStartTime = 0, g.last = h, g.tail = u, g.tailMode = p);
  }
  function Mv(r, a, u) {
    var h = a.pendingProps, p = h.revealOrder, g = h.tail;
    if (dn(r, a, h.children, u), h = nn.current, (h & 2) !== 0)
      h = h & 1 | 2, a.flags |= 128;
    else {
      if (r !== null && (r.flags & 128) !== 0)
        t: for (r = a.child; r !== null; ) {
          if (r.tag === 13)
            r.memoizedState !== null && Ev(r, u, a);
          else if (r.tag === 19)
            Ev(r, u, a);
          else if (r.child !== null) {
            r.child.return = r, r = r.child;
            continue;
          }
          if (r === a) break t;
          for (; r.sibling === null; ) {
            if (r.return === null || r.return === a)
              break t;
            r = r.return;
          }
          r.sibling.return = r.return, r = r.sibling;
        }
      h &= 1;
    }
    switch (at(nn, h), p) {
      case "forwards":
        for (u = a.child, p = null; u !== null; )
          r = u.alternate, r !== null && Lu(r) === null && (p = u), u = u.sibling;
        u = p, u === null ? (p = a.child, a.child = null) : (p = u.sibling, u.sibling = null), df(
          a,
          !1,
          p,
          u,
          g
        );
        break;
      case "backwards":
        for (u = null, p = a.child, a.child = null; p !== null; ) {
          if (r = p.alternate, r !== null && Lu(r) === null) {
            a.child = p;
            break;
          }
          r = p.sibling, p.sibling = u, u = p, p = r;
        }
        df(
          a,
          !0,
          u,
          null,
          g
        );
        break;
      case "together":
        df(a, !1, null, null, void 0);
        break;
      default:
        a.memoizedState = null;
    }
    return a.child;
  }
  function er(r, a, u) {
    if (r !== null && (a.dependencies = r.dependencies), Nr |= a.lanes, (u & a.childLanes) === 0)
      if (r !== null) {
        if (_o(
          r,
          a,
          u,
          !1
        ), (u & a.childLanes) === 0)
          return null;
      } else return null;
    if (r !== null && a.child !== r.child)
      throw Error(i(153));
    if (a.child !== null) {
      for (r = a.child, u = Xi(r, r.pendingProps), a.child = u, u.return = a; r.sibling !== null; )
        r = r.sibling, u = u.sibling = Xi(r, r.pendingProps), u.return = a;
      u.sibling = null;
    }
    return a.child;
  }
  function ff(r, a) {
    return (r.lanes & a) !== 0 ? !0 : (r = r.dependencies, !!(r !== null && wu(r)));
  }
  function g2(r, a, u) {
    switch (a.tag) {
      case 3:
        Rt(a, a.stateNode.containerInfo), Er(a, en, r.memoizedState.cache), vo();
        break;
      case 27:
      case 5:
        gt(a);
        break;
      case 4:
        Rt(a, a.stateNode.containerInfo);
        break;
      case 10:
        Er(
          a,
          a.type,
          a.memoizedProps.value
        );
        break;
      case 13:
        var h = a.memoizedState;
        if (h !== null)
          return h.dehydrated !== null ? (Br(a), a.flags |= 128, null) : (u & a.child.childLanes) !== 0 ? Cv(r, a, u) : (Br(a), r = er(
            r,
            a,
            u
          ), r !== null ? r.sibling : null);
        Br(a);
        break;
      case 19:
        var p = (r.flags & 128) !== 0;
        if (h = (u & a.childLanes) !== 0, h || (_o(
          r,
          a,
          u,
          !1
        ), h = (u & a.childLanes) !== 0), p) {
          if (h)
            return Mv(
              r,
              a,
              u
            );
          a.flags |= 128;
        }
        if (p = a.memoizedState, p !== null && (p.rendering = null, p.tail = null, p.lastEffect = null), at(nn, nn.current), h) break;
        return null;
      case 22:
      case 23:
        return a.lanes = 0, xv(r, a, u);
      case 24:
        Er(a, en, r.memoizedState.cache);
    }
    return er(r, a, u);
  }
  function Av(r, a, u) {
    if (r !== null)
      if (r.memoizedProps !== a.pendingProps)
        ln = !0;
      else {
        if (!ff(r, u) && (a.flags & 128) === 0)
          return ln = !1, g2(
            r,
            a,
            u
          );
        ln = (r.flags & 131072) !== 0;
      }
    else
      ln = !1, ie && (a.flags & 1048576) !== 0 && rb(a, Tu, a.index);
    switch (a.lanes = 0, a.tag) {
      case 16:
        t: {
          r = a.pendingProps;
          var h = a.elementType, p = h._init;
          if (h = p(h._payload), a.type = h, typeof h == "function")
            _d(h) ? (r = ys(h, r), a.tag = 1, a = Tv(
              null,
              a,
              h,
              r,
              u
            )) : (a.tag = 0, a = af(
              null,
              a,
              h,
              r,
              u
            ));
          else {
            if (h != null) {
              if (p = h.$$typeof, p === E) {
                a.tag = 11, a = yv(
                  null,
                  a,
                  h,
                  r,
                  u
                );
                break t;
              } else if (p === G) {
                a.tag = 14, a = bv(
                  null,
                  a,
                  h,
                  r,
                  u
                );
                break t;
              }
            }
            throw a = L(h) || h, Error(i(306, a, ""));
          }
        }
        return a;
      case 0:
        return af(
          r,
          a,
          a.type,
          a.pendingProps,
          u
        );
      case 1:
        return h = a.type, p = ys(
          h,
          a.pendingProps
        ), Tv(
          r,
          a,
          h,
          p,
          u
        );
      case 3:
        t: {
          if (Rt(
            a,
            a.stateNode.containerInfo
          ), r === null) throw Error(i(387));
          h = a.pendingProps;
          var g = a.memoizedState;
          p = g.element, Gd(r, a), Ao(a, h, null, u);
          var T = a.memoizedState;
          if (h = T.cache, Er(a, en, h), h !== g.cache && Rd(
            a,
            [en],
            u,
            !0
          ), Mo(), h = T.element, g.isDehydrated)
            if (g = {
              element: h,
              isDehydrated: !1,
              cache: T.cache
            }, a.updateQueue.baseState = g, a.memoizedState = g, a.flags & 256) {
              a = wv(
                r,
                a,
                h,
                u
              );
              break t;
            } else if (h !== p) {
              p = ni(
                Error(i(424)),
                a
              ), xo(p), a = wv(
                r,
                a,
                h,
                u
              );
              break t;
            } else {
              switch (r = a.stateNode.containerInfo, r.nodeType) {
                case 9:
                  r = r.body;
                  break;
                default:
                  r = r.nodeName === "HTML" ? r.ownerDocument.body : r;
              }
              for (ze = bi(r.firstChild), En = a, ie = !0, hs = null, Ri = !0, u = av(
                a,
                null,
                h,
                u
              ), a.child = u; u; )
                u.flags = u.flags & -3 | 4096, u = u.sibling;
            }
          else {
            if (vo(), h === p) {
              a = er(
                r,
                a,
                u
              );
              break t;
            }
            dn(
              r,
              a,
              h,
              u
            );
          }
          a = a.child;
        }
        return a;
      case 26:
        return $u(r, a), r === null ? (u = kx(
          a.type,
          null,
          a.pendingProps,
          null
        )) ? a.memoizedState = u : ie || (u = a.type, r = a.pendingProps, h = rc(
          ht.current
        ).createElement(u), h[yn] = a, h[kn] = r, pn(h, u, r), on(h), a.stateNode = h) : a.memoizedState = kx(
          a.type,
          r.memoizedProps,
          a.pendingProps,
          r.memoizedState
        ), null;
      case 27:
        return gt(a), r === null && ie && (h = a.stateNode = Rx(
          a.type,
          a.pendingProps,
          ht.current
        ), En = a, Ri = !0, p = ze, Fr(a.type) ? (Yf = p, ze = bi(
          h.firstChild
        )) : ze = p), dn(
          r,
          a,
          a.pendingProps.children,
          u
        ), $u(r, a), r === null && (a.flags |= 4194304), a.child;
      case 5:
        return r === null && ie && ((p = h = ze) && (h = W2(
          h,
          a.type,
          a.pendingProps,
          Ri
        ), h !== null ? (a.stateNode = h, En = a, ze = bi(
          h.firstChild
        ), Ri = !1, p = !0) : p = !1), p || ds(a)), gt(a), p = a.type, g = a.pendingProps, T = r !== null ? r.memoizedProps : null, h = g.children, $f(p, g) ? h = null : T !== null && $f(p, T) && (a.flags |= 32), a.memoizedState !== null && (p = Fd(
          r,
          a,
          l2,
          null,
          null,
          u
        ), Ko._currentValue = p), $u(r, a), dn(r, a, h, u), a.child;
      case 6:
        return r === null && ie && ((r = u = ze) && (u = V2(
          u,
          a.pendingProps,
          Ri
        ), u !== null ? (a.stateNode = u, En = a, ze = null, r = !0) : r = !1), r || ds(a)), null;
      case 13:
        return Cv(r, a, u);
      case 4:
        return Rt(
          a,
          a.stateNode.containerInfo
        ), h = a.pendingProps, r === null ? a.child = ha(
          a,
          null,
          h,
          u
        ) : dn(
          r,
          a,
          h,
          u
        ), a.child;
      case 11:
        return yv(
          r,
          a,
          a.type,
          a.pendingProps,
          u
        );
      case 7:
        return dn(
          r,
          a,
          a.pendingProps,
          u
        ), a.child;
      case 8:
        return dn(
          r,
          a,
          a.pendingProps.children,
          u
        ), a.child;
      case 12:
        return dn(
          r,
          a,
          a.pendingProps.children,
          u
        ), a.child;
      case 10:
        return h = a.pendingProps, Er(a, a.type, h.value), dn(
          r,
          a,
          h.children,
          u
        ), a.child;
      case 9:
        return p = a.type._context, h = a.pendingProps.children, ps(a), p = bn(p), h = h(p), a.flags |= 1, dn(r, a, h, u), a.child;
      case 14:
        return bv(
          r,
          a,
          a.type,
          a.pendingProps,
          u
        );
      case 15:
        return vv(
          r,
          a,
          a.type,
          a.pendingProps,
          u
        );
      case 19:
        return Mv(r, a, u);
      case 31:
        return h = a.pendingProps, u = a.mode, h = {
          mode: h.mode,
          children: h.children
        }, r === null ? (u = Wu(
          h,
          u
        ), u.ref = a.ref, a.child = u, u.return = a, a = u) : (u = Xi(r.child, h), u.ref = a.ref, a.child = u, u.return = a, a = u), a;
      case 22:
        return xv(r, a, u);
      case 24:
        return ps(a), h = bn(en), r === null ? (p = kd(), p === null && (p = Ce, g = Pd(), p.pooledCache = g, g.refCount++, g !== null && (p.pooledCacheLanes |= u), p = g), a.memoizedState = {
          parent: h,
          cache: p
        }, Dd(a), Er(a, en, p)) : ((r.lanes & u) !== 0 && (Gd(r, a), Ao(a, null, null, u), Mo()), p = r.memoizedState, g = a.memoizedState, p.parent !== h ? (p = { parent: h, cache: h }, a.memoizedState = p, a.lanes === 0 && (a.memoizedState = a.updateQueue.baseState = p), Er(a, en, h)) : (h = g.cache, Er(a, en, h), h !== p.cache && Rd(
          a,
          [en],
          u,
          !0
        ))), dn(
          r,
          a,
          a.pendingProps.children,
          u
        ), a.child;
      case 29:
        throw a.pendingProps;
    }
    throw Error(i(156, a.tag));
  }
  function nr(r) {
    r.flags |= 4;
  }
  function Rv(r, a) {
    if (a.type !== "stylesheet" || (a.state.loading & 4) !== 0)
      r.flags &= -16777217;
    else if (r.flags |= 16777216, !Nx(a)) {
      if (a = ai.current, a !== null && ((Zt & 4194048) === Zt ? Pi !== null : (Zt & 62914560) !== Zt && (Zt & 536870912) === 0 || a !== Pi))
        throw Co = Od, db;
      r.flags |= 8192;
    }
  }
  function Vu(r, a) {
    a !== null && (r.flags |= 4), r.flags & 16384 && (a = r.tag !== 22 ? Is() : 536870912, r.lanes |= a, ma |= a);
  }
  function Go(r, a) {
    if (!ie)
      switch (r.tailMode) {
        case "hidden":
          a = r.tail;
          for (var u = null; a !== null; )
            a.alternate !== null && (u = a), a = a.sibling;
          u === null ? r.tail = null : u.sibling = null;
          break;
        case "collapsed":
          u = r.tail;
          for (var h = null; u !== null; )
            u.alternate !== null && (h = u), u = u.sibling;
          h === null ? a || r.tail === null ? r.tail = null : r.tail.sibling = null : h.sibling = null;
      }
  }
  function Ge(r) {
    var a = r.alternate !== null && r.alternate.child === r.child, u = 0, h = 0;
    if (a)
      for (var p = r.child; p !== null; )
        u |= p.lanes | p.childLanes, h |= p.subtreeFlags & 65011712, h |= p.flags & 65011712, p.return = r, p = p.sibling;
    else
      for (p = r.child; p !== null; )
        u |= p.lanes | p.childLanes, h |= p.subtreeFlags, h |= p.flags, p.return = r, p = p.sibling;
    return r.subtreeFlags |= h, r.childLanes = u, a;
  }
  function y2(r, a, u) {
    var h = a.pendingProps;
    switch (Cd(a), a.tag) {
      case 31:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return Ge(a), null;
      case 1:
        return Ge(a), null;
      case 3:
        return u = a.stateNode, h = null, r !== null && (h = r.memoizedState.cache), a.memoizedState.cache !== h && (a.flags |= 2048), Qi(en), Dt(), u.pendingContext && (u.context = u.pendingContext, u.pendingContext = null), (r === null || r.child === null) && (bo(a) ? nr(a) : r === null || r.memoizedState.isDehydrated && (a.flags & 256) === 0 || (a.flags |= 1024, ob())), Ge(a), null;
      case 26:
        return u = a.memoizedState, r === null ? (nr(a), u !== null ? (Ge(a), Rv(a, u)) : (Ge(a), a.flags &= -16777217)) : u ? u !== r.memoizedState ? (nr(a), Ge(a), Rv(a, u)) : (Ge(a), a.flags &= -16777217) : (r.memoizedProps !== h && nr(a), Ge(a), a.flags &= -16777217), null;
      case 27:
        Pt(a), u = ht.current;
        var p = a.type;
        if (r !== null && a.stateNode != null)
          r.memoizedProps !== h && nr(a);
        else {
          if (!h) {
            if (a.stateNode === null)
              throw Error(i(166));
            return Ge(a), null;
          }
          r = lt.current, bo(a) ? sb(a) : (r = Rx(p, h, u), a.stateNode = r, nr(a));
        }
        return Ge(a), null;
      case 5:
        if (Pt(a), u = a.type, r !== null && a.stateNode != null)
          r.memoizedProps !== h && nr(a);
        else {
          if (!h) {
            if (a.stateNode === null)
              throw Error(i(166));
            return Ge(a), null;
          }
          if (r = lt.current, bo(a))
            sb(a);
          else {
            switch (p = rc(
              ht.current
            ), r) {
              case 1:
                r = p.createElementNS(
                  "http://www.w3.org/2000/svg",
                  u
                );
                break;
              case 2:
                r = p.createElementNS(
                  "http://www.w3.org/1998/Math/MathML",
                  u
                );
                break;
              default:
                switch (u) {
                  case "svg":
                    r = p.createElementNS(
                      "http://www.w3.org/2000/svg",
                      u
                    );
                    break;
                  case "math":
                    r = p.createElementNS(
                      "http://www.w3.org/1998/Math/MathML",
                      u
                    );
                    break;
                  case "script":
                    r = p.createElement("div"), r.innerHTML = "<script><\/script>", r = r.removeChild(r.firstChild);
                    break;
                  case "select":
                    r = typeof h.is == "string" ? p.createElement("select", { is: h.is }) : p.createElement("select"), h.multiple ? r.multiple = !0 : h.size && (r.size = h.size);
                    break;
                  default:
                    r = typeof h.is == "string" ? p.createElement(u, { is: h.is }) : p.createElement(u);
                }
            }
            r[yn] = a, r[kn] = h;
            t: for (p = a.child; p !== null; ) {
              if (p.tag === 5 || p.tag === 6)
                r.appendChild(p.stateNode);
              else if (p.tag !== 4 && p.tag !== 27 && p.child !== null) {
                p.child.return = p, p = p.child;
                continue;
              }
              if (p === a) break t;
              for (; p.sibling === null; ) {
                if (p.return === null || p.return === a)
                  break t;
                p = p.return;
              }
              p.sibling.return = p.return, p = p.sibling;
            }
            a.stateNode = r;
            t: switch (pn(r, u, h), u) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                r = !!h.autoFocus;
                break t;
              case "img":
                r = !0;
                break t;
              default:
                r = !1;
            }
            r && nr(a);
          }
        }
        return Ge(a), a.flags &= -16777217, null;
      case 6:
        if (r && a.stateNode != null)
          r.memoizedProps !== h && nr(a);
        else {
          if (typeof h != "string" && a.stateNode === null)
            throw Error(i(166));
          if (r = ht.current, bo(a)) {
            if (r = a.stateNode, u = a.memoizedProps, h = null, p = En, p !== null)
              switch (p.tag) {
                case 27:
                case 5:
                  h = p.memoizedProps;
              }
            r[yn] = a, r = !!(r.nodeValue === u || h !== null && h.suppressHydrationWarning === !0 || Sx(r.nodeValue, u)), r || ds(a);
          } else
            r = rc(r).createTextNode(
              h
            ), r[yn] = a, a.stateNode = r;
        }
        return Ge(a), null;
      case 13:
        if (h = a.memoizedState, r === null || r.memoizedState !== null && r.memoizedState.dehydrated !== null) {
          if (p = bo(a), h !== null && h.dehydrated !== null) {
            if (r === null) {
              if (!p) throw Error(i(318));
              if (p = a.memoizedState, p = p !== null ? p.dehydrated : null, !p) throw Error(i(317));
              p[yn] = a;
            } else
              vo(), (a.flags & 128) === 0 && (a.memoizedState = null), a.flags |= 4;
            Ge(a), p = !1;
          } else
            p = ob(), r !== null && r.memoizedState !== null && (r.memoizedState.hydrationErrors = p), p = !0;
          if (!p)
            return a.flags & 256 ? (tr(a), a) : (tr(a), null);
        }
        if (tr(a), (a.flags & 128) !== 0)
          return a.lanes = u, a;
        if (u = h !== null, r = r !== null && r.memoizedState !== null, u) {
          h = a.child, p = null, h.alternate !== null && h.alternate.memoizedState !== null && h.alternate.memoizedState.cachePool !== null && (p = h.alternate.memoizedState.cachePool.pool);
          var g = null;
          h.memoizedState !== null && h.memoizedState.cachePool !== null && (g = h.memoizedState.cachePool.pool), g !== p && (h.flags |= 2048);
        }
        return u !== r && u && (a.child.flags |= 8192), Vu(a, a.updateQueue), Ge(a), null;
      case 4:
        return Dt(), r === null && If(a.stateNode.containerInfo), Ge(a), null;
      case 10:
        return Qi(a.type), Ge(a), null;
      case 19:
        if (ot(nn), p = a.memoizedState, p === null) return Ge(a), null;
        if (h = (a.flags & 128) !== 0, g = p.rendering, g === null)
          if (h) Go(p, !1);
          else {
            if (Le !== 0 || r !== null && (r.flags & 128) !== 0)
              for (r = a.child; r !== null; ) {
                if (g = Lu(r), g !== null) {
                  for (a.flags |= 128, Go(p, !1), r = g.updateQueue, a.updateQueue = r, Vu(a, r), a.subtreeFlags = 0, r = u, u = a.child; u !== null; )
                    ib(u, r), u = u.sibling;
                  return at(
                    nn,
                    nn.current & 1 | 2
                  ), a.child;
                }
                r = r.sibling;
              }
            p.tail !== null && Gt() > Xu && (a.flags |= 128, h = !0, Go(p, !1), a.lanes = 4194304);
          }
        else {
          if (!h)
            if (r = Lu(g), r !== null) {
              if (a.flags |= 128, h = !0, r = r.updateQueue, a.updateQueue = r, Vu(a, r), Go(p, !0), p.tail === null && p.tailMode === "hidden" && !g.alternate && !ie)
                return Ge(a), null;
            } else
              2 * Gt() - p.renderingStartTime > Xu && u !== 536870912 && (a.flags |= 128, h = !0, Go(p, !1), a.lanes = 4194304);
          p.isBackwards ? (g.sibling = a.child, a.child = g) : (r = p.last, r !== null ? r.sibling = g : a.child = g, p.last = g);
        }
        return p.tail !== null ? (a = p.tail, p.rendering = a, p.tail = a.sibling, p.renderingStartTime = Gt(), a.sibling = null, r = nn.current, at(nn, h ? r & 1 | 2 : r & 1), a) : (Ge(a), null);
      case 22:
      case 23:
        return tr(a), zd(), h = a.memoizedState !== null, r !== null ? r.memoizedState !== null !== h && (a.flags |= 8192) : h && (a.flags |= 8192), h ? (u & 536870912) !== 0 && (a.flags & 128) === 0 && (Ge(a), a.subtreeFlags & 6 && (a.flags |= 8192)) : Ge(a), u = a.updateQueue, u !== null && Vu(a, u.retryQueue), u = null, r !== null && r.memoizedState !== null && r.memoizedState.cachePool !== null && (u = r.memoizedState.cachePool.pool), h = null, a.memoizedState !== null && a.memoizedState.cachePool !== null && (h = a.memoizedState.cachePool.pool), h !== u && (a.flags |= 2048), r !== null && ot(ms), null;
      case 24:
        return u = null, r !== null && (u = r.memoizedState.cache), a.memoizedState.cache !== u && (a.flags |= 2048), Qi(en), Ge(a), null;
      case 25:
        return null;
      case 30:
        return null;
    }
    throw Error(i(156, a.tag));
  }
  function b2(r, a) {
    switch (Cd(a), a.tag) {
      case 1:
        return r = a.flags, r & 65536 ? (a.flags = r & -65537 | 128, a) : null;
      case 3:
        return Qi(en), Dt(), r = a.flags, (r & 65536) !== 0 && (r & 128) === 0 ? (a.flags = r & -65537 | 128, a) : null;
      case 26:
      case 27:
      case 5:
        return Pt(a), null;
      case 13:
        if (tr(a), r = a.memoizedState, r !== null && r.dehydrated !== null) {
          if (a.alternate === null)
            throw Error(i(340));
          vo();
        }
        return r = a.flags, r & 65536 ? (a.flags = r & -65537 | 128, a) : null;
      case 19:
        return ot(nn), null;
      case 4:
        return Dt(), null;
      case 10:
        return Qi(a.type), null;
      case 22:
      case 23:
        return tr(a), zd(), r !== null && ot(ms), r = a.flags, r & 65536 ? (a.flags = r & -65537 | 128, a) : null;
      case 24:
        return Qi(en), null;
      case 25:
        return null;
      default:
        return null;
    }
  }
  function Pv(r, a) {
    switch (Cd(a), a.tag) {
      case 3:
        Qi(en), Dt();
        break;
      case 26:
      case 27:
      case 5:
        Pt(a);
        break;
      case 4:
        Dt();
        break;
      case 13:
        tr(a);
        break;
      case 19:
        ot(nn);
        break;
      case 10:
        Qi(a.type);
        break;
      case 22:
      case 23:
        tr(a), zd(), r !== null && ot(ms);
        break;
      case 24:
        Qi(en);
    }
  }
  function Uo(r, a) {
    try {
      var u = a.updateQueue, h = u !== null ? u.lastEffect : null;
      if (h !== null) {
        var p = h.next;
        u = p;
        do {
          if ((u.tag & r) === r) {
            h = void 0;
            var g = u.create, T = u.inst;
            h = g(), T.destroy = h;
          }
          u = u.next;
        } while (u !== p);
      }
    } catch (A) {
      _e(a, a.return, A);
    }
  }
  function Or(r, a, u) {
    try {
      var h = a.updateQueue, p = h !== null ? h.lastEffect : null;
      if (p !== null) {
        var g = p.next;
        h = g;
        do {
          if ((h.tag & r) === r) {
            var T = h.inst, A = T.destroy;
            if (A !== void 0) {
              T.destroy = void 0, p = a;
              var U = u, X = A;
              try {
                X();
              } catch (nt) {
                _e(
                  p,
                  U,
                  nt
                );
              }
            }
          }
          h = h.next;
        } while (h !== g);
      }
    } catch (nt) {
      _e(a, a.return, nt);
    }
  }
  function Bv(r) {
    var a = r.updateQueue;
    if (a !== null) {
      var u = r.stateNode;
      try {
        bb(a, u);
      } catch (h) {
        _e(r, r.return, h);
      }
    }
  }
  function kv(r, a, u) {
    u.props = ys(
      r.type,
      r.memoizedProps
    ), u.state = r.memoizedState;
    try {
      u.componentWillUnmount();
    } catch (h) {
      _e(r, a, h);
    }
  }
  function No(r, a) {
    try {
      var u = r.ref;
      if (u !== null) {
        switch (r.tag) {
          case 26:
          case 27:
          case 5:
            var h = r.stateNode;
            break;
          case 30:
            h = r.stateNode;
            break;
          default:
            h = r.stateNode;
        }
        typeof u == "function" ? r.refCleanup = u(h) : u.current = h;
      }
    } catch (p) {
      _e(r, a, p);
    }
  }
  function Bi(r, a) {
    var u = r.ref, h = r.refCleanup;
    if (u !== null)
      if (typeof h == "function")
        try {
          h();
        } catch (p) {
          _e(r, a, p);
        } finally {
          r.refCleanup = null, r = r.alternate, r != null && (r.refCleanup = null);
        }
      else if (typeof u == "function")
        try {
          u(null);
        } catch (p) {
          _e(r, a, p);
        }
      else u.current = null;
  }
  function Ov(r) {
    var a = r.type, u = r.memoizedProps, h = r.stateNode;
    try {
      t: switch (a) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          u.autoFocus && h.focus();
          break t;
        case "img":
          u.src ? h.src = u.src : u.srcSet && (h.srcset = u.srcSet);
      }
    } catch (p) {
      _e(r, r.return, p);
    }
  }
  function pf(r, a, u) {
    try {
      var h = r.stateNode;
      z2(h, r.type, u, a), h[kn] = a;
    } catch (p) {
      _e(r, r.return, p);
    }
  }
  function Dv(r) {
    return r.tag === 5 || r.tag === 3 || r.tag === 26 || r.tag === 27 && Fr(r.type) || r.tag === 4;
  }
  function mf(r) {
    t: for (; ; ) {
      for (; r.sibling === null; ) {
        if (r.return === null || Dv(r.return)) return null;
        r = r.return;
      }
      for (r.sibling.return = r.return, r = r.sibling; r.tag !== 5 && r.tag !== 6 && r.tag !== 18; ) {
        if (r.tag === 27 && Fr(r.type) || r.flags & 2 || r.child === null || r.tag === 4) continue t;
        r.child.return = r, r = r.child;
      }
      if (!(r.flags & 2)) return r.stateNode;
    }
  }
  function gf(r, a, u) {
    var h = r.tag;
    if (h === 5 || h === 6)
      r = r.stateNode, a ? (u.nodeType === 9 ? u.body : u.nodeName === "HTML" ? u.ownerDocument.body : u).insertBefore(r, a) : (a = u.nodeType === 9 ? u.body : u.nodeName === "HTML" ? u.ownerDocument.body : u, a.appendChild(r), u = u._reactRootContainer, u != null || a.onclick !== null || (a.onclick = ic));
    else if (h !== 4 && (h === 27 && Fr(r.type) && (u = r.stateNode, a = null), r = r.child, r !== null))
      for (gf(r, a, u), r = r.sibling; r !== null; )
        gf(r, a, u), r = r.sibling;
  }
  function ju(r, a, u) {
    var h = r.tag;
    if (h === 5 || h === 6)
      r = r.stateNode, a ? u.insertBefore(r, a) : u.appendChild(r);
    else if (h !== 4 && (h === 27 && Fr(r.type) && (u = r.stateNode), r = r.child, r !== null))
      for (ju(r, a, u), r = r.sibling; r !== null; )
        ju(r, a, u), r = r.sibling;
  }
  function Gv(r) {
    var a = r.stateNode, u = r.memoizedProps;
    try {
      for (var h = r.type, p = a.attributes; p.length; )
        a.removeAttributeNode(p[0]);
      pn(a, h, u), a[yn] = r, a[kn] = u;
    } catch (g) {
      _e(r, r.return, g);
    }
  }
  var ir = !1, je = !1, yf = !1, Uv = typeof WeakSet == "function" ? WeakSet : Set, un = null;
  function v2(r, a) {
    if (r = r.containerInfo, Ff = cc, r = Yy(r), pd(r)) {
      if ("selectionStart" in r)
        var u = {
          start: r.selectionStart,
          end: r.selectionEnd
        };
      else
        t: {
          u = (u = r.ownerDocument) && u.defaultView || window;
          var h = u.getSelection && u.getSelection();
          if (h && h.rangeCount !== 0) {
            u = h.anchorNode;
            var p = h.anchorOffset, g = h.focusNode;
            h = h.focusOffset;
            try {
              u.nodeType, g.nodeType;
            } catch {
              u = null;
              break t;
            }
            var T = 0, A = -1, U = -1, X = 0, nt = 0, st = r, K = null;
            e: for (; ; ) {
              for (var Z; st !== u || p !== 0 && st.nodeType !== 3 || (A = T + p), st !== g || h !== 0 && st.nodeType !== 3 || (U = T + h), st.nodeType === 3 && (T += st.nodeValue.length), (Z = st.firstChild) !== null; )
                K = st, st = Z;
              for (; ; ) {
                if (st === r) break e;
                if (K === u && ++X === p && (A = T), K === g && ++nt === h && (U = T), (Z = st.nextSibling) !== null) break;
                st = K, K = st.parentNode;
              }
              st = Z;
            }
            u = A === -1 || U === -1 ? null : { start: A, end: U };
          } else u = null;
        }
      u = u || { start: 0, end: 0 };
    } else u = null;
    for (Hf = { focusedElem: r, selectionRange: u }, cc = !1, un = a; un !== null; )
      if (a = un, r = a.child, (a.subtreeFlags & 1024) !== 0 && r !== null)
        r.return = a, un = r;
      else
        for (; un !== null; ) {
          switch (a = un, g = a.alternate, r = a.flags, a.tag) {
            case 0:
              break;
            case 11:
            case 15:
              break;
            case 1:
              if ((r & 1024) !== 0 && g !== null) {
                r = void 0, u = a, p = g.memoizedProps, g = g.memoizedState, h = u.stateNode;
                try {
                  var Ot = ys(
                    u.type,
                    p,
                    u.elementType === u.type
                  );
                  r = h.getSnapshotBeforeUpdate(
                    Ot,
                    g
                  ), h.__reactInternalSnapshotBeforeUpdate = r;
                } catch (Mt) {
                  _e(
                    u,
                    u.return,
                    Mt
                  );
                }
              }
              break;
            case 3:
              if ((r & 1024) !== 0) {
                if (r = a.stateNode.containerInfo, u = r.nodeType, u === 9)
                  Vf(r);
                else if (u === 1)
                  switch (r.nodeName) {
                    case "HEAD":
                    case "HTML":
                    case "BODY":
                      Vf(r);
                      break;
                    default:
                      r.textContent = "";
                  }
              }
              break;
            case 5:
            case 26:
            case 27:
            case 6:
            case 4:
            case 17:
              break;
            default:
              if ((r & 1024) !== 0) throw Error(i(163));
          }
          if (r = a.sibling, r !== null) {
            r.return = a.return, un = r;
            break;
          }
          un = a.return;
        }
  }
  function Nv(r, a, u) {
    var h = u.flags;
    switch (u.tag) {
      case 0:
      case 11:
      case 15:
        Dr(r, u), h & 4 && Uo(5, u);
        break;
      case 1:
        if (Dr(r, u), h & 4)
          if (r = u.stateNode, a === null)
            try {
              r.componentDidMount();
            } catch (T) {
              _e(u, u.return, T);
            }
          else {
            var p = ys(
              u.type,
              a.memoizedProps
            );
            a = a.memoizedState;
            try {
              r.componentDidUpdate(
                p,
                a,
                r.__reactInternalSnapshotBeforeUpdate
              );
            } catch (T) {
              _e(
                u,
                u.return,
                T
              );
            }
          }
        h & 64 && Bv(u), h & 512 && No(u, u.return);
        break;
      case 3:
        if (Dr(r, u), h & 64 && (r = u.updateQueue, r !== null)) {
          if (a = null, u.child !== null)
            switch (u.child.tag) {
              case 27:
              case 5:
                a = u.child.stateNode;
                break;
              case 1:
                a = u.child.stateNode;
            }
          try {
            bb(r, a);
          } catch (T) {
            _e(u, u.return, T);
          }
        }
        break;
      case 27:
        a === null && h & 4 && Gv(u);
      case 26:
      case 5:
        Dr(r, u), a === null && h & 4 && Ov(u), h & 512 && No(u, u.return);
        break;
      case 12:
        Dr(r, u);
        break;
      case 13:
        Dr(r, u), h & 4 && Lv(r, u), h & 64 && (r = u.memoizedState, r !== null && (r = r.dehydrated, r !== null && (u = A2.bind(
          null,
          u
        ), j2(r, u))));
        break;
      case 22:
        if (h = u.memoizedState !== null || ir, !h) {
          a = a !== null && a.memoizedState !== null || je, p = ir;
          var g = je;
          ir = h, (je = a) && !g ? Gr(
            r,
            u,
            (u.subtreeFlags & 8772) !== 0
          ) : Dr(r, u), ir = p, je = g;
        }
        break;
      case 30:
        break;
      default:
        Dr(r, u);
    }
  }
  function Iv(r) {
    var a = r.alternate;
    a !== null && (r.alternate = null, Iv(a)), r.child = null, r.deletions = null, r.sibling = null, r.tag === 5 && (a = r.stateNode, a !== null && qh(a)), r.stateNode = null, r.return = null, r.dependencies = null, r.memoizedProps = null, r.memoizedState = null, r.pendingProps = null, r.stateNode = null, r.updateQueue = null;
  }
  var Ae = null, Gn = !1;
  function rr(r, a, u) {
    for (u = u.child; u !== null; )
      zv(r, a, u), u = u.sibling;
  }
  function zv(r, a, u) {
    if (yt && typeof yt.onCommitFiberUnmount == "function")
      try {
        yt.onCommitFiberUnmount(ut, u);
      } catch {
      }
    switch (u.tag) {
      case 26:
        je || Bi(u, a), rr(
          r,
          a,
          u
        ), u.memoizedState ? u.memoizedState.count-- : u.stateNode && (u = u.stateNode, u.parentNode.removeChild(u));
        break;
      case 27:
        je || Bi(u, a);
        var h = Ae, p = Gn;
        Fr(u.type) && (Ae = u.stateNode, Gn = !1), rr(
          r,
          a,
          u
        ), jo(u.stateNode), Ae = h, Gn = p;
        break;
      case 5:
        je || Bi(u, a);
      case 6:
        if (h = Ae, p = Gn, Ae = null, rr(
          r,
          a,
          u
        ), Ae = h, Gn = p, Ae !== null)
          if (Gn)
            try {
              (Ae.nodeType === 9 ? Ae.body : Ae.nodeName === "HTML" ? Ae.ownerDocument.body : Ae).removeChild(u.stateNode);
            } catch (g) {
              _e(
                u,
                a,
                g
              );
            }
          else
            try {
              Ae.removeChild(u.stateNode);
            } catch (g) {
              _e(
                u,
                a,
                g
              );
            }
        break;
      case 18:
        Ae !== null && (Gn ? (r = Ae, Mx(
          r.nodeType === 9 ? r.body : r.nodeName === "HTML" ? r.ownerDocument.body : r,
          u.stateNode
        ), tl(r)) : Mx(Ae, u.stateNode));
        break;
      case 4:
        h = Ae, p = Gn, Ae = u.stateNode.containerInfo, Gn = !0, rr(
          r,
          a,
          u
        ), Ae = h, Gn = p;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        je || Or(2, u, a), je || Or(4, u, a), rr(
          r,
          a,
          u
        );
        break;
      case 1:
        je || (Bi(u, a), h = u.stateNode, typeof h.componentWillUnmount == "function" && kv(
          u,
          a,
          h
        )), rr(
          r,
          a,
          u
        );
        break;
      case 21:
        rr(
          r,
          a,
          u
        );
        break;
      case 22:
        je = (h = je) || u.memoizedState !== null, rr(
          r,
          a,
          u
        ), je = h;
        break;
      default:
        rr(
          r,
          a,
          u
        );
    }
  }
  function Lv(r, a) {
    if (a.memoizedState === null && (r = a.alternate, r !== null && (r = r.memoizedState, r !== null && (r = r.dehydrated, r !== null))))
      try {
        tl(r);
      } catch (u) {
        _e(a, a.return, u);
      }
  }
  function x2(r) {
    switch (r.tag) {
      case 13:
      case 19:
        var a = r.stateNode;
        return a === null && (a = r.stateNode = new Uv()), a;
      case 22:
        return r = r.stateNode, a = r._retryCache, a === null && (a = r._retryCache = new Uv()), a;
      default:
        throw Error(i(435, r.tag));
    }
  }
  function bf(r, a) {
    var u = x2(r);
    a.forEach(function(h) {
      var p = R2.bind(null, r, h);
      u.has(h) || (u.add(h), h.then(p, p));
    });
  }
  function Hn(r, a) {
    var u = a.deletions;
    if (u !== null)
      for (var h = 0; h < u.length; h++) {
        var p = u[h], g = r, T = a, A = T;
        t: for (; A !== null; ) {
          switch (A.tag) {
            case 27:
              if (Fr(A.type)) {
                Ae = A.stateNode, Gn = !1;
                break t;
              }
              break;
            case 5:
              Ae = A.stateNode, Gn = !1;
              break t;
            case 3:
            case 4:
              Ae = A.stateNode.containerInfo, Gn = !0;
              break t;
          }
          A = A.return;
        }
        if (Ae === null) throw Error(i(160));
        zv(g, T, p), Ae = null, Gn = !1, g = p.alternate, g !== null && (g.return = null), p.return = null;
      }
    if (a.subtreeFlags & 13878)
      for (a = a.child; a !== null; )
        Fv(a, r), a = a.sibling;
  }
  var yi = null;
  function Fv(r, a) {
    var u = r.alternate, h = r.flags;
    switch (r.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        Hn(a, r), $n(r), h & 4 && (Or(3, r, r.return), Uo(3, r), Or(5, r, r.return));
        break;
      case 1:
        Hn(a, r), $n(r), h & 512 && (je || u === null || Bi(u, u.return)), h & 64 && ir && (r = r.updateQueue, r !== null && (h = r.callbacks, h !== null && (u = r.shared.hiddenCallbacks, r.shared.hiddenCallbacks = u === null ? h : u.concat(h))));
        break;
      case 26:
        var p = yi;
        if (Hn(a, r), $n(r), h & 512 && (je || u === null || Bi(u, u.return)), h & 4) {
          var g = u !== null ? u.memoizedState : null;
          if (h = r.memoizedState, u === null)
            if (h === null)
              if (r.stateNode === null) {
                t: {
                  h = r.type, u = r.memoizedProps, p = p.ownerDocument || p;
                  e: switch (h) {
                    case "title":
                      g = p.getElementsByTagName("title")[0], (!g || g[ao] || g[yn] || g.namespaceURI === "http://www.w3.org/2000/svg" || g.hasAttribute("itemprop")) && (g = p.createElement(h), p.head.insertBefore(
                        g,
                        p.querySelector("head > title")
                      )), pn(g, h, u), g[yn] = r, on(g), h = g;
                      break t;
                    case "link":
                      var T = Gx(
                        "link",
                        "href",
                        p
                      ).get(h + (u.href || ""));
                      if (T) {
                        for (var A = 0; A < T.length; A++)
                          if (g = T[A], g.getAttribute("href") === (u.href == null || u.href === "" ? null : u.href) && g.getAttribute("rel") === (u.rel == null ? null : u.rel) && g.getAttribute("title") === (u.title == null ? null : u.title) && g.getAttribute("crossorigin") === (u.crossOrigin == null ? null : u.crossOrigin)) {
                            T.splice(A, 1);
                            break e;
                          }
                      }
                      g = p.createElement(h), pn(g, h, u), p.head.appendChild(g);
                      break;
                    case "meta":
                      if (T = Gx(
                        "meta",
                        "content",
                        p
                      ).get(h + (u.content || ""))) {
                        for (A = 0; A < T.length; A++)
                          if (g = T[A], g.getAttribute("content") === (u.content == null ? null : "" + u.content) && g.getAttribute("name") === (u.name == null ? null : u.name) && g.getAttribute("property") === (u.property == null ? null : u.property) && g.getAttribute("http-equiv") === (u.httpEquiv == null ? null : u.httpEquiv) && g.getAttribute("charset") === (u.charSet == null ? null : u.charSet)) {
                            T.splice(A, 1);
                            break e;
                          }
                      }
                      g = p.createElement(h), pn(g, h, u), p.head.appendChild(g);
                      break;
                    default:
                      throw Error(i(468, h));
                  }
                  g[yn] = r, on(g), h = g;
                }
                r.stateNode = h;
              } else
                Ux(
                  p,
                  r.type,
                  r.stateNode
                );
            else
              r.stateNode = Dx(
                p,
                h,
                r.memoizedProps
              );
          else
            g !== h ? (g === null ? u.stateNode !== null && (u = u.stateNode, u.parentNode.removeChild(u)) : g.count--, h === null ? Ux(
              p,
              r.type,
              r.stateNode
            ) : Dx(
              p,
              h,
              r.memoizedProps
            )) : h === null && r.stateNode !== null && pf(
              r,
              r.memoizedProps,
              u.memoizedProps
            );
        }
        break;
      case 27:
        Hn(a, r), $n(r), h & 512 && (je || u === null || Bi(u, u.return)), u !== null && h & 4 && pf(
          r,
          r.memoizedProps,
          u.memoizedProps
        );
        break;
      case 5:
        if (Hn(a, r), $n(r), h & 512 && (je || u === null || Bi(u, u.return)), r.flags & 32) {
          p = r.stateNode;
          try {
            Ys(p, "");
          } catch (Z) {
            _e(r, r.return, Z);
          }
        }
        h & 4 && r.stateNode != null && (p = r.memoizedProps, pf(
          r,
          p,
          u !== null ? u.memoizedProps : p
        )), h & 1024 && (yf = !0);
        break;
      case 6:
        if (Hn(a, r), $n(r), h & 4) {
          if (r.stateNode === null)
            throw Error(i(162));
          h = r.memoizedProps, u = r.stateNode;
          try {
            u.nodeValue = h;
          } catch (Z) {
            _e(r, r.return, Z);
          }
        }
        break;
      case 3:
        if (oc = null, p = yi, yi = sc(a.containerInfo), Hn(a, r), yi = p, $n(r), h & 4 && u !== null && u.memoizedState.isDehydrated)
          try {
            tl(a.containerInfo);
          } catch (Z) {
            _e(r, r.return, Z);
          }
        yf && (yf = !1, Hv(r));
        break;
      case 4:
        h = yi, yi = sc(
          r.stateNode.containerInfo
        ), Hn(a, r), $n(r), yi = h;
        break;
      case 12:
        Hn(a, r), $n(r);
        break;
      case 13:
        Hn(a, r), $n(r), r.child.flags & 8192 && r.memoizedState !== null != (u !== null && u.memoizedState !== null) && (wf = Gt()), h & 4 && (h = r.updateQueue, h !== null && (r.updateQueue = null, bf(r, h)));
        break;
      case 22:
        p = r.memoizedState !== null;
        var U = u !== null && u.memoizedState !== null, X = ir, nt = je;
        if (ir = X || p, je = nt || U, Hn(a, r), je = nt, ir = X, $n(r), h & 8192)
          t: for (a = r.stateNode, a._visibility = p ? a._visibility & -2 : a._visibility | 1, p && (u === null || U || ir || je || bs(r)), u = null, a = r; ; ) {
            if (a.tag === 5 || a.tag === 26) {
              if (u === null) {
                U = u = a;
                try {
                  if (g = U.stateNode, p)
                    T = g.style, typeof T.setProperty == "function" ? T.setProperty("display", "none", "important") : T.display = "none";
                  else {
                    A = U.stateNode;
                    var st = U.memoizedProps.style, K = st != null && st.hasOwnProperty("display") ? st.display : null;
                    A.style.display = K == null || typeof K == "boolean" ? "" : ("" + K).trim();
                  }
                } catch (Z) {
                  _e(U, U.return, Z);
                }
              }
            } else if (a.tag === 6) {
              if (u === null) {
                U = a;
                try {
                  U.stateNode.nodeValue = p ? "" : U.memoizedProps;
                } catch (Z) {
                  _e(U, U.return, Z);
                }
              }
            } else if ((a.tag !== 22 && a.tag !== 23 || a.memoizedState === null || a === r) && a.child !== null) {
              a.child.return = a, a = a.child;
              continue;
            }
            if (a === r) break t;
            for (; a.sibling === null; ) {
              if (a.return === null || a.return === r) break t;
              u === a && (u = null), a = a.return;
            }
            u === a && (u = null), a.sibling.return = a.return, a = a.sibling;
          }
        h & 4 && (h = r.updateQueue, h !== null && (u = h.retryQueue, u !== null && (h.retryQueue = null, bf(r, u))));
        break;
      case 19:
        Hn(a, r), $n(r), h & 4 && (h = r.updateQueue, h !== null && (r.updateQueue = null, bf(r, h)));
        break;
      case 30:
        break;
      case 21:
        break;
      default:
        Hn(a, r), $n(r);
    }
  }
  function $n(r) {
    var a = r.flags;
    if (a & 2) {
      try {
        for (var u, h = r.return; h !== null; ) {
          if (Dv(h)) {
            u = h;
            break;
          }
          h = h.return;
        }
        if (u == null) throw Error(i(160));
        switch (u.tag) {
          case 27:
            var p = u.stateNode, g = mf(r);
            ju(r, g, p);
            break;
          case 5:
            var T = u.stateNode;
            u.flags & 32 && (Ys(T, ""), u.flags &= -33);
            var A = mf(r);
            ju(r, A, T);
            break;
          case 3:
          case 4:
            var U = u.stateNode.containerInfo, X = mf(r);
            gf(
              r,
              X,
              U
            );
            break;
          default:
            throw Error(i(161));
        }
      } catch (nt) {
        _e(r, r.return, nt);
      }
      r.flags &= -3;
    }
    a & 4096 && (r.flags &= -4097);
  }
  function Hv(r) {
    if (r.subtreeFlags & 1024)
      for (r = r.child; r !== null; ) {
        var a = r;
        Hv(a), a.tag === 5 && a.flags & 1024 && a.stateNode.reset(), r = r.sibling;
      }
  }
  function Dr(r, a) {
    if (a.subtreeFlags & 8772)
      for (a = a.child; a !== null; )
        Nv(r, a.alternate, a), a = a.sibling;
  }
  function bs(r) {
    for (r = r.child; r !== null; ) {
      var a = r;
      switch (a.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          Or(4, a, a.return), bs(a);
          break;
        case 1:
          Bi(a, a.return);
          var u = a.stateNode;
          typeof u.componentWillUnmount == "function" && kv(
            a,
            a.return,
            u
          ), bs(a);
          break;
        case 27:
          jo(a.stateNode);
        case 26:
        case 5:
          Bi(a, a.return), bs(a);
          break;
        case 22:
          a.memoizedState === null && bs(a);
          break;
        case 30:
          bs(a);
          break;
        default:
          bs(a);
      }
      r = r.sibling;
    }
  }
  function Gr(r, a, u) {
    for (u = u && (a.subtreeFlags & 8772) !== 0, a = a.child; a !== null; ) {
      var h = a.alternate, p = r, g = a, T = g.flags;
      switch (g.tag) {
        case 0:
        case 11:
        case 15:
          Gr(
            p,
            g,
            u
          ), Uo(4, g);
          break;
        case 1:
          if (Gr(
            p,
            g,
            u
          ), h = g, p = h.stateNode, typeof p.componentDidMount == "function")
            try {
              p.componentDidMount();
            } catch (X) {
              _e(h, h.return, X);
            }
          if (h = g, p = h.updateQueue, p !== null) {
            var A = h.stateNode;
            try {
              var U = p.shared.hiddenCallbacks;
              if (U !== null)
                for (p.shared.hiddenCallbacks = null, p = 0; p < U.length; p++)
                  yb(U[p], A);
            } catch (X) {
              _e(h, h.return, X);
            }
          }
          u && T & 64 && Bv(g), No(g, g.return);
          break;
        case 27:
          Gv(g);
        case 26:
        case 5:
          Gr(
            p,
            g,
            u
          ), u && h === null && T & 4 && Ov(g), No(g, g.return);
          break;
        case 12:
          Gr(
            p,
            g,
            u
          );
          break;
        case 13:
          Gr(
            p,
            g,
            u
          ), u && T & 4 && Lv(p, g);
          break;
        case 22:
          g.memoizedState === null && Gr(
            p,
            g,
            u
          ), No(g, g.return);
          break;
        case 30:
          break;
        default:
          Gr(
            p,
            g,
            u
          );
      }
      a = a.sibling;
    }
  }
  function vf(r, a) {
    var u = null;
    r !== null && r.memoizedState !== null && r.memoizedState.cachePool !== null && (u = r.memoizedState.cachePool.pool), r = null, a.memoizedState !== null && a.memoizedState.cachePool !== null && (r = a.memoizedState.cachePool.pool), r !== u && (r != null && r.refCount++, u != null && So(u));
  }
  function xf(r, a) {
    r = null, a.alternate !== null && (r = a.alternate.memoizedState.cache), a = a.memoizedState.cache, a !== r && (a.refCount++, r != null && So(r));
  }
  function ki(r, a, u, h) {
    if (a.subtreeFlags & 10256)
      for (a = a.child; a !== null; )
        $v(
          r,
          a,
          u,
          h
        ), a = a.sibling;
  }
  function $v(r, a, u, h) {
    var p = a.flags;
    switch (a.tag) {
      case 0:
      case 11:
      case 15:
        ki(
          r,
          a,
          u,
          h
        ), p & 2048 && Uo(9, a);
        break;
      case 1:
        ki(
          r,
          a,
          u,
          h
        );
        break;
      case 3:
        ki(
          r,
          a,
          u,
          h
        ), p & 2048 && (r = null, a.alternate !== null && (r = a.alternate.memoizedState.cache), a = a.memoizedState.cache, a !== r && (a.refCount++, r != null && So(r)));
        break;
      case 12:
        if (p & 2048) {
          ki(
            r,
            a,
            u,
            h
          ), r = a.stateNode;
          try {
            var g = a.memoizedProps, T = g.id, A = g.onPostCommit;
            typeof A == "function" && A(
              T,
              a.alternate === null ? "mount" : "update",
              r.passiveEffectDuration,
              -0
            );
          } catch (U) {
            _e(a, a.return, U);
          }
        } else
          ki(
            r,
            a,
            u,
            h
          );
        break;
      case 13:
        ki(
          r,
          a,
          u,
          h
        );
        break;
      case 23:
        break;
      case 22:
        g = a.stateNode, T = a.alternate, a.memoizedState !== null ? g._visibility & 2 ? ki(
          r,
          a,
          u,
          h
        ) : Io(r, a) : g._visibility & 2 ? ki(
          r,
          a,
          u,
          h
        ) : (g._visibility |= 2, da(
          r,
          a,
          u,
          h,
          (a.subtreeFlags & 10256) !== 0
        )), p & 2048 && vf(T, a);
        break;
      case 24:
        ki(
          r,
          a,
          u,
          h
        ), p & 2048 && xf(a.alternate, a);
        break;
      default:
        ki(
          r,
          a,
          u,
          h
        );
    }
  }
  function da(r, a, u, h, p) {
    for (p = p && (a.subtreeFlags & 10256) !== 0, a = a.child; a !== null; ) {
      var g = r, T = a, A = u, U = h, X = T.flags;
      switch (T.tag) {
        case 0:
        case 11:
        case 15:
          da(
            g,
            T,
            A,
            U,
            p
          ), Uo(8, T);
          break;
        case 23:
          break;
        case 22:
          var nt = T.stateNode;
          T.memoizedState !== null ? nt._visibility & 2 ? da(
            g,
            T,
            A,
            U,
            p
          ) : Io(
            g,
            T
          ) : (nt._visibility |= 2, da(
            g,
            T,
            A,
            U,
            p
          )), p && X & 2048 && vf(
            T.alternate,
            T
          );
          break;
        case 24:
          da(
            g,
            T,
            A,
            U,
            p
          ), p && X & 2048 && xf(T.alternate, T);
          break;
        default:
          da(
            g,
            T,
            A,
            U,
            p
          );
      }
      a = a.sibling;
    }
  }
  function Io(r, a) {
    if (a.subtreeFlags & 10256)
      for (a = a.child; a !== null; ) {
        var u = r, h = a, p = h.flags;
        switch (h.tag) {
          case 22:
            Io(u, h), p & 2048 && vf(
              h.alternate,
              h
            );
            break;
          case 24:
            Io(u, h), p & 2048 && xf(h.alternate, h);
            break;
          default:
            Io(u, h);
        }
        a = a.sibling;
      }
  }
  var zo = 8192;
  function fa(r) {
    if (r.subtreeFlags & zo)
      for (r = r.child; r !== null; )
        Wv(r), r = r.sibling;
  }
  function Wv(r) {
    switch (r.tag) {
      case 26:
        fa(r), r.flags & zo && r.memoizedState !== null && sM(
          yi,
          r.memoizedState,
          r.memoizedProps
        );
        break;
      case 5:
        fa(r);
        break;
      case 3:
      case 4:
        var a = yi;
        yi = sc(r.stateNode.containerInfo), fa(r), yi = a;
        break;
      case 22:
        r.memoizedState === null && (a = r.alternate, a !== null && a.memoizedState !== null ? (a = zo, zo = 16777216, fa(r), zo = a) : fa(r));
        break;
      default:
        fa(r);
    }
  }
  function Vv(r) {
    var a = r.alternate;
    if (a !== null && (r = a.child, r !== null)) {
      a.child = null;
      do
        a = r.sibling, r.sibling = null, r = a;
      while (r !== null);
    }
  }
  function Lo(r) {
    var a = r.deletions;
    if ((r.flags & 16) !== 0) {
      if (a !== null)
        for (var u = 0; u < a.length; u++) {
          var h = a[u];
          un = h, Yv(
            h,
            r
          );
        }
      Vv(r);
    }
    if (r.subtreeFlags & 10256)
      for (r = r.child; r !== null; )
        jv(r), r = r.sibling;
  }
  function jv(r) {
    switch (r.tag) {
      case 0:
      case 11:
      case 15:
        Lo(r), r.flags & 2048 && Or(9, r, r.return);
        break;
      case 3:
        Lo(r);
        break;
      case 12:
        Lo(r);
        break;
      case 22:
        var a = r.stateNode;
        r.memoizedState !== null && a._visibility & 2 && (r.return === null || r.return.tag !== 13) ? (a._visibility &= -3, Yu(r)) : Lo(r);
        break;
      default:
        Lo(r);
    }
  }
  function Yu(r) {
    var a = r.deletions;
    if ((r.flags & 16) !== 0) {
      if (a !== null)
        for (var u = 0; u < a.length; u++) {
          var h = a[u];
          un = h, Yv(
            h,
            r
          );
        }
      Vv(r);
    }
    for (r = r.child; r !== null; ) {
      switch (a = r, a.tag) {
        case 0:
        case 11:
        case 15:
          Or(8, a, a.return), Yu(a);
          break;
        case 22:
          u = a.stateNode, u._visibility & 2 && (u._visibility &= -3, Yu(a));
          break;
        default:
          Yu(a);
      }
      r = r.sibling;
    }
  }
  function Yv(r, a) {
    for (; un !== null; ) {
      var u = un;
      switch (u.tag) {
        case 0:
        case 11:
        case 15:
          Or(8, u, a);
          break;
        case 23:
        case 22:
          if (u.memoizedState !== null && u.memoizedState.cachePool !== null) {
            var h = u.memoizedState.cachePool.pool;
            h != null && h.refCount++;
          }
          break;
        case 24:
          So(u.memoizedState.cache);
      }
      if (h = u.child, h !== null) h.return = u, un = h;
      else
        t: for (u = r; un !== null; ) {
          h = un;
          var p = h.sibling, g = h.return;
          if (Iv(h), h === u) {
            un = null;
            break t;
          }
          if (p !== null) {
            p.return = g, un = p;
            break t;
          }
          un = g;
        }
    }
  }
  var _2 = {
    getCacheForType: function(r) {
      var a = bn(en), u = a.data.get(r);
      return u === void 0 && (u = r(), a.data.set(r, u)), u;
    }
  }, S2 = typeof WeakMap == "function" ? WeakMap : Map, ce = 0, Ce = null, qt = null, Zt = 0, he = 0, Wn = null, Ur = !1, pa = !1, _f = !1, sr = 0, Le = 0, Nr = 0, vs = 0, Sf = 0, oi = 0, ma = 0, Fo = null, Un = null, Tf = !1, wf = 0, Xu = 1 / 0, qu = null, Ir = null, fn = 0, zr = null, ga = null, ya = 0, Cf = 0, Ef = null, Xv = null, Ho = 0, Mf = null;
  function Vn() {
    if ((ce & 2) !== 0 && Zt !== 0)
      return Zt & -Zt;
    if (B.T !== null) {
      var r = ra;
      return r !== 0 ? r : Df();
    }
    return cy();
  }
  function qv() {
    oi === 0 && (oi = (Zt & 536870912) === 0 || ie ? Vi() : 536870912);
    var r = ai.current;
    return r !== null && (r.flags |= 32), oi;
  }
  function jn(r, a, u) {
    (r === Ce && (he === 2 || he === 9) || r.cancelPendingCommit !== null) && (ba(r, 0), Lr(
      r,
      Zt,
      oi,
      !1
    )), we(r, u), ((ce & 2) === 0 || r !== Ce) && (r === Ce && ((ce & 2) === 0 && (vs |= u), Le === 4 && Lr(
      r,
      Zt,
      oi,
      !1
    )), Oi(r));
  }
  function Kv(r, a, u) {
    if ((ce & 6) !== 0) throw Error(i(327));
    var h = !u && (a & 124) === 0 && (a & r.expiredLanes) === 0 || xe(r, a), p = h ? C2(r, a) : Pf(r, a, !0), g = h;
    do {
      if (p === 0) {
        pa && !h && Lr(r, a, 0, !1);
        break;
      } else {
        if (u = r.current.alternate, g && !T2(u)) {
          p = Pf(r, a, !1), g = !1;
          continue;
        }
        if (p === 2) {
          if (g = a, r.errorRecoveryDisabledLanes & g)
            var T = 0;
          else
            T = r.pendingLanes & -536870913, T = T !== 0 ? T : T & 536870912 ? 536870912 : 0;
          if (T !== 0) {
            a = T;
            t: {
              var A = r;
              p = Fo;
              var U = A.current.memoizedState.isDehydrated;
              if (U && (ba(A, T).flags |= 256), T = Pf(
                A,
                T,
                !1
              ), T !== 2) {
                if (_f && !U) {
                  A.errorRecoveryDisabledLanes |= g, vs |= g, p = 4;
                  break t;
                }
                g = Un, Un = p, g !== null && (Un === null ? Un = g : Un.push.apply(
                  Un,
                  g
                ));
              }
              p = T;
            }
            if (g = !1, p !== 2) continue;
          }
        }
        if (p === 1) {
          ba(r, 0), Lr(r, a, 0, !0);
          break;
        }
        t: {
          switch (h = r, g = p, g) {
            case 0:
            case 1:
              throw Error(i(345));
            case 4:
              if ((a & 4194048) !== a) break;
            case 6:
              Lr(
                h,
                a,
                oi,
                !Ur
              );
              break t;
            case 2:
              Un = null;
              break;
            case 3:
            case 5:
              break;
            default:
              throw Error(i(329));
          }
          if ((a & 62914560) === a && (p = wf + 300 - Gt(), 10 < p)) {
            if (Lr(
              h,
              a,
              oi,
              !Ur
            ), Jt(h, 0, !0) !== 0) break t;
            h.timeoutHandle = Cx(
              Zv.bind(
                null,
                h,
                u,
                Un,
                qu,
                Tf,
                a,
                oi,
                vs,
                ma,
                Ur,
                g,
                2,
                -0,
                0
              ),
              p
            );
            break t;
          }
          Zv(
            h,
            u,
            Un,
            qu,
            Tf,
            a,
            oi,
            vs,
            ma,
            Ur,
            g,
            0,
            -0,
            0
          );
        }
      }
      break;
    } while (!0);
    Oi(r);
  }
  function Zv(r, a, u, h, p, g, T, A, U, X, nt, st, K, Z) {
    if (r.timeoutHandle = -1, st = a.subtreeFlags, (st & 8192 || (st & 16785408) === 16785408) && (qo = { stylesheets: null, count: 0, unsuspend: rM }, Wv(a), st = aM(), st !== null)) {
      r.cancelPendingCommit = st(
        rx.bind(
          null,
          r,
          a,
          g,
          u,
          h,
          p,
          T,
          A,
          U,
          nt,
          1,
          K,
          Z
        )
      ), Lr(r, g, T, !X);
      return;
    }
    rx(
      r,
      a,
      g,
      u,
      h,
      p,
      T,
      A,
      U
    );
  }
  function T2(r) {
    for (var a = r; ; ) {
      var u = a.tag;
      if ((u === 0 || u === 11 || u === 15) && a.flags & 16384 && (u = a.updateQueue, u !== null && (u = u.stores, u !== null)))
        for (var h = 0; h < u.length; h++) {
          var p = u[h], g = p.getSnapshot;
          p = p.value;
          try {
            if (!Ln(g(), p)) return !1;
          } catch {
            return !1;
          }
        }
      if (u = a.child, a.subtreeFlags & 16384 && u !== null)
        u.return = a, a = u;
      else {
        if (a === r) break;
        for (; a.sibling === null; ) {
          if (a.return === null || a.return === r) return !0;
          a = a.return;
        }
        a.sibling.return = a.return, a = a.sibling;
      }
    }
    return !0;
  }
  function Lr(r, a, u, h) {
    a &= ~Sf, a &= ~vs, r.suspendedLanes |= a, r.pingedLanes &= ~a, h && (r.warmLanes |= a), h = r.expirationTimes;
    for (var p = a; 0 < p; ) {
      var g = 31 - Ct(p), T = 1 << g;
      h[g] = -1, p &= ~T;
    }
    u !== 0 && zs(r, u, a);
  }
  function Ku() {
    return (ce & 6) === 0 ? ($o(0), !1) : !0;
  }
  function Af() {
    if (qt !== null) {
      if (he === 0)
        var r = qt.return;
      else
        r = qt, Zi = fs = null, Wd(r), ca = null, Oo = 0, r = qt;
      for (; r !== null; )
        Pv(r.alternate, r), r = r.return;
      qt = null;
    }
  }
  function ba(r, a) {
    var u = r.timeoutHandle;
    u !== -1 && (r.timeoutHandle = -1, F2(u)), u = r.cancelPendingCommit, u !== null && (r.cancelPendingCommit = null, u()), Af(), Ce = r, qt = u = Xi(r.current, null), Zt = a, he = 0, Wn = null, Ur = !1, pa = xe(r, a), _f = !1, ma = oi = Sf = vs = Nr = Le = 0, Un = Fo = null, Tf = !1, (a & 8) !== 0 && (a |= a & 32);
    var h = r.entangledLanes;
    if (h !== 0)
      for (r = r.entanglements, h &= a; 0 < h; ) {
        var p = 31 - Ct(h), g = 1 << p;
        a |= r[p], h &= ~g;
      }
    return sr = a, bu(), u;
  }
  function Qv(r, a) {
    jt = null, B.H = Nu, a === wo || a === Mu ? (a = mb(), he = 3) : a === db ? (a = mb(), he = 4) : he = a === gv ? 8 : a !== null && typeof a == "object" && typeof a.then == "function" ? 6 : 1, Wn = a, qt === null && (Le = 1, Hu(
      r,
      ni(a, r.current)
    ));
  }
  function Jv() {
    var r = B.H;
    return B.H = Nu, r === null ? Nu : r;
  }
  function tx() {
    var r = B.A;
    return B.A = _2, r;
  }
  function Rf() {
    Le = 4, Ur || (Zt & 4194048) !== Zt && ai.current !== null || (pa = !0), (Nr & 134217727) === 0 && (vs & 134217727) === 0 || Ce === null || Lr(
      Ce,
      Zt,
      oi,
      !1
    );
  }
  function Pf(r, a, u) {
    var h = ce;
    ce |= 2;
    var p = Jv(), g = tx();
    (Ce !== r || Zt !== a) && (qu = null, ba(r, a)), a = !1;
    var T = Le;
    t: do
      try {
        if (he !== 0 && qt !== null) {
          var A = qt, U = Wn;
          switch (he) {
            case 8:
              Af(), T = 6;
              break t;
            case 3:
            case 2:
            case 9:
            case 6:
              ai.current === null && (a = !0);
              var X = he;
              if (he = 0, Wn = null, va(r, A, U, X), u && pa) {
                T = 0;
                break t;
              }
              break;
            default:
              X = he, he = 0, Wn = null, va(r, A, U, X);
          }
        }
        w2(), T = Le;
        break;
      } catch (nt) {
        Qv(r, nt);
      }
    while (!0);
    return a && r.shellSuspendCounter++, Zi = fs = null, ce = h, B.H = p, B.A = g, qt === null && (Ce = null, Zt = 0, bu()), T;
  }
  function w2() {
    for (; qt !== null; ) ex(qt);
  }
  function C2(r, a) {
    var u = ce;
    ce |= 2;
    var h = Jv(), p = tx();
    Ce !== r || Zt !== a ? (qu = null, Xu = Gt() + 500, ba(r, a)) : pa = xe(
      r,
      a
    );
    t: do
      try {
        if (he !== 0 && qt !== null) {
          a = qt;
          var g = Wn;
          e: switch (he) {
            case 1:
              he = 0, Wn = null, va(r, a, g, 1);
              break;
            case 2:
            case 9:
              if (fb(g)) {
                he = 0, Wn = null, nx(a);
                break;
              }
              a = function() {
                he !== 2 && he !== 9 || Ce !== r || (he = 7), Oi(r);
              }, g.then(a, a);
              break t;
            case 3:
              he = 7;
              break t;
            case 4:
              he = 5;
              break t;
            case 7:
              fb(g) ? (he = 0, Wn = null, nx(a)) : (he = 0, Wn = null, va(r, a, g, 7));
              break;
            case 5:
              var T = null;
              switch (qt.tag) {
                case 26:
                  T = qt.memoizedState;
                case 5:
                case 27:
                  var A = qt;
                  if (!T || Nx(T)) {
                    he = 0, Wn = null;
                    var U = A.sibling;
                    if (U !== null) qt = U;
                    else {
                      var X = A.return;
                      X !== null ? (qt = X, Zu(X)) : qt = null;
                    }
                    break e;
                  }
              }
              he = 0, Wn = null, va(r, a, g, 5);
              break;
            case 6:
              he = 0, Wn = null, va(r, a, g, 6);
              break;
            case 8:
              Af(), Le = 6;
              break t;
            default:
              throw Error(i(462));
          }
        }
        E2();
        break;
      } catch (nt) {
        Qv(r, nt);
      }
    while (!0);
    return Zi = fs = null, B.H = h, B.A = p, ce = u, qt !== null ? 0 : (Ce = null, Zt = 0, bu(), Le);
  }
  function E2() {
    for (; qt !== null && !Yt(); )
      ex(qt);
  }
  function ex(r) {
    var a = Av(r.alternate, r, sr);
    r.memoizedProps = r.pendingProps, a === null ? Zu(r) : qt = a;
  }
  function nx(r) {
    var a = r, u = a.alternate;
    switch (a.tag) {
      case 15:
      case 0:
        a = Sv(
          u,
          a,
          a.pendingProps,
          a.type,
          void 0,
          Zt
        );
        break;
      case 11:
        a = Sv(
          u,
          a,
          a.pendingProps,
          a.type.render,
          a.ref,
          Zt
        );
        break;
      case 5:
        Wd(a);
      default:
        Pv(u, a), a = qt = ib(a, sr), a = Av(u, a, sr);
    }
    r.memoizedProps = r.pendingProps, a === null ? Zu(r) : qt = a;
  }
  function va(r, a, u, h) {
    Zi = fs = null, Wd(a), ca = null, Oo = 0;
    var p = a.return;
    try {
      if (m2(
        r,
        p,
        a,
        u,
        Zt
      )) {
        Le = 1, Hu(
          r,
          ni(u, r.current)
        ), qt = null;
        return;
      }
    } catch (g) {
      if (p !== null) throw qt = p, g;
      Le = 1, Hu(
        r,
        ni(u, r.current)
      ), qt = null;
      return;
    }
    a.flags & 32768 ? (ie || h === 1 ? r = !0 : pa || (Zt & 536870912) !== 0 ? r = !1 : (Ur = r = !0, (h === 2 || h === 9 || h === 3 || h === 6) && (h = ai.current, h !== null && h.tag === 13 && (h.flags |= 16384))), ix(a, r)) : Zu(a);
  }
  function Zu(r) {
    var a = r;
    do {
      if ((a.flags & 32768) !== 0) {
        ix(
          a,
          Ur
        );
        return;
      }
      r = a.return;
      var u = y2(
        a.alternate,
        a,
        sr
      );
      if (u !== null) {
        qt = u;
        return;
      }
      if (a = a.sibling, a !== null) {
        qt = a;
        return;
      }
      qt = a = r;
    } while (a !== null);
    Le === 0 && (Le = 5);
  }
  function ix(r, a) {
    do {
      var u = b2(r.alternate, r);
      if (u !== null) {
        u.flags &= 32767, qt = u;
        return;
      }
      if (u = r.return, u !== null && (u.flags |= 32768, u.subtreeFlags = 0, u.deletions = null), !a && (r = r.sibling, r !== null)) {
        qt = r;
        return;
      }
      qt = r = u;
    } while (r !== null);
    Le = 6, qt = null;
  }
  function rx(r, a, u, h, p, g, T, A, U) {
    r.cancelPendingCommit = null;
    do
      Qu();
    while (fn !== 0);
    if ((ce & 6) !== 0) throw Error(i(327));
    if (a !== null) {
      if (a === r.current) throw Error(i(177));
      if (g = a.lanes | a.childLanes, g |= vd, tn(
        r,
        u,
        g,
        T,
        A,
        U
      ), r === Ce && (qt = Ce = null, Zt = 0), ga = a, zr = r, ya = u, Cf = g, Ef = p, Xv = h, (a.subtreeFlags & 10256) !== 0 || (a.flags & 10256) !== 0 ? (r.callbackNode = null, r.callbackPriority = 0, P2(le, function() {
        return ux(), null;
      })) : (r.callbackNode = null, r.callbackPriority = 0), h = (a.flags & 13878) !== 0, (a.subtreeFlags & 13878) !== 0 || h) {
        h = B.T, B.T = null, p = I.p, I.p = 2, T = ce, ce |= 4;
        try {
          v2(r, a, u);
        } finally {
          ce = T, I.p = p, B.T = h;
        }
      }
      fn = 1, sx(), ax(), ox();
    }
  }
  function sx() {
    if (fn === 1) {
      fn = 0;
      var r = zr, a = ga, u = (a.flags & 13878) !== 0;
      if ((a.subtreeFlags & 13878) !== 0 || u) {
        u = B.T, B.T = null;
        var h = I.p;
        I.p = 2;
        var p = ce;
        ce |= 4;
        try {
          Fv(a, r);
          var g = Hf, T = Yy(r.containerInfo), A = g.focusedElem, U = g.selectionRange;
          if (T !== A && A && A.ownerDocument && jy(
            A.ownerDocument.documentElement,
            A
          )) {
            if (U !== null && pd(A)) {
              var X = U.start, nt = U.end;
              if (nt === void 0 && (nt = X), "selectionStart" in A)
                A.selectionStart = X, A.selectionEnd = Math.min(
                  nt,
                  A.value.length
                );
              else {
                var st = A.ownerDocument || document, K = st && st.defaultView || window;
                if (K.getSelection) {
                  var Z = K.getSelection(), Ot = A.textContent.length, Mt = Math.min(U.start, Ot), ye = U.end === void 0 ? Mt : Math.min(U.end, Ot);
                  !Z.extend && Mt > ye && (T = ye, ye = Mt, Mt = T);
                  var z = Vy(
                    A,
                    Mt
                  ), N = Vy(
                    A,
                    ye
                  );
                  if (z && N && (Z.rangeCount !== 1 || Z.anchorNode !== z.node || Z.anchorOffset !== z.offset || Z.focusNode !== N.node || Z.focusOffset !== N.offset)) {
                    var V = st.createRange();
                    V.setStart(z.node, z.offset), Z.removeAllRanges(), Mt > ye ? (Z.addRange(V), Z.extend(N.node, N.offset)) : (V.setEnd(N.node, N.offset), Z.addRange(V));
                  }
                }
              }
            }
            for (st = [], Z = A; Z = Z.parentNode; )
              Z.nodeType === 1 && st.push({
                element: Z,
                left: Z.scrollLeft,
                top: Z.scrollTop
              });
            for (typeof A.focus == "function" && A.focus(), A = 0; A < st.length; A++) {
              var it = st[A];
              it.element.scrollLeft = it.left, it.element.scrollTop = it.top;
            }
          }
          cc = !!Ff, Hf = Ff = null;
        } finally {
          ce = p, I.p = h, B.T = u;
        }
      }
      r.current = a, fn = 2;
    }
  }
  function ax() {
    if (fn === 2) {
      fn = 0;
      var r = zr, a = ga, u = (a.flags & 8772) !== 0;
      if ((a.subtreeFlags & 8772) !== 0 || u) {
        u = B.T, B.T = null;
        var h = I.p;
        I.p = 2;
        var p = ce;
        ce |= 4;
        try {
          Nv(r, a.alternate, a);
        } finally {
          ce = p, I.p = h, B.T = u;
        }
      }
      fn = 3;
    }
  }
  function ox() {
    if (fn === 4 || fn === 3) {
      fn = 0, Ie();
      var r = zr, a = ga, u = ya, h = Xv;
      (a.subtreeFlags & 10256) !== 0 || (a.flags & 10256) !== 0 ? fn = 5 : (fn = 0, ga = zr = null, lx(r, r.pendingLanes));
      var p = r.pendingLanes;
      if (p === 0 && (Ir = null), Yh(u), a = a.stateNode, yt && typeof yt.onCommitFiberRoot == "function")
        try {
          yt.onCommitFiberRoot(
            ut,
            a,
            void 0,
            (a.current.flags & 128) === 128
          );
        } catch {
        }
      if (h !== null) {
        a = B.T, p = I.p, I.p = 2, B.T = null;
        try {
          for (var g = r.onRecoverableError, T = 0; T < h.length; T++) {
            var A = h[T];
            g(A.value, {
              componentStack: A.stack
            });
          }
        } finally {
          B.T = a, I.p = p;
        }
      }
      (ya & 3) !== 0 && Qu(), Oi(r), p = r.pendingLanes, (u & 4194090) !== 0 && (p & 42) !== 0 ? r === Mf ? Ho++ : (Ho = 0, Mf = r) : Ho = 0, $o(0);
    }
  }
  function lx(r, a) {
    (r.pooledCacheLanes &= a) === 0 && (a = r.pooledCache, a != null && (r.pooledCache = null, So(a)));
  }
  function Qu(r) {
    return sx(), ax(), ox(), ux();
  }
  function ux() {
    if (fn !== 5) return !1;
    var r = zr, a = Cf;
    Cf = 0;
    var u = Yh(ya), h = B.T, p = I.p;
    try {
      I.p = 32 > u ? 32 : u, B.T = null, u = Ef, Ef = null;
      var g = zr, T = ya;
      if (fn = 0, ga = zr = null, ya = 0, (ce & 6) !== 0) throw Error(i(331));
      var A = ce;
      if (ce |= 4, jv(g.current), $v(
        g,
        g.current,
        T,
        u
      ), ce = A, $o(0, !1), yt && typeof yt.onPostCommitFiberRoot == "function")
        try {
          yt.onPostCommitFiberRoot(ut, g);
        } catch {
        }
      return !0;
    } finally {
      I.p = p, B.T = h, lx(r, a);
    }
  }
  function cx(r, a, u) {
    a = ni(u, a), a = sf(r.stateNode, a, 2), r = Rr(r, a, 2), r !== null && (we(r, 2), Oi(r));
  }
  function _e(r, a, u) {
    if (r.tag === 3)
      cx(r, r, u);
    else
      for (; a !== null; ) {
        if (a.tag === 3) {
          cx(
            a,
            r,
            u
          );
          break;
        } else if (a.tag === 1) {
          var h = a.stateNode;
          if (typeof a.type.getDerivedStateFromError == "function" || typeof h.componentDidCatch == "function" && (Ir === null || !Ir.has(h))) {
            r = ni(u, r), u = pv(2), h = Rr(a, u, 2), h !== null && (mv(
              u,
              h,
              a,
              r
            ), we(h, 2), Oi(h));
            break;
          }
        }
        a = a.return;
      }
  }
  function Bf(r, a, u) {
    var h = r.pingCache;
    if (h === null) {
      h = r.pingCache = new S2();
      var p = /* @__PURE__ */ new Set();
      h.set(a, p);
    } else
      p = h.get(a), p === void 0 && (p = /* @__PURE__ */ new Set(), h.set(a, p));
    p.has(u) || (_f = !0, p.add(u), r = M2.bind(null, r, a, u), a.then(r, r));
  }
  function M2(r, a, u) {
    var h = r.pingCache;
    h !== null && h.delete(a), r.pingedLanes |= r.suspendedLanes & u, r.warmLanes &= ~u, Ce === r && (Zt & u) === u && (Le === 4 || Le === 3 && (Zt & 62914560) === Zt && 300 > Gt() - wf ? (ce & 2) === 0 && ba(r, 0) : Sf |= u, ma === Zt && (ma = 0)), Oi(r);
  }
  function hx(r, a) {
    a === 0 && (a = Is()), r = ta(r, a), r !== null && (we(r, a), Oi(r));
  }
  function A2(r) {
    var a = r.memoizedState, u = 0;
    a !== null && (u = a.retryLane), hx(r, u);
  }
  function R2(r, a) {
    var u = 0;
    switch (r.tag) {
      case 13:
        var h = r.stateNode, p = r.memoizedState;
        p !== null && (u = p.retryLane);
        break;
      case 19:
        h = r.stateNode;
        break;
      case 22:
        h = r.stateNode._retryCache;
        break;
      default:
        throw Error(i(314));
    }
    h !== null && h.delete(a), hx(r, u);
  }
  function P2(r, a) {
    return It(r, a);
  }
  var Ju = null, xa = null, kf = !1, tc = !1, Of = !1, xs = 0;
  function Oi(r) {
    r !== xa && r.next === null && (xa === null ? Ju = xa = r : xa = xa.next = r), tc = !0, kf || (kf = !0, k2());
  }
  function $o(r, a) {
    if (!Of && tc) {
      Of = !0;
      do
        for (var u = !1, h = Ju; h !== null; ) {
          if (r !== 0) {
            var p = h.pendingLanes;
            if (p === 0) var g = 0;
            else {
              var T = h.suspendedLanes, A = h.pingedLanes;
              g = (1 << 31 - Ct(42 | r) + 1) - 1, g &= p & ~(T & ~A), g = g & 201326741 ? g & 201326741 | 1 : g ? g | 2 : 0;
            }
            g !== 0 && (u = !0, mx(h, g));
          } else
            g = Zt, g = Jt(
              h,
              h === Ce ? g : 0,
              h.cancelPendingCommit !== null || h.timeoutHandle !== -1
            ), (g & 3) === 0 || xe(h, g) || (u = !0, mx(h, g));
          h = h.next;
        }
      while (u);
      Of = !1;
    }
  }
  function B2() {
    dx();
  }
  function dx() {
    tc = kf = !1;
    var r = 0;
    xs !== 0 && (L2() && (r = xs), xs = 0);
    for (var a = Gt(), u = null, h = Ju; h !== null; ) {
      var p = h.next, g = fx(h, a);
      g === 0 ? (h.next = null, u === null ? Ju = p : u.next = p, p === null && (xa = u)) : (u = h, (r !== 0 || (g & 3) !== 0) && (tc = !0)), h = p;
    }
    $o(r);
  }
  function fx(r, a) {
    for (var u = r.suspendedLanes, h = r.pingedLanes, p = r.expirationTimes, g = r.pendingLanes & -62914561; 0 < g; ) {
      var T = 31 - Ct(g), A = 1 << T, U = p[T];
      U === -1 ? ((A & u) === 0 || (A & h) !== 0) && (p[T] = Ai(A, a)) : U <= a && (r.expiredLanes |= A), g &= ~A;
    }
    if (a = Ce, u = Zt, u = Jt(
      r,
      r === a ? u : 0,
      r.cancelPendingCommit !== null || r.timeoutHandle !== -1
    ), h = r.callbackNode, u === 0 || r === a && (he === 2 || he === 9) || r.cancelPendingCommit !== null)
      return h !== null && h !== null && wt(h), r.callbackNode = null, r.callbackPriority = 0;
    if ((u & 3) === 0 || xe(r, u)) {
      if (a = u & -u, a === r.callbackPriority) return a;
      switch (h !== null && wt(h), Yh(u)) {
        case 2:
        case 8:
          u = De;
          break;
        case 32:
          u = le;
          break;
        case 268435456:
          u = sn;
          break;
        default:
          u = le;
      }
      return h = px.bind(null, r), u = It(u, h), r.callbackPriority = a, r.callbackNode = u, a;
    }
    return h !== null && h !== null && wt(h), r.callbackPriority = 2, r.callbackNode = null, 2;
  }
  function px(r, a) {
    if (fn !== 0 && fn !== 5)
      return r.callbackNode = null, r.callbackPriority = 0, null;
    var u = r.callbackNode;
    if (Qu() && r.callbackNode !== u)
      return null;
    var h = Zt;
    return h = Jt(
      r,
      r === Ce ? h : 0,
      r.cancelPendingCommit !== null || r.timeoutHandle !== -1
    ), h === 0 ? null : (Kv(r, h, a), fx(r, Gt()), r.callbackNode != null && r.callbackNode === u ? px.bind(null, r) : null);
  }
  function mx(r, a) {
    if (Qu()) return null;
    Kv(r, a, !0);
  }
  function k2() {
    H2(function() {
      (ce & 6) !== 0 ? It(
        Je,
        B2
      ) : dx();
    });
  }
  function Df() {
    return xs === 0 && (xs = Vi()), xs;
  }
  function gx(r) {
    return r == null || typeof r == "symbol" || typeof r == "boolean" ? null : typeof r == "function" ? r : hu("" + r);
  }
  function yx(r, a) {
    var u = a.ownerDocument.createElement("input");
    return u.name = a.name, u.value = a.value, r.id && u.setAttribute("form", r.id), a.parentNode.insertBefore(u, a), r = new FormData(r), u.parentNode.removeChild(u), r;
  }
  function O2(r, a, u, h, p) {
    if (a === "submit" && u && u.stateNode === p) {
      var g = gx(
        (p[kn] || null).action
      ), T = h.submitter;
      T && (a = (a = T[kn] || null) ? gx(a.formAction) : T.getAttribute("formAction"), a !== null && (g = a, T = null));
      var A = new mu(
        "action",
        "action",
        null,
        h,
        p
      );
      r.push({
        event: A,
        listeners: [
          {
            instance: null,
            listener: function() {
              if (h.defaultPrevented) {
                if (xs !== 0) {
                  var U = T ? yx(p, T) : new FormData(p);
                  Jd(
                    u,
                    {
                      pending: !0,
                      data: U,
                      method: p.method,
                      action: g
                    },
                    null,
                    U
                  );
                }
              } else
                typeof g == "function" && (A.preventDefault(), U = T ? yx(p, T) : new FormData(p), Jd(
                  u,
                  {
                    pending: !0,
                    data: U,
                    method: p.method,
                    action: g
                  },
                  g,
                  U
                ));
            },
            currentTarget: p
          }
        ]
      });
    }
  }
  for (var Gf = 0; Gf < bd.length; Gf++) {
    var Uf = bd[Gf], D2 = Uf.toLowerCase(), G2 = Uf[0].toUpperCase() + Uf.slice(1);
    gi(
      D2,
      "on" + G2
    );
  }
  gi(Ky, "onAnimationEnd"), gi(Zy, "onAnimationIteration"), gi(Qy, "onAnimationStart"), gi("dblclick", "onDoubleClick"), gi("focusin", "onFocus"), gi("focusout", "onBlur"), gi(QE, "onTransitionRun"), gi(JE, "onTransitionStart"), gi(t2, "onTransitionCancel"), gi(Jy, "onTransitionEnd"), Ws("onMouseEnter", ["mouseout", "mouseover"]), Ws("onMouseLeave", ["mouseout", "mouseover"]), Ws("onPointerEnter", ["pointerout", "pointerover"]), Ws("onPointerLeave", ["pointerout", "pointerover"]), rs(
    "onChange",
    "change click focusin focusout input keydown keyup selectionchange".split(" ")
  ), rs(
    "onSelect",
    "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
      " "
    )
  ), rs("onBeforeInput", [
    "compositionend",
    "keypress",
    "textInput",
    "paste"
  ]), rs(
    "onCompositionEnd",
    "compositionend focusout keydown keypress keyup mousedown".split(" ")
  ), rs(
    "onCompositionStart",
    "compositionstart focusout keydown keypress keyup mousedown".split(" ")
  ), rs(
    "onCompositionUpdate",
    "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
  );
  var Wo = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
    " "
  ), U2 = new Set(
    "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Wo)
  );
  function bx(r, a) {
    a = (a & 4) !== 0;
    for (var u = 0; u < r.length; u++) {
      var h = r[u], p = h.event;
      h = h.listeners;
      t: {
        var g = void 0;
        if (a)
          for (var T = h.length - 1; 0 <= T; T--) {
            var A = h[T], U = A.instance, X = A.currentTarget;
            if (A = A.listener, U !== g && p.isPropagationStopped())
              break t;
            g = A, p.currentTarget = X;
            try {
              g(p);
            } catch (nt) {
              Fu(nt);
            }
            p.currentTarget = null, g = U;
          }
        else
          for (T = 0; T < h.length; T++) {
            if (A = h[T], U = A.instance, X = A.currentTarget, A = A.listener, U !== g && p.isPropagationStopped())
              break t;
            g = A, p.currentTarget = X;
            try {
              g(p);
            } catch (nt) {
              Fu(nt);
            }
            p.currentTarget = null, g = U;
          }
      }
    }
  }
  function Kt(r, a) {
    var u = a[Xh];
    u === void 0 && (u = a[Xh] = /* @__PURE__ */ new Set());
    var h = r + "__bubble";
    u.has(h) || (vx(a, r, 2, !1), u.add(h));
  }
  function Nf(r, a, u) {
    var h = 0;
    a && (h |= 4), vx(
      u,
      r,
      h,
      a
    );
  }
  var ec = "_reactListening" + Math.random().toString(36).slice(2);
  function If(r) {
    if (!r[ec]) {
      r[ec] = !0, dy.forEach(function(u) {
        u !== "selectionchange" && (U2.has(u) || Nf(u, !1, r), Nf(u, !0, r));
      });
      var a = r.nodeType === 9 ? r : r.ownerDocument;
      a === null || a[ec] || (a[ec] = !0, Nf("selectionchange", !1, a));
    }
  }
  function vx(r, a, u, h) {
    switch ($x(a)) {
      case 2:
        var p = uM;
        break;
      case 8:
        p = cM;
        break;
      default:
        p = Qf;
    }
    u = p.bind(
      null,
      a,
      u,
      r
    ), p = void 0, !sd || a !== "touchstart" && a !== "touchmove" && a !== "wheel" || (p = !0), h ? p !== void 0 ? r.addEventListener(a, u, {
      capture: !0,
      passive: p
    }) : r.addEventListener(a, u, !0) : p !== void 0 ? r.addEventListener(a, u, {
      passive: p
    }) : r.addEventListener(a, u, !1);
  }
  function zf(r, a, u, h, p) {
    var g = h;
    if ((a & 1) === 0 && (a & 2) === 0 && h !== null)
      t: for (; ; ) {
        if (h === null) return;
        var T = h.tag;
        if (T === 3 || T === 4) {
          var A = h.stateNode.containerInfo;
          if (A === p) break;
          if (T === 4)
            for (T = h.return; T !== null; ) {
              var U = T.tag;
              if ((U === 3 || U === 4) && T.stateNode.containerInfo === p)
                return;
              T = T.return;
            }
          for (; A !== null; ) {
            if (T = Fs(A), T === null) return;
            if (U = T.tag, U === 5 || U === 6 || U === 26 || U === 27) {
              h = g = T;
              continue t;
            }
            A = A.parentNode;
          }
        }
        h = h.return;
      }
    Ey(function() {
      var X = g, nt = id(u), st = [];
      t: {
        var K = tb.get(r);
        if (K !== void 0) {
          var Z = mu, Ot = r;
          switch (r) {
            case "keypress":
              if (fu(u) === 0) break t;
            case "keydown":
            case "keyup":
              Z = PE;
              break;
            case "focusin":
              Ot = "focus", Z = ud;
              break;
            case "focusout":
              Ot = "blur", Z = ud;
              break;
            case "beforeblur":
            case "afterblur":
              Z = ud;
              break;
            case "click":
              if (u.button === 2) break t;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              Z = Ry;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              Z = bE;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              Z = OE;
              break;
            case Ky:
            case Zy:
            case Qy:
              Z = _E;
              break;
            case Jy:
              Z = GE;
              break;
            case "scroll":
            case "scrollend":
              Z = gE;
              break;
            case "wheel":
              Z = NE;
              break;
            case "copy":
            case "cut":
            case "paste":
              Z = TE;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              Z = By;
              break;
            case "toggle":
            case "beforetoggle":
              Z = zE;
          }
          var Mt = (a & 4) !== 0, ye = !Mt && (r === "scroll" || r === "scrollend"), z = Mt ? K !== null ? K + "Capture" : null : K;
          Mt = [];
          for (var N = X, V; N !== null; ) {
            var it = N;
            if (V = it.stateNode, it = it.tag, it !== 5 && it !== 26 && it !== 27 || V === null || z === null || (it = lo(N, z), it != null && Mt.push(
              Vo(N, it, V)
            )), ye) break;
            N = N.return;
          }
          0 < Mt.length && (K = new Z(
            K,
            Ot,
            null,
            u,
            nt
          ), st.push({ event: K, listeners: Mt }));
        }
      }
      if ((a & 7) === 0) {
        t: {
          if (K = r === "mouseover" || r === "pointerover", Z = r === "mouseout" || r === "pointerout", K && u !== nd && (Ot = u.relatedTarget || u.fromElement) && (Fs(Ot) || Ot[Ls]))
            break t;
          if ((Z || K) && (K = nt.window === nt ? nt : (K = nt.ownerDocument) ? K.defaultView || K.parentWindow : window, Z ? (Ot = u.relatedTarget || u.toElement, Z = X, Ot = Ot ? Fs(Ot) : null, Ot !== null && (ye = o(Ot), Mt = Ot.tag, Ot !== ye || Mt !== 5 && Mt !== 27 && Mt !== 6) && (Ot = null)) : (Z = null, Ot = X), Z !== Ot)) {
            if (Mt = Ry, it = "onMouseLeave", z = "onMouseEnter", N = "mouse", (r === "pointerout" || r === "pointerover") && (Mt = By, it = "onPointerLeave", z = "onPointerEnter", N = "pointer"), ye = Z == null ? K : oo(Z), V = Ot == null ? K : oo(Ot), K = new Mt(
              it,
              N + "leave",
              Z,
              u,
              nt
            ), K.target = ye, K.relatedTarget = V, it = null, Fs(nt) === X && (Mt = new Mt(
              z,
              N + "enter",
              Ot,
              u,
              nt
            ), Mt.target = V, Mt.relatedTarget = ye, it = Mt), ye = it, Z && Ot)
              e: {
                for (Mt = Z, z = Ot, N = 0, V = Mt; V; V = _a(V))
                  N++;
                for (V = 0, it = z; it; it = _a(it))
                  V++;
                for (; 0 < N - V; )
                  Mt = _a(Mt), N--;
                for (; 0 < V - N; )
                  z = _a(z), V--;
                for (; N--; ) {
                  if (Mt === z || z !== null && Mt === z.alternate)
                    break e;
                  Mt = _a(Mt), z = _a(z);
                }
                Mt = null;
              }
            else Mt = null;
            Z !== null && xx(
              st,
              K,
              Z,
              Mt,
              !1
            ), Ot !== null && ye !== null && xx(
              st,
              ye,
              Ot,
              Mt,
              !0
            );
          }
        }
        t: {
          if (K = X ? oo(X) : window, Z = K.nodeName && K.nodeName.toLowerCase(), Z === "select" || Z === "input" && K.type === "file")
            var ft = zy;
          else if (Ny(K))
            if (Ly)
              ft = qE;
            else {
              ft = YE;
              var Xt = jE;
            }
          else
            Z = K.nodeName, !Z || Z.toLowerCase() !== "input" || K.type !== "checkbox" && K.type !== "radio" ? X && ed(X.elementType) && (ft = zy) : ft = XE;
          if (ft && (ft = ft(r, X))) {
            Iy(
              st,
              ft,
              u,
              nt
            );
            break t;
          }
          Xt && Xt(r, K, X), r === "focusout" && X && K.type === "number" && X.memoizedProps.value != null && td(K, "number", K.value);
        }
        switch (Xt = X ? oo(X) : window, r) {
          case "focusin":
            (Ny(Xt) || Xt.contentEditable === "true") && (Zs = Xt, md = X, yo = null);
            break;
          case "focusout":
            yo = md = Zs = null;
            break;
          case "mousedown":
            gd = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            gd = !1, Xy(st, u, nt);
            break;
          case "selectionchange":
            if (ZE) break;
          case "keydown":
          case "keyup":
            Xy(st, u, nt);
        }
        var _t;
        if (hd)
          t: {
            switch (r) {
              case "compositionstart":
                var At = "onCompositionStart";
                break t;
              case "compositionend":
                At = "onCompositionEnd";
                break t;
              case "compositionupdate":
                At = "onCompositionUpdate";
                break t;
            }
            At = void 0;
          }
        else
          Ks ? Gy(r, u) && (At = "onCompositionEnd") : r === "keydown" && u.keyCode === 229 && (At = "onCompositionStart");
        At && (ky && u.locale !== "ko" && (Ks || At !== "onCompositionStart" ? At === "onCompositionEnd" && Ks && (_t = My()) : (Cr = nt, ad = "value" in Cr ? Cr.value : Cr.textContent, Ks = !0)), Xt = nc(X, At), 0 < Xt.length && (At = new Py(
          At,
          r,
          null,
          u,
          nt
        ), st.push({ event: At, listeners: Xt }), _t ? At.data = _t : (_t = Uy(u), _t !== null && (At.data = _t)))), (_t = FE ? HE(r, u) : $E(r, u)) && (At = nc(X, "onBeforeInput"), 0 < At.length && (Xt = new Py(
          "onBeforeInput",
          "beforeinput",
          null,
          u,
          nt
        ), st.push({
          event: Xt,
          listeners: At
        }), Xt.data = _t)), O2(
          st,
          r,
          X,
          u,
          nt
        );
      }
      bx(st, a);
    });
  }
  function Vo(r, a, u) {
    return {
      instance: r,
      listener: a,
      currentTarget: u
    };
  }
  function nc(r, a) {
    for (var u = a + "Capture", h = []; r !== null; ) {
      var p = r, g = p.stateNode;
      if (p = p.tag, p !== 5 && p !== 26 && p !== 27 || g === null || (p = lo(r, u), p != null && h.unshift(
        Vo(r, p, g)
      ), p = lo(r, a), p != null && h.push(
        Vo(r, p, g)
      )), r.tag === 3) return h;
      r = r.return;
    }
    return [];
  }
  function _a(r) {
    if (r === null) return null;
    do
      r = r.return;
    while (r && r.tag !== 5 && r.tag !== 27);
    return r || null;
  }
  function xx(r, a, u, h, p) {
    for (var g = a._reactName, T = []; u !== null && u !== h; ) {
      var A = u, U = A.alternate, X = A.stateNode;
      if (A = A.tag, U !== null && U === h) break;
      A !== 5 && A !== 26 && A !== 27 || X === null || (U = X, p ? (X = lo(u, g), X != null && T.unshift(
        Vo(u, X, U)
      )) : p || (X = lo(u, g), X != null && T.push(
        Vo(u, X, U)
      ))), u = u.return;
    }
    T.length !== 0 && r.push({ event: a, listeners: T });
  }
  var N2 = /\r\n?/g, I2 = /\u0000|\uFFFD/g;
  function _x(r) {
    return (typeof r == "string" ? r : "" + r).replace(N2, `
`).replace(I2, "");
  }
  function Sx(r, a) {
    return a = _x(a), _x(r) === a;
  }
  function ic() {
  }
  function ge(r, a, u, h, p, g) {
    switch (u) {
      case "children":
        typeof h == "string" ? a === "body" || a === "textarea" && h === "" || Ys(r, h) : (typeof h == "number" || typeof h == "bigint") && a !== "body" && Ys(r, "" + h);
        break;
      case "className":
        lu(r, "class", h);
        break;
      case "tabIndex":
        lu(r, "tabindex", h);
        break;
      case "dir":
      case "role":
      case "viewBox":
      case "width":
      case "height":
        lu(r, u, h);
        break;
      case "style":
        wy(r, h, g);
        break;
      case "data":
        if (a !== "object") {
          lu(r, "data", h);
          break;
        }
      case "src":
      case "href":
        if (h === "" && (a !== "a" || u !== "href")) {
          r.removeAttribute(u);
          break;
        }
        if (h == null || typeof h == "function" || typeof h == "symbol" || typeof h == "boolean") {
          r.removeAttribute(u);
          break;
        }
        h = hu("" + h), r.setAttribute(u, h);
        break;
      case "action":
      case "formAction":
        if (typeof h == "function") {
          r.setAttribute(
            u,
            "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
          );
          break;
        } else
          typeof g == "function" && (u === "formAction" ? (a !== "input" && ge(r, a, "name", p.name, p, null), ge(
            r,
            a,
            "formEncType",
            p.formEncType,
            p,
            null
          ), ge(
            r,
            a,
            "formMethod",
            p.formMethod,
            p,
            null
          ), ge(
            r,
            a,
            "formTarget",
            p.formTarget,
            p,
            null
          )) : (ge(r, a, "encType", p.encType, p, null), ge(r, a, "method", p.method, p, null), ge(r, a, "target", p.target, p, null)));
        if (h == null || typeof h == "symbol" || typeof h == "boolean") {
          r.removeAttribute(u);
          break;
        }
        h = hu("" + h), r.setAttribute(u, h);
        break;
      case "onClick":
        h != null && (r.onclick = ic);
        break;
      case "onScroll":
        h != null && Kt("scroll", r);
        break;
      case "onScrollEnd":
        h != null && Kt("scrollend", r);
        break;
      case "dangerouslySetInnerHTML":
        if (h != null) {
          if (typeof h != "object" || !("__html" in h))
            throw Error(i(61));
          if (u = h.__html, u != null) {
            if (p.children != null) throw Error(i(60));
            r.innerHTML = u;
          }
        }
        break;
      case "multiple":
        r.multiple = h && typeof h != "function" && typeof h != "symbol";
        break;
      case "muted":
        r.muted = h && typeof h != "function" && typeof h != "symbol";
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "ref":
        break;
      case "autoFocus":
        break;
      case "xlinkHref":
        if (h == null || typeof h == "function" || typeof h == "boolean" || typeof h == "symbol") {
          r.removeAttribute("xlink:href");
          break;
        }
        u = hu("" + h), r.setAttributeNS(
          "http://www.w3.org/1999/xlink",
          "xlink:href",
          u
        );
        break;
      case "contentEditable":
      case "spellCheck":
      case "draggable":
      case "value":
      case "autoReverse":
      case "externalResourcesRequired":
      case "focusable":
      case "preserveAlpha":
        h != null && typeof h != "function" && typeof h != "symbol" ? r.setAttribute(u, "" + h) : r.removeAttribute(u);
        break;
      case "inert":
      case "allowFullScreen":
      case "async":
      case "autoPlay":
      case "controls":
      case "default":
      case "defer":
      case "disabled":
      case "disablePictureInPicture":
      case "disableRemotePlayback":
      case "formNoValidate":
      case "hidden":
      case "loop":
      case "noModule":
      case "noValidate":
      case "open":
      case "playsInline":
      case "readOnly":
      case "required":
      case "reversed":
      case "scoped":
      case "seamless":
      case "itemScope":
        h && typeof h != "function" && typeof h != "symbol" ? r.setAttribute(u, "") : r.removeAttribute(u);
        break;
      case "capture":
      case "download":
        h === !0 ? r.setAttribute(u, "") : h !== !1 && h != null && typeof h != "function" && typeof h != "symbol" ? r.setAttribute(u, h) : r.removeAttribute(u);
        break;
      case "cols":
      case "rows":
      case "size":
      case "span":
        h != null && typeof h != "function" && typeof h != "symbol" && !isNaN(h) && 1 <= h ? r.setAttribute(u, h) : r.removeAttribute(u);
        break;
      case "rowSpan":
      case "start":
        h == null || typeof h == "function" || typeof h == "symbol" || isNaN(h) ? r.removeAttribute(u) : r.setAttribute(u, h);
        break;
      case "popover":
        Kt("beforetoggle", r), Kt("toggle", r), ou(r, "popover", h);
        break;
      case "xlinkActuate":
        ji(
          r,
          "http://www.w3.org/1999/xlink",
          "xlink:actuate",
          h
        );
        break;
      case "xlinkArcrole":
        ji(
          r,
          "http://www.w3.org/1999/xlink",
          "xlink:arcrole",
          h
        );
        break;
      case "xlinkRole":
        ji(
          r,
          "http://www.w3.org/1999/xlink",
          "xlink:role",
          h
        );
        break;
      case "xlinkShow":
        ji(
          r,
          "http://www.w3.org/1999/xlink",
          "xlink:show",
          h
        );
        break;
      case "xlinkTitle":
        ji(
          r,
          "http://www.w3.org/1999/xlink",
          "xlink:title",
          h
        );
        break;
      case "xlinkType":
        ji(
          r,
          "http://www.w3.org/1999/xlink",
          "xlink:type",
          h
        );
        break;
      case "xmlBase":
        ji(
          r,
          "http://www.w3.org/XML/1998/namespace",
          "xml:base",
          h
        );
        break;
      case "xmlLang":
        ji(
          r,
          "http://www.w3.org/XML/1998/namespace",
          "xml:lang",
          h
        );
        break;
      case "xmlSpace":
        ji(
          r,
          "http://www.w3.org/XML/1998/namespace",
          "xml:space",
          h
        );
        break;
      case "is":
        ou(r, "is", h);
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        (!(2 < u.length) || u[0] !== "o" && u[0] !== "O" || u[1] !== "n" && u[1] !== "N") && (u = pE.get(u) || u, ou(r, u, h));
    }
  }
  function Lf(r, a, u, h, p, g) {
    switch (u) {
      case "style":
        wy(r, h, g);
        break;
      case "dangerouslySetInnerHTML":
        if (h != null) {
          if (typeof h != "object" || !("__html" in h))
            throw Error(i(61));
          if (u = h.__html, u != null) {
            if (p.children != null) throw Error(i(60));
            r.innerHTML = u;
          }
        }
        break;
      case "children":
        typeof h == "string" ? Ys(r, h) : (typeof h == "number" || typeof h == "bigint") && Ys(r, "" + h);
        break;
      case "onScroll":
        h != null && Kt("scroll", r);
        break;
      case "onScrollEnd":
        h != null && Kt("scrollend", r);
        break;
      case "onClick":
        h != null && (r.onclick = ic);
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "innerHTML":
      case "ref":
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        if (!fy.hasOwnProperty(u))
          t: {
            if (u[0] === "o" && u[1] === "n" && (p = u.endsWith("Capture"), a = u.slice(2, p ? u.length - 7 : void 0), g = r[kn] || null, g = g != null ? g[u] : null, typeof g == "function" && r.removeEventListener(a, g, p), typeof h == "function")) {
              typeof g != "function" && g !== null && (u in r ? r[u] = null : r.hasAttribute(u) && r.removeAttribute(u)), r.addEventListener(a, h, p);
              break t;
            }
            u in r ? r[u] = h : h === !0 ? r.setAttribute(u, "") : ou(r, u, h);
          }
    }
  }
  function pn(r, a, u) {
    switch (a) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "img":
        Kt("error", r), Kt("load", r);
        var h = !1, p = !1, g;
        for (g in u)
          if (u.hasOwnProperty(g)) {
            var T = u[g];
            if (T != null)
              switch (g) {
                case "src":
                  h = !0;
                  break;
                case "srcSet":
                  p = !0;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(i(137, a));
                default:
                  ge(r, a, g, T, u, null);
              }
          }
        p && ge(r, a, "srcSet", u.srcSet, u, null), h && ge(r, a, "src", u.src, u, null);
        return;
      case "input":
        Kt("invalid", r);
        var A = g = T = p = null, U = null, X = null;
        for (h in u)
          if (u.hasOwnProperty(h)) {
            var nt = u[h];
            if (nt != null)
              switch (h) {
                case "name":
                  p = nt;
                  break;
                case "type":
                  T = nt;
                  break;
                case "checked":
                  U = nt;
                  break;
                case "defaultChecked":
                  X = nt;
                  break;
                case "value":
                  g = nt;
                  break;
                case "defaultValue":
                  A = nt;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (nt != null)
                    throw Error(i(137, a));
                  break;
                default:
                  ge(r, a, h, nt, u, null);
              }
          }
        xy(
          r,
          g,
          A,
          U,
          X,
          T,
          p,
          !1
        ), uu(r);
        return;
      case "select":
        Kt("invalid", r), h = T = g = null;
        for (p in u)
          if (u.hasOwnProperty(p) && (A = u[p], A != null))
            switch (p) {
              case "value":
                g = A;
                break;
              case "defaultValue":
                T = A;
                break;
              case "multiple":
                h = A;
              default:
                ge(r, a, p, A, u, null);
            }
        a = g, u = T, r.multiple = !!h, a != null ? js(r, !!h, a, !1) : u != null && js(r, !!h, u, !0);
        return;
      case "textarea":
        Kt("invalid", r), g = p = h = null;
        for (T in u)
          if (u.hasOwnProperty(T) && (A = u[T], A != null))
            switch (T) {
              case "value":
                h = A;
                break;
              case "defaultValue":
                p = A;
                break;
              case "children":
                g = A;
                break;
              case "dangerouslySetInnerHTML":
                if (A != null) throw Error(i(91));
                break;
              default:
                ge(r, a, T, A, u, null);
            }
        Sy(r, h, p, g), uu(r);
        return;
      case "option":
        for (U in u)
          if (u.hasOwnProperty(U) && (h = u[U], h != null))
            switch (U) {
              case "selected":
                r.selected = h && typeof h != "function" && typeof h != "symbol";
                break;
              default:
                ge(r, a, U, h, u, null);
            }
        return;
      case "dialog":
        Kt("beforetoggle", r), Kt("toggle", r), Kt("cancel", r), Kt("close", r);
        break;
      case "iframe":
      case "object":
        Kt("load", r);
        break;
      case "video":
      case "audio":
        for (h = 0; h < Wo.length; h++)
          Kt(Wo[h], r);
        break;
      case "image":
        Kt("error", r), Kt("load", r);
        break;
      case "details":
        Kt("toggle", r);
        break;
      case "embed":
      case "source":
      case "link":
        Kt("error", r), Kt("load", r);
      case "area":
      case "base":
      case "br":
      case "col":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "track":
      case "wbr":
      case "menuitem":
        for (X in u)
          if (u.hasOwnProperty(X) && (h = u[X], h != null))
            switch (X) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(i(137, a));
              default:
                ge(r, a, X, h, u, null);
            }
        return;
      default:
        if (ed(a)) {
          for (nt in u)
            u.hasOwnProperty(nt) && (h = u[nt], h !== void 0 && Lf(
              r,
              a,
              nt,
              h,
              u,
              void 0
            ));
          return;
        }
    }
    for (A in u)
      u.hasOwnProperty(A) && (h = u[A], h != null && ge(r, a, A, h, u, null));
  }
  function z2(r, a, u, h) {
    switch (a) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "input":
        var p = null, g = null, T = null, A = null, U = null, X = null, nt = null;
        for (Z in u) {
          var st = u[Z];
          if (u.hasOwnProperty(Z) && st != null)
            switch (Z) {
              case "checked":
                break;
              case "value":
                break;
              case "defaultValue":
                U = st;
              default:
                h.hasOwnProperty(Z) || ge(r, a, Z, null, h, st);
            }
        }
        for (var K in h) {
          var Z = h[K];
          if (st = u[K], h.hasOwnProperty(K) && (Z != null || st != null))
            switch (K) {
              case "type":
                g = Z;
                break;
              case "name":
                p = Z;
                break;
              case "checked":
                X = Z;
                break;
              case "defaultChecked":
                nt = Z;
                break;
              case "value":
                T = Z;
                break;
              case "defaultValue":
                A = Z;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if (Z != null)
                  throw Error(i(137, a));
                break;
              default:
                Z !== st && ge(
                  r,
                  a,
                  K,
                  Z,
                  h,
                  st
                );
            }
        }
        Jh(
          r,
          T,
          A,
          U,
          X,
          nt,
          g,
          p
        );
        return;
      case "select":
        Z = T = A = K = null;
        for (g in u)
          if (U = u[g], u.hasOwnProperty(g) && U != null)
            switch (g) {
              case "value":
                break;
              case "multiple":
                Z = U;
              default:
                h.hasOwnProperty(g) || ge(
                  r,
                  a,
                  g,
                  null,
                  h,
                  U
                );
            }
        for (p in h)
          if (g = h[p], U = u[p], h.hasOwnProperty(p) && (g != null || U != null))
            switch (p) {
              case "value":
                K = g;
                break;
              case "defaultValue":
                A = g;
                break;
              case "multiple":
                T = g;
              default:
                g !== U && ge(
                  r,
                  a,
                  p,
                  g,
                  h,
                  U
                );
            }
        a = A, u = T, h = Z, K != null ? js(r, !!u, K, !1) : !!h != !!u && (a != null ? js(r, !!u, a, !0) : js(r, !!u, u ? [] : "", !1));
        return;
      case "textarea":
        Z = K = null;
        for (A in u)
          if (p = u[A], u.hasOwnProperty(A) && p != null && !h.hasOwnProperty(A))
            switch (A) {
              case "value":
                break;
              case "children":
                break;
              default:
                ge(r, a, A, null, h, p);
            }
        for (T in h)
          if (p = h[T], g = u[T], h.hasOwnProperty(T) && (p != null || g != null))
            switch (T) {
              case "value":
                K = p;
                break;
              case "defaultValue":
                Z = p;
                break;
              case "children":
                break;
              case "dangerouslySetInnerHTML":
                if (p != null) throw Error(i(91));
                break;
              default:
                p !== g && ge(r, a, T, p, h, g);
            }
        _y(r, K, Z);
        return;
      case "option":
        for (var Ot in u)
          if (K = u[Ot], u.hasOwnProperty(Ot) && K != null && !h.hasOwnProperty(Ot))
            switch (Ot) {
              case "selected":
                r.selected = !1;
                break;
              default:
                ge(
                  r,
                  a,
                  Ot,
                  null,
                  h,
                  K
                );
            }
        for (U in h)
          if (K = h[U], Z = u[U], h.hasOwnProperty(U) && K !== Z && (K != null || Z != null))
            switch (U) {
              case "selected":
                r.selected = K && typeof K != "function" && typeof K != "symbol";
                break;
              default:
                ge(
                  r,
                  a,
                  U,
                  K,
                  h,
                  Z
                );
            }
        return;
      case "img":
      case "link":
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
      case "menuitem":
        for (var Mt in u)
          K = u[Mt], u.hasOwnProperty(Mt) && K != null && !h.hasOwnProperty(Mt) && ge(r, a, Mt, null, h, K);
        for (X in h)
          if (K = h[X], Z = u[X], h.hasOwnProperty(X) && K !== Z && (K != null || Z != null))
            switch (X) {
              case "children":
              case "dangerouslySetInnerHTML":
                if (K != null)
                  throw Error(i(137, a));
                break;
              default:
                ge(
                  r,
                  a,
                  X,
                  K,
                  h,
                  Z
                );
            }
        return;
      default:
        if (ed(a)) {
          for (var ye in u)
            K = u[ye], u.hasOwnProperty(ye) && K !== void 0 && !h.hasOwnProperty(ye) && Lf(
              r,
              a,
              ye,
              void 0,
              h,
              K
            );
          for (nt in h)
            K = h[nt], Z = u[nt], !h.hasOwnProperty(nt) || K === Z || K === void 0 && Z === void 0 || Lf(
              r,
              a,
              nt,
              K,
              h,
              Z
            );
          return;
        }
    }
    for (var z in u)
      K = u[z], u.hasOwnProperty(z) && K != null && !h.hasOwnProperty(z) && ge(r, a, z, null, h, K);
    for (st in h)
      K = h[st], Z = u[st], !h.hasOwnProperty(st) || K === Z || K == null && Z == null || ge(r, a, st, K, h, Z);
  }
  var Ff = null, Hf = null;
  function rc(r) {
    return r.nodeType === 9 ? r : r.ownerDocument;
  }
  function Tx(r) {
    switch (r) {
      case "http://www.w3.org/2000/svg":
        return 1;
      case "http://www.w3.org/1998/Math/MathML":
        return 2;
      default:
        return 0;
    }
  }
  function wx(r, a) {
    if (r === 0)
      switch (a) {
        case "svg":
          return 1;
        case "math":
          return 2;
        default:
          return 0;
      }
    return r === 1 && a === "foreignObject" ? 0 : r;
  }
  function $f(r, a) {
    return r === "textarea" || r === "noscript" || typeof a.children == "string" || typeof a.children == "number" || typeof a.children == "bigint" || typeof a.dangerouslySetInnerHTML == "object" && a.dangerouslySetInnerHTML !== null && a.dangerouslySetInnerHTML.__html != null;
  }
  var Wf = null;
  function L2() {
    var r = window.event;
    return r && r.type === "popstate" ? r === Wf ? !1 : (Wf = r, !0) : (Wf = null, !1);
  }
  var Cx = typeof setTimeout == "function" ? setTimeout : void 0, F2 = typeof clearTimeout == "function" ? clearTimeout : void 0, Ex = typeof Promise == "function" ? Promise : void 0, H2 = typeof queueMicrotask == "function" ? queueMicrotask : typeof Ex < "u" ? function(r) {
    return Ex.resolve(null).then(r).catch($2);
  } : Cx;
  function $2(r) {
    setTimeout(function() {
      throw r;
    });
  }
  function Fr(r) {
    return r === "head";
  }
  function Mx(r, a) {
    var u = a, h = 0, p = 0;
    do {
      var g = u.nextSibling;
      if (r.removeChild(u), g && g.nodeType === 8)
        if (u = g.data, u === "/$") {
          if (0 < h && 8 > h) {
            u = h;
            var T = r.ownerDocument;
            if (u & 1 && jo(T.documentElement), u & 2 && jo(T.body), u & 4)
              for (u = T.head, jo(u), T = u.firstChild; T; ) {
                var A = T.nextSibling, U = T.nodeName;
                T[ao] || U === "SCRIPT" || U === "STYLE" || U === "LINK" && T.rel.toLowerCase() === "stylesheet" || u.removeChild(T), T = A;
              }
          }
          if (p === 0) {
            r.removeChild(g), tl(a);
            return;
          }
          p--;
        } else
          u === "$" || u === "$?" || u === "$!" ? p++ : h = u.charCodeAt(0) - 48;
      else h = 0;
      u = g;
    } while (u);
    tl(a);
  }
  function Vf(r) {
    var a = r.firstChild;
    for (a && a.nodeType === 10 && (a = a.nextSibling); a; ) {
      var u = a;
      switch (a = a.nextSibling, u.nodeName) {
        case "HTML":
        case "HEAD":
        case "BODY":
          Vf(u), qh(u);
          continue;
        case "SCRIPT":
        case "STYLE":
          continue;
        case "LINK":
          if (u.rel.toLowerCase() === "stylesheet") continue;
      }
      r.removeChild(u);
    }
  }
  function W2(r, a, u, h) {
    for (; r.nodeType === 1; ) {
      var p = u;
      if (r.nodeName.toLowerCase() !== a.toLowerCase()) {
        if (!h && (r.nodeName !== "INPUT" || r.type !== "hidden"))
          break;
      } else if (h) {
        if (!r[ao])
          switch (a) {
            case "meta":
              if (!r.hasAttribute("itemprop")) break;
              return r;
            case "link":
              if (g = r.getAttribute("rel"), g === "stylesheet" && r.hasAttribute("data-precedence"))
                break;
              if (g !== p.rel || r.getAttribute("href") !== (p.href == null || p.href === "" ? null : p.href) || r.getAttribute("crossorigin") !== (p.crossOrigin == null ? null : p.crossOrigin) || r.getAttribute("title") !== (p.title == null ? null : p.title))
                break;
              return r;
            case "style":
              if (r.hasAttribute("data-precedence")) break;
              return r;
            case "script":
              if (g = r.getAttribute("src"), (g !== (p.src == null ? null : p.src) || r.getAttribute("type") !== (p.type == null ? null : p.type) || r.getAttribute("crossorigin") !== (p.crossOrigin == null ? null : p.crossOrigin)) && g && r.hasAttribute("async") && !r.hasAttribute("itemprop"))
                break;
              return r;
            default:
              return r;
          }
      } else if (a === "input" && r.type === "hidden") {
        var g = p.name == null ? null : "" + p.name;
        if (p.type === "hidden" && r.getAttribute("name") === g)
          return r;
      } else return r;
      if (r = bi(r.nextSibling), r === null) break;
    }
    return null;
  }
  function V2(r, a, u) {
    if (a === "") return null;
    for (; r.nodeType !== 3; )
      if ((r.nodeType !== 1 || r.nodeName !== "INPUT" || r.type !== "hidden") && !u || (r = bi(r.nextSibling), r === null)) return null;
    return r;
  }
  function jf(r) {
    return r.data === "$!" || r.data === "$?" && r.ownerDocument.readyState === "complete";
  }
  function j2(r, a) {
    var u = r.ownerDocument;
    if (r.data !== "$?" || u.readyState === "complete")
      a();
    else {
      var h = function() {
        a(), u.removeEventListener("DOMContentLoaded", h);
      };
      u.addEventListener("DOMContentLoaded", h), r._reactRetry = h;
    }
  }
  function bi(r) {
    for (; r != null; r = r.nextSibling) {
      var a = r.nodeType;
      if (a === 1 || a === 3) break;
      if (a === 8) {
        if (a = r.data, a === "$" || a === "$!" || a === "$?" || a === "F!" || a === "F")
          break;
        if (a === "/$") return null;
      }
    }
    return r;
  }
  var Yf = null;
  function Ax(r) {
    r = r.previousSibling;
    for (var a = 0; r; ) {
      if (r.nodeType === 8) {
        var u = r.data;
        if (u === "$" || u === "$!" || u === "$?") {
          if (a === 0) return r;
          a--;
        } else u === "/$" && a++;
      }
      r = r.previousSibling;
    }
    return null;
  }
  function Rx(r, a, u) {
    switch (a = rc(u), r) {
      case "html":
        if (r = a.documentElement, !r) throw Error(i(452));
        return r;
      case "head":
        if (r = a.head, !r) throw Error(i(453));
        return r;
      case "body":
        if (r = a.body, !r) throw Error(i(454));
        return r;
      default:
        throw Error(i(451));
    }
  }
  function jo(r) {
    for (var a = r.attributes; a.length; )
      r.removeAttributeNode(a[0]);
    qh(r);
  }
  var li = /* @__PURE__ */ new Map(), Px = /* @__PURE__ */ new Set();
  function sc(r) {
    return typeof r.getRootNode == "function" ? r.getRootNode() : r.nodeType === 9 ? r : r.ownerDocument;
  }
  var ar = I.d;
  I.d = {
    f: Y2,
    r: X2,
    D: q2,
    C: K2,
    L: Z2,
    m: Q2,
    X: tM,
    S: J2,
    M: eM
  };
  function Y2() {
    var r = ar.f(), a = Ku();
    return r || a;
  }
  function X2(r) {
    var a = Hs(r);
    a !== null && a.tag === 5 && a.type === "form" ? Kb(a) : ar.r(r);
  }
  var Sa = typeof document > "u" ? null : document;
  function Bx(r, a, u) {
    var h = Sa;
    if (h && typeof a == "string" && a) {
      var p = ei(a);
      p = 'link[rel="' + r + '"][href="' + p + '"]', typeof u == "string" && (p += '[crossorigin="' + u + '"]'), Px.has(p) || (Px.add(p), r = { rel: r, crossOrigin: u, href: a }, h.querySelector(p) === null && (a = h.createElement("link"), pn(a, "link", r), on(a), h.head.appendChild(a)));
    }
  }
  function q2(r) {
    ar.D(r), Bx("dns-prefetch", r, null);
  }
  function K2(r, a) {
    ar.C(r, a), Bx("preconnect", r, a);
  }
  function Z2(r, a, u) {
    ar.L(r, a, u);
    var h = Sa;
    if (h && r && a) {
      var p = 'link[rel="preload"][as="' + ei(a) + '"]';
      a === "image" && u && u.imageSrcSet ? (p += '[imagesrcset="' + ei(
        u.imageSrcSet
      ) + '"]', typeof u.imageSizes == "string" && (p += '[imagesizes="' + ei(
        u.imageSizes
      ) + '"]')) : p += '[href="' + ei(r) + '"]';
      var g = p;
      switch (a) {
        case "style":
          g = Ta(r);
          break;
        case "script":
          g = wa(r);
      }
      li.has(g) || (r = m(
        {
          rel: "preload",
          href: a === "image" && u && u.imageSrcSet ? void 0 : r,
          as: a
        },
        u
      ), li.set(g, r), h.querySelector(p) !== null || a === "style" && h.querySelector(Yo(g)) || a === "script" && h.querySelector(Xo(g)) || (a = h.createElement("link"), pn(a, "link", r), on(a), h.head.appendChild(a)));
    }
  }
  function Q2(r, a) {
    ar.m(r, a);
    var u = Sa;
    if (u && r) {
      var h = a && typeof a.as == "string" ? a.as : "script", p = 'link[rel="modulepreload"][as="' + ei(h) + '"][href="' + ei(r) + '"]', g = p;
      switch (h) {
        case "audioworklet":
        case "paintworklet":
        case "serviceworker":
        case "sharedworker":
        case "worker":
        case "script":
          g = wa(r);
      }
      if (!li.has(g) && (r = m({ rel: "modulepreload", href: r }, a), li.set(g, r), u.querySelector(p) === null)) {
        switch (h) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script":
            if (u.querySelector(Xo(g)))
              return;
        }
        h = u.createElement("link"), pn(h, "link", r), on(h), u.head.appendChild(h);
      }
    }
  }
  function J2(r, a, u) {
    ar.S(r, a, u);
    var h = Sa;
    if (h && r) {
      var p = $s(h).hoistableStyles, g = Ta(r);
      a = a || "default";
      var T = p.get(g);
      if (!T) {
        var A = { loading: 0, preload: null };
        if (T = h.querySelector(
          Yo(g)
        ))
          A.loading = 5;
        else {
          r = m(
            { rel: "stylesheet", href: r, "data-precedence": a },
            u
          ), (u = li.get(g)) && Xf(r, u);
          var U = T = h.createElement("link");
          on(U), pn(U, "link", r), U._p = new Promise(function(X, nt) {
            U.onload = X, U.onerror = nt;
          }), U.addEventListener("load", function() {
            A.loading |= 1;
          }), U.addEventListener("error", function() {
            A.loading |= 2;
          }), A.loading |= 4, ac(T, a, h);
        }
        T = {
          type: "stylesheet",
          instance: T,
          count: 1,
          state: A
        }, p.set(g, T);
      }
    }
  }
  function tM(r, a) {
    ar.X(r, a);
    var u = Sa;
    if (u && r) {
      var h = $s(u).hoistableScripts, p = wa(r), g = h.get(p);
      g || (g = u.querySelector(Xo(p)), g || (r = m({ src: r, async: !0 }, a), (a = li.get(p)) && qf(r, a), g = u.createElement("script"), on(g), pn(g, "link", r), u.head.appendChild(g)), g = {
        type: "script",
        instance: g,
        count: 1,
        state: null
      }, h.set(p, g));
    }
  }
  function eM(r, a) {
    ar.M(r, a);
    var u = Sa;
    if (u && r) {
      var h = $s(u).hoistableScripts, p = wa(r), g = h.get(p);
      g || (g = u.querySelector(Xo(p)), g || (r = m({ src: r, async: !0, type: "module" }, a), (a = li.get(p)) && qf(r, a), g = u.createElement("script"), on(g), pn(g, "link", r), u.head.appendChild(g)), g = {
        type: "script",
        instance: g,
        count: 1,
        state: null
      }, h.set(p, g));
    }
  }
  function kx(r, a, u, h) {
    var p = (p = ht.current) ? sc(p) : null;
    if (!p) throw Error(i(446));
    switch (r) {
      case "meta":
      case "title":
        return null;
      case "style":
        return typeof u.precedence == "string" && typeof u.href == "string" ? (a = Ta(u.href), u = $s(
          p
        ).hoistableStyles, h = u.get(a), h || (h = {
          type: "style",
          instance: null,
          count: 0,
          state: null
        }, u.set(a, h)), h) : { type: "void", instance: null, count: 0, state: null };
      case "link":
        if (u.rel === "stylesheet" && typeof u.href == "string" && typeof u.precedence == "string") {
          r = Ta(u.href);
          var g = $s(
            p
          ).hoistableStyles, T = g.get(r);
          if (T || (p = p.ownerDocument || p, T = {
            type: "stylesheet",
            instance: null,
            count: 0,
            state: { loading: 0, preload: null }
          }, g.set(r, T), (g = p.querySelector(
            Yo(r)
          )) && !g._p && (T.instance = g, T.state.loading = 5), li.has(r) || (u = {
            rel: "preload",
            as: "style",
            href: u.href,
            crossOrigin: u.crossOrigin,
            integrity: u.integrity,
            media: u.media,
            hrefLang: u.hrefLang,
            referrerPolicy: u.referrerPolicy
          }, li.set(r, u), g || nM(
            p,
            r,
            u,
            T.state
          ))), a && h === null)
            throw Error(i(528, ""));
          return T;
        }
        if (a && h !== null)
          throw Error(i(529, ""));
        return null;
      case "script":
        return a = u.async, u = u.src, typeof u == "string" && a && typeof a != "function" && typeof a != "symbol" ? (a = wa(u), u = $s(
          p
        ).hoistableScripts, h = u.get(a), h || (h = {
          type: "script",
          instance: null,
          count: 0,
          state: null
        }, u.set(a, h)), h) : { type: "void", instance: null, count: 0, state: null };
      default:
        throw Error(i(444, r));
    }
  }
  function Ta(r) {
    return 'href="' + ei(r) + '"';
  }
  function Yo(r) {
    return 'link[rel="stylesheet"][' + r + "]";
  }
  function Ox(r) {
    return m({}, r, {
      "data-precedence": r.precedence,
      precedence: null
    });
  }
  function nM(r, a, u, h) {
    r.querySelector('link[rel="preload"][as="style"][' + a + "]") ? h.loading = 1 : (a = r.createElement("link"), h.preload = a, a.addEventListener("load", function() {
      return h.loading |= 1;
    }), a.addEventListener("error", function() {
      return h.loading |= 2;
    }), pn(a, "link", u), on(a), r.head.appendChild(a));
  }
  function wa(r) {
    return '[src="' + ei(r) + '"]';
  }
  function Xo(r) {
    return "script[async]" + r;
  }
  function Dx(r, a, u) {
    if (a.count++, a.instance === null)
      switch (a.type) {
        case "style":
          var h = r.querySelector(
            'style[data-href~="' + ei(u.href) + '"]'
          );
          if (h)
            return a.instance = h, on(h), h;
          var p = m({}, u, {
            "data-href": u.href,
            "data-precedence": u.precedence,
            href: null,
            precedence: null
          });
          return h = (r.ownerDocument || r).createElement(
            "style"
          ), on(h), pn(h, "style", p), ac(h, u.precedence, r), a.instance = h;
        case "stylesheet":
          p = Ta(u.href);
          var g = r.querySelector(
            Yo(p)
          );
          if (g)
            return a.state.loading |= 4, a.instance = g, on(g), g;
          h = Ox(u), (p = li.get(p)) && Xf(h, p), g = (r.ownerDocument || r).createElement("link"), on(g);
          var T = g;
          return T._p = new Promise(function(A, U) {
            T.onload = A, T.onerror = U;
          }), pn(g, "link", h), a.state.loading |= 4, ac(g, u.precedence, r), a.instance = g;
        case "script":
          return g = wa(u.src), (p = r.querySelector(
            Xo(g)
          )) ? (a.instance = p, on(p), p) : (h = u, (p = li.get(g)) && (h = m({}, u), qf(h, p)), r = r.ownerDocument || r, p = r.createElement("script"), on(p), pn(p, "link", h), r.head.appendChild(p), a.instance = p);
        case "void":
          return null;
        default:
          throw Error(i(443, a.type));
      }
    else
      a.type === "stylesheet" && (a.state.loading & 4) === 0 && (h = a.instance, a.state.loading |= 4, ac(h, u.precedence, r));
    return a.instance;
  }
  function ac(r, a, u) {
    for (var h = u.querySelectorAll(
      'link[rel="stylesheet"][data-precedence],style[data-precedence]'
    ), p = h.length ? h[h.length - 1] : null, g = p, T = 0; T < h.length; T++) {
      var A = h[T];
      if (A.dataset.precedence === a) g = A;
      else if (g !== p) break;
    }
    g ? g.parentNode.insertBefore(r, g.nextSibling) : (a = u.nodeType === 9 ? u.head : u, a.insertBefore(r, a.firstChild));
  }
  function Xf(r, a) {
    r.crossOrigin == null && (r.crossOrigin = a.crossOrigin), r.referrerPolicy == null && (r.referrerPolicy = a.referrerPolicy), r.title == null && (r.title = a.title);
  }
  function qf(r, a) {
    r.crossOrigin == null && (r.crossOrigin = a.crossOrigin), r.referrerPolicy == null && (r.referrerPolicy = a.referrerPolicy), r.integrity == null && (r.integrity = a.integrity);
  }
  var oc = null;
  function Gx(r, a, u) {
    if (oc === null) {
      var h = /* @__PURE__ */ new Map(), p = oc = /* @__PURE__ */ new Map();
      p.set(u, h);
    } else
      p = oc, h = p.get(u), h || (h = /* @__PURE__ */ new Map(), p.set(u, h));
    if (h.has(r)) return h;
    for (h.set(r, null), u = u.getElementsByTagName(r), p = 0; p < u.length; p++) {
      var g = u[p];
      if (!(g[ao] || g[yn] || r === "link" && g.getAttribute("rel") === "stylesheet") && g.namespaceURI !== "http://www.w3.org/2000/svg") {
        var T = g.getAttribute(a) || "";
        T = r + T;
        var A = h.get(T);
        A ? A.push(g) : h.set(T, [g]);
      }
    }
    return h;
  }
  function Ux(r, a, u) {
    r = r.ownerDocument || r, r.head.insertBefore(
      u,
      a === "title" ? r.querySelector("head > title") : null
    );
  }
  function iM(r, a, u) {
    if (u === 1 || a.itemProp != null) return !1;
    switch (r) {
      case "meta":
      case "title":
        return !0;
      case "style":
        if (typeof a.precedence != "string" || typeof a.href != "string" || a.href === "")
          break;
        return !0;
      case "link":
        if (typeof a.rel != "string" || typeof a.href != "string" || a.href === "" || a.onLoad || a.onError)
          break;
        switch (a.rel) {
          case "stylesheet":
            return r = a.disabled, typeof a.precedence == "string" && r == null;
          default:
            return !0;
        }
      case "script":
        if (a.async && typeof a.async != "function" && typeof a.async != "symbol" && !a.onLoad && !a.onError && a.src && typeof a.src == "string")
          return !0;
    }
    return !1;
  }
  function Nx(r) {
    return !(r.type === "stylesheet" && (r.state.loading & 3) === 0);
  }
  var qo = null;
  function rM() {
  }
  function sM(r, a, u) {
    if (qo === null) throw Error(i(475));
    var h = qo;
    if (a.type === "stylesheet" && (typeof u.media != "string" || matchMedia(u.media).matches !== !1) && (a.state.loading & 4) === 0) {
      if (a.instance === null) {
        var p = Ta(u.href), g = r.querySelector(
          Yo(p)
        );
        if (g) {
          r = g._p, r !== null && typeof r == "object" && typeof r.then == "function" && (h.count++, h = lc.bind(h), r.then(h, h)), a.state.loading |= 4, a.instance = g, on(g);
          return;
        }
        g = r.ownerDocument || r, u = Ox(u), (p = li.get(p)) && Xf(u, p), g = g.createElement("link"), on(g);
        var T = g;
        T._p = new Promise(function(A, U) {
          T.onload = A, T.onerror = U;
        }), pn(g, "link", u), a.instance = g;
      }
      h.stylesheets === null && (h.stylesheets = /* @__PURE__ */ new Map()), h.stylesheets.set(a, r), (r = a.state.preload) && (a.state.loading & 3) === 0 && (h.count++, a = lc.bind(h), r.addEventListener("load", a), r.addEventListener("error", a));
    }
  }
  function aM() {
    if (qo === null) throw Error(i(475));
    var r = qo;
    return r.stylesheets && r.count === 0 && Kf(r, r.stylesheets), 0 < r.count ? function(a) {
      var u = setTimeout(function() {
        if (r.stylesheets && Kf(r, r.stylesheets), r.unsuspend) {
          var h = r.unsuspend;
          r.unsuspend = null, h();
        }
      }, 6e4);
      return r.unsuspend = a, function() {
        r.unsuspend = null, clearTimeout(u);
      };
    } : null;
  }
  function lc() {
    if (this.count--, this.count === 0) {
      if (this.stylesheets) Kf(this, this.stylesheets);
      else if (this.unsuspend) {
        var r = this.unsuspend;
        this.unsuspend = null, r();
      }
    }
  }
  var uc = null;
  function Kf(r, a) {
    r.stylesheets = null, r.unsuspend !== null && (r.count++, uc = /* @__PURE__ */ new Map(), a.forEach(oM, r), uc = null, lc.call(r));
  }
  function oM(r, a) {
    if (!(a.state.loading & 4)) {
      var u = uc.get(r);
      if (u) var h = u.get(null);
      else {
        u = /* @__PURE__ */ new Map(), uc.set(r, u);
        for (var p = r.querySelectorAll(
          "link[data-precedence],style[data-precedence]"
        ), g = 0; g < p.length; g++) {
          var T = p[g];
          (T.nodeName === "LINK" || T.getAttribute("media") !== "not all") && (u.set(T.dataset.precedence, T), h = T);
        }
        h && u.set(null, h);
      }
      p = a.instance, T = p.getAttribute("data-precedence"), g = u.get(T) || h, g === h && u.set(null, p), u.set(T, p), this.count++, h = lc.bind(this), p.addEventListener("load", h), p.addEventListener("error", h), g ? g.parentNode.insertBefore(p, g.nextSibling) : (r = r.nodeType === 9 ? r.head : r, r.insertBefore(p, r.firstChild)), a.state.loading |= 4;
    }
  }
  var Ko = {
    $$typeof: w,
    Provider: null,
    Consumer: null,
    _currentValue: rt,
    _currentValue2: rt,
    _threadCount: 0
  };
  function lM(r, a, u, h, p, g, T, A) {
    this.tag = 1, this.containerInfo = r, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = so(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = so(0), this.hiddenUpdates = so(null), this.identifierPrefix = h, this.onUncaughtError = p, this.onCaughtError = g, this.onRecoverableError = T, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = A, this.incompleteTransitions = /* @__PURE__ */ new Map();
  }
  function Ix(r, a, u, h, p, g, T, A, U, X, nt, st) {
    return r = new lM(
      r,
      a,
      u,
      T,
      A,
      U,
      X,
      st
    ), a = 1, g === !0 && (a |= 24), g = Fn(3, null, null, a), r.current = g, g.stateNode = r, a = Pd(), a.refCount++, r.pooledCache = a, a.refCount++, g.memoizedState = {
      element: h,
      isDehydrated: u,
      cache: a
    }, Dd(g), r;
  }
  function zx(r) {
    return r ? (r = ea, r) : ea;
  }
  function Lx(r, a, u, h, p, g) {
    p = zx(p), h.context === null ? h.context = p : h.pendingContext = p, h = Ar(a), h.payload = { element: u }, g = g === void 0 ? null : g, g !== null && (h.callback = g), u = Rr(r, h, a), u !== null && (jn(u, r, a), Eo(u, r, a));
  }
  function Fx(r, a) {
    if (r = r.memoizedState, r !== null && r.dehydrated !== null) {
      var u = r.retryLane;
      r.retryLane = u !== 0 && u < a ? u : a;
    }
  }
  function Zf(r, a) {
    Fx(r, a), (r = r.alternate) && Fx(r, a);
  }
  function Hx(r) {
    if (r.tag === 13) {
      var a = ta(r, 67108864);
      a !== null && jn(a, r, 67108864), Zf(r, 67108864);
    }
  }
  var cc = !0;
  function uM(r, a, u, h) {
    var p = B.T;
    B.T = null;
    var g = I.p;
    try {
      I.p = 2, Qf(r, a, u, h);
    } finally {
      I.p = g, B.T = p;
    }
  }
  function cM(r, a, u, h) {
    var p = B.T;
    B.T = null;
    var g = I.p;
    try {
      I.p = 8, Qf(r, a, u, h);
    } finally {
      I.p = g, B.T = p;
    }
  }
  function Qf(r, a, u, h) {
    if (cc) {
      var p = Jf(h);
      if (p === null)
        zf(
          r,
          a,
          h,
          hc,
          u
        ), Wx(r, h);
      else if (dM(
        p,
        r,
        a,
        u,
        h
      ))
        h.stopPropagation();
      else if (Wx(r, h), a & 4 && -1 < hM.indexOf(r)) {
        for (; p !== null; ) {
          var g = Hs(p);
          if (g !== null)
            switch (g.tag) {
              case 3:
                if (g = g.stateNode, g.current.memoizedState.isDehydrated) {
                  var T = pt(g.pendingLanes);
                  if (T !== 0) {
                    var A = g;
                    for (A.pendingLanes |= 2, A.entangledLanes |= 2; T; ) {
                      var U = 1 << 31 - Ct(T);
                      A.entanglements[1] |= U, T &= ~U;
                    }
                    Oi(g), (ce & 6) === 0 && (Xu = Gt() + 500, $o(0));
                  }
                }
                break;
              case 13:
                A = ta(g, 2), A !== null && jn(A, g, 2), Ku(), Zf(g, 2);
            }
          if (g = Jf(h), g === null && zf(
            r,
            a,
            h,
            hc,
            u
          ), g === p) break;
          p = g;
        }
        p !== null && h.stopPropagation();
      } else
        zf(
          r,
          a,
          h,
          null,
          u
        );
    }
  }
  function Jf(r) {
    return r = id(r), tp(r);
  }
  var hc = null;
  function tp(r) {
    if (hc = null, r = Fs(r), r !== null) {
      var a = o(r);
      if (a === null) r = null;
      else {
        var u = a.tag;
        if (u === 13) {
          if (r = l(a), r !== null) return r;
          r = null;
        } else if (u === 3) {
          if (a.stateNode.current.memoizedState.isDehydrated)
            return a.tag === 3 ? a.stateNode.containerInfo : null;
          r = null;
        } else a !== r && (r = null);
      }
    }
    return hc = r, null;
  }
  function $x(r) {
    switch (r) {
      case "beforetoggle":
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "toggle":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 2;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 8;
      case "message":
        switch (pe()) {
          case Je:
            return 2;
          case De:
            return 8;
          case le:
          case xt:
            return 32;
          case sn:
            return 268435456;
          default:
            return 32;
        }
      default:
        return 32;
    }
  }
  var ep = !1, Hr = null, $r = null, Wr = null, Zo = /* @__PURE__ */ new Map(), Qo = /* @__PURE__ */ new Map(), Vr = [], hM = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
    " "
  );
  function Wx(r, a) {
    switch (r) {
      case "focusin":
      case "focusout":
        Hr = null;
        break;
      case "dragenter":
      case "dragleave":
        $r = null;
        break;
      case "mouseover":
      case "mouseout":
        Wr = null;
        break;
      case "pointerover":
      case "pointerout":
        Zo.delete(a.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Qo.delete(a.pointerId);
    }
  }
  function Jo(r, a, u, h, p, g) {
    return r === null || r.nativeEvent !== g ? (r = {
      blockedOn: a,
      domEventName: u,
      eventSystemFlags: h,
      nativeEvent: g,
      targetContainers: [p]
    }, a !== null && (a = Hs(a), a !== null && Hx(a)), r) : (r.eventSystemFlags |= h, a = r.targetContainers, p !== null && a.indexOf(p) === -1 && a.push(p), r);
  }
  function dM(r, a, u, h, p) {
    switch (a) {
      case "focusin":
        return Hr = Jo(
          Hr,
          r,
          a,
          u,
          h,
          p
        ), !0;
      case "dragenter":
        return $r = Jo(
          $r,
          r,
          a,
          u,
          h,
          p
        ), !0;
      case "mouseover":
        return Wr = Jo(
          Wr,
          r,
          a,
          u,
          h,
          p
        ), !0;
      case "pointerover":
        var g = p.pointerId;
        return Zo.set(
          g,
          Jo(
            Zo.get(g) || null,
            r,
            a,
            u,
            h,
            p
          )
        ), !0;
      case "gotpointercapture":
        return g = p.pointerId, Qo.set(
          g,
          Jo(
            Qo.get(g) || null,
            r,
            a,
            u,
            h,
            p
          )
        ), !0;
    }
    return !1;
  }
  function Vx(r) {
    var a = Fs(r.target);
    if (a !== null) {
      var u = o(a);
      if (u !== null) {
        if (a = u.tag, a === 13) {
          if (a = l(u), a !== null) {
            r.blockedOn = a, sE(r.priority, function() {
              if (u.tag === 13) {
                var h = Vn();
                h = zn(h);
                var p = ta(u, h);
                p !== null && jn(p, u, h), Zf(u, h);
              }
            });
            return;
          }
        } else if (a === 3 && u.stateNode.current.memoizedState.isDehydrated) {
          r.blockedOn = u.tag === 3 ? u.stateNode.containerInfo : null;
          return;
        }
      }
    }
    r.blockedOn = null;
  }
  function dc(r) {
    if (r.blockedOn !== null) return !1;
    for (var a = r.targetContainers; 0 < a.length; ) {
      var u = Jf(r.nativeEvent);
      if (u === null) {
        u = r.nativeEvent;
        var h = new u.constructor(
          u.type,
          u
        );
        nd = h, u.target.dispatchEvent(h), nd = null;
      } else
        return a = Hs(u), a !== null && Hx(a), r.blockedOn = u, !1;
      a.shift();
    }
    return !0;
  }
  function jx(r, a, u) {
    dc(r) && u.delete(a);
  }
  function fM() {
    ep = !1, Hr !== null && dc(Hr) && (Hr = null), $r !== null && dc($r) && ($r = null), Wr !== null && dc(Wr) && (Wr = null), Zo.forEach(jx), Qo.forEach(jx);
  }
  function fc(r, a) {
    r.blockedOn === a && (r.blockedOn = null, ep || (ep = !0, n.unstable_scheduleCallback(
      n.unstable_NormalPriority,
      fM
    )));
  }
  var pc = null;
  function Yx(r) {
    pc !== r && (pc = r, n.unstable_scheduleCallback(
      n.unstable_NormalPriority,
      function() {
        pc === r && (pc = null);
        for (var a = 0; a < r.length; a += 3) {
          var u = r[a], h = r[a + 1], p = r[a + 2];
          if (typeof h != "function") {
            if (tp(h || u) === null)
              continue;
            break;
          }
          var g = Hs(u);
          g !== null && (r.splice(a, 3), a -= 3, Jd(
            g,
            {
              pending: !0,
              data: p,
              method: u.method,
              action: h
            },
            h,
            p
          ));
        }
      }
    ));
  }
  function tl(r) {
    function a(U) {
      return fc(U, r);
    }
    Hr !== null && fc(Hr, r), $r !== null && fc($r, r), Wr !== null && fc(Wr, r), Zo.forEach(a), Qo.forEach(a);
    for (var u = 0; u < Vr.length; u++) {
      var h = Vr[u];
      h.blockedOn === r && (h.blockedOn = null);
    }
    for (; 0 < Vr.length && (u = Vr[0], u.blockedOn === null); )
      Vx(u), u.blockedOn === null && Vr.shift();
    if (u = (r.ownerDocument || r).$$reactFormReplay, u != null)
      for (h = 0; h < u.length; h += 3) {
        var p = u[h], g = u[h + 1], T = p[kn] || null;
        if (typeof g == "function")
          T || Yx(u);
        else if (T) {
          var A = null;
          if (g && g.hasAttribute("formAction")) {
            if (p = g, T = g[kn] || null)
              A = T.formAction;
            else if (tp(p) !== null) continue;
          } else A = T.action;
          typeof A == "function" ? u[h + 1] = A : (u.splice(h, 3), h -= 3), Yx(u);
        }
      }
  }
  function np(r) {
    this._internalRoot = r;
  }
  mc.prototype.render = np.prototype.render = function(r) {
    var a = this._internalRoot;
    if (a === null) throw Error(i(409));
    var u = a.current, h = Vn();
    Lx(u, h, r, a, null, null);
  }, mc.prototype.unmount = np.prototype.unmount = function() {
    var r = this._internalRoot;
    if (r !== null) {
      this._internalRoot = null;
      var a = r.containerInfo;
      Lx(r.current, 2, null, r, null, null), Ku(), a[Ls] = null;
    }
  };
  function mc(r) {
    this._internalRoot = r;
  }
  mc.prototype.unstable_scheduleHydration = function(r) {
    if (r) {
      var a = cy();
      r = { blockedOn: null, target: r, priority: a };
      for (var u = 0; u < Vr.length && a !== 0 && a < Vr[u].priority; u++) ;
      Vr.splice(u, 0, r), u === 0 && Vx(r);
    }
  };
  var Xx = t.version;
  if (Xx !== "19.1.1")
    throw Error(
      i(
        527,
        Xx,
        "19.1.1"
      )
    );
  I.findDOMNode = function(r) {
    var a = r._reactInternals;
    if (a === void 0)
      throw typeof r.render == "function" ? Error(i(188)) : (r = Object.keys(r).join(","), Error(i(268, r)));
    return r = d(a), r = r !== null ? f(r) : null, r = r === null ? null : r.stateNode, r;
  };
  var pM = {
    bundleType: 0,
    version: "19.1.1",
    rendererPackageName: "react-dom",
    currentDispatcherRef: B,
    reconcilerVersion: "19.1.1"
  };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var gc = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!gc.isDisabled && gc.supportsFiber)
      try {
        ut = gc.inject(
          pM
        ), yt = gc;
      } catch {
      }
  }
  return nl.createRoot = function(r, a) {
    if (!s(r)) throw Error(i(299));
    var u = !1, h = "", p = cv, g = hv, T = dv, A = null;
    return a != null && (a.unstable_strictMode === !0 && (u = !0), a.identifierPrefix !== void 0 && (h = a.identifierPrefix), a.onUncaughtError !== void 0 && (p = a.onUncaughtError), a.onCaughtError !== void 0 && (g = a.onCaughtError), a.onRecoverableError !== void 0 && (T = a.onRecoverableError), a.unstable_transitionCallbacks !== void 0 && (A = a.unstable_transitionCallbacks)), a = Ix(
      r,
      1,
      !1,
      null,
      null,
      u,
      h,
      p,
      g,
      T,
      A,
      null
    ), r[Ls] = a.current, If(r), new np(a);
  }, nl.hydrateRoot = function(r, a, u) {
    if (!s(r)) throw Error(i(299));
    var h = !1, p = "", g = cv, T = hv, A = dv, U = null, X = null;
    return u != null && (u.unstable_strictMode === !0 && (h = !0), u.identifierPrefix !== void 0 && (p = u.identifierPrefix), u.onUncaughtError !== void 0 && (g = u.onUncaughtError), u.onCaughtError !== void 0 && (T = u.onCaughtError), u.onRecoverableError !== void 0 && (A = u.onRecoverableError), u.unstable_transitionCallbacks !== void 0 && (U = u.unstable_transitionCallbacks), u.formState !== void 0 && (X = u.formState)), a = Ix(
      r,
      1,
      !0,
      a,
      u ?? null,
      h,
      p,
      g,
      T,
      A,
      U,
      X
    ), a.context = zx(null), u = a.current, h = Vn(), h = zn(h), p = Ar(h), p.callback = null, Rr(u, p, h), u = h, a.current.lanes = u, we(a, u), Oi(a), r[Ls] = a.current, If(r), new mc(a);
  }, nl.version = "19.1.1", nl;
}
var r_;
function wM() {
  if (r_) return rp.exports;
  r_ = 1;
  function n() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n);
      } catch (t) {
        console.error(t);
      }
  }
  return n(), rp.exports = TM(), rp.exports;
}
var CM = wM(), O = Km();
const Fi = /* @__PURE__ */ xh(O), am = /* @__PURE__ */ gM({
  __proto__: null,
  default: Fi
}, [O]), EM = (n = 10, t = 10) => {
  const [e, i] = O.useState([]), [s, o] = O.useState(n), [l, c] = O.useState(t), [d, f] = O.useState({ totalCells: 0, aliveCells: 0 }), [m, y] = O.useState([]), b = O.useCallback((w = 10, E = 10) => {
    const P = [];
    for (let k = 0; k < E; k++)
      for (let G = 0; G < w; G++)
        P.push({
          id: `${G}-${k}`,
          row: G,
          col: k,
          state: 0
          // 0 = dead, 1 = alive
        });
    f({ totalCells: w * E, aliveCells: 0 }), i(P), o(w), c(E);
  }, [s, l]), v = O.useCallback(() => {
    i(e.map((w) => ({ ...w, state: 0 })));
  }, [e]), x = O.useCallback(() => {
    i([]), o(0), c(0);
  }, []), S = O.useCallback((w) => {
    i(e.map(
      (P) => P.id === w ? { ...P, state: P.state === 0 ? 1 : 0 } : P
    ));
    const E = e.reduce((P, k) => P + (k.id === w ? k.state === 0 ? 1 : 0 : k.state), 0);
    f((P) => ({ ...P, aliveCells: E }));
  }, [e]), _ = O.useCallback(() => e.map((w) => ({ id: w.id, state: w.state })), [e]), C = O.useCallback(() => e.map((w) => w.state), [e]), R = O.useCallback((w) => {
    i((E) => (console.log("Length cells:", E.length, " - newStates:", w.length), w.length !== E.length ? (console.error("New states array length does not match the number of cells."), E) : E.map((P, k) => ({ ...P, state: w[k] }))));
  }, []);
  return {
    // Values
    cells: e,
    rows: s,
    cols: l,
    stats: d,
    frames: m,
    // Functions
    createGrid: b,
    clearGrid: v,
    emptyGrid: x,
    toggleCell: S,
    getAllStates: _,
    getCellStates: C,
    updateCellStates: R,
    setFrames: y
  };
};
var W = /* @__PURE__ */ ((n) => (n.Application = "application", n.WebGLPipes = "webgl-pipes", n.WebGLPipesAdaptor = "webgl-pipes-adaptor", n.WebGLSystem = "webgl-system", n.WebGPUPipes = "webgpu-pipes", n.WebGPUPipesAdaptor = "webgpu-pipes-adaptor", n.WebGPUSystem = "webgpu-system", n.CanvasSystem = "canvas-system", n.CanvasPipesAdaptor = "canvas-pipes-adaptor", n.CanvasPipes = "canvas-pipes", n.Asset = "asset", n.LoadParser = "load-parser", n.ResolveParser = "resolve-parser", n.CacheParser = "cache-parser", n.DetectionParser = "detection-parser", n.MaskEffect = "mask-effect", n.BlendMode = "blend-mode", n.TextureSource = "texture-source", n.Environment = "environment", n.ShapeBuilder = "shape-builder", n.Batcher = "batcher", n))(W || {});
const om = (n) => {
  if (typeof n == "function" || typeof n == "object" && n.extension) {
    if (!n.extension)
      throw new Error("Extension class must have an extension object");
    n = { ...typeof n.extension != "object" ? { type: n.extension } : n.extension, ref: n };
  }
  if (typeof n == "object")
    n = { ...n };
  else
    throw new Error("Invalid extension type");
  return typeof n.type == "string" && (n.type = [n.type]), n;
}, yc = (n, t) => om(n).priority ?? t, Nt = {
  /** @ignore */
  _addHandlers: {},
  /** @ignore */
  _removeHandlers: {},
  /** @ignore */
  _queue: {},
  /**
   * Remove extensions from PixiJS.
   * @param extensions - Extensions to be removed. Can be:
   * - Extension class with static `extension` property
   * - Extension format object with `type` and `ref`
   * - Multiple extensions as separate arguments
   * @returns {extensions} this for chaining
   * @example
   * ```ts
   * // Remove a single extension
   * extensions.remove(MyRendererPlugin);
   *
   * // Remove multiple extensions
   * extensions.remove(
   *     MyRendererPlugin,
   *     MySystemPlugin
   * );
   * ```
   * @see {@link ExtensionType} For available extension types
   * @see {@link ExtensionFormat} For extension format details
   */
  remove(...n) {
    return n.map(om).forEach((t) => {
      t.type.forEach((e) => this._removeHandlers[e]?.(t));
    }), this;
  },
  /**
   * Register new extensions with PixiJS. Extensions can be registered in multiple formats:
   * - As a class with a static `extension` property
   * - As an extension format object
   * - As multiple extensions passed as separate arguments
   * @param extensions - Extensions to add to PixiJS. Each can be:
   * - A class with static `extension` property
   * - An extension format object with `type` and `ref`
   * - Multiple extensions as separate arguments
   * @returns This extensions instance for chaining
   * @example
   * ```ts
   * // Register a simple extension
   * extensions.add(MyRendererPlugin);
   *
   * // Register multiple extensions
   * extensions.add(
   *     MyRendererPlugin,
   *     MySystemPlugin,
   * });
   * ```
   * @see {@link ExtensionType} For available extension types
   * @see {@link ExtensionFormat} For extension format details
   * @see {@link extensions.remove} For removing registered extensions
   */
  add(...n) {
    return n.map(om).forEach((t) => {
      t.type.forEach((e) => {
        const i = this._addHandlers, s = this._queue;
        i[e] ? i[e]?.(t) : (s[e] = s[e] || [], s[e]?.push(t));
      });
    }), this;
  },
  /**
   * Internal method to handle extensions by name.
   * @param type - The extension type.
   * @param onAdd  - Function handler when extensions are added/registered {@link StrictExtensionFormat}.
   * @param onRemove  - Function handler when extensions are removed/unregistered {@link StrictExtensionFormat}.
   * @returns this for chaining.
   * @internal
   * @ignore
   */
  handle(n, t, e) {
    const i = this._addHandlers, s = this._removeHandlers;
    if (i[n] || s[n])
      throw new Error(`Extension type ${n} already has a handler`);
    i[n] = t, s[n] = e;
    const o = this._queue;
    return o[n] && (o[n]?.forEach((l) => t(l)), delete o[n]), this;
  },
  /**
   * Handle a type, but using a map by `name` property.
   * @param type - Type of extension to handle.
   * @param map - The object map of named extensions.
   * @returns this for chaining.
   * @ignore
   */
  handleByMap(n, t) {
    return this.handle(
      n,
      (e) => {
        e.name && (t[e.name] = e.ref);
      },
      (e) => {
        e.name && delete t[e.name];
      }
    );
  },
  /**
   * Handle a type, but using a list of extensions with a `name` property.
   * @param type - Type of extension to handle.
   * @param map - The array of named extensions.
   * @param defaultPriority - Fallback priority if none is defined.
   * @returns this for chaining.
   * @ignore
   */
  handleByNamedList(n, t, e = -1) {
    return this.handle(
      n,
      (i) => {
        t.findIndex((o) => o.name === i.name) >= 0 || (t.push({ name: i.name, value: i.ref }), t.sort((o, l) => yc(l.value, e) - yc(o.value, e)));
      },
      (i) => {
        const s = t.findIndex((o) => o.name === i.name);
        s !== -1 && t.splice(s, 1);
      }
    );
  },
  /**
   * Handle a type, but using a list of extensions.
   * @param type - Type of extension to handle.
   * @param list - The list of extensions.
   * @param defaultPriority - The default priority to use if none is specified.
   * @returns this for chaining.
   * @ignore
   */
  handleByList(n, t, e = -1) {
    return this.handle(
      n,
      (i) => {
        t.includes(i.ref) || (t.push(i.ref), t.sort((s, o) => yc(o, e) - yc(s, e)));
      },
      (i) => {
        const s = t.indexOf(i.ref);
        s !== -1 && t.splice(s, 1);
      }
    );
  },
  /**
   * Mixin the source object(s) properties into the target class's prototype.
   * Copies all property descriptors from source objects to the target's prototype.
   * @param Target - The target class to mix properties into
   * @param sources - One or more source objects containing properties to mix in
   * @example
   * ```ts
   * // Create a mixin with shared properties
   * const moveable = {
   *     x: 0,
   *     y: 0,
   *     move(x: number, y: number) {
   *         this.x += x;
   *         this.y += y;
   *     }
   * };
   *
   * // Create a mixin with computed properties
   * const scalable = {
   *     scale: 1,
   *     get scaled() {
   *         return this.scale > 1;
   *     }
   * };
   *
   * // Apply mixins to a class
   * extensions.mixin(Sprite, moveable, scalable);
   *
   * // Use mixed-in properties
   * const sprite = new Sprite();
   * sprite.move(10, 20);
   * console.log(sprite.x, sprite.y); // 10, 20
   * ```
   * @remarks
   * - Copies all properties including getters/setters
   * - Does not modify source objects
   * - Preserves property descriptors
   * @see {@link Object.defineProperties} For details on property descriptors
   * @see {@link Object.getOwnPropertyDescriptors} For details on property copying
   */
  mixin(n, ...t) {
    for (const e of t)
      Object.defineProperties(n.prototype, Object.getOwnPropertyDescriptors(e));
  }
}, MM = {
  extension: {
    type: W.Environment,
    name: "browser",
    priority: -1
  },
  test: () => !0,
  load: async () => {
    await Promise.resolve().then(() => yI);
  }
}, AM = {
  extension: {
    type: W.Environment,
    name: "webworker",
    priority: 0
  },
  test: () => typeof self < "u" && self.WorkerGlobalScope !== void 0,
  load: async () => {
    await Promise.resolve().then(() => bI);
  }
};
class _n {
  /**
   * Creates a new `ObservablePoint`
   * @param observer - Observer to pass to listen for change events.
   * @param {number} [x=0] - position of the point on the x axis
   * @param {number} [y=0] - position of the point on the y axis
   */
  constructor(t, e, i) {
    this._x = e || 0, this._y = i || 0, this._observer = t;
  }
  /**
   * Creates a clone of this point.
   * @example
   * ```ts
   * // Basic cloning
   * const point = new ObservablePoint(observer, 100, 200);
   * const copy = point.clone();
   *
   * // Clone with new observer
   * const newObserver = {
   *     _onUpdate: (p) => console.log(`Clone updated: (${p.x}, ${p.y})`)
   * };
   * const watched = point.clone(newObserver);
   *
   * // Verify independence
   * watched.set(300, 400); // Only triggers new observer
   * ```
   * @param observer - Optional observer to pass to the new observable point
   * @returns A copy of this observable point
   * @see {@link ObservablePoint.copyFrom} For copying into existing point
   * @see {@link Observer} For observer interface details
   */
  clone(t) {
    return new _n(t ?? this._observer, this._x, this._y);
  }
  /**
   * Sets the point to a new x and y position.
   *
   * If y is omitted, both x and y will be set to x.
   * @example
   * ```ts
   * // Basic position setting
   * const point = new ObservablePoint(observer);
   * point.set(100, 200);
   *
   * // Set both x and y to same value
   * point.set(50); // x=50, y=50
   * ```
   * @param x - Position on the x axis
   * @param y - Position on the y axis, defaults to x
   * @returns The point instance itself
   * @see {@link ObservablePoint.copyFrom} For copying from another point
   * @see {@link ObservablePoint.equals} For comparing positions
   */
  set(t = 0, e = t) {
    return (this._x !== t || this._y !== e) && (this._x = t, this._y = e, this._observer._onUpdate(this)), this;
  }
  /**
   * Copies x and y from the given point into this point.
   * @example
   * ```ts
   * // Basic copying
   * const source = new ObservablePoint(observer, 100, 200);
   * const target = new ObservablePoint();
   * target.copyFrom(source);
   *
   * // Copy and chain operations
   * const point = new ObservablePoint()
   *     .copyFrom(source)
   *     .set(x + 50, y + 50);
   *
   * // Copy from any PointData
   * const data = { x: 10, y: 20 };
   * point.copyFrom(data);
   * ```
   * @param p - The point to copy from
   * @returns The point instance itself
   * @see {@link ObservablePoint.copyTo} For copying to another point
   * @see {@link ObservablePoint.clone} For creating new point copy
   */
  copyFrom(t) {
    return (this._x !== t.x || this._y !== t.y) && (this._x = t.x, this._y = t.y, this._observer._onUpdate(this)), this;
  }
  /**
   * Copies this point's x and y into the given point.
   * @example
   * ```ts
   * // Basic copying
   * const source = new ObservablePoint(100, 200);
   * const target = new ObservablePoint();
   * source.copyTo(target);
   * ```
   * @param p - The point to copy to. Can be any type that is or extends `PointLike`
   * @returns The point (`p`) with values updated
   * @see {@link ObservablePoint.copyFrom} For copying from another point
   * @see {@link ObservablePoint.clone} For creating new point copy
   */
  copyTo(t) {
    return t.set(this._x, this._y), t;
  }
  /**
   * Checks if another point is equal to this point.
   *
   * Compares x and y values using strict equality.
   * @example
   * ```ts
   * // Basic equality check
   * const p1 = new ObservablePoint(100, 200);
   * const p2 = new ObservablePoint(100, 200);
   * console.log(p1.equals(p2)); // true
   *
   * // Compare with PointData
   * const data = { x: 100, y: 200 };
   * console.log(p1.equals(data)); // true
   *
   * // Check different points
   * const p3 = new ObservablePoint(200, 300);
   * console.log(p1.equals(p3)); // false
   * ```
   * @param p - The point to check
   * @returns `true` if both `x` and `y` are equal
   * @see {@link ObservablePoint.copyFrom} For making points equal
   * @see {@link PointData} For point data interface
   */
  equals(t) {
    return t.x === this._x && t.y === this._y;
  }
  toString() {
    return `[pixi.js/math:ObservablePoint x=${this._x} y=${this._y} scope=${this._observer}]`;
  }
  /**
   * Position of the observable point on the x axis.
   * Triggers observer callback when value changes.
   * @example
   * ```ts
   * // Basic x position
   * const point = new ObservablePoint(observer);
   * point.x = 100; // Triggers observer
   *
   * // Use in calculations
   * const width = rightPoint.x - leftPoint.x;
   * ```
   * @default 0
   */
  get x() {
    return this._x;
  }
  set x(t) {
    this._x !== t && (this._x = t, this._observer._onUpdate(this));
  }
  /**
   * Position of the observable point on the y axis.
   * Triggers observer callback when value changes.
   * @example
   * ```ts
   * // Basic y position
   * const point = new ObservablePoint(observer);
   * point.y = 200; // Triggers observer
   *
   * // Use in calculations
   * const height = bottomPoint.y - topPoint.y;
   * ```
   * @default 0
   */
  get y() {
    return this._y;
  }
  set y(t) {
    this._y !== t && (this._y = t, this._observer._onUpdate(this));
  }
}
var up = { exports: {} }, s_;
function RM() {
  return s_ || (s_ = 1, (function(n) {
    var t = Object.prototype.hasOwnProperty, e = "~";
    function i() {
    }
    Object.create && (i.prototype = /* @__PURE__ */ Object.create(null), new i().__proto__ || (e = !1));
    function s(d, f, m) {
      this.fn = d, this.context = f, this.once = m || !1;
    }
    function o(d, f, m, y, b) {
      if (typeof m != "function")
        throw new TypeError("The listener must be a function");
      var v = new s(m, y || d, b), x = e ? e + f : f;
      return d._events[x] ? d._events[x].fn ? d._events[x] = [d._events[x], v] : d._events[x].push(v) : (d._events[x] = v, d._eventsCount++), d;
    }
    function l(d, f) {
      --d._eventsCount === 0 ? d._events = new i() : delete d._events[f];
    }
    function c() {
      this._events = new i(), this._eventsCount = 0;
    }
    c.prototype.eventNames = function() {
      var f = [], m, y;
      if (this._eventsCount === 0) return f;
      for (y in m = this._events)
        t.call(m, y) && f.push(e ? y.slice(1) : y);
      return Object.getOwnPropertySymbols ? f.concat(Object.getOwnPropertySymbols(m)) : f;
    }, c.prototype.listeners = function(f) {
      var m = e ? e + f : f, y = this._events[m];
      if (!y) return [];
      if (y.fn) return [y.fn];
      for (var b = 0, v = y.length, x = new Array(v); b < v; b++)
        x[b] = y[b].fn;
      return x;
    }, c.prototype.listenerCount = function(f) {
      var m = e ? e + f : f, y = this._events[m];
      return y ? y.fn ? 1 : y.length : 0;
    }, c.prototype.emit = function(f, m, y, b, v, x) {
      var S = e ? e + f : f;
      if (!this._events[S]) return !1;
      var _ = this._events[S], C = arguments.length, R, w;
      if (_.fn) {
        switch (_.once && this.removeListener(f, _.fn, void 0, !0), C) {
          case 1:
            return _.fn.call(_.context), !0;
          case 2:
            return _.fn.call(_.context, m), !0;
          case 3:
            return _.fn.call(_.context, m, y), !0;
          case 4:
            return _.fn.call(_.context, m, y, b), !0;
          case 5:
            return _.fn.call(_.context, m, y, b, v), !0;
          case 6:
            return _.fn.call(_.context, m, y, b, v, x), !0;
        }
        for (w = 1, R = new Array(C - 1); w < C; w++)
          R[w - 1] = arguments[w];
        _.fn.apply(_.context, R);
      } else {
        var E = _.length, P;
        for (w = 0; w < E; w++)
          switch (_[w].once && this.removeListener(f, _[w].fn, void 0, !0), C) {
            case 1:
              _[w].fn.call(_[w].context);
              break;
            case 2:
              _[w].fn.call(_[w].context, m);
              break;
            case 3:
              _[w].fn.call(_[w].context, m, y);
              break;
            case 4:
              _[w].fn.call(_[w].context, m, y, b);
              break;
            default:
              if (!R) for (P = 1, R = new Array(C - 1); P < C; P++)
                R[P - 1] = arguments[P];
              _[w].fn.apply(_[w].context, R);
          }
      }
      return !0;
    }, c.prototype.on = function(f, m, y) {
      return o(this, f, m, y, !1);
    }, c.prototype.once = function(f, m, y) {
      return o(this, f, m, y, !0);
    }, c.prototype.removeListener = function(f, m, y, b) {
      var v = e ? e + f : f;
      if (!this._events[v]) return this;
      if (!m)
        return l(this, v), this;
      var x = this._events[v];
      if (x.fn)
        x.fn === m && (!b || x.once) && (!y || x.context === y) && l(this, v);
      else {
        for (var S = 0, _ = [], C = x.length; S < C; S++)
          (x[S].fn !== m || b && !x[S].once || y && x[S].context !== y) && _.push(x[S]);
        _.length ? this._events[v] = _.length === 1 ? _[0] : _ : l(this, v);
      }
      return this;
    }, c.prototype.removeAllListeners = function(f) {
      var m;
      return f ? (m = e ? e + f : f, this._events[m] && l(this, m)) : (this._events = new i(), this._eventsCount = 0), this;
    }, c.prototype.off = c.prototype.removeListener, c.prototype.addListener = c.prototype.on, c.prefixed = e, c.EventEmitter = c, n.exports = c;
  })(up)), up.exports;
}
var PM = RM();
const Jn = /* @__PURE__ */ xh(PM), BM = Math.PI * 2, kM = 180 / Math.PI, OM = Math.PI / 180;
class Ut {
  /**
   * Creates a new `Point`
   * @param {number} [x=0] - position of the point on the x axis
   * @param {number} [y=0] - position of the point on the y axis
   */
  constructor(t = 0, e = 0) {
    this.x = 0, this.y = 0, this.x = t, this.y = e;
  }
  /**
   * Creates a clone of this point, which is a new instance with the same `x` and `y` values.
   * @example
   * ```ts
   * // Basic point cloning
   * const original = new Point(100, 200);
   * const copy = original.clone();
   *
   * // Clone and modify
   * const modified = original.clone();
   * modified.set(300, 400);
   *
   * // Verify independence
   * console.log(original); // Point(100, 200)
   * console.log(modified); // Point(300, 400)
   * ```
   * @remarks
   * - Creates new Point instance
   * - Deep copies x and y values
   * - Independent from original
   * - Useful for preserving values
   * @returns A clone of this point
   * @see {@link Point.copyFrom} For copying into existing point
   * @see {@link Point.copyTo} For copying to existing point
   */
  clone() {
    return new Ut(this.x, this.y);
  }
  /**
   * Copies x and y from the given point into this point.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Point(100, 200);
   * const target = new Point();
   * target.copyFrom(source);
   *
   * // Copy and chain operations
   * const point = new Point()
   *     .copyFrom(source)
   *     .set(x + 50, y + 50);
   *
   * // Copy from any PointData
   * const data = { x: 10, y: 20 };
   * point.copyFrom(data);
   * ```
   * @param p - The point to copy from
   * @returns The point instance itself
   * @see {@link Point.copyTo} For copying to another point
   * @see {@link Point.clone} For creating new point copy
   */
  copyFrom(t) {
    return this.set(t.x, t.y), this;
  }
  /**
   * Copies this point's x and y into the given point.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Point(100, 200);
   * const target = new Point();
   * source.copyTo(target);
   * ```
   * @param p - The point to copy to. Can be any type that is or extends `PointLike`
   * @returns The point (`p`) with values updated
   * @see {@link Point.copyFrom} For copying from another point
   * @see {@link Point.clone} For creating new point copy
   */
  copyTo(t) {
    return t.set(this.x, this.y), t;
  }
  /**
   * Checks if another point is equal to this point.
   *
   * Compares x and y values using strict equality.
   * @example
   * ```ts
   * // Basic equality check
   * const p1 = new Point(100, 200);
   * const p2 = new Point(100, 200);
   * console.log(p1.equals(p2)); // true
   *
   * // Compare with PointData
   * const data = { x: 100, y: 200 };
   * console.log(p1.equals(data)); // true
   *
   * // Check different points
   * const p3 = new Point(200, 300);
   * console.log(p1.equals(p3)); // false
   * ```
   * @param p - The point to check
   * @returns `true` if both `x` and `y` are equal
   * @see {@link Point.copyFrom} For making points equal
   * @see {@link PointData} For point data interface
   */
  equals(t) {
    return t.x === this.x && t.y === this.y;
  }
  /**
   * Sets the point to a new x and y position.
   *
   * If y is omitted, both x and y will be set to x.
   * @example
   * ```ts
   * // Basic position setting
   * const point = new Point();
   * point.set(100, 200);
   *
   * // Set both x and y to same value
   * point.set(50); // x=50, y=50
   *
   * // Chain with other operations
   * point
   *     .set(10, 20)
   *     .copyTo(otherPoint);
   * ```
   * @param x - Position on the x axis
   * @param y - Position on the y axis, defaults to x
   * @returns The point instance itself
   * @see {@link Point.copyFrom} For copying from another point
   * @see {@link Point.equals} For comparing positions
   */
  set(t = 0, e = t) {
    return this.x = t, this.y = e, this;
  }
  toString() {
    return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;
  }
  /**
   * A static Point object with `x` and `y` values of `0`.
   *
   * This shared instance is reset to zero values when accessed.
   *
   * > [!IMPORTANT] This point is shared and temporary. Do not store references to it.
   * @example
   * ```ts
   * // Use for temporary calculations
   * const tempPoint = Point.shared;
   * tempPoint.set(100, 200);
   * matrix.apply(tempPoint);
   *
   * // Will be reset to (0,0) on next access
   * const fresh = Point.shared; // x=0, y=0
   * ```
   * @readonly
   * @returns A fresh zeroed point for temporary use
   * @see {@link Point.constructor} For creating new points
   * @see {@link PointData} For basic point interface
   */
  static get shared() {
    return cp.x = 0, cp.y = 0, cp;
  }
}
const cp = new Ut();
class bt {
  /**
   * @param a - x scale
   * @param b - y skew
   * @param c - x skew
   * @param d - y scale
   * @param tx - x translation
   * @param ty - y translation
   */
  constructor(t = 1, e = 0, i = 0, s = 1, o = 0, l = 0) {
    this.array = null, this.a = t, this.b = e, this.c = i, this.d = s, this.tx = o, this.ty = l;
  }
  /**
   * Creates a Matrix object based on the given array.
   * Populates matrix components from a flat array in column-major order.
   *
   * > [!NOTE] Array mapping order:
   * > ```
   * > array[0] = a  (x scale)
   * > array[1] = b  (y skew)
   * > array[2] = tx (x translation)
   * > array[3] = c  (x skew)
   * > array[4] = d  (y scale)
   * > array[5] = ty (y translation)
   * > ```
   * @example
   * ```ts
   * // Create matrix from array
   * const matrix = new Matrix();
   * matrix.fromArray([
   *     2, 0,  100,  // a, b, tx
   *     0, 2,  100   // c, d, ty
   * ]);
   *
   * // Create matrix from typed array
   * const float32Array = new Float32Array([
   *     1, 0, 0,     // Scale x1, no skew
   *     0, 1, 0      // No skew, scale x1
   * ]);
   * matrix.fromArray(float32Array);
   * ```
   * @param array - The array to populate the matrix from
   * @see {@link Matrix.toArray} For converting matrix to array
   * @see {@link Matrix.set} For setting values directly
   */
  fromArray(t) {
    this.a = t[0], this.b = t[1], this.c = t[3], this.d = t[4], this.tx = t[2], this.ty = t[5];
  }
  /**
   * Sets the matrix properties directly.
   * All matrix components can be set in one call.
   * @example
   * ```ts
   * // Set to identity matrix
   * matrix.set(1, 0, 0, 1, 0, 0);
   *
   * // Set to scale matrix
   * matrix.set(2, 0, 0, 2, 0, 0); // Scale 2x
   *
   * // Set to translation matrix
   * matrix.set(1, 0, 0, 1, 100, 50); // Move 100,50
   * ```
   * @param a - Scale on x axis
   * @param b - Shear on y axis
   * @param c - Shear on x axis
   * @param d - Scale on y axis
   * @param tx - Translation on x axis
   * @param ty - Translation on y axis
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.identity} For resetting to identity
   * @see {@link Matrix.fromArray} For setting from array
   */
  set(t, e, i, s, o, l) {
    return this.a = t, this.b = e, this.c = i, this.d = s, this.tx = o, this.ty = l, this;
  }
  /**
   * Creates an array from the current Matrix object.
   *
   * > [!NOTE] The array format is:
   * > ```
   * > Non-transposed:
   * > [a, c, tx,
   * > b, d, ty,
   * > 0, 0, 1]
   * >
   * > Transposed:
   * > [a, b, 0,
   * > c, d, 0,
   * > tx,ty,1]
   * > ```
   * @example
   * ```ts
   * // Basic array conversion
   * const matrix = new Matrix(2, 0, 0, 2, 100, 100);
   * const array = matrix.toArray();
   *
   * // Using existing array
   * const float32Array = new Float32Array(9);
   * matrix.toArray(false, float32Array);
   *
   * // Get transposed array
   * const transposed = matrix.toArray(true);
   * ```
   * @param transpose - Whether to transpose the matrix
   * @param out - Optional Float32Array to store the result
   * @returns The array containing the matrix values
   * @see {@link Matrix.fromArray} For creating matrix from array
   * @see {@link Matrix.array} For cached array storage
   */
  toArray(t, e) {
    this.array || (this.array = new Float32Array(9));
    const i = e || this.array;
    return t ? (i[0] = this.a, i[1] = this.b, i[2] = 0, i[3] = this.c, i[4] = this.d, i[5] = 0, i[6] = this.tx, i[7] = this.ty, i[8] = 1) : (i[0] = this.a, i[1] = this.c, i[2] = this.tx, i[3] = this.b, i[4] = this.d, i[5] = this.ty, i[6] = 0, i[7] = 0, i[8] = 1), i;
  }
  /**
   * Get a new position with the current transformation applied.
   *
   * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
   * @example
   * ```ts
   * // Basic point transformation
   * const matrix = new Matrix().translate(100, 50).rotate(Math.PI / 4);
   * const point = new Point(10, 20);
   * const transformed = matrix.apply(point);
   *
   * // Reuse existing point
   * const output = new Point();
   * matrix.apply(point, output);
   * ```
   * @param pos - The origin point to transform
   * @param newPos - Optional point to store the result
   * @returns The transformed point
   * @see {@link Matrix.applyInverse} For inverse transformation
   * @see {@link Point} For point operations
   */
  apply(t, e) {
    e = e || new Ut();
    const i = t.x, s = t.y;
    return e.x = this.a * i + this.c * s + this.tx, e.y = this.b * i + this.d * s + this.ty, e;
  }
  /**
   * Get a new position with the inverse of the current transformation applied.
   *
   * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
   * @example
   * ```ts
   * // Basic inverse transformation
   * const matrix = new Matrix().translate(100, 50).rotate(Math.PI / 4);
   * const worldPoint = new Point(150, 100);
   * const localPoint = matrix.applyInverse(worldPoint);
   *
   * // Reuse existing point
   * const output = new Point();
   * matrix.applyInverse(worldPoint, output);
   *
   * // Convert mouse position to local space
   * const mousePoint = new Point(mouseX, mouseY);
   * const localMouse = matrix.applyInverse(mousePoint);
   * ```
   * @param pos - The origin point to inverse-transform
   * @param newPos - Optional point to store the result
   * @returns The inverse-transformed point
   * @see {@link Matrix.apply} For forward transformation
   * @see {@link Matrix.invert} For getting inverse matrix
   */
  applyInverse(t, e) {
    e = e || new Ut();
    const i = this.a, s = this.b, o = this.c, l = this.d, c = this.tx, d = this.ty, f = 1 / (i * l + o * -s), m = t.x, y = t.y;
    return e.x = l * f * m + -o * f * y + (d * o - c * l) * f, e.y = i * f * y + -s * f * m + (-d * i + c * s) * f, e;
  }
  /**
   * Translates the matrix on the x and y axes.
   * Adds to the position values while preserving scale, rotation and skew.
   * @example
   * ```ts
   * // Basic translation
   * const matrix = new Matrix();
   * matrix.translate(100, 50); // Move right 100, down 50
   *
   * // Chain with other transformations
   * matrix
   *     .scale(2, 2)
   *     .translate(100, 0)
   *     .rotate(Math.PI / 4);
   * ```
   * @param x - How much to translate on the x axis
   * @param y - How much to translate on the y axis
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.set} For setting position directly
   * @see {@link Matrix.setTransform} For complete transform setup
   */
  translate(t, e) {
    return this.tx += t, this.ty += e, this;
  }
  /**
   * Applies a scale transformation to the matrix.
   * Multiplies the scale values with existing matrix components.
   * @example
   * ```ts
   * // Basic scaling
   * const matrix = new Matrix();
   * matrix.scale(2, 3); // Scale 2x horizontally, 3x vertically
   *
   * // Chain with other transformations
   * matrix
   *     .translate(100, 100)
   *     .scale(2, 2)     // Scales after translation
   *     .rotate(Math.PI / 4);
   * ```
   * @param x - The amount to scale horizontally
   * @param y - The amount to scale vertically
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.setTransform} For setting scale directly
   * @see {@link Matrix.append} For combining transformations
   */
  scale(t, e) {
    return this.a *= t, this.d *= e, this.c *= t, this.b *= e, this.tx *= t, this.ty *= e, this;
  }
  /**
   * Applies a rotation transformation to the matrix.
   *
   * Rotates around the origin (0,0) by the given angle in radians.
   * @example
   * ```ts
   * // Basic rotation
   * const matrix = new Matrix();
   * matrix.rotate(Math.PI / 4); // Rotate 45 degrees
   *
   * // Chain with other transformations
   * matrix
   *     .translate(100, 100) // Move to rotation center
   *     .rotate(Math.PI)     // Rotate 180 degrees
   *     .scale(2, 2);        // Scale after rotation
   *
   * // Common angles
   * matrix.rotate(Math.PI / 2);  // 90 degrees
   * matrix.rotate(Math.PI);      // 180 degrees
   * matrix.rotate(Math.PI * 2);  // 360 degrees
   * ```
   * @remarks
   * - Rotates around origin point (0,0)
   * - Affects position if translation was set
   * - Uses counter-clockwise rotation
   * - Order of operations matters when chaining
   * @param angle - The angle in radians
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.setTransform} For setting rotation directly
   * @see {@link Matrix.append} For combining transformations
   */
  rotate(t) {
    const e = Math.cos(t), i = Math.sin(t), s = this.a, o = this.c, l = this.tx;
    return this.a = s * e - this.b * i, this.b = s * i + this.b * e, this.c = o * e - this.d * i, this.d = o * i + this.d * e, this.tx = l * e - this.ty * i, this.ty = l * i + this.ty * e, this;
  }
  /**
   * Appends the given Matrix to this Matrix.
   * Combines two matrices by multiplying them together: this = this * matrix
   * @example
   * ```ts
   * // Basic matrix combination
   * const matrix = new Matrix();
   * const other = new Matrix().translate(100, 0).rotate(Math.PI / 4);
   * matrix.append(other);
   * ```
   * @remarks
   * - Order matters: A.append(B) !== B.append(A)
   * - Modifies current matrix
   * - Preserves transformation order
   * - Commonly used for combining transforms
   * @param matrix - The matrix to append
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.prepend} For prepending transformations
   * @see {@link Matrix.appendFrom} For appending two external matrices
   */
  append(t) {
    const e = this.a, i = this.b, s = this.c, o = this.d;
    return this.a = t.a * e + t.b * s, this.b = t.a * i + t.b * o, this.c = t.c * e + t.d * s, this.d = t.c * i + t.d * o, this.tx = t.tx * e + t.ty * s + this.tx, this.ty = t.tx * i + t.ty * o + this.ty, this;
  }
  /**
   * Appends two matrices and sets the result to this matrix.
   * Performs matrix multiplication: this = A * B
   * @example
   * ```ts
   * // Basic matrix multiplication
   * const result = new Matrix();
   * const matrixA = new Matrix().scale(2, 2);
   * const matrixB = new Matrix().rotate(Math.PI / 4);
   * result.appendFrom(matrixA, matrixB);
   * ```
   * @remarks
   * - Order matters: A * B !== B * A
   * - Creates a new transformation from two others
   * - More efficient than append() for multiple operations
   * - Does not modify input matrices
   * @param a - The first matrix to multiply
   * @param b - The second matrix to multiply
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.append} For single matrix combination
   * @see {@link Matrix.prepend} For reverse order multiplication
   */
  appendFrom(t, e) {
    const i = t.a, s = t.b, o = t.c, l = t.d, c = t.tx, d = t.ty, f = e.a, m = e.b, y = e.c, b = e.d;
    return this.a = i * f + s * y, this.b = i * m + s * b, this.c = o * f + l * y, this.d = o * m + l * b, this.tx = c * f + d * y + e.tx, this.ty = c * m + d * b + e.ty, this;
  }
  /**
   * Sets the matrix based on all the available properties.
   * Combines position, scale, rotation, skew and pivot in a single operation.
   * @example
   * ```ts
   * // Basic transform setup
   * const matrix = new Matrix();
   * matrix.setTransform(
   *     100, 100,    // position
   *     0, 0,        // pivot
   *     2, 2,        // scale
   *     Math.PI / 4, // rotation (45 degrees)
   *     0, 0         // skew
   * );
   * ```
   * @remarks
   * - Updates all matrix components at once
   * - More efficient than separate transform calls
   * - Uses radians for rotation and skew
   * - Pivot affects rotation center
   * @param x - Position on the x axis
   * @param y - Position on the y axis
   * @param pivotX - Pivot on the x axis
   * @param pivotY - Pivot on the y axis
   * @param scaleX - Scale on the x axis
   * @param scaleY - Scale on the y axis
   * @param rotation - Rotation in radians
   * @param skewX - Skew on the x axis
   * @param skewY - Skew on the y axis
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.decompose} For extracting transform properties
   * @see {@link TransformableObject} For transform data structure
   */
  setTransform(t, e, i, s, o, l, c, d, f) {
    return this.a = Math.cos(c + f) * o, this.b = Math.sin(c + f) * o, this.c = -Math.sin(c - d) * l, this.d = Math.cos(c - d) * l, this.tx = t - (i * this.a + s * this.c), this.ty = e - (i * this.b + s * this.d), this;
  }
  /**
   * Prepends the given Matrix to this Matrix.
   * Combines two matrices by multiplying them together: this = matrix * this
   * @example
   * ```ts
   * // Basic matrix prepend
   * const matrix = new Matrix().scale(2, 2);
   * const other = new Matrix().translate(100, 0);
   * matrix.prepend(other); // Translation happens before scaling
   * ```
   * @remarks
   * - Order matters: A.prepend(B) !== B.prepend(A)
   * - Modifies current matrix
   * - Reverses transformation order compared to append()
   * @param matrix - The matrix to prepend
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.append} For appending transformations
   * @see {@link Matrix.appendFrom} For combining external matrices
   */
  prepend(t) {
    const e = this.tx;
    if (t.a !== 1 || t.b !== 0 || t.c !== 0 || t.d !== 1) {
      const i = this.a, s = this.c;
      this.a = i * t.a + this.b * t.c, this.b = i * t.b + this.b * t.d, this.c = s * t.a + this.d * t.c, this.d = s * t.b + this.d * t.d;
    }
    return this.tx = e * t.a + this.ty * t.c + t.tx, this.ty = e * t.b + this.ty * t.d + t.ty, this;
  }
  /**
   * Decomposes the matrix into its individual transform components.
   * Extracts position, scale, rotation and skew values from the matrix.
   * @example
   * ```ts
   * // Basic decomposition
   * const matrix = new Matrix()
   *     .translate(100, 100)
   *     .rotate(Math.PI / 4)
   *     .scale(2, 2);
   *
   * const transform = {
   *     position: new Point(),
   *     scale: new Point(),
   *     pivot: new Point(),
   *     skew: new Point(),
   *     rotation: 0
   * };
   *
   * matrix.decompose(transform);
   * console.log(transform.position); // Point(100, 100)
   * console.log(transform.rotation); // ~0.785 (PI/4)
   * console.log(transform.scale); // Point(2, 2)
   * ```
   * @remarks
   * - Handles combined transformations
   * - Accounts for pivot points
   * - Chooses between rotation/skew based on transform type
   * - Uses radians for rotation and skew
   * @param transform - The transform object to store the decomposed values
   * @returns The transform with the newly applied properties
   * @see {@link Matrix.setTransform} For composing from components
   * @see {@link TransformableObject} For transform structure
   */
  decompose(t) {
    const e = this.a, i = this.b, s = this.c, o = this.d, l = t.pivot, c = -Math.atan2(-s, o), d = Math.atan2(i, e), f = Math.abs(c + d);
    return f < 1e-5 || Math.abs(BM - f) < 1e-5 ? (t.rotation = d, t.skew.x = t.skew.y = 0) : (t.rotation = 0, t.skew.x = c, t.skew.y = d), t.scale.x = Math.sqrt(e * e + i * i), t.scale.y = Math.sqrt(s * s + o * o), t.position.x = this.tx + (l.x * e + l.y * s), t.position.y = this.ty + (l.x * i + l.y * o), t;
  }
  /**
   * Inverts this matrix.
   * Creates the matrix that when multiplied with this matrix results in an identity matrix.
   * @example
   * ```ts
   * // Basic matrix inversion
   * const matrix = new Matrix()
   *     .translate(100, 50)
   *     .scale(2, 2);
   *
   * matrix.invert(); // Now transforms in opposite direction
   *
   * // Verify inversion
   * const point = new Point(50, 50);
   * const transformed = matrix.apply(point);
   * const original = matrix.invert().apply(transformed);
   * // original  point
   * ```
   * @remarks
   * - Modifies the current matrix
   * - Useful for reversing transformations
   * - Cannot invert matrices with zero determinant
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.identity} For resetting to identity
   * @see {@link Matrix.applyInverse} For inverse transformations
   */
  invert() {
    const t = this.a, e = this.b, i = this.c, s = this.d, o = this.tx, l = t * s - e * i;
    return this.a = s / l, this.b = -e / l, this.c = -i / l, this.d = t / l, this.tx = (i * this.ty - s * o) / l, this.ty = -(t * this.ty - e * o) / l, this;
  }
  /**
   * Checks if this matrix is an identity matrix.
   *
   * An identity matrix has no transformations applied (default state).
   * @example
   * ```ts
   * // Check if matrix is identity
   * const matrix = new Matrix();
   * console.log(matrix.isIdentity()); // true
   *
   * // Check after transformations
   * matrix.translate(100, 0);
   * console.log(matrix.isIdentity()); // false
   *
   * // Reset and verify
   * matrix.identity();
   * console.log(matrix.isIdentity()); // true
   * ```
   * @remarks
   * - Verifies a = 1, d = 1 (no scale)
   * - Verifies b = 0, c = 0 (no skew)
   * - Verifies tx = 0, ty = 0 (no translation)
   * @returns True if matrix has no transformations
   * @see {@link Matrix.identity} For resetting to identity
   * @see {@link Matrix.IDENTITY} For constant identity matrix
   */
  isIdentity() {
    return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;
  }
  /**
   * Resets this Matrix to an identity (default) matrix.
   * Sets all components to their default values: scale=1, no skew, no translation.
   * @example
   * ```ts
   * // Reset transformed matrix
   * const matrix = new Matrix()
   *     .scale(2, 2)
   *     .rotate(Math.PI / 4);
   * matrix.identity(); // Back to default state
   *
   * // Chain after reset
   * matrix
   *     .identity()
   *     .translate(100, 100)
   *     .scale(2, 2);
   *
   * // Compare with identity constant
   * const isDefault = matrix.equals(Matrix.IDENTITY);
   * ```
   * @remarks
   * - Sets a=1, d=1 (default scale)
   * - Sets b=0, c=0 (no skew)
   * - Sets tx=0, ty=0 (no translation)
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.IDENTITY} For constant identity matrix
   * @see {@link Matrix.isIdentity} For checking identity state
   */
  identity() {
    return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this;
  }
  /**
   * Creates a new Matrix object with the same values as this one.
   * @returns A copy of this matrix. Good for chaining method calls.
   */
  clone() {
    const t = new bt();
    return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t;
  }
  /**
   * Creates a new Matrix object with the same values as this one.
   * @param matrix
   * @example
   * ```ts
   * // Basic matrix cloning
   * const matrix = new Matrix()
   *     .translate(100, 100)
   *     .rotate(Math.PI / 4);
   * const copy = matrix.clone();
   *
   * // Clone and modify
   * const modified = matrix.clone()
   *     .scale(2, 2);
   *
   * // Compare matrices
   * console.log(matrix.equals(copy));     // true
   * console.log(matrix.equals(modified)); // false
   * ```
   * @returns A copy of this matrix. Good for chaining method calls.
   * @see {@link Matrix.copyTo} For copying to existing matrix
   * @see {@link Matrix.copyFrom} For copying from another matrix
   */
  copyTo(t) {
    return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t;
  }
  /**
   * Changes the values of the matrix to be the same as the ones in given matrix.
   * @example
   * ```ts
   * // Basic matrix copying
   * const source = new Matrix()
   *     .translate(100, 100)
   *     .rotate(Math.PI / 4);
   * const target = new Matrix();
   * target.copyFrom(source);
   * ```
   * @param matrix - The matrix to copy from
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.clone} For creating new matrix copy
   * @see {@link Matrix.copyTo} For copying to another matrix
   */
  copyFrom(t) {
    return this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty, this;
  }
  /**
   * Checks if this matrix equals another matrix.
   * Compares all components for exact equality.
   * @example
   * ```ts
   * // Basic equality check
   * const m1 = new Matrix();
   * const m2 = new Matrix();
   * console.log(m1.equals(m2)); // true
   *
   * // Compare transformed matrices
   * const transform = new Matrix()
   *     .translate(100, 100)
   * const clone = new Matrix()
   *     .scale(2, 2);
   * console.log(transform.equals(clone)); // false
   * ```
   * @param matrix - The matrix to compare to
   * @returns True if matrices are identical
   * @see {@link Matrix.copyFrom} For copying matrix values
   * @see {@link Matrix.isIdentity} For identity comparison
   */
  equals(t) {
    return t.a === this.a && t.b === this.b && t.c === this.c && t.d === this.d && t.tx === this.tx && t.ty === this.ty;
  }
  toString() {
    return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
  }
  /**
   * A default (identity) matrix with no transformations applied.
   *
   * > [!IMPORTANT] This is a shared read-only object. Create a new Matrix if you need to modify it.
   * @example
   * ```ts
   * // Get identity matrix reference
   * const identity = Matrix.IDENTITY;
   * console.log(identity.isIdentity()); // true
   *
   * // Compare with identity
   * const matrix = new Matrix();
   * console.log(matrix.equals(Matrix.IDENTITY)); // true
   *
   * // Create new matrix instead of modifying IDENTITY
   * const transform = new Matrix()
   *     .copyFrom(Matrix.IDENTITY)
   *     .translate(100, 100);
   * ```
   * @readonly
   * @returns A read-only identity matrix
   * @see {@link Matrix.shared} For temporary calculations
   * @see {@link Matrix.identity} For resetting matrices
   */
  static get IDENTITY() {
    return GM.identity();
  }
  /**
   * A static Matrix that can be used to avoid creating new objects.
   * Will always ensure the matrix is reset to identity when requested.
   *
   * > [!IMPORTANT] This matrix is shared and temporary. Do not store references to it.
   * @example
   * ```ts
   * // Use for temporary calculations
   * const tempMatrix = Matrix.shared;
   * tempMatrix.translate(100, 100).rotate(Math.PI / 4);
   * const point = tempMatrix.apply({ x: 10, y: 20 });
   *
   * // Will be reset to identity on next access
   * const fresh = Matrix.shared; // Back to identity
   * ```
   * @remarks
   * - Always returns identity matrix
   * - Safe to modify temporarily
   * - Not safe to store references
   * - Useful for one-off calculations
   * @readonly
   * @returns A fresh identity matrix for temporary use
   * @see {@link Matrix.IDENTITY} For immutable identity matrix
   * @see {@link Matrix.identity} For resetting matrices
   */
  static get shared() {
    return DM.identity();
  }
}
const DM = new bt(), GM = new bt(), Es = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1], Ms = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1], As = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1], Rs = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1], lm = [], XS = [], bc = Math.sign;
function UM() {
  for (let n = 0; n < 16; n++) {
    const t = [];
    lm.push(t);
    for (let e = 0; e < 16; e++) {
      const i = bc(Es[n] * Es[e] + As[n] * Ms[e]), s = bc(Ms[n] * Es[e] + Rs[n] * Ms[e]), o = bc(Es[n] * As[e] + As[n] * Rs[e]), l = bc(Ms[n] * As[e] + Rs[n] * Rs[e]);
      for (let c = 0; c < 16; c++)
        if (Es[c] === i && Ms[c] === s && As[c] === o && Rs[c] === l) {
          t.push(c);
          break;
        }
    }
  }
  for (let n = 0; n < 16; n++) {
    const t = new bt();
    t.set(Es[n], Ms[n], As[n], Rs[n], 0, 0), XS.push(t);
  }
}
UM();
const Se = {
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 0       | East      |
   * @group groupD8
   * @type {GD8Symmetry}
   */
  E: 0,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 45     | Southeast |
   * @group groupD8
   * @type {GD8Symmetry}
   */
  SE: 1,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 90     | South     |
   * @group groupD8
   * @type {GD8Symmetry}
   */
  S: 2,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 135    | Southwest |
   * @group groupD8
   * @type {GD8Symmetry}
   */
  SW: 3,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 180     | West      |
   * @group groupD8
   * @type {GD8Symmetry}
   */
  W: 4,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -135/225 | Northwest    |
   * @group groupD8
   * @type {GD8Symmetry}
   */
  NW: 5,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -90/270  | North        |
   * @group groupD8
   * @type {GD8Symmetry}
   */
  N: 6,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -45/315  | Northeast    |
   * @group groupD8
   * @type {GD8Symmetry}
   */
  NE: 7,
  /**
   * Reflection about Y-axis.
   * @group groupD8
   * @type {GD8Symmetry}
   */
  MIRROR_VERTICAL: 8,
  /**
   * Reflection about the main diagonal.
   * @group groupD8
   * @type {GD8Symmetry}
   */
  MAIN_DIAGONAL: 10,
  /**
   * Reflection about X-axis.
   * @group groupD8
   * @type {GD8Symmetry}
   */
  MIRROR_HORIZONTAL: 12,
  /**
   * Reflection about reverse diagonal.
   * @group groupD8
   * @type {GD8Symmetry}
   */
  REVERSE_DIAGONAL: 14,
  /**
   * @group groupD8
   * @param {GD8Symmetry} ind - sprite rotation angle.
   * @returns {GD8Symmetry} The X-component of the U-axis
   *    after rotating the axes.
   */
  uX: (n) => Es[n],
  /**
   * @group groupD8
   * @param {GD8Symmetry} ind - sprite rotation angle.
   * @returns {GD8Symmetry} The Y-component of the U-axis
   *    after rotating the axes.
   */
  uY: (n) => Ms[n],
  /**
   * @group groupD8
   * @param {GD8Symmetry} ind - sprite rotation angle.
   * @returns {GD8Symmetry} The X-component of the V-axis
   *    after rotating the axes.
   */
  vX: (n) => As[n],
  /**
   * @group groupD8
   * @param {GD8Symmetry} ind - sprite rotation angle.
   * @returns {GD8Symmetry} The Y-component of the V-axis
   *    after rotating the axes.
   */
  vY: (n) => Rs[n],
  /**
   * @group groupD8
   * @param {GD8Symmetry} rotation - symmetry whose opposite
   *   is needed. Only rotations have opposite symmetries while
   *   reflections don't.
   * @returns {GD8Symmetry} The opposite symmetry of `rotation`
   */
  inv: (n) => n & 8 ? n & 15 : -n & 7,
  /**
   * Composes the two D8 operations.
   *
   * Taking `^` as reflection:
   *
   * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |
   * |-------|-----|-----|-----|-----|------|-------|-------|-------|
   * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |
   * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |
   * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |
   * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |
   * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |
   * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |
   * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |
   * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |
   *
   * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}
   * @group groupD8
   * @param {GD8Symmetry} rotationSecond - Second operation, which
   *   is the row in the above cayley table.
   * @param {GD8Symmetry} rotationFirst - First operation, which
   *   is the column in the above cayley table.
   * @returns {GD8Symmetry} Composed operation
   */
  add: (n, t) => lm[n][t],
  /**
   * Reverse of `add`.
   * @group groupD8
   * @param {GD8Symmetry} rotationSecond - Second operation
   * @param {GD8Symmetry} rotationFirst - First operation
   * @returns {GD8Symmetry} Result
   */
  sub: (n, t) => lm[n][Se.inv(t)],
  /**
   * Adds 180 degrees to rotation, which is a commutative
   * operation.
   * @group groupD8
   * @param {number} rotation - The number to rotate.
   * @returns {number} Rotated number
   */
  rotate180: (n) => n ^ 4,
  /**
   * Checks if the rotation angle is vertical, i.e. south
   * or north. It doesn't work for reflections.
   * @group groupD8
   * @param {GD8Symmetry} rotation - The number to check.
   * @returns {boolean} Whether or not the direction is vertical
   */
  isVertical: (n) => (n & 3) === 2,
  // rotation % 4 === 2
  /**
   * Approximates the vector `V(dx,dy)` into one of the
   * eight directions provided by `groupD8`.
   * @group groupD8
   * @param {number} dx - X-component of the vector
   * @param {number} dy - Y-component of the vector
   * @returns {GD8Symmetry} Approximation of the vector into
   *  one of the eight symmetries.
   */
  byDirection: (n, t) => Math.abs(n) * 2 <= Math.abs(t) ? t >= 0 ? Se.S : Se.N : Math.abs(t) * 2 <= Math.abs(n) ? n > 0 ? Se.E : Se.W : t > 0 ? n > 0 ? Se.SE : Se.SW : n > 0 ? Se.NE : Se.NW,
  /**
   * Helps sprite to compensate texture packer rotation.
   * @group groupD8
   * @param {Matrix} matrix - sprite world matrix
   * @param {GD8Symmetry} rotation - The rotation factor to use.
   * @param {number} tx - sprite anchoring
   * @param {number} ty - sprite anchoring
   */
  matrixAppendRotationInv: (n, t, e = 0, i = 0) => {
    const s = XS[Se.inv(t)];
    s.tx = e, s.ty = i, n.append(s);
  },
  /**
   * Transforms rectangle coordinates based on texture packer rotation.
   * Used when texture atlas pages are rotated and coordinates need to be adjusted.
   * @group groupD8
   * @param {RectangleLike} rect - Rectangle with original coordinates to transform
   * @param {RectangleLike} sourceFrame - Source texture frame (includes offset and dimensions)
   * @param {GD8Symmetry} rotation - The groupD8 rotation value
   * @param {Rectangle} out - Rectangle to store the result
   * @returns {Rectangle} Transformed coordinates (includes source frame offset)
   */
  transformRectCoords: (n, t, e, i) => {
    const { x: s, y: o, width: l, height: c } = n, { x: d, y: f, width: m, height: y } = t;
    return e === Se.E ? (i.set(s + d, o + f, l, c), i) : e === Se.S ? i.set(
      m - o - c + d,
      s + f,
      c,
      l
    ) : e === Se.W ? i.set(
      m - s - l + d,
      y - o - c + f,
      l,
      c
    ) : e === Se.N ? i.set(
      o + d,
      y - s - l + f,
      c,
      l
    ) : i.set(s + d, o + f, l, c);
  }
}, vc = [new Ut(), new Ut(), new Ut(), new Ut()];
class ne {
  /**
   * @param x - The X coordinate of the upper-left corner of the rectangle
   * @param y - The Y coordinate of the upper-left corner of the rectangle
   * @param width - The overall width of the rectangle
   * @param height - The overall height of the rectangle
   */
  constructor(t = 0, e = 0, i = 0, s = 0) {
    this.type = "rectangle", this.x = Number(t), this.y = Number(e), this.width = Number(i), this.height = Number(s);
  }
  /**
   * Returns the left edge (x-coordinate) of the rectangle.
   * @example
   * ```ts
   * // Get left edge position
   * const rect = new Rectangle(100, 100, 200, 150);
   * console.log(rect.left); // 100
   *
   * // Use in alignment calculations
   * sprite.x = rect.left + padding;
   *
   * // Compare positions
   * if (point.x > rect.left) {
   *     console.log('Point is right of rectangle');
   * }
   * ```
   * @readonly
   * @returns The x-coordinate of the left edge
   * @see {@link Rectangle.right} For right edge position
   * @see {@link Rectangle.x} For direct x-coordinate access
   */
  get left() {
    return this.x;
  }
  /**
   * Returns the right edge (x + width) of the rectangle.
   * @example
   * ```ts
   * // Get right edge position
   * const rect = new Rectangle(100, 100, 200, 150);
   * console.log(rect.right); // 300
   *
   * // Align to right edge
   * sprite.x = rect.right - sprite.width;
   *
   * // Check boundaries
   * if (point.x < rect.right) {
   *     console.log('Point is inside right bound');
   * }
   * ```
   * @readonly
   * @returns The x-coordinate of the right edge
   * @see {@link Rectangle.left} For left edge position
   * @see {@link Rectangle.width} For width value
   */
  get right() {
    return this.x + this.width;
  }
  /**
   * Returns the top edge (y-coordinate) of the rectangle.
   * @example
   * ```ts
   * // Get top edge position
   * const rect = new Rectangle(100, 100, 200, 150);
   * console.log(rect.top); // 100
   *
   * // Position above rectangle
   * sprite.y = rect.top - sprite.height;
   *
   * // Check vertical position
   * if (point.y > rect.top) {
   *     console.log('Point is below top edge');
   * }
   * ```
   * @readonly
   * @returns The y-coordinate of the top edge
   * @see {@link Rectangle.bottom} For bottom edge position
   * @see {@link Rectangle.y} For direct y-coordinate access
   */
  get top() {
    return this.y;
  }
  /**
   * Returns the bottom edge (y + height) of the rectangle.
   * @example
   * ```ts
   * // Get bottom edge position
   * const rect = new Rectangle(100, 100, 200, 150);
   * console.log(rect.bottom); // 250
   *
   * // Stack below rectangle
   * sprite.y = rect.bottom + margin;
   *
   * // Check vertical bounds
   * if (point.y < rect.bottom) {
   *     console.log('Point is above bottom edge');
   * }
   * ```
   * @readonly
   * @returns The y-coordinate of the bottom edge
   * @see {@link Rectangle.top} For top edge position
   * @see {@link Rectangle.height} For height value
   */
  get bottom() {
    return this.y + this.height;
  }
  /**
   * Determines whether the Rectangle is empty (has no area).
   * @example
   * ```ts
   * // Check zero dimensions
   * const rect = new Rectangle(100, 100, 0, 50);
   * console.log(rect.isEmpty()); // true
   * ```
   * @returns True if the rectangle has no area
   * @see {@link Rectangle.width} For width value
   * @see {@link Rectangle.height} For height value
   */
  isEmpty() {
    return this.left === this.right || this.top === this.bottom;
  }
  /**
   * A constant empty rectangle. This is a new object every time the property is accessed.
   * @example
   * ```ts
   * // Get fresh empty rectangle
   * const empty = Rectangle.EMPTY;
   * console.log(empty.isEmpty()); // true
   * ```
   * @returns A new empty rectangle instance
   * @see {@link Rectangle.isEmpty} For empty state testing
   */
  static get EMPTY() {
    return new ne(0, 0, 0, 0);
  }
  /**
   * Creates a clone of this Rectangle
   * @example
   * ```ts
   * // Basic cloning
   * const original = new Rectangle(100, 100, 200, 150);
   * const copy = original.clone();
   *
   * // Clone and modify
   * const modified = original.clone();
   * modified.width *= 2;
   * modified.height += 50;
   *
   * // Verify independence
   * console.log(original.width);  // 200
   * console.log(modified.width);  // 400
   * ```
   * @returns A copy of the rectangle
   * @see {@link Rectangle.copyFrom} For copying into existing rectangle
   * @see {@link Rectangle.copyTo} For copying to another rectangle
   */
  clone() {
    return new ne(this.x, this.y, this.width, this.height);
  }
  /**
   * Converts a Bounds object to a Rectangle object.
   * @example
   * ```ts
   * // Convert bounds to rectangle
   * const bounds = container.getBounds();
   * const rect = new Rectangle().copyFromBounds(bounds);
   * ```
   * @param bounds - The bounds to copy and convert to a rectangle
   * @returns Returns itself
   * @see {@link Bounds} For bounds object structure
   * @see {@link Rectangle.getBounds} For getting rectangle bounds
   */
  copyFromBounds(t) {
    return this.x = t.minX, this.y = t.minY, this.width = t.maxX - t.minX, this.height = t.maxY - t.minY, this;
  }
  /**
   * Copies another rectangle to this one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Rectangle(100, 100, 200, 150);
   * const target = new Rectangle();
   * target.copyFrom(source);
   *
   * // Chain with other operations
   * const rect = new Rectangle()
   *     .copyFrom(source)
   *     .pad(10);
   * ```
   * @param rectangle - The rectangle to copy from
   * @returns Returns itself
   * @see {@link Rectangle.copyTo} For copying to another rectangle
   * @see {@link Rectangle.clone} For creating new rectangle copy
   */
  copyFrom(t) {
    return this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this;
  }
  /**
   * Copies this rectangle to another one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Rectangle(100, 100, 200, 150);
   * const target = new Rectangle();
   * source.copyTo(target);
   *
   * // Chain with other operations
   * const result = source
   *     .copyTo(new Rectangle())
   *     .getBounds();
   * ```
   * @param rectangle - The rectangle to copy to
   * @returns Returns given parameter
   * @see {@link Rectangle.copyFrom} For copying from another rectangle
   * @see {@link Rectangle.clone} For creating new rectangle copy
   */
  copyTo(t) {
    return t.copyFrom(this), t;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this Rectangle
   * @example
   * ```ts
   * // Basic containment check
   * const rect = new Rectangle(100, 100, 200, 150);
   * const isInside = rect.contains(150, 125); // true
   * // Check edge cases
   * console.log(rect.contains(100, 100)); // true (on edge)
   * console.log(rect.contains(300, 250)); // false (outside)
   * ```
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coordinates are within this Rectangle
   * @see {@link Rectangle.containsRect} For rectangle containment
   * @see {@link Rectangle.strokeContains} For checking stroke intersection
   */
  contains(t, e) {
    return this.width <= 0 || this.height <= 0 ? !1 : t >= this.x && t < this.x + this.width && e >= this.y && e < this.y + this.height;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.
   * @example
   * ```ts
   * // Basic stroke check
   * const rect = new Rectangle(100, 100, 200, 150);
   * const isOnStroke = rect.strokeContains(150, 100, 4); // 4px line width
   *
   * // Check with different alignments
   * const innerStroke = rect.strokeContains(150, 100, 4, 1);   // Inside
   * const centerStroke = rect.strokeContains(150, 100, 4, 0.5); // Centered
   * const outerStroke = rect.strokeContains(150, 100, 4, 0);   // Outside
   * ```
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @param strokeWidth - The width of the line to check
   * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)
   * @returns Whether the x/y coordinates are within this rectangle's stroke
   * @see {@link Rectangle.contains} For checking fill containment
   * @see {@link Rectangle.getBounds} For getting stroke bounds
   */
  strokeContains(t, e, i, s = 0.5) {
    const { width: o, height: l } = this;
    if (o <= 0 || l <= 0)
      return !1;
    const c = this.x, d = this.y, f = i * (1 - s), m = i - f, y = c - f, b = c + o + f, v = d - f, x = d + l + f, S = c + m, _ = c + o - m, C = d + m, R = d + l - m;
    return t >= y && t <= b && e >= v && e <= x && !(t > S && t < _ && e > C && e < R);
  }
  /**
   * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.
   * Returns true only if the area of the intersection is >0, this means that Rectangles
   * sharing a side are not overlapping. Another side effect is that an arealess rectangle
   * (width or height equal to zero) can't intersect any other rectangle.
   * @param {Rectangle} other - The Rectangle to intersect with `this`.
   * @param {Matrix} transform - The transformation matrix of `other`.
   * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.
   */
  /**
   * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.
   *
   * Returns true only if the area of the intersection is greater than 0.
   * This means that rectangles sharing only a side are not considered intersecting.
   * @example
   * ```ts
   * // Basic intersection check
   * const rect1 = new Rectangle(0, 0, 100, 100);
   * const rect2 = new Rectangle(50, 50, 100, 100);
   * console.log(rect1.intersects(rect2)); // true
   *
   * // With transformation matrix
   * const matrix = new Matrix();
   * matrix.rotate(Math.PI / 4); // 45 degrees
   * console.log(rect1.intersects(rect2, matrix)); // Checks with rotation
   *
   * // Edge cases
   * const zeroWidth = new Rectangle(0, 0, 0, 100);
   * console.log(rect1.intersects(zeroWidth)); // false (no area)
   * ```
   * @remarks
   * - Returns true only if intersection area is > 0
   * - Rectangles sharing only a side are not intersecting
   * - Zero-area rectangles cannot intersect anything
   * - Supports optional transformation matrix
   * @param other - The Rectangle to intersect with `this`
   * @param transform - Optional transformation matrix of `other`
   * @returns True if the transformed `other` Rectangle intersects with `this`
   * @see {@link Rectangle.containsRect} For containment testing
   * @see {@link Rectangle.contains} For point testing
   */
  intersects(t, e) {
    if (!e) {
      const $ = this.x < t.x ? t.x : this.x;
      if ((this.right > t.right ? t.right : this.right) <= $)
        return !1;
      const j = this.y < t.y ? t.y : this.y;
      return (this.bottom > t.bottom ? t.bottom : this.bottom) > j;
    }
    const i = this.left, s = this.right, o = this.top, l = this.bottom;
    if (s <= i || l <= o)
      return !1;
    const c = vc[0].set(t.left, t.top), d = vc[1].set(t.left, t.bottom), f = vc[2].set(t.right, t.top), m = vc[3].set(t.right, t.bottom);
    if (f.x <= c.x || d.y <= c.y)
      return !1;
    const y = Math.sign(e.a * e.d - e.b * e.c);
    if (y === 0 || (e.apply(c, c), e.apply(d, d), e.apply(f, f), e.apply(m, m), Math.max(c.x, d.x, f.x, m.x) <= i || Math.min(c.x, d.x, f.x, m.x) >= s || Math.max(c.y, d.y, f.y, m.y) <= o || Math.min(c.y, d.y, f.y, m.y) >= l))
      return !1;
    const b = y * (d.y - c.y), v = y * (c.x - d.x), x = b * i + v * o, S = b * s + v * o, _ = b * i + v * l, C = b * s + v * l;
    if (Math.max(x, S, _, C) <= b * c.x + v * c.y || Math.min(x, S, _, C) >= b * m.x + v * m.y)
      return !1;
    const R = y * (c.y - f.y), w = y * (f.x - c.x), E = R * i + w * o, P = R * s + w * o, k = R * i + w * l, G = R * s + w * l;
    return !(Math.max(E, P, k, G) <= R * c.x + w * c.y || Math.min(E, P, k, G) >= R * m.x + w * m.y);
  }
  /**
   * Pads the rectangle making it grow in all directions.
   *
   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
   * @example
   * ```ts
   * // Basic padding
   * const rect = new Rectangle(100, 100, 200, 150);
   * rect.pad(10); // Adds 10px padding on all sides
   *
   * // Different horizontal and vertical padding
   * const uiRect = new Rectangle(0, 0, 100, 50);
   * uiRect.pad(20, 10); // 20px horizontal, 10px vertical
   * ```
   * @remarks
   * - Adjusts x/y by subtracting padding
   * - Increases width/height by padding * 2
   * - Common in UI layout calculations
   * - Chainable with other methods
   * @param paddingX - The horizontal padding amount
   * @param paddingY - The vertical padding amount
   * @returns Returns itself
   * @see {@link Rectangle.enlarge} For growing to include another rectangle
   * @see {@link Rectangle.fit} For shrinking to fit within another rectangle
   */
  pad(t = 0, e = t) {
    return this.x -= t, this.y -= e, this.width += t * 2, this.height += e * 2, this;
  }
  /**
   * Fits this rectangle around the passed one.
   * @example
   * ```ts
   * // Basic fitting
   * const container = new Rectangle(0, 0, 100, 100);
   * const content = new Rectangle(25, 25, 200, 200);
   * content.fit(container); // Clips to container bounds
   * ```
   * @param rectangle - The rectangle to fit around
   * @returns Returns itself
   * @see {@link Rectangle.enlarge} For growing to include another rectangle
   * @see {@link Rectangle.pad} For adding padding around the rectangle
   */
  fit(t) {
    const e = Math.max(this.x, t.x), i = Math.min(this.x + this.width, t.x + t.width), s = Math.max(this.y, t.y), o = Math.min(this.y + this.height, t.y + t.height);
    return this.x = e, this.width = Math.max(i - e, 0), this.y = s, this.height = Math.max(o - s, 0), this;
  }
  /**
   * Enlarges rectangle so that its corners lie on a grid defined by resolution.
   * @example
   * ```ts
   * // Basic grid alignment
   * const rect = new Rectangle(10.2, 10.6, 100.8, 100.4);
   * rect.ceil(); // Aligns to whole pixels
   *
   * // Custom resolution grid
   * const uiRect = new Rectangle(5.3, 5.7, 50.2, 50.8);
   * uiRect.ceil(0.5); // Aligns to half pixels
   *
   * // Use with precision value
   * const preciseRect = new Rectangle(20.001, 20.999, 100.001, 100.999);
   * preciseRect.ceil(1, 0.01); // Handles small decimal variations
   * ```
   * @param resolution - The grid size to align to (1 = whole pixels)
   * @param eps - Small number to prevent floating point errors
   * @returns Returns itself
   * @see {@link Rectangle.fit} For constraining to bounds
   * @see {@link Rectangle.enlarge} For growing dimensions
   */
  ceil(t = 1, e = 1e-3) {
    const i = Math.ceil((this.x + this.width - e) * t) / t, s = Math.ceil((this.y + this.height - e) * t) / t;
    return this.x = Math.floor((this.x + e) * t) / t, this.y = Math.floor((this.y + e) * t) / t, this.width = i - this.x, this.height = s - this.y, this;
  }
  /**
   * Scales the rectangle's dimensions and position by the specified factors.
   * @example
   * ```ts
   * const rect = new Rectangle(50, 50, 100, 100);
   *
   * // Scale uniformly
   * rect.scale(0.5, 0.5);
   * // rect is now: x=25, y=25, width=50, height=50
   *
   * // non-uniformly
   * rect.scale(0.5, 1);
   * // rect is now: x=25, y=50, width=50, height=100
   * ```
   * @param x - The factor by which to scale the horizontal properties (x, width).
   * @param y - The factor by which to scale the vertical properties (y, height).
   * @returns Returns itself
   */
  scale(t, e = t) {
    return this.x *= t, this.y *= e, this.width *= t, this.height *= e, this;
  }
  /**
   * Enlarges this rectangle to include the passed rectangle.
   * @example
   * ```ts
   * // Basic enlargement
   * const rect = new Rectangle(50, 50, 100, 100);
   * const other = new Rectangle(0, 0, 200, 75);
   * rect.enlarge(other);
   * // rect is now: x=0, y=0, width=200, height=150
   *
   * // Use for bounding box calculation
   * const bounds = new Rectangle();
   * objects.forEach((obj) => {
   *     bounds.enlarge(obj.getBounds());
   * });
   * ```
   * @param rectangle - The rectangle to include
   * @returns Returns itself
   * @see {@link Rectangle.fit} For shrinking to fit within another rectangle
   * @see {@link Rectangle.pad} For adding padding around the rectangle
   */
  enlarge(t) {
    const e = Math.min(this.x, t.x), i = Math.max(this.x + this.width, t.x + t.width), s = Math.min(this.y, t.y), o = Math.max(this.y + this.height, t.y + t.height);
    return this.x = e, this.width = i - e, this.y = s, this.height = o - s, this;
  }
  /**
   * Returns the framing rectangle of the rectangle as a Rectangle object
   * @example
   * ```ts
   * // Basic bounds retrieval
   * const rect = new Rectangle(100, 100, 200, 150);
   * const bounds = rect.getBounds();
   *
   * // Reuse existing rectangle
   * const out = new Rectangle();
   * rect.getBounds(out);
   * ```
   * @param out - Optional rectangle to store the result
   * @returns The framing rectangle
   * @see {@link Rectangle.copyFrom} For direct copying
   * @see {@link Rectangle.clone} For creating new copy
   */
  getBounds(t) {
    return t || (t = new ne()), t.copyFrom(this), t;
  }
  /**
   * Determines whether another Rectangle is fully contained within this Rectangle.
   *
   * Rectangles that occupy the same space are considered to be containing each other.
   *
   * Rectangles without area (width or height equal to zero) can't contain anything,
   * not even other arealess rectangles.
   * @example
   * ```ts
   * // Check if one rectangle contains another
   * const container = new Rectangle(0, 0, 100, 100);
   * const inner = new Rectangle(25, 25, 50, 50);
   *
   * console.log(container.containsRect(inner)); // true
   *
   * // Check overlapping rectangles
   * const partial = new Rectangle(75, 75, 50, 50);
   * console.log(container.containsRect(partial)); // false
   *
   * // Zero-area rectangles
   * const empty = new Rectangle(0, 0, 0, 100);
   * console.log(container.containsRect(empty)); // false
   * ```
   * @param other - The Rectangle to check for containment
   * @returns True if other is fully contained within this Rectangle
   * @see {@link Rectangle.contains} For point containment
   * @see {@link Rectangle.intersects} For overlap testing
   */
  containsRect(t) {
    if (this.width <= 0 || this.height <= 0)
      return !1;
    const e = t.x, i = t.y, s = t.x + t.width, o = t.y + t.height;
    return e >= this.x && e < this.x + this.width && i >= this.y && i < this.y + this.height && s >= this.x && s < this.x + this.width && o >= this.y && o < this.y + this.height;
  }
  /**
   * Sets the position and dimensions of the rectangle.
   * @example
   * ```ts
   * // Basic usage
   * const rect = new Rectangle();
   * rect.set(100, 100, 200, 150);
   *
   * // Chain with other operations
   * const bounds = new Rectangle()
   *     .set(0, 0, 100, 100)
   *     .pad(10);
   * ```
   * @param x - The X coordinate of the upper-left corner of the rectangle
   * @param y - The Y coordinate of the upper-left corner of the rectangle
   * @param width - The overall width of the rectangle
   * @param height - The overall height of the rectangle
   * @returns Returns itself for method chaining
   * @see {@link Rectangle.copyFrom} For copying from another rectangle
   * @see {@link Rectangle.clone} For creating a new copy
   */
  set(t, e, i, s) {
    return this.x = t, this.y = e, this.width = i, this.height = s, this;
  }
  toString() {
    return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
  }
}
const hp = {
  default: -1
};
function Ee(n = "default") {
  return hp[n] === void 0 && (hp[n] = -1), ++hp[n];
}
const a_ = /* @__PURE__ */ new Set(), ae = "8.0.0", NM = "8.3.4", La = {
  quiet: !1,
  noColor: !1
}, zt = (n, t, e = 3) => {
  if (La.quiet || a_.has(t))
    return;
  let i = new Error().stack;
  const s = `${t}
Deprecated since v${n}`, o = typeof console.groupCollapsed == "function" && !La.noColor;
  typeof i > "u" ? console.warn("PixiJS Deprecation Warning: ", s) : (i = i.split(`
`).splice(e).join(`
`), o ? (console.groupCollapsed(
    "%cPixiJS Deprecation Warning: %c%s",
    "color:#614108;background:#fffbe6",
    "font-weight:normal;color:#614108;background:#fffbe6",
    s
  ), console.warn(i), console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", s), console.warn(i))), a_.add(t);
};
Object.defineProperties(zt, {
  quiet: {
    get: () => La.quiet,
    set: (n) => {
      La.quiet = n;
    },
    enumerable: !0,
    configurable: !1
  },
  noColor: {
    get: () => La.noColor,
    set: (n) => {
      La.noColor = n;
    },
    enumerable: !0,
    configurable: !1
  }
});
const qS = () => {
};
function Wa(n) {
  return n += n === 0 ? 1 : 0, --n, n |= n >>> 1, n |= n >>> 2, n |= n >>> 4, n |= n >>> 8, n |= n >>> 16, n + 1;
}
function o_(n) {
  return !(n & n - 1) && !!n;
}
function KS(n) {
  const t = {};
  for (const e in n)
    n[e] !== void 0 && (t[e] = n[e]);
  return t;
}
const l_ = /* @__PURE__ */ Object.create(null);
function IM(n) {
  const t = l_[n];
  return t === void 0 && (l_[n] = Ee("resource")), t;
}
const ZS = class QS extends Jn {
  /**
   * @param options - options for the style
   */
  constructor(t = {}) {
    super(), this._resourceType = "textureSampler", this._touched = 0, this._maxAnisotropy = 1, this.destroyed = !1, t = { ...QS.defaultOptions, ...t }, this.addressMode = t.addressMode, this.addressModeU = t.addressModeU ?? this.addressModeU, this.addressModeV = t.addressModeV ?? this.addressModeV, this.addressModeW = t.addressModeW ?? this.addressModeW, this.scaleMode = t.scaleMode, this.magFilter = t.magFilter ?? this.magFilter, this.minFilter = t.minFilter ?? this.minFilter, this.mipmapFilter = t.mipmapFilter ?? this.mipmapFilter, this.lodMinClamp = t.lodMinClamp, this.lodMaxClamp = t.lodMaxClamp, this.compare = t.compare, this.maxAnisotropy = t.maxAnisotropy ?? 1;
  }
  set addressMode(t) {
    this.addressModeU = t, this.addressModeV = t, this.addressModeW = t;
  }
  /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */
  get addressMode() {
    return this.addressModeU;
  }
  set wrapMode(t) {
    zt(ae, "TextureStyle.wrapMode is now TextureStyle.addressMode"), this.addressMode = t;
  }
  get wrapMode() {
    return this.addressMode;
  }
  set scaleMode(t) {
    this.magFilter = t, this.minFilter = t, this.mipmapFilter = t;
  }
  /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */
  get scaleMode() {
    return this.magFilter;
  }
  /** Specifies the maximum anisotropy value clamp used by the sampler. */
  set maxAnisotropy(t) {
    this._maxAnisotropy = Math.min(t, 16), this._maxAnisotropy > 1 && (this.scaleMode = "linear");
  }
  get maxAnisotropy() {
    return this._maxAnisotropy;
  }
  // TODO - move this to WebGL?
  get _resourceId() {
    return this._sharedResourceId || this._generateResourceId();
  }
  update() {
    this.emit("change", this), this._sharedResourceId = null;
  }
  _generateResourceId() {
    const t = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;
    return this._sharedResourceId = IM(t), this._resourceId;
  }
  /** Destroys the style */
  destroy() {
    this.destroyed = !0, this.emit("destroy", this), this.emit("change", this), this.removeAllListeners();
  }
};
ZS.defaultOptions = {
  addressMode: "clamp-to-edge",
  scaleMode: "linear"
};
let Qr = ZS;
const JS = class t1 extends Jn {
  /**
   * @param options - options for creating a new TextureSource
   */
  constructor(t = {}) {
    super(), this.options = t, this.uid = Ee("textureSource"), this._resourceType = "textureSource", this._resourceId = Ee("resource"), this.uploadMethodId = "unknown", this._resolution = 1, this.pixelWidth = 1, this.pixelHeight = 1, this.width = 1, this.height = 1, this.sampleCount = 1, this.mipLevelCount = 1, this.autoGenerateMipmaps = !1, this.format = "rgba8unorm", this.dimension = "2d", this.antialias = !1, this._touched = 0, this._batchTick = -1, this._textureBindLocation = -1, t = { ...t1.defaultOptions, ...t }, this.label = t.label ?? "", this.resource = t.resource, this.autoGarbageCollect = t.autoGarbageCollect, this._resolution = t.resolution, t.width ? this.pixelWidth = t.width * this._resolution : this.pixelWidth = this.resource ? this.resourceWidth ?? 1 : 1, t.height ? this.pixelHeight = t.height * this._resolution : this.pixelHeight = this.resource ? this.resourceHeight ?? 1 : 1, this.width = this.pixelWidth / this._resolution, this.height = this.pixelHeight / this._resolution, this.format = t.format, this.dimension = t.dimensions, this.mipLevelCount = t.mipLevelCount, this.autoGenerateMipmaps = t.autoGenerateMipmaps, this.sampleCount = t.sampleCount, this.antialias = t.antialias, this.alphaMode = t.alphaMode, this.style = new Qr(KS(t)), this.destroyed = !1, this._refreshPOT();
  }
  /** returns itself */
  get source() {
    return this;
  }
  /** the style of the texture */
  get style() {
    return this._style;
  }
  set style(t) {
    this.style !== t && (this._style?.off("change", this._onStyleChange, this), this._style = t, this._style?.on("change", this._onStyleChange, this), this._onStyleChange());
  }
  /** Specifies the maximum anisotropy value clamp used by the sampler. */
  set maxAnisotropy(t) {
    this._style.maxAnisotropy = t;
  }
  get maxAnisotropy() {
    return this._style.maxAnisotropy;
  }
  /** setting this will set wrapModeU, wrapModeV and wrapModeW all at once! */
  get addressMode() {
    return this._style.addressMode;
  }
  set addressMode(t) {
    this._style.addressMode = t;
  }
  /** setting this will set wrapModeU, wrapModeV and wrapModeW all at once! */
  get repeatMode() {
    return this._style.addressMode;
  }
  set repeatMode(t) {
    this._style.addressMode = t;
  }
  /** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */
  get magFilter() {
    return this._style.magFilter;
  }
  set magFilter(t) {
    this._style.magFilter = t;
  }
  /** Specifies the sampling behavior when the sample footprint is larger than one texel. */
  get minFilter() {
    return this._style.minFilter;
  }
  set minFilter(t) {
    this._style.minFilter = t;
  }
  /** Specifies behavior for sampling between mipmap levels. */
  get mipmapFilter() {
    return this._style.mipmapFilter;
  }
  set mipmapFilter(t) {
    this._style.mipmapFilter = t;
  }
  /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */
  get lodMinClamp() {
    return this._style.lodMinClamp;
  }
  set lodMinClamp(t) {
    this._style.lodMinClamp = t;
  }
  /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */
  get lodMaxClamp() {
    return this._style.lodMaxClamp;
  }
  set lodMaxClamp(t) {
    this._style.lodMaxClamp = t;
  }
  _onStyleChange() {
    this.emit("styleChange", this);
  }
  /** call this if you have modified the texture outside of the constructor */
  update() {
    if (this.resource) {
      const t = this._resolution;
      if (this.resize(this.resourceWidth / t, this.resourceHeight / t))
        return;
    }
    this.emit("update", this);
  }
  /** Destroys this texture source */
  destroy() {
    this.destroyed = !0, this.emit("destroy", this), this.emit("change", this), this._style && (this._style.destroy(), this._style = null), this.uploadMethodId = null, this.resource = null, this.removeAllListeners();
  }
  /**
   * This will unload the Texture source from the GPU. This will free up the GPU memory
   * As soon as it is required fore rendering, it will be re-uploaded.
   */
  unload() {
    this._resourceId = Ee("resource"), this.emit("change", this), this.emit("unload", this);
  }
  /** the width of the resource. This is the REAL pure number, not accounting resolution   */
  get resourceWidth() {
    const { resource: t } = this;
    return t.naturalWidth || t.videoWidth || t.displayWidth || t.width;
  }
  /** the height of the resource. This is the REAL pure number, not accounting resolution */
  get resourceHeight() {
    const { resource: t } = this;
    return t.naturalHeight || t.videoHeight || t.displayHeight || t.height;
  }
  /**
   * the resolution of the texture. Changing this number, will not change the number of pixels in the actual texture
   * but will the size of the texture when rendered.
   *
   * changing the resolution of this texture to 2 for example will make it appear twice as small when rendered (as pixel
   * density will have increased)
   */
  get resolution() {
    return this._resolution;
  }
  set resolution(t) {
    this._resolution !== t && (this._resolution = t, this.width = this.pixelWidth / t, this.height = this.pixelHeight / t);
  }
  /**
   * Resize the texture, this is handy if you want to use the texture as a render texture
   * @param width - the new width of the texture
   * @param height - the new height of the texture
   * @param resolution - the new resolution of the texture
   * @returns - if the texture was resized
   */
  resize(t, e, i) {
    i || (i = this._resolution), t || (t = this.width), e || (e = this.height);
    const s = Math.round(t * i), o = Math.round(e * i);
    return this.width = s / i, this.height = o / i, this._resolution = i, this.pixelWidth === s && this.pixelHeight === o ? !1 : (this._refreshPOT(), this.pixelWidth = s, this.pixelHeight = o, this.emit("resize", this), this._resourceId = Ee("resource"), this.emit("change", this), !0);
  }
  /**
   * Lets the renderer know that this texture has been updated and its mipmaps should be re-generated.
   * This is only important for RenderTexture instances, as standard Texture instances will have their
   * mipmaps generated on upload. You should call this method after you make any change to the texture
   *
   * The reason for this is is can be quite expensive to update mipmaps for a texture. So by default,
   * We want you, the developer to specify when this action should happen.
   *
   * Generally you don't want to have mipmaps generated on Render targets that are changed every frame,
   */
  updateMipmaps() {
    this.autoGenerateMipmaps && this.mipLevelCount > 1 && this.emit("updateMipmaps", this);
  }
  set wrapMode(t) {
    this._style.wrapMode = t;
  }
  get wrapMode() {
    return this._style.wrapMode;
  }
  set scaleMode(t) {
    this._style.scaleMode = t;
  }
  /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */
  get scaleMode() {
    return this._style.scaleMode;
  }
  /**
   * Refresh check for isPowerOfTwo texture based on size
   * @private
   */
  _refreshPOT() {
    this.isPowerOfTwo = o_(this.pixelWidth) && o_(this.pixelHeight);
  }
  static test(t) {
    throw new Error("Unimplemented");
  }
};
JS.defaultOptions = {
  resolution: 1,
  format: "bgra8unorm",
  alphaMode: "premultiply-alpha-on-upload",
  dimensions: "2d",
  mipLevelCount: 1,
  autoGenerateMipmaps: !1,
  sampleCount: 1,
  antialias: !1,
  autoGarbageCollect: !1
};
let rn = JS;
class Zm extends rn {
  constructor(t) {
    const e = t.resource || new Float32Array(t.width * t.height * 4);
    let i = t.format;
    i || (e instanceof Float32Array ? i = "rgba32float" : e instanceof Int32Array || e instanceof Uint32Array ? i = "rgba32uint" : e instanceof Int16Array || e instanceof Uint16Array ? i = "rgba16uint" : (e instanceof Int8Array, i = "bgra8unorm")), super({
      ...t,
      resource: e,
      format: i
    }), this.uploadMethodId = "buffer";
  }
  static test(t) {
    return t instanceof Int8Array || t instanceof Uint8Array || t instanceof Uint8ClampedArray || t instanceof Int16Array || t instanceof Uint16Array || t instanceof Int32Array || t instanceof Uint32Array || t instanceof Float32Array;
  }
}
Zm.extension = W.TextureSource;
const u_ = new bt();
class e1 {
  /**
   * @param texture - observed texture
   * @param clampMargin - Changes frame clamping, 0.5 by default. Use -0.5 for extra border.
   */
  constructor(t, e) {
    this.mapCoord = new bt(), this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, typeof e > "u" ? this.clampMargin = t.width < 10 ? 0 : 0.5 : this.clampMargin = e, this.isSimple = !1, this.texture = t;
  }
  /** Texture property. */
  get texture() {
    return this._texture;
  }
  set texture(t) {
    this.texture !== t && (this._texture?.removeListener("update", this.update, this), this._texture = t, this._texture.addListener("update", this.update, this), this.update());
  }
  /**
   * Multiplies uvs array to transform
   * @param uvs - mesh uvs
   * @param [out=uvs] - output
   * @returns - output
   */
  multiplyUvs(t, e) {
    e === void 0 && (e = t);
    const i = this.mapCoord;
    for (let s = 0; s < t.length; s += 2) {
      const o = t[s], l = t[s + 1];
      e[s] = o * i.a + l * i.c + i.tx, e[s + 1] = o * i.b + l * i.d + i.ty;
    }
    return e;
  }
  /**
   * Updates matrices if texture was changed
   * @returns - whether or not it was updated
   */
  update() {
    const t = this._texture;
    this._updateID++;
    const e = t.uvs;
    this.mapCoord.set(e.x1 - e.x0, e.y1 - e.y0, e.x3 - e.x0, e.y3 - e.y0, e.x0, e.y0);
    const i = t.orig, s = t.trim;
    s && (u_.set(
      i.width / s.width,
      0,
      0,
      i.height / s.height,
      -s.x / s.width,
      -s.y / s.height
    ), this.mapCoord.append(u_));
    const o = t.source, l = this.uClampFrame, c = this.clampMargin / o._resolution, d = this.clampOffset / o._resolution;
    return l[0] = (t.frame.x + c + d) / o.width, l[1] = (t.frame.y + c + d) / o.height, l[2] = (t.frame.x + t.frame.width - c + d) / o.width, l[3] = (t.frame.y + t.frame.height - c + d) / o.height, this.uClampOffset[0] = this.clampOffset / o.pixelWidth, this.uClampOffset[1] = this.clampOffset / o.pixelHeight, this.isSimple = t.frame.width === o.width && t.frame.height === o.height && t.rotate === 0, !0;
  }
}
class Tt extends Jn {
  /**
   * @param {TextureOptions} options - Options for the texture
   */
  constructor({
    source: t,
    label: e,
    frame: i,
    orig: s,
    trim: o,
    defaultAnchor: l,
    defaultBorders: c,
    rotate: d,
    dynamic: f
  } = {}) {
    if (super(), this.uid = Ee("texture"), this.uvs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 }, this.frame = new ne(), this.noFrame = !1, this.dynamic = !1, this.isTexture = !0, this.label = e, this.source = t?.source ?? new rn(), this.noFrame = !i, i)
      this.frame.copyFrom(i);
    else {
      const { width: m, height: y } = this._source;
      this.frame.width = m, this.frame.height = y;
    }
    this.orig = s || this.frame, this.trim = o, this.rotate = d ?? 0, this.defaultAnchor = l, this.defaultBorders = c, this.destroyed = !1, this.dynamic = f || !1, this.updateUvs();
  }
  set source(t) {
    this._source && this._source.off("resize", this.update, this), this._source = t, t.on("resize", this.update, this), this.emit("update", this);
  }
  /** the underlying source of the texture (equivalent of baseTexture in v7) */
  get source() {
    return this._source;
  }
  /** returns a TextureMatrix instance for this texture. By default, that object is not created because its heavy. */
  get textureMatrix() {
    return this._textureMatrix || (this._textureMatrix = new e1(this)), this._textureMatrix;
  }
  /** The width of the Texture in pixels. */
  get width() {
    return this.orig.width;
  }
  /** The height of the Texture in pixels. */
  get height() {
    return this.orig.height;
  }
  /** Call this function when you have modified the frame of this texture. */
  updateUvs() {
    const { uvs: t, frame: e } = this, { width: i, height: s } = this._source, o = e.x / i, l = e.y / s, c = e.width / i, d = e.height / s;
    let f = this.rotate;
    if (f) {
      const m = c / 2, y = d / 2, b = o + m, v = l + y;
      f = Se.add(f, Se.NW), t.x0 = b + m * Se.uX(f), t.y0 = v + y * Se.uY(f), f = Se.add(f, 2), t.x1 = b + m * Se.uX(f), t.y1 = v + y * Se.uY(f), f = Se.add(f, 2), t.x2 = b + m * Se.uX(f), t.y2 = v + y * Se.uY(f), f = Se.add(f, 2), t.x3 = b + m * Se.uX(f), t.y3 = v + y * Se.uY(f);
    } else
      t.x0 = o, t.y0 = l, t.x1 = o + c, t.y1 = l, t.x2 = o + c, t.y2 = l + d, t.x3 = o, t.y3 = l + d;
  }
  /**
   * Destroys this texture
   * @param destroySource - Destroy the source when the texture is destroyed.
   */
  destroy(t = !1) {
    this._source && t && (this._source.destroy(), this._source = null), this._textureMatrix = null, this.destroyed = !0, this.emit("destroy", this), this.removeAllListeners();
  }
  /**
   * Call this if you have modified the `texture outside` of the constructor.
   *
   * If you have modified this texture's source, you must separately call `texture.source.update()` to see those changes.
   */
  update() {
    this.noFrame && (this.frame.width = this._source.width, this.frame.height = this._source.height), this.updateUvs(), this.emit("update", this);
  }
  /** @deprecated since 8.0.0 */
  get baseTexture() {
    return zt(ae, "Texture.baseTexture is now Texture.source"), this._source;
  }
}
Tt.EMPTY = new Tt({
  label: "EMPTY",
  source: new rn({
    label: "EMPTY"
  })
});
Tt.EMPTY.destroy = qS;
Tt.WHITE = new Tt({
  source: new Zm({
    resource: new Uint8Array([255, 255, 255, 255]),
    width: 1,
    height: 1,
    alphaMode: "premultiply-alpha-on-upload",
    label: "WHITE"
  }),
  label: "WHITE"
});
Tt.WHITE.destroy = qS;
function n1(n, t, e) {
  const { width: i, height: s } = e.orig, o = e.trim;
  if (o) {
    const l = o.width, c = o.height;
    n.minX = o.x - t._x * i, n.maxX = n.minX + l, n.minY = o.y - t._y * s, n.maxY = n.minY + c;
  } else
    n.minX = -t._x * i, n.maxX = n.minX + i, n.minY = -t._y * s, n.maxY = n.minY + s;
}
const c_ = new bt();
class Cn {
  /**
   * Creates a new Bounds object.
   * @param minX - The minimum X coordinate of the bounds.
   * @param minY - The minimum Y coordinate of the bounds.
   * @param maxX - The maximum X coordinate of the bounds.
   * @param maxY - The maximum Y coordinate of the bounds.
   */
  constructor(t = 1 / 0, e = 1 / 0, i = -1 / 0, s = -1 / 0) {
    this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.matrix = c_, this.minX = t, this.minY = e, this.maxX = i, this.maxY = s;
  }
  /**
   * Checks if bounds are empty, meaning either width or height is zero or negative.
   * Empty bounds occur when min values exceed max values on either axis.
   * @example
   * ```ts
   * const bounds = new Bounds();
   *
   * // Check if newly created bounds are empty
   * console.log(bounds.isEmpty()); // true, default bounds are empty
   *
   * // Add frame and check again
   * bounds.addFrame(0, 0, 100, 100);
   * console.log(bounds.isEmpty()); // false, bounds now have area
   *
   * // Clear bounds
   * bounds.clear();
   * console.log(bounds.isEmpty()); // true, bounds are empty again
   * ```
   * @returns True if bounds are empty (have no area)
   * @see {@link Bounds#clear} For resetting bounds
   * @see {@link Bounds#isValid} For checking validity
   */
  isEmpty() {
    return this.minX > this.maxX || this.minY > this.maxY;
  }
  /**
   * The bounding rectangle representation of these bounds.
   * Lazily creates and updates a Rectangle instance based on the current bounds.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   *
   * // Get rectangle representation
   * const rect = bounds.rectangle;
   * console.log(rect.x, rect.y, rect.width, rect.height);
   *
   * // Use for hit testing
   * if (bounds.rectangle.contains(mouseX, mouseY)) {
   *     console.log('Mouse is inside bounds!');
   * }
   * ```
   * @see {@link Rectangle} For rectangle methods
   * @see {@link Bounds.isEmpty} For bounds validation
   */
  get rectangle() {
    this._rectangle || (this._rectangle = new ne());
    const t = this._rectangle;
    return this.minX > this.maxX || this.minY > this.maxY ? (t.x = 0, t.y = 0, t.width = 0, t.height = 0) : t.copyFromBounds(this), t;
  }
  /**
   * Clears the bounds and resets all coordinates to their default values.
   * Resets the transformation matrix back to identity.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * console.log(bounds.isEmpty()); // false
   * // Clear the bounds
   * bounds.clear();
   * console.log(bounds.isEmpty()); // true
   * ```
   * @returns This bounds object for chaining
   */
  clear() {
    return this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.matrix = c_, this;
  }
  /**
   * Sets the bounds directly using coordinate values.
   * Provides a way to set all bounds values at once.
   * @example
   * ```ts
   * const bounds = new Bounds();
   * bounds.set(0, 0, 100, 100);
   * ```
   * @param x0 - Left X coordinate of frame
   * @param y0 - Top Y coordinate of frame
   * @param x1 - Right X coordinate of frame
   * @param y1 - Bottom Y coordinate of frame
   * @see {@link Bounds#addFrame} For matrix-aware bounds setting
   * @see {@link Bounds#clear} For resetting bounds
   */
  set(t, e, i, s) {
    this.minX = t, this.minY = e, this.maxX = i, this.maxY = s;
  }
  /**
   * Adds a rectangular frame to the bounds, optionally transformed by a matrix.
   * Updates the bounds to encompass the new frame coordinates.
   * @example
   * ```ts
   * const bounds = new Bounds();
   * bounds.addFrame(0, 0, 100, 100);
   *
   * // Add transformed frame
   * const matrix = new Matrix()
   *     .translate(50, 50)
   *     .rotate(Math.PI / 4);
   * bounds.addFrame(0, 0, 100, 100, matrix);
   * ```
   * @param x0 - Left X coordinate of frame
   * @param y0 - Top Y coordinate of frame
   * @param x1 - Right X coordinate of frame
   * @param y1 - Bottom Y coordinate of frame
   * @param matrix - Optional transformation matrix
   * @see {@link Bounds#addRect} For adding Rectangle objects
   * @see {@link Bounds#addBounds} For adding other Bounds
   */
  addFrame(t, e, i, s, o) {
    o || (o = this.matrix);
    const l = o.a, c = o.b, d = o.c, f = o.d, m = o.tx, y = o.ty;
    let b = this.minX, v = this.minY, x = this.maxX, S = this.maxY, _ = l * t + d * e + m, C = c * t + f * e + y;
    _ < b && (b = _), C < v && (v = C), _ > x && (x = _), C > S && (S = C), _ = l * i + d * e + m, C = c * i + f * e + y, _ < b && (b = _), C < v && (v = C), _ > x && (x = _), C > S && (S = C), _ = l * t + d * s + m, C = c * t + f * s + y, _ < b && (b = _), C < v && (v = C), _ > x && (x = _), C > S && (S = C), _ = l * i + d * s + m, C = c * i + f * s + y, _ < b && (b = _), C < v && (v = C), _ > x && (x = _), C > S && (S = C), this.minX = b, this.minY = v, this.maxX = x, this.maxY = S;
  }
  /**
   * Adds a rectangle to the bounds, optionally transformed by a matrix.
   * Updates the bounds to encompass the given rectangle.
   * @example
   * ```ts
   * const bounds = new Bounds();
   * // Add simple rectangle
   * const rect = new Rectangle(0, 0, 100, 100);
   * bounds.addRect(rect);
   *
   * // Add transformed rectangle
   * const matrix = new Matrix()
   *     .translate(50, 50)
   *     .rotate(Math.PI / 4);
   * bounds.addRect(rect, matrix);
   * ```
   * @param rect - The rectangle to be added
   * @param matrix - Optional transformation matrix
   * @see {@link Bounds#addFrame} For adding raw coordinates
   * @see {@link Bounds#addBounds} For adding other bounds
   */
  addRect(t, e) {
    this.addFrame(t.x, t.y, t.x + t.width, t.y + t.height, e);
  }
  /**
   * Adds another bounds object to this one, optionally transformed by a matrix.
   * Expands the bounds to include the given bounds' area.
   * @example
   * ```ts
   * const bounds = new Bounds();
   *
   * // Add child bounds
   * const childBounds = sprite.getBounds();
   * bounds.addBounds(childBounds);
   *
   * // Add transformed bounds
   * const matrix = new Matrix()
   *     .scale(2, 2);
   * bounds.addBounds(childBounds, matrix);
   * ```
   * @param bounds - The bounds to be added
   * @param matrix - Optional transformation matrix
   * @see {@link Bounds#addFrame} For adding raw coordinates
   * @see {@link Bounds#addRect} For adding rectangles
   */
  addBounds(t, e) {
    this.addFrame(t.minX, t.minY, t.maxX, t.maxY, e);
  }
  /**
   * Adds other Bounds as a mask, creating an intersection of the two bounds.
   * Only keeps the overlapping region between current bounds and mask bounds.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * // Create mask bounds
   * const mask = new Bounds();
   * mask.addFrame(50, 50, 150, 150);
   * // Apply mask - results in bounds of (50,50,100,100)
   * bounds.addBoundsMask(mask);
   * ```
   * @param mask - The Bounds to use as a mask
   * @see {@link Bounds#addBounds} For union operation
   * @see {@link Bounds#fit} For fitting to rectangle
   */
  addBoundsMask(t) {
    this.minX = this.minX > t.minX ? this.minX : t.minX, this.minY = this.minY > t.minY ? this.minY : t.minY, this.maxX = this.maxX < t.maxX ? this.maxX : t.maxX, this.maxY = this.maxY < t.maxY ? this.maxY : t.maxY;
  }
  /**
   * Applies a transformation matrix to the bounds, updating its coordinates.
   * Transforms all corners of the bounds using the given matrix.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * // Apply translation
   * const translateMatrix = new Matrix()
   *     .translate(50, 50);
   * bounds.applyMatrix(translateMatrix);
   * ```
   * @param matrix - The matrix to apply to the bounds
   * @see {@link Matrix} For matrix operations
   * @see {@link Bounds#addFrame} For adding transformed frames
   */
  applyMatrix(t) {
    const e = this.minX, i = this.minY, s = this.maxX, o = this.maxY, { a: l, b: c, c: d, d: f, tx: m, ty: y } = t;
    let b = l * e + d * i + m, v = c * e + f * i + y;
    this.minX = b, this.minY = v, this.maxX = b, this.maxY = v, b = l * s + d * i + m, v = c * s + f * i + y, this.minX = b < this.minX ? b : this.minX, this.minY = v < this.minY ? v : this.minY, this.maxX = b > this.maxX ? b : this.maxX, this.maxY = v > this.maxY ? v : this.maxY, b = l * e + d * o + m, v = c * e + f * o + y, this.minX = b < this.minX ? b : this.minX, this.minY = v < this.minY ? v : this.minY, this.maxX = b > this.maxX ? b : this.maxX, this.maxY = v > this.maxY ? v : this.maxY, b = l * s + d * o + m, v = c * s + f * o + y, this.minX = b < this.minX ? b : this.minX, this.minY = v < this.minY ? v : this.minY, this.maxX = b > this.maxX ? b : this.maxX, this.maxY = v > this.maxY ? v : this.maxY;
  }
  /**
   * Resizes the bounds object to fit within the given rectangle.
   * Clips the bounds if they extend beyond the rectangle's edges.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 200, 200);
   * // Fit within viewport
   * const viewport = new Rectangle(50, 50, 100, 100);
   * bounds.fit(viewport);
   * // bounds are now (50, 50, 150, 150)
   * ```
   * @param rect - The rectangle to fit within
   * @returns This bounds object for chaining
   * @see {@link Bounds#addBoundsMask} For intersection
   * @see {@link Bounds#pad} For expanding bounds
   */
  fit(t) {
    return this.minX < t.left && (this.minX = t.left), this.maxX > t.right && (this.maxX = t.right), this.minY < t.top && (this.minY = t.top), this.maxY > t.bottom && (this.maxY = t.bottom), this;
  }
  /**
   * Resizes the bounds object to include the given bounds.
   * Similar to fit() but works with raw coordinate values instead of a Rectangle.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 200, 200);
   * // Fit to specific coordinates
   * bounds.fitBounds(50, 150, 50, 150);
   * // bounds are now (50, 50, 150, 150)
   * ```
   * @param left - The left value of the bounds
   * @param right - The right value of the bounds
   * @param top - The top value of the bounds
   * @param bottom - The bottom value of the bounds
   * @returns This bounds object for chaining
   * @see {@link Bounds#fit} For fitting to Rectangle
   * @see {@link Bounds#addBoundsMask} For intersection
   */
  fitBounds(t, e, i, s) {
    return this.minX < t && (this.minX = t), this.maxX > e && (this.maxX = e), this.minY < i && (this.minY = i), this.maxY > s && (this.maxY = s), this;
  }
  /**
   * Pads bounds object, making it grow in all directions.
   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   *
   * // Add equal padding
   * bounds.pad(10);
   * // bounds are now (-10, -10, 110, 110)
   *
   * // Add different padding for x and y
   * bounds.pad(20, 10);
   * // bounds are now (-30, -20, 130, 120)
   * ```
   * @param paddingX - The horizontal padding amount
   * @param paddingY - The vertical padding amount
   * @returns This bounds object for chaining
   * @see {@link Bounds#fit} For constraining bounds
   * @see {@link Bounds#scale} For uniform scaling
   */
  pad(t, e = t) {
    return this.minX -= t, this.maxX += t, this.minY -= e, this.maxY += e, this;
  }
  /**
   * Ceils the bounds by rounding up max values and rounding down min values.
   * Useful for pixel-perfect calculations and avoiding fractional pixels.
   * @example
   * ```ts
   * const bounds = new Bounds();
   * bounds.set(10.2, 10.9, 50.1, 50.8);
   *
   * // Round to whole pixels
   * bounds.ceil();
   * // bounds are now (10, 10, 51, 51)
   * ```
   * @returns This bounds object for chaining
   * @see {@link Bounds#scale} For size adjustments
   * @see {@link Bounds#fit} For constraining bounds
   */
  ceil() {
    return this.minX = Math.floor(this.minX), this.minY = Math.floor(this.minY), this.maxX = Math.ceil(this.maxX), this.maxY = Math.ceil(this.maxY), this;
  }
  /**
   * Creates a new Bounds instance with the same values.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   *
   * // Create a copy
   * const copy = bounds.clone();
   *
   * // Original and copy are independent
   * bounds.pad(10);
   * console.log(copy.width === bounds.width); // false
   * ```
   * @returns A new Bounds instance with the same values
   * @see {@link Bounds#copyFrom} For reusing existing bounds
   */
  clone() {
    return new Cn(this.minX, this.minY, this.maxX, this.maxY);
  }
  /**
   * Scales the bounds by the given values, adjusting all edges proportionally.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   *
   * // Scale uniformly
   * bounds.scale(2);
   * // bounds are now (0, 0, 200, 200)
   *
   * // Scale non-uniformly
   * bounds.scale(0.5, 2);
   * // bounds are now (0, 0, 100, 400)
   * ```
   * @param x - The X value to scale by
   * @param y - The Y value to scale by (defaults to x)
   * @returns This bounds object for chaining
   * @see {@link Bounds#pad} For adding padding
   * @see {@link Bounds#fit} For constraining size
   */
  scale(t, e = t) {
    return this.minX *= t, this.minY *= e, this.maxX *= t, this.maxY *= e, this;
  }
  /**
   * The x position of the bounds in local space.
   * Setting this value will move the bounds while maintaining its width.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * // Get x position
   * console.log(bounds.x); // 0
   *
   * // Move bounds horizontally
   * bounds.x = 50;
   * console.log(bounds.minX, bounds.maxX); // 50, 150
   *
   * // Width stays the same
   * console.log(bounds.width); // Still 100
   * ```
   */
  get x() {
    return this.minX;
  }
  set x(t) {
    const e = this.maxX - this.minX;
    this.minX = t, this.maxX = t + e;
  }
  /**
   * The y position of the bounds in local space.
   * Setting this value will move the bounds while maintaining its height.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * // Get y position
   * console.log(bounds.y); // 0
   *
   * // Move bounds vertically
   * bounds.y = 50;
   * console.log(bounds.minY, bounds.maxY); // 50, 150
   *
   * // Height stays the same
   * console.log(bounds.height); // Still 100
   * ```
   */
  get y() {
    return this.minY;
  }
  set y(t) {
    const e = this.maxY - this.minY;
    this.minY = t, this.maxY = t + e;
  }
  /**
   * The width value of the bounds.
   * Represents the distance between minX and maxX coordinates.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * // Get width
   * console.log(bounds.width); // 100
   * // Resize width
   * bounds.width = 200;
   * console.log(bounds.maxX - bounds.minX); // 200
   * ```
   */
  get width() {
    return this.maxX - this.minX;
  }
  set width(t) {
    this.maxX = this.minX + t;
  }
  /**
   * The height value of the bounds.
   * Represents the distance between minY and maxY coordinates.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * // Get height
   * console.log(bounds.height); // 100
   * // Resize height
   * bounds.height = 150;
   * console.log(bounds.maxY - bounds.minY); // 150
   * ```
   */
  get height() {
    return this.maxY - this.minY;
  }
  set height(t) {
    this.maxY = this.minY + t;
  }
  /**
   * The left edge coordinate of the bounds.
   * Alias for minX.
   * @example
   * ```ts
   * const bounds = new Bounds(50, 0, 150, 100);
   * console.log(bounds.left); // 50
   * console.log(bounds.left === bounds.minX); // true
   * ```
   * @readonly
   */
  get left() {
    return this.minX;
  }
  /**
   * The right edge coordinate of the bounds.
   * Alias for maxX.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * console.log(bounds.right); // 100
   * console.log(bounds.right === bounds.maxX); // true
   * ```
   * @readonly
   */
  get right() {
    return this.maxX;
  }
  /**
   * The top edge coordinate of the bounds.
   * Alias for minY.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 25, 100, 125);
   * console.log(bounds.top); // 25
   * console.log(bounds.top === bounds.minY); // true
   * ```
   * @readonly
   */
  get top() {
    return this.minY;
  }
  /**
   * The bottom edge coordinate of the bounds.
   * Alias for maxY.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 200);
   * console.log(bounds.bottom); // 200
   * console.log(bounds.bottom === bounds.maxY); // true
   * ```
   * @readonly
   */
  get bottom() {
    return this.maxY;
  }
  /**
   * Whether the bounds has positive width and height.
   * Checks if both dimensions are greater than zero.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * // Check if bounds are positive
   * console.log(bounds.isPositive); // true
   *
   * // Negative bounds
   * bounds.maxX = bounds.minX;
   * console.log(bounds.isPositive); // false, width is 0
   * ```
   * @readonly
   * @see {@link Bounds#isEmpty} For checking empty state
   * @see {@link Bounds#isValid} For checking validity
   */
  get isPositive() {
    return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;
  }
  /**
   * Whether the bounds has valid coordinates.
   * Checks if the bounds has been initialized with real values.
   * @example
   * ```ts
   * const bounds = new Bounds();
   * console.log(bounds.isValid); // false, default state
   *
   * // Set valid bounds
   * bounds.addFrame(0, 0, 100, 100);
   * console.log(bounds.isValid); // true
   * ```
   * @readonly
   * @see {@link Bounds#isEmpty} For checking empty state
   * @see {@link Bounds#isPositive} For checking dimensions
   */
  get isValid() {
    return this.minX + this.minY !== 1 / 0;
  }
  /**
   * Adds vertices from a Float32Array to the bounds, optionally transformed by a matrix.
   * Used for efficiently updating bounds from raw vertex data.
   * @example
   * ```ts
   * const bounds = new Bounds();
   *
   * // Add vertices from geometry
   * const vertices = new Float32Array([
   *     0, 0,    // Vertex 1
   *     100, 0,  // Vertex 2
   *     100, 100 // Vertex 3
   * ]);
   * bounds.addVertexData(vertices, 0, 6);
   *
   * // Add transformed vertices
   * const matrix = new Matrix()
   *     .translate(50, 50)
   *     .rotate(Math.PI / 4);
   * bounds.addVertexData(vertices, 0, 6, matrix);
   *
   * // Add subset of vertices
   * bounds.addVertexData(vertices, 2, 4); // Only second vertex
   * ```
   * @param vertexData - The array of vertices to add
   * @param beginOffset - Starting index in the vertex array
   * @param endOffset - Ending index in the vertex array (excluded)
   * @param matrix - Optional transformation matrix
   * @see {@link Bounds#addFrame} For adding rectangular frames
   * @see {@link Matrix} For transformation details
   */
  addVertexData(t, e, i, s) {
    let o = this.minX, l = this.minY, c = this.maxX, d = this.maxY;
    s || (s = this.matrix);
    const f = s.a, m = s.b, y = s.c, b = s.d, v = s.tx, x = s.ty;
    for (let S = e; S < i; S += 2) {
      const _ = t[S], C = t[S + 1], R = f * _ + y * C + v, w = m * _ + b * C + x;
      o = R < o ? R : o, l = w < l ? w : l, c = R > c ? R : c, d = w > d ? w : d;
    }
    this.minX = o, this.minY = l, this.maxX = c, this.maxY = d;
  }
  /**
   * Checks if a point is contained within the bounds.
   * Returns true if the point's coordinates fall within the bounds' area.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * // Basic point check
   * console.log(bounds.containsPoint(50, 50)); // true
   * console.log(bounds.containsPoint(150, 150)); // false
   *
   * // Check edges
   * console.log(bounds.containsPoint(0, 0));   // true, includes edges
   * console.log(bounds.containsPoint(100, 100)); // true, includes edges
   * ```
   * @param x - x coordinate to check
   * @param y - y coordinate to check
   * @returns True if the point is inside the bounds
   * @see {@link Bounds#isPositive} For valid bounds check
   * @see {@link Bounds#rectangle} For Rectangle representation
   */
  containsPoint(t, e) {
    return this.minX <= t && this.minY <= e && this.maxX >= t && this.maxY >= e;
  }
  /**
   * Returns a string representation of the bounds.
   * Useful for debugging and logging bounds information.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * console.log(bounds.toString()); // "[pixi.js:Bounds minX=0 minY=0 maxX=100 maxY=100 width=100 height=100]"
   * ```
   * @returns A string describing the bounds
   * @see {@link Bounds#copyFrom} For copying bounds
   * @see {@link Bounds#clone} For creating a new instance
   */
  toString() {
    return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;
  }
  /**
   * Copies the bounds from another bounds object.
   * Useful for reusing bounds objects and avoiding allocations.
   * @example
   * ```ts
   * const sourceBounds = new Bounds(0, 0, 100, 100);
   * // Copy bounds
   * const targetBounds = new Bounds();
   * targetBounds.copyFrom(sourceBounds);
   * ```
   * @param bounds - The bounds to copy from
   * @returns This bounds object for chaining
   * @see {@link Bounds#clone} For creating new instances
   */
  copyFrom(t) {
    return this.minX = t.minX, this.minY = t.minY, this.maxX = t.maxX, this.maxY = t.maxY, this;
  }
}
var zM = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) }, or = function(n) {
  return typeof n == "string" ? n.length > 0 : typeof n == "number";
}, hn = function(n, t, e) {
  return t === void 0 && (t = 0), e === void 0 && (e = Math.pow(10, t)), Math.round(e * n) / e + 0;
}, hi = function(n, t, e) {
  return t === void 0 && (t = 0), e === void 0 && (e = 1), n > e ? e : n > t ? n : t;
}, i1 = function(n) {
  return (n = isFinite(n) ? n % 360 : 0) > 0 ? n : n + 360;
}, h_ = function(n) {
  return { r: hi(n.r, 0, 255), g: hi(n.g, 0, 255), b: hi(n.b, 0, 255), a: hi(n.a) };
}, dp = function(n) {
  return { r: hn(n.r), g: hn(n.g), b: hn(n.b), a: hn(n.a, 3) };
}, LM = /^#([0-9a-f]{3,8})$/i, xc = function(n) {
  var t = n.toString(16);
  return t.length < 2 ? "0" + t : t;
}, r1 = function(n) {
  var t = n.r, e = n.g, i = n.b, s = n.a, o = Math.max(t, e, i), l = o - Math.min(t, e, i), c = l ? o === t ? (e - i) / l : o === e ? 2 + (i - t) / l : 4 + (t - e) / l : 0;
  return { h: 60 * (c < 0 ? c + 6 : c), s: o ? l / o * 100 : 0, v: o / 255 * 100, a: s };
}, s1 = function(n) {
  var t = n.h, e = n.s, i = n.v, s = n.a;
  t = t / 360 * 6, e /= 100, i /= 100;
  var o = Math.floor(t), l = i * (1 - e), c = i * (1 - (t - o) * e), d = i * (1 - (1 - t + o) * e), f = o % 6;
  return { r: 255 * [i, c, l, l, d, i][f], g: 255 * [d, i, i, c, l, l][f], b: 255 * [l, l, d, i, i, c][f], a: s };
}, d_ = function(n) {
  return { h: i1(n.h), s: hi(n.s, 0, 100), l: hi(n.l, 0, 100), a: hi(n.a) };
}, f_ = function(n) {
  return { h: hn(n.h), s: hn(n.s), l: hn(n.l), a: hn(n.a, 3) };
}, p_ = function(n) {
  return s1((e = (t = n).s, { h: t.h, s: (e *= ((i = t.l) < 50 ? i : 100 - i) / 100) > 0 ? 2 * e / (i + e) * 100 : 0, v: i + e, a: t.a }));
  var t, e, i;
}, wl = function(n) {
  return { h: (t = r1(n)).h, s: (s = (200 - (e = t.s)) * (i = t.v) / 100) > 0 && s < 200 ? e * i / 100 / (s <= 100 ? s : 200 - s) * 100 : 0, l: s / 2, a: t.a };
  var t, e, i, s;
}, FM = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, HM = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, $M = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, WM = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, um = { string: [[function(n) {
  var t = LM.exec(n);
  return t ? (n = t[1]).length <= 4 ? { r: parseInt(n[0] + n[0], 16), g: parseInt(n[1] + n[1], 16), b: parseInt(n[2] + n[2], 16), a: n.length === 4 ? hn(parseInt(n[3] + n[3], 16) / 255, 2) : 1 } : n.length === 6 || n.length === 8 ? { r: parseInt(n.substr(0, 2), 16), g: parseInt(n.substr(2, 2), 16), b: parseInt(n.substr(4, 2), 16), a: n.length === 8 ? hn(parseInt(n.substr(6, 2), 16) / 255, 2) : 1 } : null : null;
}, "hex"], [function(n) {
  var t = $M.exec(n) || WM.exec(n);
  return t ? t[2] !== t[4] || t[4] !== t[6] ? null : h_({ r: Number(t[1]) / (t[2] ? 100 / 255 : 1), g: Number(t[3]) / (t[4] ? 100 / 255 : 1), b: Number(t[5]) / (t[6] ? 100 / 255 : 1), a: t[7] === void 0 ? 1 : Number(t[7]) / (t[8] ? 100 : 1) }) : null;
}, "rgb"], [function(n) {
  var t = FM.exec(n) || HM.exec(n);
  if (!t) return null;
  var e, i, s = d_({ h: (e = t[1], i = t[2], i === void 0 && (i = "deg"), Number(e) * (zM[i] || 1)), s: Number(t[3]), l: Number(t[4]), a: t[5] === void 0 ? 1 : Number(t[5]) / (t[6] ? 100 : 1) });
  return p_(s);
}, "hsl"]], object: [[function(n) {
  var t = n.r, e = n.g, i = n.b, s = n.a, o = s === void 0 ? 1 : s;
  return or(t) && or(e) && or(i) ? h_({ r: Number(t), g: Number(e), b: Number(i), a: Number(o) }) : null;
}, "rgb"], [function(n) {
  var t = n.h, e = n.s, i = n.l, s = n.a, o = s === void 0 ? 1 : s;
  if (!or(t) || !or(e) || !or(i)) return null;
  var l = d_({ h: Number(t), s: Number(e), l: Number(i), a: Number(o) });
  return p_(l);
}, "hsl"], [function(n) {
  var t = n.h, e = n.s, i = n.v, s = n.a, o = s === void 0 ? 1 : s;
  if (!or(t) || !or(e) || !or(i)) return null;
  var l = (function(c) {
    return { h: i1(c.h), s: hi(c.s, 0, 100), v: hi(c.v, 0, 100), a: hi(c.a) };
  })({ h: Number(t), s: Number(e), v: Number(i), a: Number(o) });
  return s1(l);
}, "hsv"]] }, m_ = function(n, t) {
  for (var e = 0; e < t.length; e++) {
    var i = t[e][0](n);
    if (i) return [i, t[e][1]];
  }
  return [null, void 0];
}, VM = function(n) {
  return typeof n == "string" ? m_(n.trim(), um.string) : typeof n == "object" && n !== null ? m_(n, um.object) : [null, void 0];
}, fp = function(n, t) {
  var e = wl(n);
  return { h: e.h, s: hi(e.s + 100 * t, 0, 100), l: e.l, a: e.a };
}, pp = function(n) {
  return (299 * n.r + 587 * n.g + 114 * n.b) / 1e3 / 255;
}, g_ = function(n, t) {
  var e = wl(n);
  return { h: e.h, s: e.s, l: hi(e.l + 100 * t, 0, 100), a: e.a };
}, cm = (function() {
  function n(t) {
    this.parsed = VM(t)[0], this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 };
  }
  return n.prototype.isValid = function() {
    return this.parsed !== null;
  }, n.prototype.brightness = function() {
    return hn(pp(this.rgba), 2);
  }, n.prototype.isDark = function() {
    return pp(this.rgba) < 0.5;
  }, n.prototype.isLight = function() {
    return pp(this.rgba) >= 0.5;
  }, n.prototype.toHex = function() {
    return t = dp(this.rgba), e = t.r, i = t.g, s = t.b, l = (o = t.a) < 1 ? xc(hn(255 * o)) : "", "#" + xc(e) + xc(i) + xc(s) + l;
    var t, e, i, s, o, l;
  }, n.prototype.toRgb = function() {
    return dp(this.rgba);
  }, n.prototype.toRgbString = function() {
    return t = dp(this.rgba), e = t.r, i = t.g, s = t.b, (o = t.a) < 1 ? "rgba(" + e + ", " + i + ", " + s + ", " + o + ")" : "rgb(" + e + ", " + i + ", " + s + ")";
    var t, e, i, s, o;
  }, n.prototype.toHsl = function() {
    return f_(wl(this.rgba));
  }, n.prototype.toHslString = function() {
    return t = f_(wl(this.rgba)), e = t.h, i = t.s, s = t.l, (o = t.a) < 1 ? "hsla(" + e + ", " + i + "%, " + s + "%, " + o + ")" : "hsl(" + e + ", " + i + "%, " + s + "%)";
    var t, e, i, s, o;
  }, n.prototype.toHsv = function() {
    return t = r1(this.rgba), { h: hn(t.h), s: hn(t.s), v: hn(t.v), a: hn(t.a, 3) };
    var t;
  }, n.prototype.invert = function() {
    return Ui({ r: 255 - (t = this.rgba).r, g: 255 - t.g, b: 255 - t.b, a: t.a });
    var t;
  }, n.prototype.saturate = function(t) {
    return t === void 0 && (t = 0.1), Ui(fp(this.rgba, t));
  }, n.prototype.desaturate = function(t) {
    return t === void 0 && (t = 0.1), Ui(fp(this.rgba, -t));
  }, n.prototype.grayscale = function() {
    return Ui(fp(this.rgba, -1));
  }, n.prototype.lighten = function(t) {
    return t === void 0 && (t = 0.1), Ui(g_(this.rgba, t));
  }, n.prototype.darken = function(t) {
    return t === void 0 && (t = 0.1), Ui(g_(this.rgba, -t));
  }, n.prototype.rotate = function(t) {
    return t === void 0 && (t = 15), this.hue(this.hue() + t);
  }, n.prototype.alpha = function(t) {
    return typeof t == "number" ? Ui({ r: (e = this.rgba).r, g: e.g, b: e.b, a: t }) : hn(this.rgba.a, 3);
    var e;
  }, n.prototype.hue = function(t) {
    var e = wl(this.rgba);
    return typeof t == "number" ? Ui({ h: t, s: e.s, l: e.l, a: e.a }) : hn(e.h);
  }, n.prototype.isEqual = function(t) {
    return this.toHex() === Ui(t).toHex();
  }, n;
})(), Ui = function(n) {
  return n instanceof cm ? n : new cm(n);
}, y_ = [], jM = function(n) {
  n.forEach(function(t) {
    y_.indexOf(t) < 0 && (t(cm, um), y_.push(t));
  });
};
function YM(n, t) {
  var e = { white: "#ffffff", bisque: "#ffe4c4", blue: "#0000ff", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", antiquewhite: "#faebd7", aqua: "#00ffff", azure: "#f0ffff", whitesmoke: "#f5f5f5", papayawhip: "#ffefd5", plum: "#dda0dd", blanchedalmond: "#ffebcd", black: "#000000", gold: "#ffd700", goldenrod: "#daa520", gainsboro: "#dcdcdc", cornsilk: "#fff8dc", cornflowerblue: "#6495ed", burlywood: "#deb887", aquamarine: "#7fffd4", beige: "#f5f5dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkkhaki: "#bdb76b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", peachpuff: "#ffdab9", darkmagenta: "#8b008b", darkred: "#8b0000", darkorchid: "#9932cc", darkorange: "#ff8c00", darkslateblue: "#483d8b", gray: "#808080", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", deeppink: "#ff1493", deepskyblue: "#00bfff", wheat: "#f5deb3", firebrick: "#b22222", floralwhite: "#fffaf0", ghostwhite: "#f8f8ff", darkviolet: "#9400d3", magenta: "#ff00ff", green: "#008000", dodgerblue: "#1e90ff", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", blueviolet: "#8a2be2", forestgreen: "#228b22", lawngreen: "#7cfc00", indianred: "#cd5c5c", indigo: "#4b0082", fuchsia: "#ff00ff", brown: "#a52a2a", maroon: "#800000", mediumblue: "#0000cd", lightcoral: "#f08080", darkturquoise: "#00ced1", lightcyan: "#e0ffff", ivory: "#fffff0", lightyellow: "#ffffe0", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", linen: "#faf0e6", mediumaquamarine: "#66cdaa", lemonchiffon: "#fffacd", lime: "#00ff00", khaki: "#f0e68c", mediumseagreen: "#3cb371", limegreen: "#32cd32", mediumspringgreen: "#00fa9a", lightskyblue: "#87cefa", lightblue: "#add8e6", midnightblue: "#191970", lightpink: "#ffb6c1", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", mintcream: "#f5fffa", lightslategray: "#778899", lightslategrey: "#778899", navajowhite: "#ffdead", navy: "#000080", mediumvioletred: "#c71585", powderblue: "#b0e0e6", palegoldenrod: "#eee8aa", oldlace: "#fdf5e6", paleturquoise: "#afeeee", mediumturquoise: "#48d1cc", mediumorchid: "#ba55d3", rebeccapurple: "#663399", lightsteelblue: "#b0c4de", mediumslateblue: "#7b68ee", thistle: "#d8bfd8", tan: "#d2b48c", orchid: "#da70d6", mediumpurple: "#9370db", purple: "#800080", pink: "#ffc0cb", skyblue: "#87ceeb", springgreen: "#00ff7f", palegreen: "#98fb98", red: "#ff0000", yellow: "#ffff00", slateblue: "#6a5acd", lavenderblush: "#fff0f5", peru: "#cd853f", palevioletred: "#db7093", violet: "#ee82ee", teal: "#008080", slategray: "#708090", slategrey: "#708090", aliceblue: "#f0f8ff", darkseagreen: "#8fbc8f", darkolivegreen: "#556b2f", greenyellow: "#adff2f", seagreen: "#2e8b57", seashell: "#fff5ee", tomato: "#ff6347", silver: "#c0c0c0", sienna: "#a0522d", lavender: "#e6e6fa", lightgreen: "#90ee90", orange: "#ffa500", orangered: "#ff4500", steelblue: "#4682b4", royalblue: "#4169e1", turquoise: "#40e0d0", yellowgreen: "#9acd32", salmon: "#fa8072", saddlebrown: "#8b4513", sandybrown: "#f4a460", rosybrown: "#bc8f8f", darksalmon: "#e9967a", lightgoldenrodyellow: "#fafad2", snow: "#fffafa", lightgrey: "#d3d3d3", lightgray: "#d3d3d3", dimgray: "#696969", dimgrey: "#696969", olivedrab: "#6b8e23", olive: "#808000" }, i = {};
  for (var s in e) i[e[s]] = s;
  var o = {};
  n.prototype.toName = function(l) {
    if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b)) return "transparent";
    var c, d, f = i[this.toHex()];
    if (f) return f;
    if (l?.closest) {
      var m = this.toRgb(), y = 1 / 0, b = "black";
      if (!o.length) for (var v in e) o[v] = new n(e[v]).toRgb();
      for (var x in e) {
        var S = (c = m, d = o[x], Math.pow(c.r - d.r, 2) + Math.pow(c.g - d.g, 2) + Math.pow(c.b - d.b, 2));
        S < y && (y = S, b = x);
      }
      return b;
    }
  }, t.string.push([function(l) {
    var c = l.toLowerCase(), d = c === "transparent" ? "#0000" : e[c];
    return d ? new n(d).toRgb() : null;
  }, "name"]);
}
jM([YM]);
const Va = class yl {
  /**
   * @param {ColorSource} value - Optional value to use, if not provided, white is used.
   */
  constructor(t = 16777215) {
    this._value = null, this._components = new Float32Array(4), this._components.fill(1), this._int = 16777215, this.value = t;
  }
  /**
   * Get the red component of the color, normalized between 0 and 1.
   * @example
   * ```ts
   * const color = new Color('red');
   * console.log(color.red); // 1
   *
   * const green = new Color('#00ff00');
   * console.log(green.red); // 0
   * ```
   */
  get red() {
    return this._components[0];
  }
  /**
   * Get the green component of the color, normalized between 0 and 1.
   * @example
   * ```ts
   * const color = new Color('lime');
   * console.log(color.green); // 1
   *
   * const red = new Color('#ff0000');
   * console.log(red.green); // 0
   * ```
   */
  get green() {
    return this._components[1];
  }
  /**
   * Get the blue component of the color, normalized between 0 and 1.
   * @example
   * ```ts
   * const color = new Color('blue');
   * console.log(color.blue); // 1
   *
   * const yellow = new Color('#ffff00');
   * console.log(yellow.blue); // 0
   * ```
   */
  get blue() {
    return this._components[2];
  }
  /**
   * Get the alpha component of the color, normalized between 0 and 1.
   * @example
   * ```ts
   * const color = new Color('red');
   * console.log(color.alpha); // 1 (fully opaque)
   *
   * const transparent = new Color('rgba(255, 0, 0, 0.5)');
   * console.log(transparent.alpha); // 0.5 (semi-transparent)
   * ```
   */
  get alpha() {
    return this._components[3];
  }
  /**
   * Sets the color value and returns the instance for chaining.
   *
   * This is a chainable version of setting the `value` property.
   * @param value - The color to set. Accepts various formats:
   * - Hex strings/numbers (e.g., '#ff0000', 0xff0000)
   * - RGB/RGBA values (arrays, objects)
   * - CSS color names
   * - HSL/HSLA values
   * - HSV/HSVA values
   * @returns The Color instance for chaining
   * @example
   * ```ts
   * // Basic usage
   * const color = new Color();
   * color.setValue('#ff0000')
   *     .setAlpha(0.5)
   *     .premultiply(0.8);
   *
   * // Different formats
   * color.setValue(0xff0000);          // Hex number
   * color.setValue('#ff0000');         // Hex string
   * color.setValue([1, 0, 0]);         // RGB array
   * color.setValue([1, 0, 0, 0.5]);    // RGBA array
   * color.setValue({ r: 1, g: 0, b: 0 }); // RGB object
   *
   * // Copy from another color
   * const red = new Color('red');
   * color.setValue(red);
   * ```
   * @throws {Error} If the color value is invalid or null
   * @see {@link Color.value} For the underlying value property
   */
  setValue(t) {
    return this.value = t, this;
  }
  /**
   * The current color source. This property allows getting and setting the color value
   * while preserving the original format where possible.
   * @remarks
   * When setting:
   * - Setting to a `Color` instance copies its source and components
   * - Setting to other valid sources normalizes and stores the value
   * - Setting to `null` throws an Error
   * - The color remains unchanged if normalization fails
   *
   * When getting:
   * - Returns `null` if color was modified by {@link Color.multiply} or {@link Color.premultiply}
   * - Otherwise returns the original color source
   * @example
   * ```ts
   * // Setting different color formats
   * const color = new Color();
   *
   * color.value = 0xff0000;         // Hex number
   * color.value = '#ff0000';        // Hex string
   * color.value = [1, 0, 0];        // RGB array
   * color.value = [1, 0, 0, 0.5];   // RGBA array
   * color.value = { r: 1, g: 0, b: 0 }; // RGB object
   *
   * // Copying from another color
   * const red = new Color('red');
   * color.value = red;  // Copies red's components
   *
   * // Getting the value
   * console.log(color.value);  // Returns original format
   *
   * // After modifications
   * color.multiply([0.5, 0.5, 0.5]);
   * console.log(color.value);  // Returns null
   * ```
   * @throws {Error} When attempting to set `null`
   */
  set value(t) {
    if (t instanceof yl)
      this._value = this._cloneSource(t._value), this._int = t._int, this._components.set(t._components);
    else {
      if (t === null)
        throw new Error("Cannot set Color#value to null");
      (this._value === null || !this._isSourceEqual(this._value, t)) && (this._value = this._cloneSource(t), this._normalize(this._value));
    }
  }
  get value() {
    return this._value;
  }
  /**
   * Copy a color source internally.
   * @param value - Color source
   */
  _cloneSource(t) {
    return typeof t == "string" || typeof t == "number" || t instanceof Number || t === null ? t : Array.isArray(t) || ArrayBuffer.isView(t) ? t.slice(0) : typeof t == "object" && t !== null ? { ...t } : t;
  }
  /**
   * Equality check for color sources.
   * @param value1 - First color source
   * @param value2 - Second color source
   * @returns `true` if the color sources are equal, `false` otherwise.
   */
  _isSourceEqual(t, e) {
    const i = typeof t;
    if (i !== typeof e)
      return !1;
    if (i === "number" || i === "string" || t instanceof Number)
      return t === e;
    if (Array.isArray(t) && Array.isArray(e) || ArrayBuffer.isView(t) && ArrayBuffer.isView(e))
      return t.length !== e.length ? !1 : t.every((o, l) => o === e[l]);
    if (t !== null && e !== null) {
      const o = Object.keys(t), l = Object.keys(e);
      return o.length !== l.length ? !1 : o.every((c) => t[c] === e[c]);
    }
    return t === e;
  }
  /**
   * Convert to a RGBA color object with normalized components (0-1).
   * @example
   * ```ts
   * import { Color } from 'pixi.js';
   *
   * // Convert colors to RGBA objects
   * new Color('white').toRgba();     // returns { r: 1, g: 1, b: 1, a: 1 }
   * new Color('#ff0000').toRgba();   // returns { r: 1, g: 0, b: 0, a: 1 }
   *
   * // With transparency
   * new Color('rgba(255,0,0,0.5)').toRgba(); // returns { r: 1, g: 0, b: 0, a: 0.5 }
   * ```
   * @returns An RGBA object with normalized components
   */
  toRgba() {
    const [t, e, i, s] = this._components;
    return { r: t, g: e, b: i, a: s };
  }
  /**
   * Convert to a RGB color object with normalized components (0-1).
   *
   * Alpha component is omitted in the output.
   * @example
   * ```ts
   * import { Color } from 'pixi.js';
   *
   * // Convert colors to RGB objects
   * new Color('white').toRgb();     // returns { r: 1, g: 1, b: 1 }
   * new Color('#ff0000').toRgb();   // returns { r: 1, g: 0, b: 0 }
   *
   * // Alpha is ignored
   * new Color('rgba(255,0,0,0.5)').toRgb(); // returns { r: 1, g: 0, b: 0 }
   * ```
   * @returns An RGB object with normalized components
   */
  toRgb() {
    const [t, e, i] = this._components;
    return { r: t, g: e, b: i };
  }
  /**
   * Convert to a CSS-style rgba string representation.
   *
   * RGB components are scaled to 0-255 range, alpha remains 0-1.
   * @example
   * ```ts
   * import { Color } from 'pixi.js';
   *
   * // Convert colors to RGBA strings
   * new Color('white').toRgbaString();     // returns "rgba(255,255,255,1)"
   * new Color('#ff0000').toRgbaString();   // returns "rgba(255,0,0,1)"
   *
   * // With transparency
   * new Color([1, 0, 0, 0.5]).toRgbaString(); // returns "rgba(255,0,0,0.5)"
   * ```
   * @returns A CSS-compatible rgba string
   */
  toRgbaString() {
    const [t, e, i] = this.toUint8RgbArray();
    return `rgba(${t},${e},${i},${this.alpha})`;
  }
  /**
   * Convert to an [R, G, B] array of clamped uint8 values (0 to 255).
   * @param {number[]|Uint8Array|Uint8ClampedArray} [out] - Optional output array. If not provided,
   * a cached array will be used and returned.
   * @returns Array containing RGB components as integers between 0-255
   * @example
   * ```ts
   * // Basic usage
   * new Color('white').toUint8RgbArray(); // returns [255, 255, 255]
   * new Color('#ff0000').toUint8RgbArray(); // returns [255, 0, 0]
   *
   * // Using custom output array
   * const rgb = new Uint8Array(3);
   * new Color('blue').toUint8RgbArray(rgb); // rgb is now [0, 0, 255]
   *
   * // Using different array types
   * new Color('red').toUint8RgbArray(new Uint8ClampedArray(3)); // [255, 0, 0]
   * new Color('red').toUint8RgbArray([]); // [255, 0, 0]
   * ```
   * @remarks
   * - Output values are always clamped between 0-255
   * - Alpha component is not included in output
   * - Reuses internal cache array if no output array provided
   */
  toUint8RgbArray(t) {
    const [e, i, s] = this._components;
    return this._arrayRgb || (this._arrayRgb = []), t || (t = this._arrayRgb), t[0] = Math.round(e * 255), t[1] = Math.round(i * 255), t[2] = Math.round(s * 255), t;
  }
  /**
   * Convert to an [R, G, B, A] array of normalized floats (numbers from 0.0 to 1.0).
   * @param {number[]|Float32Array} [out] - Optional output array. If not provided,
   * a cached array will be used and returned.
   * @returns Array containing RGBA components as floats between 0-1
   * @example
   * ```ts
   * // Basic usage
   * new Color('white').toArray();  // returns [1, 1, 1, 1]
   * new Color('red').toArray();    // returns [1, 0, 0, 1]
   *
   * // With alpha
   * new Color('rgba(255,0,0,0.5)').toArray(); // returns [1, 0, 0, 0.5]
   *
   * // Using custom output array
   * const rgba = new Float32Array(4);
   * new Color('blue').toArray(rgba); // rgba is now [0, 0, 1, 1]
   * ```
   * @remarks
   * - Output values are normalized between 0-1
   * - Includes alpha component as the fourth value
   * - Reuses internal cache array if no output array provided
   */
  toArray(t) {
    this._arrayRgba || (this._arrayRgba = []), t || (t = this._arrayRgba);
    const [e, i, s, o] = this._components;
    return t[0] = e, t[1] = i, t[2] = s, t[3] = o, t;
  }
  /**
   * Convert to an [R, G, B] array of normalized floats (numbers from 0.0 to 1.0).
   * @param {number[]|Float32Array} [out] - Optional output array. If not provided,
   * a cached array will be used and returned.
   * @returns Array containing RGB components as floats between 0-1
   * @example
   * ```ts
   * // Basic usage
   * new Color('white').toRgbArray(); // returns [1, 1, 1]
   * new Color('red').toRgbArray();   // returns [1, 0, 0]
   *
   * // Using custom output array
   * const rgb = new Float32Array(3);
   * new Color('blue').toRgbArray(rgb); // rgb is now [0, 0, 1]
   * ```
   * @remarks
   * - Output values are normalized between 0-1
   * - Alpha component is omitted from output
   * - Reuses internal cache array if no output array provided
   */
  toRgbArray(t) {
    this._arrayRgb || (this._arrayRgb = []), t || (t = this._arrayRgb);
    const [e, i, s] = this._components;
    return t[0] = e, t[1] = i, t[2] = s, t;
  }
  /**
   * Convert to a hexadecimal number.
   * @returns The color as a 24-bit RGB integer
   * @example
   * ```ts
   * // Basic usage
   * new Color('white').toNumber(); // returns 0xffffff
   * new Color('red').toNumber();   // returns 0xff0000
   *
   * // Store as hex
   * const color = new Color('blue');
   * const hex = color.toNumber(); // 0x0000ff
   * ```
   */
  toNumber() {
    return this._int;
  }
  /**
   * Convert to a BGR number.
   *
   * Useful for platforms that expect colors in BGR format.
   * @returns The color as a 24-bit BGR integer
   * @example
   * ```ts
   * // Convert RGB to BGR
   * new Color(0xffcc99).toBgrNumber(); // returns 0x99ccff
   *
   * // Common use case: platform-specific color format
   * const color = new Color('orange');
   * const bgrColor = color.toBgrNumber(); // Color with swapped R/B channels
   * ```
   * @remarks
   * This swaps the red and blue channels compared to the normal RGB format:
   * - RGB 0xRRGGBB becomes BGR 0xBBGGRR
   */
  toBgrNumber() {
    const [t, e, i] = this.toUint8RgbArray();
    return (i << 16) + (e << 8) + t;
  }
  /**
   * Convert to a hexadecimal number in little endian format (e.g., BBGGRR).
   *
   * Useful for platforms that expect colors in little endian byte order.
   * @example
   * ```ts
   * import { Color } from 'pixi.js';
   *
   * // Convert RGB color to little endian format
   * new Color(0xffcc99).toLittleEndianNumber(); // returns 0x99ccff
   *
   * // Common use cases:
   * const color = new Color('orange');
   * const leColor = color.toLittleEndianNumber(); // Swaps byte order for LE systems
   *
   * // Multiple conversions
   * const colors = {
   *     normal: 0xffcc99,
   *     littleEndian: new Color(0xffcc99).toLittleEndianNumber(), // 0x99ccff
   *     backToNormal: new Color(0x99ccff).toLittleEndianNumber()  // 0xffcc99
   * };
   * ```
   * @remarks
   * - Swaps R and B channels in the color value
   * - RGB 0xRRGGBB becomes 0xBBGGRR
   * - Useful for systems that use little endian byte order
   * - Can be used to convert back and forth between formats
   * @returns The color as a number in little endian format (BBGGRR)
   * @see {@link Color.toBgrNumber} For BGR format without byte swapping
   */
  toLittleEndianNumber() {
    const t = this._int;
    return (t >> 16) + (t & 65280) + ((t & 255) << 16);
  }
  /**
   * Multiply with another color.
   *
   * This action is destructive and modifies the original color.
   * @param {ColorSource} value - The color to multiply by. Accepts any valid color format:
   * - Hex strings/numbers (e.g., '#ff0000', 0xff0000)
   * - RGB/RGBA arrays ([1, 0, 0], [1, 0, 0, 1])
   * - Color objects ({ r: 1, g: 0, b: 0 })
   * - CSS color names ('red', 'blue')
   * @returns this - The Color instance for chaining
   * @example
   * ```ts
   * // Basic multiplication
   * const color = new Color('#ff0000');
   * color.multiply(0x808080); // 50% darker red
   *
   * // With transparency
   * color.multiply([1, 1, 1, 0.5]); // 50% transparent
   *
   * // Chain operations
   * color
   *     .multiply('#808080')
   *     .multiply({ r: 1, g: 1, b: 1, a: 0.5 });
   * ```
   * @remarks
   * - Multiplies each RGB component and alpha separately
   * - Values are clamped between 0-1
   * - Original color format is lost (value becomes null)
   * - Operation cannot be undone
   */
  multiply(t) {
    const [e, i, s, o] = yl._temp.setValue(t)._components;
    return this._components[0] *= e, this._components[1] *= i, this._components[2] *= s, this._components[3] *= o, this._refreshInt(), this._value = null, this;
  }
  /**
   * Converts color to a premultiplied alpha format.
   *
   * This action is destructive and modifies the original color.
   * @param alpha - The alpha value to multiply by (0-1)
   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels
   * @returns {Color} The Color instance for chaining
   * @example
   * ```ts
   * // Basic premultiplication
   * const color = new Color('red');
   * color.premultiply(0.5); // 50% transparent red with premultiplied RGB
   *
   * // Alpha only (RGB unchanged)
   * color.premultiply(0.5, false); // 50% transparent, original RGB
   *
   * // Chain with other operations
   * color
   *     .multiply(0x808080)
   *     .premultiply(0.5)
   *     .toNumber();
   * ```
   * @remarks
   * - RGB channels are multiplied by alpha when applyToRGB is true
   * - Alpha is always set to the provided value
   * - Values are clamped between 0-1
   * - Original color format is lost (value becomes null)
   * - Operation cannot be undone
   */
  premultiply(t, e = !0) {
    return e && (this._components[0] *= t, this._components[1] *= t, this._components[2] *= t), this._components[3] = t, this._refreshInt(), this._value = null, this;
  }
  /**
   * Returns the color as a 32-bit premultiplied alpha integer.
   *
   * Format: 0xAARRGGBB
   * @param {number} alpha - The alpha value to multiply by (0-1)
   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels
   * @returns {number} The premultiplied color as a 32-bit integer
   * @example
   * ```ts
   * // Convert to premultiplied format
   * const color = new Color('red');
   *
   * // Full opacity (0xFFRRGGBB)
   * color.toPremultiplied(1.0); // 0xFFFF0000
   *
   * // 50% transparency with premultiplied RGB
   * color.toPremultiplied(0.5); // 0x7F7F0000
   *
   * // 50% transparency without RGB premultiplication
   * color.toPremultiplied(0.5, false); // 0x7FFF0000
   * ```
   * @remarks
   * - Returns full opacity (0xFF000000) when alpha is 1.0
   * - Returns 0 when alpha is 0.0 and applyToRGB is true
   * - RGB values are rounded during premultiplication
   */
  toPremultiplied(t, e = !0) {
    if (t === 1)
      return (255 << 24) + this._int;
    if (t === 0)
      return e ? 0 : this._int;
    let i = this._int >> 16 & 255, s = this._int >> 8 & 255, o = this._int & 255;
    return e && (i = i * t + 0.5 | 0, s = s * t + 0.5 | 0, o = o * t + 0.5 | 0), (t * 255 << 24) + (i << 16) + (s << 8) + o;
  }
  /**
   * Convert to a hexadecimal string (6 characters).
   * @returns A CSS-compatible hex color string (e.g., "#ff0000")
   * @example
   * ```ts
   * import { Color } from 'pixi.js';
   *
   * // Basic colors
   * new Color('red').toHex();    // returns "#ff0000"
   * new Color('white').toHex();  // returns "#ffffff"
   * new Color('black').toHex();  // returns "#000000"
   *
   * // From different formats
   * new Color(0xff0000).toHex(); // returns "#ff0000"
   * new Color([1, 0, 0]).toHex(); // returns "#ff0000"
   * new Color({ r: 1, g: 0, b: 0 }).toHex(); // returns "#ff0000"
   * ```
   * @remarks
   * - Always returns a 6-character hex string
   * - Includes leading "#" character
   * - Alpha channel is ignored
   * - Values are rounded to nearest hex value
   */
  toHex() {
    const t = this._int.toString(16);
    return `#${"000000".substring(0, 6 - t.length) + t}`;
  }
  /**
   * Convert to a hexadecimal string with alpha (8 characters).
   * @returns A CSS-compatible hex color string with alpha (e.g., "#ff0000ff")
   * @example
   * ```ts
   * import { Color } from 'pixi.js';
   *
   * // Fully opaque colors
   * new Color('red').toHexa();   // returns "#ff0000ff"
   * new Color('white').toHexa(); // returns "#ffffffff"
   *
   * // With transparency
   * new Color('rgba(255, 0, 0, 0.5)').toHexa(); // returns "#ff00007f"
   * new Color([1, 0, 0, 0]).toHexa(); // returns "#ff000000"
   * ```
   * @remarks
   * - Returns an 8-character hex string
   * - Includes leading "#" character
   * - Alpha is encoded in last two characters
   * - Values are rounded to nearest hex value
   */
  toHexa() {
    const e = Math.round(this._components[3] * 255).toString(16);
    return this.toHex() + "00".substring(0, 2 - e.length) + e;
  }
  /**
   * Set alpha (transparency) value while preserving color components.
   *
   * Provides a chainable interface for setting alpha.
   * @param alpha - Alpha value between 0 (fully transparent) and 1 (fully opaque)
   * @returns The Color instance for chaining
   * @example
   * ```ts
   * // Basic alpha setting
   * const color = new Color('red');
   * color.setAlpha(0.5);  // 50% transparent red
   *
   * // Chain with other operations
   * color
   *     .setValue('#ff0000')
   *     .setAlpha(0.8)    // 80% opaque
   *     .premultiply(0.5); // Further modify alpha
   *
   * // Reset to fully opaque
   * color.setAlpha(1);
   * ```
   * @remarks
   * - Alpha value is clamped between 0-1
   * - Can be chained with other color operations
   */
  setAlpha(t) {
    return this._components[3] = this._clamp(t), this;
  }
  /**
   * Normalize the input value into rgba
   * @param value - Input value
   */
  _normalize(t) {
    let e, i, s, o;
    if ((typeof t == "number" || t instanceof Number) && t >= 0 && t <= 16777215) {
      const l = t;
      e = (l >> 16 & 255) / 255, i = (l >> 8 & 255) / 255, s = (l & 255) / 255, o = 1;
    } else if ((Array.isArray(t) || t instanceof Float32Array) && t.length >= 3 && t.length <= 4)
      t = this._clamp(t), [e, i, s, o = 1] = t;
    else if ((t instanceof Uint8Array || t instanceof Uint8ClampedArray) && t.length >= 3 && t.length <= 4)
      t = this._clamp(t, 0, 255), [e, i, s, o = 255] = t, e /= 255, i /= 255, s /= 255, o /= 255;
    else if (typeof t == "string" || typeof t == "object") {
      if (typeof t == "string") {
        const c = yl.HEX_PATTERN.exec(t);
        c && (t = `#${c[2]}`);
      }
      const l = Ui(t);
      l.isValid() && ({ r: e, g: i, b: s, a: o } = l.rgba, e /= 255, i /= 255, s /= 255);
    }
    if (e !== void 0)
      this._components[0] = e, this._components[1] = i, this._components[2] = s, this._components[3] = o, this._refreshInt();
    else
      throw new Error(`Unable to convert color ${t}`);
  }
  /** Refresh the internal color rgb number */
  _refreshInt() {
    this._clamp(this._components);
    const [t, e, i] = this._components;
    this._int = (t * 255 << 16) + (e * 255 << 8) + (i * 255 | 0);
  }
  /**
   * Clamps values to a range. Will override original values
   * @param value - Value(s) to clamp
   * @param min - Minimum value
   * @param max - Maximum value
   */
  _clamp(t, e = 0, i = 1) {
    return typeof t == "number" ? Math.min(Math.max(t, e), i) : (t.forEach((s, o) => {
      t[o] = Math.min(Math.max(s, e), i);
    }), t);
  }
  /**
   * Check if a value can be interpreted as a valid color format.
   * Supports all color formats that can be used with the Color class.
   * @param value - Value to check
   * @returns True if the value can be used as a color
   * @example
   * ```ts
   * import { Color } from 'pixi.js';
   *
   * // CSS colors and hex values
   * Color.isColorLike('red');          // true
   * Color.isColorLike('#ff0000');      // true
   * Color.isColorLike(0xff0000);       // true
   *
   * // Arrays (RGB/RGBA)
   * Color.isColorLike([1, 0, 0]);      // true
   * Color.isColorLike([1, 0, 0, 0.5]); // true
   *
   * // TypedArrays
   * Color.isColorLike(new Float32Array([1, 0, 0]));          // true
   * Color.isColorLike(new Uint8Array([255, 0, 0]));          // true
   * Color.isColorLike(new Uint8ClampedArray([255, 0, 0]));   // true
   *
   * // Object formats
   * Color.isColorLike({ r: 1, g: 0, b: 0 });            // true (RGB)
   * Color.isColorLike({ r: 1, g: 0, b: 0, a: 0.5 });    // true (RGBA)
   * Color.isColorLike({ h: 0, s: 100, l: 50 });         // true (HSL)
   * Color.isColorLike({ h: 0, s: 100, l: 50, a: 0.5 }); // true (HSLA)
   * Color.isColorLike({ h: 0, s: 100, v: 100 });        // true (HSV)
   * Color.isColorLike({ h: 0, s: 100, v: 100, a: 0.5 });// true (HSVA)
   *
   * // Color instances
   * Color.isColorLike(new Color('red')); // true
   *
   * // Invalid values
   * Color.isColorLike(null);           // false
   * Color.isColorLike(undefined);      // false
   * Color.isColorLike({});             // false
   * Color.isColorLike([]);             // false
   * Color.isColorLike('not-a-color');  // false
   * ```
   * @remarks
   * Checks for the following formats:
   * - Numbers (0x000000 to 0xffffff)
   * - CSS color strings
   * - RGB/RGBA arrays and objects
   * - HSL/HSLA objects
   * - HSV/HSVA objects
   * - TypedArrays (Float32Array, Uint8Array, Uint8ClampedArray)
   * - Color instances
   * @see {@link ColorSource} For supported color format types
   * @see {@link Color.setValue} For setting color values
   * @category utility
   */
  static isColorLike(t) {
    return typeof t == "number" || typeof t == "string" || t instanceof Number || t instanceof yl || Array.isArray(t) || t instanceof Uint8Array || t instanceof Uint8ClampedArray || t instanceof Float32Array || t.r !== void 0 && t.g !== void 0 && t.b !== void 0 || t.r !== void 0 && t.g !== void 0 && t.b !== void 0 && t.a !== void 0 || t.h !== void 0 && t.s !== void 0 && t.l !== void 0 || t.h !== void 0 && t.s !== void 0 && t.l !== void 0 && t.a !== void 0 || t.h !== void 0 && t.s !== void 0 && t.v !== void 0 || t.h !== void 0 && t.s !== void 0 && t.v !== void 0 && t.a !== void 0;
  }
};
Va.shared = new Va();
Va._temp = new Va();
Va.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
let Pe = Va;
const XM = {
  cullArea: null,
  cullable: !1,
  cullableChildren: !0
};
let mp = 0;
const b_ = 500;
function $t(...n) {
  mp !== b_ && (mp++, mp === b_ ? console.warn("PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.") : console.warn("PixiJS Warning: ", ...n));
}
const to = {
  /**
   * Set of registered pools and cleanable objects.
   * @private
   */
  _registeredResources: /* @__PURE__ */ new Set(),
  /**
   * Registers a pool or cleanable object for cleanup.
   * @param {Cleanable} pool - The pool or object to register.
   */
  register(n) {
    this._registeredResources.add(n);
  },
  /**
   * Unregisters a pool or cleanable object from cleanup.
   * @param {Cleanable} pool - The pool or object to unregister.
   */
  unregister(n) {
    this._registeredResources.delete(n);
  },
  /** Clears all registered pools and cleanable objects. This will call clear() on each registered item. */
  release() {
    this._registeredResources.forEach((n) => n.clear());
  },
  /**
   * Gets the number of registered pools and cleanable objects.
   * @returns {number} The count of registered items.
   */
  get registeredCount() {
    return this._registeredResources.size;
  },
  /**
   * Checks if a specific pool or cleanable object is registered.
   * @param {Cleanable} pool - The pool or object to check.
   * @returns {boolean} True if the item is registered, false otherwise.
   */
  isRegistered(n) {
    return this._registeredResources.has(n);
  },
  /**
   * Removes all registrations without clearing the pools.
   * Useful if you want to reset the collector without affecting the pools.
   */
  reset() {
    this._registeredResources.clear();
  }
};
class qM {
  /**
   * Constructs a new Pool.
   * @param ClassType - The constructor of the items in the pool.
   * @param {number} [initialSize] - The initial size of the pool.
   */
  constructor(t, e) {
    this._pool = [], this._count = 0, this._index = 0, this._classType = t, e && this.prepopulate(e);
  }
  /**
   * Prepopulates the pool with a given number of items.
   * @param total - The number of items to add to the pool.
   */
  prepopulate(t) {
    for (let e = 0; e < t; e++)
      this._pool[this._index++] = new this._classType();
    this._count += t;
  }
  /**
   * Gets an item from the pool. Calls the item's `init` method if it exists.
   * If there are no items left in the pool, a new one will be created.
   * @param {unknown} [data] - Optional data to pass to the item's constructor.
   * @returns {T} The item from the pool.
   */
  get(t) {
    let e;
    return this._index > 0 ? e = this._pool[--this._index] : e = new this._classType(), e.init?.(t), e;
  }
  /**
   * Returns an item to the pool. Calls the item's `reset` method if it exists.
   * @param {T} item - The item to return to the pool.
   */
  return(t) {
    t.reset?.(), this._pool[this._index++] = t;
  }
  /**
   * Gets the number of items in the pool.
   * @readonly
   */
  get totalSize() {
    return this._count;
  }
  /**
   * Gets the number of items in the pool that are free to use without needing to create more.
   * @readonly
   */
  get totalFree() {
    return this._index;
  }
  /**
   * Gets the number of items in the pool that are currently in use.
   * @readonly
   */
  get totalUsed() {
    return this._count - this._index;
  }
  /** clears the pool */
  clear() {
    if (this._pool.length > 0 && this._pool[0].destroy)
      for (let t = 0; t < this._index; t++)
        this._pool[t].destroy();
    this._pool.length = 0, this._count = 0, this._index = 0;
  }
}
class KM {
  constructor() {
    this._poolsByClass = /* @__PURE__ */ new Map();
  }
  /**
   * Prepopulates a specific pool with a given number of items.
   * @template T The type of items in the pool. Must extend PoolItem.
   * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.
   * @param {number} total - The number of items to add to the pool.
   */
  prepopulate(t, e) {
    this.getPool(t).prepopulate(e);
  }
  /**
   * Gets an item from a specific pool.
   * @template T The type of items in the pool. Must extend PoolItem.
   * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.
   * @param {unknown} [data] - Optional data to pass to the item's constructor.
   * @returns {T} The item from the pool.
   */
  get(t, e) {
    return this.getPool(t).get(e);
  }
  /**
   * Returns an item to its respective pool.
   * @param {PoolItem} item - The item to return to the pool.
   */
  return(t) {
    this.getPool(t.constructor).return(t);
  }
  /**
   * Gets a specific pool based on the class type.
   * @template T The type of items in the pool. Must extend PoolItem.
   * @param {PoolItemConstructor<T>} ClassType - The constructor of the items in the pool.
   * @returns {Pool<T>} The pool of the given class type.
   */
  getPool(t) {
    return this._poolsByClass.has(t) || this._poolsByClass.set(t, new qM(t)), this._poolsByClass.get(t);
  }
  /** gets the usage stats of each pool in the system */
  stats() {
    const t = {};
    return this._poolsByClass.forEach((e) => {
      const i = t[e._classType.name] ? e._classType.name + e._classType.ID : e._classType.name;
      t[i] = {
        free: e.totalFree,
        used: e.totalUsed,
        size: e.totalSize
      };
    }), t;
  }
  /** Clears all pools in the group. This will reset all pools and free their resources. */
  clear() {
    this._poolsByClass.forEach((t) => t.clear()), this._poolsByClass.clear();
  }
}
const Qe = new KM();
to.register(Qe);
const ZM = {
  get isCachedAsTexture() {
    return !!this.renderGroup?.isCachedAsTexture;
  },
  cacheAsTexture(n) {
    typeof n == "boolean" && n === !1 ? this.disableRenderGroup() : (this.enableRenderGroup(), this.renderGroup.enableCacheAsTexture(n === !0 ? {} : n));
  },
  updateCacheTexture() {
    this.renderGroup?.updateCacheTexture();
  },
  get cacheAsBitmap() {
    return this.isCachedAsTexture;
  },
  set cacheAsBitmap(n) {
    zt("v8.6.0", "cacheAsBitmap is deprecated, use cacheAsTexture instead."), this.cacheAsTexture(n);
  }
};
function a1(n, t, e) {
  const i = n.length;
  let s;
  if (t >= i || e === 0)
    return;
  e = t + e > i ? i - t : e;
  const o = i - e;
  for (s = t; s < o; ++s)
    n[s] = n[s + e];
  n.length = o;
}
const QM = {
  allowChildren: !0,
  removeChildren(n = 0, t) {
    const e = t ?? this.children.length, i = e - n, s = [];
    if (i > 0 && i <= e) {
      for (let l = e - 1; l >= n; l--) {
        const c = this.children[l];
        c && (s.push(c), c.parent = null);
      }
      a1(this.children, n, e);
      const o = this.renderGroup || this.parentRenderGroup;
      o && o.removeChildren(s);
      for (let l = 0; l < s.length; ++l) {
        const c = s[l];
        c.parentRenderLayer?.detach(c), this.emit("childRemoved", c, this, l), s[l].emit("removed", this);
      }
      return s.length > 0 && this._didViewChangeTick++, s;
    } else if (i === 0 && this.children.length === 0)
      return s;
    throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
  },
  removeChildAt(n) {
    const t = this.getChildAt(n);
    return this.removeChild(t);
  },
  getChildAt(n) {
    if (n < 0 || n >= this.children.length)
      throw new Error(`getChildAt: Index (${n}) does not exist.`);
    return this.children[n];
  },
  setChildIndex(n, t) {
    if (t < 0 || t >= this.children.length)
      throw new Error(`The index ${t} supplied is out of bounds ${this.children.length}`);
    this.getChildIndex(n), this.addChildAt(n, t);
  },
  getChildIndex(n) {
    const t = this.children.indexOf(n);
    if (t === -1)
      throw new Error("The supplied Container must be a child of the caller");
    return t;
  },
  addChildAt(n, t) {
    this.allowChildren || zt(ae, "addChildAt: Only Containers will be allowed to add children in v8.0.0");
    const { children: e } = this;
    if (t < 0 || t > e.length)
      throw new Error(`${n}addChildAt: The index ${t} supplied is out of bounds ${e.length}`);
    if (n.parent) {
      const s = n.parent.children.indexOf(n);
      if (n.parent === this && s === t)
        return n;
      s !== -1 && n.parent.children.splice(s, 1);
    }
    t === e.length ? e.push(n) : e.splice(t, 0, n), n.parent = this, n.didChange = !0, n._updateFlags = 15;
    const i = this.renderGroup || this.parentRenderGroup;
    return i && i.addChild(n), this.sortableChildren && (this.sortDirty = !0), this.emit("childAdded", n, this, t), n.emit("added", this), n;
  },
  swapChildren(n, t) {
    if (n === t)
      return;
    const e = this.getChildIndex(n), i = this.getChildIndex(t);
    this.children[e] = t, this.children[i] = n;
    const s = this.renderGroup || this.parentRenderGroup;
    s && (s.structureDidChange = !0), this._didContainerChangeTick++;
  },
  removeFromParent() {
    this.parent?.removeChild(this);
  },
  reparentChild(...n) {
    return n.length === 1 ? this.reparentChildAt(n[0], this.children.length) : (n.forEach((t) => this.reparentChildAt(t, this.children.length)), n[0]);
  },
  reparentChildAt(n, t) {
    if (n.parent === this)
      return this.setChildIndex(n, t), n;
    const e = n.worldTransform.clone();
    n.removeFromParent(), this.addChildAt(n, t);
    const i = this.worldTransform.clone();
    return i.invert(), e.prepend(i), n.setFromMatrix(e), n;
  },
  replaceChild(n, t) {
    n.updateLocalTransform(), this.addChildAt(t, this.getChildIndex(n)), t.setFromMatrix(n.localTransform), t.updateLocalTransform(), this.removeChild(n);
  }
}, JM = {
  collectRenderables(n, t, e) {
    this.parentRenderLayer && this.parentRenderLayer !== e || this.globalDisplayStatus < 7 || !this.includeInBuild || (this.sortableChildren && this.sortChildren(), this.isSimple ? this.collectRenderablesSimple(n, t, e) : this.renderGroup ? t.renderPipes.renderGroup.addRenderGroup(this.renderGroup, n) : this.collectRenderablesWithEffects(n, t, e));
  },
  collectRenderablesSimple(n, t, e) {
    const i = this.children, s = i.length;
    for (let o = 0; o < s; o++)
      i[o].collectRenderables(n, t, e);
  },
  collectRenderablesWithEffects(n, t, e) {
    const { renderPipes: i } = t;
    for (let s = 0; s < this.effects.length; s++) {
      const o = this.effects[s];
      i[o.pipe].push(o, this, n);
    }
    this.collectRenderablesSimple(n, t, e);
    for (let s = this.effects.length - 1; s >= 0; s--) {
      const o = this.effects[s];
      i[o.pipe].pop(o, this, n);
    }
  }
};
class th {
  constructor() {
    this.pipe = "filter", this.priority = 1;
  }
  destroy() {
    for (let t = 0; t < this.filters.length; t++)
      this.filters[t].destroy();
    this.filters = null, this.filterArea = null;
  }
}
class tA {
  constructor() {
    this._effectClasses = [], this._tests = [], this._initialized = !1;
  }
  init() {
    this._initialized || (this._initialized = !0, this._effectClasses.forEach((t) => {
      this.add({
        test: t.test,
        maskClass: t
      });
    }));
  }
  add(t) {
    this._tests.push(t);
  }
  getMaskEffect(t) {
    this._initialized || this.init();
    for (let e = 0; e < this._tests.length; e++) {
      const i = this._tests[e];
      if (i.test(t))
        return Qe.get(i.maskClass, t);
    }
    return t;
  }
  returnMaskEffect(t) {
    Qe.return(t);
  }
}
const hm = new tA();
Nt.handleByList(W.MaskEffect, hm._effectClasses);
const eA = {
  _maskEffect: null,
  _maskOptions: {
    inverse: !1
  },
  _filterEffect: null,
  effects: [],
  _markStructureAsChanged() {
    const n = this.renderGroup || this.parentRenderGroup;
    n && (n.structureDidChange = !0);
  },
  addEffect(n) {
    this.effects.indexOf(n) === -1 && (this.effects.push(n), this.effects.sort((e, i) => e.priority - i.priority), this._markStructureAsChanged(), this._updateIsSimple());
  },
  removeEffect(n) {
    const t = this.effects.indexOf(n);
    t !== -1 && (this.effects.splice(t, 1), this._markStructureAsChanged(), this._updateIsSimple());
  },
  set mask(n) {
    const t = this._maskEffect;
    t?.mask !== n && (t && (this.removeEffect(t), hm.returnMaskEffect(t), this._maskEffect = null), n != null && (this._maskEffect = hm.getMaskEffect(n), this.addEffect(this._maskEffect)));
  },
  get mask() {
    return this._maskEffect?.mask;
  },
  setMask(n) {
    this._maskOptions = {
      ...this._maskOptions,
      ...n
    }, n.mask && (this.mask = n.mask), this._markStructureAsChanged();
  },
  set filters(n) {
    !Array.isArray(n) && n && (n = [n]);
    const t = this._filterEffect || (this._filterEffect = new th());
    n = n;
    const e = n?.length > 0, i = t.filters?.length > 0, s = e !== i;
    n = Array.isArray(n) ? n.slice(0) : n, t.filters = Object.freeze(n), s && (e ? this.addEffect(t) : (this.removeEffect(t), t.filters = n ?? null));
  },
  get filters() {
    return this._filterEffect?.filters;
  },
  set filterArea(n) {
    this._filterEffect || (this._filterEffect = new th()), this._filterEffect.filterArea = n;
  },
  get filterArea() {
    return this._filterEffect?.filterArea;
  }
}, nA = {
  label: null,
  get name() {
    return zt(ae, "Container.name property has been removed, use Container.label instead"), this.label;
  },
  set name(n) {
    zt(ae, "Container.name property has been removed, use Container.label instead"), this.label = n;
  },
  getChildByName(n, t = !1) {
    return this.getChildByLabel(n, t);
  },
  getChildByLabel(n, t = !1) {
    const e = this.children;
    for (let i = 0; i < e.length; i++) {
      const s = e[i];
      if (s.label === n || n instanceof RegExp && n.test(s.label))
        return s;
    }
    if (t)
      for (let i = 0; i < e.length; i++) {
        const o = e[i].getChildByLabel(n, !0);
        if (o)
          return o;
      }
    return null;
  },
  getChildrenByLabel(n, t = !1, e = []) {
    const i = this.children;
    for (let s = 0; s < i.length; s++) {
      const o = i[s];
      (o.label === n || n instanceof RegExp && n.test(o.label)) && e.push(o);
    }
    if (t)
      for (let s = 0; s < i.length; s++)
        i[s].getChildrenByLabel(n, !0, e);
    return e;
  }
}, Mn = Qe.getPool(bt), mr = Qe.getPool(Cn), iA = new bt(), rA = {
  getFastGlobalBounds(n, t) {
    t || (t = new Cn()), t.clear(), this._getGlobalBoundsRecursive(!!n, t, this.parentRenderLayer), t.isValid || t.set(0, 0, 0, 0);
    const e = this.renderGroup || this.parentRenderGroup;
    return t.applyMatrix(e.worldTransform), t;
  },
  _getGlobalBoundsRecursive(n, t, e) {
    let i = t;
    if (n && this.parentRenderLayer && this.parentRenderLayer !== e || this.localDisplayStatus !== 7 || !this.measurable)
      return;
    const s = !!this.effects.length;
    if ((this.renderGroup || s) && (i = mr.get().clear()), this.boundsArea)
      t.addRect(this.boundsArea, this.worldTransform);
    else {
      if (this.renderPipeId) {
        const l = this.bounds;
        i.addFrame(
          l.minX,
          l.minY,
          l.maxX,
          l.maxY,
          this.groupTransform
        );
      }
      const o = this.children;
      for (let l = 0; l < o.length; l++)
        o[l]._getGlobalBoundsRecursive(n, i, e);
    }
    if (s) {
      let o = !1;
      const l = this.renderGroup || this.parentRenderGroup;
      for (let c = 0; c < this.effects.length; c++)
        this.effects[c].addBounds && (o || (o = !0, i.applyMatrix(l.worldTransform)), this.effects[c].addBounds(i, !0));
      o && i.applyMatrix(l.worldTransform.copyTo(iA).invert()), t.addBounds(i), mr.return(i);
    } else this.renderGroup && (t.addBounds(i, this.relativeGroupTransform), mr.return(i));
  }
};
function Qm(n, t, e) {
  e.clear();
  let i, s;
  return n.parent ? t ? i = n.parent.worldTransform : (s = Mn.get().identity(), i = Jm(n, s)) : i = bt.IDENTITY, o1(n, e, i, t), s && Mn.return(s), e.isValid || e.set(0, 0, 0, 0), e;
}
function o1(n, t, e, i) {
  if (!n.visible || !n.measurable)
    return;
  let s;
  i ? s = n.worldTransform : (n.updateLocalTransform(), s = Mn.get(), s.appendFrom(n.localTransform, e));
  const o = t, l = !!n.effects.length;
  if (l && (t = mr.get().clear()), n.boundsArea)
    t.addRect(n.boundsArea, s);
  else {
    const c = n.bounds;
    c && !c.isEmpty() && (t.matrix = s, t.addBounds(c));
    for (let d = 0; d < n.children.length; d++)
      o1(n.children[d], t, s, i);
  }
  if (l) {
    for (let c = 0; c < n.effects.length; c++)
      n.effects[c].addBounds?.(t);
    o.addBounds(t, bt.IDENTITY), mr.return(t);
  }
  i || Mn.return(s);
}
function Jm(n, t) {
  const e = n.parent;
  return e && (Jm(e, t), e.updateLocalTransform(), t.append(e.localTransform)), t;
}
function l1(n, t) {
  if (n === 16777215 || !t)
    return t;
  if (t === 16777215 || !n)
    return n;
  const e = n >> 16 & 255, i = n >> 8 & 255, s = n & 255, o = t >> 16 & 255, l = t >> 8 & 255, c = t & 255, d = e * o / 255 | 0, f = i * l / 255 | 0, m = s * c / 255 | 0;
  return (d << 16) + (f << 8) + m;
}
const v_ = 16777215;
function eh(n, t) {
  return n === v_ ? t : t === v_ ? n : l1(n, t);
}
function jc(n) {
  return ((n & 255) << 16) + (n & 65280) + (n >> 16 & 255);
}
const sA = {
  getGlobalAlpha(n) {
    if (n)
      return this.renderGroup ? this.renderGroup.worldAlpha : this.parentRenderGroup ? this.parentRenderGroup.worldAlpha * this.alpha : this.alpha;
    let t = this.alpha, e = this.parent;
    for (; e; )
      t *= e.alpha, e = e.parent;
    return t;
  },
  getGlobalTransform(n = new bt(), t) {
    if (t)
      return n.copyFrom(this.worldTransform);
    this.updateLocalTransform();
    const e = Jm(this, Mn.get().identity());
    return n.appendFrom(this.localTransform, e), Mn.return(e), n;
  },
  getGlobalTint(n) {
    if (n)
      return this.renderGroup ? jc(this.renderGroup.worldColor) : this.parentRenderGroup ? jc(
        eh(this.localColor, this.parentRenderGroup.worldColor)
      ) : this.tint;
    let t = this.localColor, e = this.parent;
    for (; e; )
      t = eh(t, e.localColor), e = e.parent;
    return jc(t);
  }
};
function tg(n, t, e) {
  return t.clear(), e || (e = bt.IDENTITY), u1(n, t, e, n, !0), t.isValid || t.set(0, 0, 0, 0), t;
}
function u1(n, t, e, i, s) {
  let o;
  if (s)
    o = Mn.get(), o = e.copyTo(o);
  else {
    if (!n.visible || !n.measurable)
      return;
    n.updateLocalTransform();
    const d = n.localTransform;
    o = Mn.get(), o.appendFrom(d, e);
  }
  const l = t, c = !!n.effects.length;
  if (c && (t = mr.get().clear()), n.boundsArea)
    t.addRect(n.boundsArea, o);
  else {
    n.renderPipeId && (t.matrix = o, t.addBounds(n.bounds));
    const d = n.children;
    for (let f = 0; f < d.length; f++)
      u1(d[f], t, o, i, !1);
  }
  if (c) {
    for (let d = 0; d < n.effects.length; d++)
      n.effects[d].addLocalBounds?.(t, i);
    l.addBounds(t, bt.IDENTITY), mr.return(t);
  }
  Mn.return(o);
}
function c1(n, t) {
  const e = n.children;
  for (let i = 0; i < e.length; i++) {
    const s = e[i], o = s.uid, l = (s._didViewChangeTick & 65535) << 16 | s._didContainerChangeTick & 65535, c = t.index;
    (t.data[c] !== o || t.data[c + 1] !== l) && (t.data[t.index] = o, t.data[t.index + 1] = l, t.didChange = !0), t.index = c + 2, s.children.length && c1(s, t);
  }
  return t.didChange;
}
const aA = new bt(), oA = {
  _localBoundsCacheId: -1,
  _localBoundsCacheData: null,
  _setWidth(n, t) {
    const e = Math.sign(this.scale.x) || 1;
    t !== 0 ? this.scale.x = n / t * e : this.scale.x = e;
  },
  _setHeight(n, t) {
    const e = Math.sign(this.scale.y) || 1;
    t !== 0 ? this.scale.y = n / t * e : this.scale.y = e;
  },
  getLocalBounds() {
    this._localBoundsCacheData || (this._localBoundsCacheData = {
      data: [],
      index: 1,
      didChange: !1,
      localBounds: new Cn()
    });
    const n = this._localBoundsCacheData;
    return n.index = 1, n.didChange = !1, n.data[0] !== this._didViewChangeTick && (n.didChange = !0, n.data[0] = this._didViewChangeTick), c1(this, n), n.didChange && tg(this, n.localBounds, aA), n.localBounds;
  },
  getBounds(n, t) {
    return Qm(this, n, t || new Cn());
  }
}, lA = {
  _onRender: null,
  set onRender(n) {
    const t = this.renderGroup || this.parentRenderGroup;
    if (!n) {
      this._onRender && t?.removeOnRender(this), this._onRender = null;
      return;
    }
    this._onRender || t?.addOnRender(this), this._onRender = n;
  },
  get onRender() {
    return this._onRender;
  }
}, uA = {
  _zIndex: 0,
  sortDirty: !1,
  sortableChildren: !1,
  get zIndex() {
    return this._zIndex;
  },
  set zIndex(n) {
    this._zIndex !== n && (this._zIndex = n, this.depthOfChildModified());
  },
  depthOfChildModified() {
    this.parent && (this.parent.sortableChildren = !0, this.parent.sortDirty = !0), this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0);
  },
  sortChildren() {
    this.sortDirty && (this.sortDirty = !1, this.children.sort(cA));
  }
};
function cA(n, t) {
  return n._zIndex - t._zIndex;
}
const hA = {
  getGlobalPosition(n = new Ut(), t = !1) {
    return this.parent ? this.parent.toGlobal(this._position, n, t) : (n.x = this._position.x, n.y = this._position.y), n;
  },
  toGlobal(n, t, e = !1) {
    const i = this.getGlobalTransform(Mn.get(), e);
    return t = i.apply(n, t), Mn.return(i), t;
  },
  toLocal(n, t, e, i) {
    t && (n = t.toGlobal(n, e, i));
    const s = this.getGlobalTransform(Mn.get(), i);
    return e = s.applyInverse(n, e), Mn.return(s), e;
  }
};
class h1 {
  constructor() {
    this.uid = Ee("instructionSet"), this.instructions = [], this.instructionSize = 0, this.renderables = [], this.gcTick = 0;
  }
  /** reset the instruction set so it can be reused set size back to 0 */
  reset() {
    this.instructionSize = 0;
  }
  /**
   * Destroy the instruction set, clearing the instructions and renderables.
   * @internal
   */
  destroy() {
    this.instructions.length = 0, this.renderables.length = 0, this.renderPipes = null, this.gcTick = 0;
  }
  /**
   * Add an instruction to the set
   * @param instruction - add an instruction to the set
   */
  add(t) {
    this.instructions[this.instructionSize++] = t;
  }
  /**
   * Log the instructions to the console (for debugging)
   * @internal
   */
  log() {
    this.instructions.length = this.instructionSize, console.table(this.instructions, ["type", "action"]);
  }
}
let dA = 0;
class fA {
  /**
   * @param textureOptions - options that will be passed to BaseRenderTexture constructor
   * @param {SCALE_MODE} [textureOptions.scaleMode] - See {@link SCALE_MODE} for possible values.
   */
  constructor(t) {
    this._poolKeyHash = /* @__PURE__ */ Object.create(null), this._texturePool = {}, this.textureOptions = t || {}, this.enableFullScreen = !1, this.textureStyle = new Qr(this.textureOptions);
  }
  /**
   * Creates texture with params that were specified in pool constructor.
   * @param pixelWidth - Width of texture in pixels.
   * @param pixelHeight - Height of texture in pixels.
   * @param antialias
   */
  createTexture(t, e, i) {
    const s = new rn({
      ...this.textureOptions,
      width: t,
      height: e,
      resolution: 1,
      antialias: i,
      autoGarbageCollect: !1
    });
    return new Tt({
      source: s,
      label: `texturePool_${dA++}`
    });
  }
  /**
   * Gets a Power-of-Two render texture or fullScreen texture
   * @param frameWidth - The minimum width of the render texture.
   * @param frameHeight - The minimum height of the render texture.
   * @param resolution - The resolution of the render texture.
   * @param antialias
   * @returns The new render texture.
   */
  getOptimalTexture(t, e, i = 1, s) {
    let o = Math.ceil(t * i - 1e-6), l = Math.ceil(e * i - 1e-6);
    o = Wa(o), l = Wa(l);
    const c = (o << 17) + (l << 1) + (s ? 1 : 0);
    this._texturePool[c] || (this._texturePool[c] = []);
    let d = this._texturePool[c].pop();
    return d || (d = this.createTexture(o, l, s)), d.source._resolution = i, d.source.width = o / i, d.source.height = l / i, d.source.pixelWidth = o, d.source.pixelHeight = l, d.frame.x = 0, d.frame.y = 0, d.frame.width = t, d.frame.height = e, d.updateUvs(), this._poolKeyHash[d.uid] = c, d;
  }
  /**
   * Gets extra texture of the same size as input renderTexture
   * @param texture - The texture to check what size it is.
   * @param antialias - Whether to use antialias.
   * @returns A texture that is a power of two
   */
  getSameSizeTexture(t, e = !1) {
    const i = t.source;
    return this.getOptimalTexture(t.width, t.height, i._resolution, e);
  }
  /**
   * Place a render texture back into the pool. Optionally reset the style of the texture to the default texture style.
   * useful if you modified the style of the texture after getting it from the pool.
   * @param renderTexture - The renderTexture to free
   * @param resetStyle - Whether to reset the style of the texture to the default texture style
   */
  returnTexture(t, e = !1) {
    const i = this._poolKeyHash[t.uid];
    e && (t.source.style = this.textureStyle), this._texturePool[i].push(t);
  }
  /**
   * Clears the pool.
   * @param destroyTextures - Destroy all stored textures.
   */
  clear(t) {
    if (t = t !== !1, t)
      for (const e in this._texturePool) {
        const i = this._texturePool[e];
        if (i)
          for (let s = 0; s < i.length; s++)
            i[s].destroy(!0);
      }
    this._texturePool = {};
  }
}
const mn = new fA();
to.register(mn);
class dm {
  constructor() {
    this.renderPipeId = "renderGroup", this.root = null, this.canBundle = !1, this.renderGroupParent = null, this.renderGroupChildren = [], this.worldTransform = new bt(), this.worldColorAlpha = 4294967295, this.worldColor = 16777215, this.worldAlpha = 1, this.childrenToUpdate = /* @__PURE__ */ Object.create(null), this.updateTick = 0, this.gcTick = 0, this.childrenRenderablesToUpdate = { list: [], index: 0 }, this.structureDidChange = !0, this.instructionSet = new h1(), this._onRenderContainers = [], this.textureNeedsUpdate = !0, this.isCachedAsTexture = !1, this._matrixDirty = 7;
  }
  init(t) {
    this.root = t, t._onRender && this.addOnRender(t), t.didChange = !0;
    const e = t.children;
    for (let i = 0; i < e.length; i++) {
      const s = e[i];
      s._updateFlags = 15, this.addChild(s);
    }
  }
  enableCacheAsTexture(t = {}) {
    this.textureOptions = t, this.isCachedAsTexture = !0, this.textureNeedsUpdate = !0;
  }
  disableCacheAsTexture() {
    this.isCachedAsTexture = !1, this.texture && (mn.returnTexture(this.texture, !0), this.texture = null);
  }
  updateCacheTexture() {
    this.textureNeedsUpdate = !0;
    const t = this._parentCacheAsTextureRenderGroup;
    t && !t.textureNeedsUpdate && t.updateCacheTexture();
  }
  reset() {
    this.renderGroupChildren.length = 0;
    for (const t in this.childrenToUpdate) {
      const e = this.childrenToUpdate[t];
      e.list.fill(null), e.index = 0;
    }
    this.childrenRenderablesToUpdate.index = 0, this.childrenRenderablesToUpdate.list.fill(null), this.root = null, this.updateTick = 0, this.structureDidChange = !0, this._onRenderContainers.length = 0, this.renderGroupParent = null, this.disableCacheAsTexture();
  }
  get localTransform() {
    return this.root.localTransform;
  }
  addRenderGroupChild(t) {
    t.renderGroupParent && t.renderGroupParent._removeRenderGroupChild(t), t.renderGroupParent = this, this.renderGroupChildren.push(t);
  }
  _removeRenderGroupChild(t) {
    const e = this.renderGroupChildren.indexOf(t);
    e > -1 && this.renderGroupChildren.splice(e, 1), t.renderGroupParent = null;
  }
  addChild(t) {
    if (this.structureDidChange = !0, t.parentRenderGroup = this, t.updateTick = -1, t.parent === this.root ? t.relativeRenderGroupDepth = 1 : t.relativeRenderGroupDepth = t.parent.relativeRenderGroupDepth + 1, t.didChange = !0, this.onChildUpdate(t), t.renderGroup) {
      this.addRenderGroupChild(t.renderGroup);
      return;
    }
    t._onRender && this.addOnRender(t);
    const e = t.children;
    for (let i = 0; i < e.length; i++)
      this.addChild(e[i]);
  }
  removeChild(t) {
    if (this.structureDidChange = !0, t._onRender && (t.renderGroup || this.removeOnRender(t)), t.parentRenderGroup = null, t.renderGroup) {
      this._removeRenderGroupChild(t.renderGroup);
      return;
    }
    const e = t.children;
    for (let i = 0; i < e.length; i++)
      this.removeChild(e[i]);
  }
  removeChildren(t) {
    for (let e = 0; e < t.length; e++)
      this.removeChild(t[e]);
  }
  onChildUpdate(t) {
    let e = this.childrenToUpdate[t.relativeRenderGroupDepth];
    e || (e = this.childrenToUpdate[t.relativeRenderGroupDepth] = {
      index: 0,
      list: []
    }), e.list[e.index++] = t;
  }
  updateRenderable(t) {
    t.globalDisplayStatus < 7 || (this.instructionSet.renderPipes[t.renderPipeId].updateRenderable(t), t.didViewUpdate = !1);
  }
  onChildViewUpdate(t) {
    this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = t;
  }
  get isRenderable() {
    return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;
  }
  /**
   * adding a container to the onRender list will make sure the user function
   * passed in to the user defined 'onRender` callBack
   * @param container - the container to add to the onRender list
   */
  addOnRender(t) {
    this._onRenderContainers.push(t);
  }
  removeOnRender(t) {
    this._onRenderContainers.splice(this._onRenderContainers.indexOf(t), 1);
  }
  runOnRender(t) {
    for (let e = 0; e < this._onRenderContainers.length; e++)
      this._onRenderContainers[e]._onRender(t);
  }
  destroy() {
    this.disableCacheAsTexture(), this.renderGroupParent = null, this.root = null, this.childrenRenderablesToUpdate = null, this.childrenToUpdate = null, this.renderGroupChildren = null, this._onRenderContainers = null, this.instructionSet = null;
  }
  getChildren(t = []) {
    const e = this.root.children;
    for (let i = 0; i < e.length; i++)
      this._getChildren(e[i], t);
    return t;
  }
  _getChildren(t, e = []) {
    if (e.push(t), t.renderGroup)
      return e;
    const i = t.children;
    for (let s = 0; s < i.length; s++)
      this._getChildren(i[s], e);
    return e;
  }
  invalidateMatrices() {
    this._matrixDirty = 7;
  }
  /**
   * Returns the inverse of the world transform matrix.
   * @returns {Matrix} The inverse of the world transform matrix.
   */
  get inverseWorldTransform() {
    return (this._matrixDirty & 1) === 0 ? this._inverseWorldTransform : (this._matrixDirty &= -2, this._inverseWorldTransform || (this._inverseWorldTransform = new bt()), this._inverseWorldTransform.copyFrom(this.worldTransform).invert());
  }
  /**
   * Returns the inverse of the texture offset transform matrix.
   * @returns {Matrix} The inverse of the texture offset transform matrix.
   */
  get textureOffsetInverseTransform() {
    return (this._matrixDirty & 2) === 0 ? this._textureOffsetInverseTransform : (this._matrixDirty &= -3, this._textureOffsetInverseTransform || (this._textureOffsetInverseTransform = new bt()), this._textureOffsetInverseTransform.copyFrom(this.inverseWorldTransform).translate(
      -this._textureBounds.x,
      -this._textureBounds.y
    ));
  }
  /**
   * Returns the inverse of the parent texture transform matrix.
   * This is used to properly transform coordinates when rendering into cached textures.
   * @returns {Matrix} The inverse of the parent texture transform matrix.
   */
  get inverseParentTextureTransform() {
    if ((this._matrixDirty & 4) === 0)
      return this._inverseParentTextureTransform;
    this._matrixDirty &= -5;
    const t = this._parentCacheAsTextureRenderGroup;
    return t ? (this._inverseParentTextureTransform || (this._inverseParentTextureTransform = new bt()), this._inverseParentTextureTransform.copyFrom(this.worldTransform).prepend(t.inverseWorldTransform).translate(
      -t._textureBounds.x,
      -t._textureBounds.y
    )) : this.worldTransform;
  }
  /**
   * Returns a matrix that transforms coordinates to the correct coordinate space of the texture being rendered to.
   * This is the texture offset inverse transform of the closest parent RenderGroup that is cached as a texture.
   * @returns {Matrix | null} The transform matrix for the cached texture coordinate space,
   * or null if no parent is cached as texture.
   */
  get cacheToLocalTransform() {
    return this.isCachedAsTexture ? this.textureOffsetInverseTransform : this._parentCacheAsTextureRenderGroup ? this._parentCacheAsTextureRenderGroup.textureOffsetInverseTransform : null;
  }
}
function pA(n, t, e = {}) {
  for (const i in t)
    !e[i] && t[i] !== void 0 && (n[i] = t[i]);
}
const gp = new _n(null), _c = new _n(null), yp = new _n(null, 1, 1), Sc = new _n(null), nh = 1, eg = 2, Cl = 4;
class Rn extends Jn {
  constructor(t = {}) {
    super(), this.uid = Ee("renderable"), this._updateFlags = 15, this.renderGroup = null, this.parentRenderGroup = null, this.parentRenderGroupIndex = 0, this.didChange = !1, this.didViewUpdate = !1, this.relativeRenderGroupDepth = 0, this.children = [], this.parent = null, this.includeInBuild = !0, this.measurable = !0, this.isSimple = !0, this.updateTick = -1, this.localTransform = new bt(), this.relativeGroupTransform = new bt(), this.groupTransform = this.relativeGroupTransform, this.destroyed = !1, this._position = new _n(this, 0, 0), this._scale = yp, this._pivot = _c, this._origin = Sc, this._skew = gp, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._rotation = 0, this.localColor = 16777215, this.localAlpha = 1, this.groupAlpha = 1, this.groupColor = 16777215, this.groupColorAlpha = 4294967295, this.localBlendMode = "inherit", this.groupBlendMode = "normal", this.localDisplayStatus = 7, this.globalDisplayStatus = 7, this._didContainerChangeTick = 0, this._didViewChangeTick = 0, this._didLocalTransformChangeId = -1, this.effects = [], pA(this, t, {
      children: !0,
      parent: !0,
      effects: !0
    }), t.children?.forEach((e) => this.addChild(e)), t.parent?.addChild(this);
  }
  /**
   * Mixes all enumerable properties and methods from a source object to Container.
   * @param source - The source of properties and methods to mix in.
   * @deprecated since 8.8.0
   */
  static mixin(t) {
    zt("8.8.0", "Container.mixin is deprecated, please use extensions.mixin instead."), Nt.mixin(Rn, t);
  }
  // = 'default';
  /**
   * We now use the _didContainerChangeTick and _didViewChangeTick to track changes
   * @deprecated since 8.2.6
   * @ignore
   */
  set _didChangeId(t) {
    this._didViewChangeTick = t >> 12 & 4095, this._didContainerChangeTick = t & 4095;
  }
  /** @ignore */
  get _didChangeId() {
    return this._didContainerChangeTick & 4095 | (this._didViewChangeTick & 4095) << 12;
  }
  /**
   * Adds one or more children to the container.
   * The children will be rendered as part of this container's display list.
   * @example
   * ```ts
   * // Add a single child
   * container.addChild(sprite);
   *
   * // Add multiple children
   * container.addChild(background, player, foreground);
   *
   * // Add with type checking
   * const sprite = container.addChild<Sprite>(new Sprite(texture));
   * sprite.tint = 'red';
   * ```
   * @param children - The Container(s) to add to the container
   * @returns The first child that was added
   * @see {@link Container#removeChild} For removing children
   * @see {@link Container#addChildAt} For adding at specific index
   */
  addChild(...t) {
    if (this.allowChildren || zt(ae, "addChild: Only Containers will be allowed to add children in v8.0.0"), t.length > 1) {
      for (let s = 0; s < t.length; s++)
        this.addChild(t[s]);
      return t[0];
    }
    const e = t[0], i = this.renderGroup || this.parentRenderGroup;
    return e.parent === this ? (this.children.splice(this.children.indexOf(e), 1), this.children.push(e), i && (i.structureDidChange = !0), e) : (e.parent && e.parent.removeChild(e), this.children.push(e), this.sortableChildren && (this.sortDirty = !0), e.parent = this, e.didChange = !0, e._updateFlags = 15, i && i.addChild(e), this.emit("childAdded", e, this, this.children.length - 1), e.emit("added", this), this._didViewChangeTick++, e._zIndex !== 0 && e.depthOfChildModified(), e);
  }
  /**
   * Removes one or more children from the container.
   * When removing multiple children, events will be triggered for each child in sequence.
   * @example
   * ```ts
   * // Remove a single child
   * const removed = container.removeChild(sprite);
   *
   * // Remove multiple children
   * const bg = container.removeChild(background, player, userInterface);
   *
   * // Remove with type checking
   * const sprite = container.removeChild<Sprite>(childSprite);
   * sprite.texture = newTexture;
   * ```
   * @param children - The Container(s) to remove
   * @returns The first child that was removed
   * @see {@link Container#addChild} For adding children
   * @see {@link Container#removeChildren} For removing multiple children
   */
  removeChild(...t) {
    if (t.length > 1) {
      for (let s = 0; s < t.length; s++)
        this.removeChild(t[s]);
      return t[0];
    }
    const e = t[0], i = this.children.indexOf(e);
    return i > -1 && (this._didViewChangeTick++, this.children.splice(i, 1), this.renderGroup ? this.renderGroup.removeChild(e) : this.parentRenderGroup && this.parentRenderGroup.removeChild(e), e.parentRenderLayer && e.parentRenderLayer.detach(e), e.parent = null, this.emit("childRemoved", e, this, i), e.emit("removed", this)), e;
  }
  /** @ignore */
  _onUpdate(t) {
    t && t === this._skew && this._updateSkew(), this._didContainerChangeTick++, !this.didChange && (this.didChange = !0, this.parentRenderGroup && this.parentRenderGroup.onChildUpdate(this));
  }
  set isRenderGroup(t) {
    !!this.renderGroup !== t && (t ? this.enableRenderGroup() : this.disableRenderGroup());
  }
  /**
   * Returns true if this container is a render group.
   * This means that it will be rendered as a separate pass, with its own set of instructions
   * @advanced
   */
  get isRenderGroup() {
    return !!this.renderGroup;
  }
  /**
   * Calling this enables a render group for this container.
   * This means it will be rendered as a separate set of instructions.
   * The transform of the container will also be handled on the GPU rather than the CPU.
   * @advanced
   */
  enableRenderGroup() {
    if (this.renderGroup)
      return;
    const t = this.parentRenderGroup;
    t?.removeChild(this), this.renderGroup = Qe.get(dm, this), this.groupTransform = bt.IDENTITY, t?.addChild(this), this._updateIsSimple();
  }
  /**
   * This will disable the render group for this container.
   * @advanced
   */
  disableRenderGroup() {
    if (!this.renderGroup)
      return;
    const t = this.parentRenderGroup;
    t?.removeChild(this), Qe.return(this.renderGroup), this.renderGroup = null, this.groupTransform = this.relativeGroupTransform, t?.addChild(this), this._updateIsSimple();
  }
  /** @ignore */
  _updateIsSimple() {
    this.isSimple = !this.renderGroup && this.effects.length === 0;
  }
  /**
   * Current transform of the object based on world (parent) factors.
   *
   * This matrix represents the absolute transformation in the scene graph.
   * @example
   * ```ts
   * // Get world position
   * const worldPos = container.worldTransform;
   * console.log(`World position: (${worldPos.tx}, ${worldPos.ty})`);
   * ```
   * @readonly
   * @see {@link Container#localTransform} For local space transform
   */
  get worldTransform() {
    return this._worldTransform || (this._worldTransform = new bt()), this.renderGroup ? this._worldTransform.copyFrom(this.renderGroup.worldTransform) : this.parentRenderGroup && this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform), this._worldTransform;
  }
  /**
   * The position of the container on the x axis relative to the local coordinates of the parent.
   *
   * An alias to position.x
   * @example
   * ```ts
   * // Basic position
   * container.x = 100;
   * ```
   */
  get x() {
    return this._position.x;
  }
  set x(t) {
    this._position.x = t;
  }
  /**
   * The position of the container on the y axis relative to the local coordinates of the parent.
   *
   * An alias to position.y
   * @example
   * ```ts
   * // Basic position
   * container.y = 200;
   * ```
   */
  get y() {
    return this._position.y;
  }
  set y(t) {
    this._position.y = t;
  }
  /**
   * The coordinate of the object relative to the local coordinates of the parent.
   * @example
   * ```ts
   * // Basic position setting
   * container.position.set(100, 200);
   * container.position.set(100); // Sets both x and y to 100
   * // Using point data
   * container.position = { x: 50, y: 75 };
   * ```
   * @since 4.0.0
   */
  get position() {
    return this._position;
  }
  set position(t) {
    this._position.copyFrom(t);
  }
  /**
   * The rotation of the object in radians.
   *
   * > [!NOTE] 'rotation' and 'angle' have the same effect on a display object;
   * > rotation is in radians, angle is in degrees.
   * @example
   * ```ts
   * // Basic rotation
   * container.rotation = Math.PI / 4; // 45 degrees
   *
   * // Convert from degrees
   * const degrees = 45;
   * container.rotation = degrees * Math.PI / 180;
   *
   * // Rotate around center
   * container.pivot.set(container.width / 2, container.height / 2);
   * container.rotation = Math.PI; // 180 degrees
   *
   * // Rotate around center with origin
   * container.origin.set(container.width / 2, container.height / 2);
   * container.rotation = Math.PI; // 180 degrees
   * ```
   */
  get rotation() {
    return this._rotation;
  }
  set rotation(t) {
    this._rotation !== t && (this._rotation = t, this._onUpdate(this._skew));
  }
  /**
   * The angle of the object in degrees.
   *
   * > [!NOTE] 'rotation' and 'angle' have the same effect on a display object;
   * > rotation is in radians, angle is in degrees.
   * @example
   * ```ts
   * // Basic angle rotation
   * sprite.angle = 45; // 45 degrees
   *
   * // Rotate around center
   * sprite.pivot.set(sprite.width / 2, sprite.height / 2);
   * sprite.angle = 180; // Half rotation
   *
   * // Rotate around center with origin
   * sprite.origin.set(sprite.width / 2, sprite.height / 2);
   * sprite.angle = 180; // Half rotation
   *
   * // Reset rotation
   * sprite.angle = 0;
   * ```
   */
  get angle() {
    return this.rotation * kM;
  }
  set angle(t) {
    this.rotation = t * OM;
  }
  /**
   * The center of rotation, scaling, and skewing for this display object in its local space.
   * The `position` is the projection of `pivot` in the parent's local space.
   *
   * By default, the pivot is the origin (0, 0).
   * @example
   * ```ts
   * // Rotate around center
   * container.pivot.set(container.width / 2, container.height / 2);
   * container.rotation = Math.PI; // Rotates around center
   * ```
   * @since 4.0.0
   */
  get pivot() {
    return this._pivot === _c && (this._pivot = new _n(this, 0, 0)), this._pivot;
  }
  set pivot(t) {
    this._pivot === _c && (this._pivot = new _n(this, 0, 0), this._origin !== Sc && $t("Setting both a pivot and origin on a Container is not recommended. This can lead to unexpected behavior if not handled carefully.")), typeof t == "number" ? this._pivot.set(t) : this._pivot.copyFrom(t);
  }
  /**
   * The skew factor for the object in radians. Skewing is a transformation that distorts
   * the object by rotating it differently at each point, creating a non-uniform shape.
   * @example
   * ```ts
   * // Basic skewing
   * container.skew.set(0.5, 0); // Skew horizontally
   * container.skew.set(0, 0.5); // Skew vertically
   *
   * // Skew with point data
   * container.skew = { x: 0.3, y: 0.3 }; // Diagonal skew
   *
   * // Reset skew
   * container.skew.set(0, 0);
   *
   * // Animate skew
   * app.ticker.add(() => {
   *     // Create wave effect
   *     container.skew.x = Math.sin(Date.now() / 1000) * 0.3;
   * });
   *
   * // Combine with rotation
   * container.rotation = Math.PI / 4; // 45 degrees
   * container.skew.set(0.2, 0.2); // Skew the rotated object
   * ```
   * @since 4.0.0
   * @type {ObservablePoint} Point-like object with x/y properties in radians
   * @default {x: 0, y: 0}
   */
  get skew() {
    return this._skew === gp && (this._skew = new _n(this, 0, 0)), this._skew;
  }
  set skew(t) {
    this._skew === gp && (this._skew = new _n(this, 0, 0)), this._skew.copyFrom(t);
  }
  /**
   * The scale factors of this object along the local coordinate axes.
   *
   * The default scale is (1, 1).
   * @example
   * ```ts
   * // Basic scaling
   * container.scale.set(2, 2); // Scales to double size
   * container.scale.set(2); // Scales uniformly to double size
   * container.scale = 2; // Scales uniformly to double size
   * // Scale to a specific width and height
   * container.setSize(200, 100); // Sets width to 200 and height to 100
   * ```
   * @since 4.0.0
   */
  get scale() {
    return this._scale === yp && (this._scale = new _n(this, 1, 1)), this._scale;
  }
  set scale(t) {
    this._scale === yp && (this._scale = new _n(this, 0, 0)), typeof t == "string" && (t = parseFloat(t)), typeof t == "number" ? this._scale.set(t) : this._scale.copyFrom(t);
  }
  /**
   * @experimental
   * The origin point around which the container rotates and scales without affecting its position.
   * Unlike pivot, changing the origin will not move the container's position.
   * @example
   * ```ts
   * // Rotate around center point
   * container.origin.set(container.width / 2, container.height / 2);
   * container.rotation = Math.PI; // Rotates around center
   *
   * // Reset origin
   * container.origin.set(0, 0);
   * ```
   */
  get origin() {
    return this._origin === Sc && (this._origin = new _n(this, 0, 0)), this._origin;
  }
  set origin(t) {
    this._origin === Sc && (this._origin = new _n(this, 0, 0), this._pivot !== _c && $t("Setting both a pivot and origin on a Container is not recommended. This can lead to unexpected behavior if not handled carefully.")), typeof t == "number" ? this._origin.set(t) : this._origin.copyFrom(t);
  }
  /**
   * The width of the Container, setting this will actually modify the scale to achieve the value set.
   * > [!NOTE] Changing the width will adjust the scale.x property of the container while maintaining its aspect ratio.
   * > [!NOTE] If you want to set both width and height at the same time, use {@link Container#setSize}
   * as it is more optimized by not recalculating the local bounds twice.
   * @example
   * ```ts
   * // Basic width setting
   * container.width = 100;
   * // Optimized width setting
   * container.setSize(100, 100);
   * ```
   */
  get width() {
    return Math.abs(this.scale.x * this.getLocalBounds().width);
  }
  set width(t) {
    const e = this.getLocalBounds().width;
    this._setWidth(t, e);
  }
  /**
   * The height of the Container,
   * > [!NOTE] Changing the height will adjust the scale.y property of the container while maintaining its aspect ratio.
   * > [!NOTE] If you want to set both width and height at the same time, use {@link Container#setSize}
   * as it is more optimized by not recalculating the local bounds twice.
   * @example
   * ```ts
   * // Basic height setting
   * container.height = 200;
   * // Optimized height setting
   * container.setSize(100, 200);
   * ```
   */
  get height() {
    return Math.abs(this.scale.y * this.getLocalBounds().height);
  }
  set height(t) {
    const e = this.getLocalBounds().height;
    this._setHeight(t, e);
  }
  /**
   * Retrieves the size of the container as a [Size]{@link Size} object.
   *
   * This is faster than get the width and height separately.
   * @example
   * ```ts
   * // Basic size retrieval
   * const size = container.getSize();
   * console.log(`Size: ${size.width}x${size.height}`);
   *
   * // Reuse existing size object
   * const reuseSize = { width: 0, height: 0 };
   * container.getSize(reuseSize);
   * ```
   * @param out - Optional object to store the size in.
   * @returns The size of the container.
   */
  getSize(t) {
    t || (t = {});
    const e = this.getLocalBounds();
    return t.width = Math.abs(this.scale.x * e.width), t.height = Math.abs(this.scale.y * e.height), t;
  }
  /**
   * Sets the size of the container to the specified width and height.
   * This is more efficient than setting width and height separately as it only recalculates bounds once.
   * @example
   * ```ts
   * // Basic size setting
   * container.setSize(100, 200);
   *
   * // Set uniform size
   * container.setSize(100); // Sets both width and height to 100
   * ```
   * @param value - This can be either a number or a [Size]{@link Size} object.
   * @param height - The height to set. Defaults to the value of `width` if not provided.
   */
  setSize(t, e) {
    const i = this.getLocalBounds();
    typeof t == "object" ? (e = t.height ?? t.width, t = t.width) : e ?? (e = t), t !== void 0 && this._setWidth(t, i.width), e !== void 0 && this._setHeight(e, i.height);
  }
  /** Called when the skew or the rotation changes. */
  _updateSkew() {
    const t = this._rotation, e = this._skew;
    this._cx = Math.cos(t + e._y), this._sx = Math.sin(t + e._y), this._cy = -Math.sin(t - e._x), this._sy = Math.cos(t - e._x);
  }
  /**
   * Updates the transform properties of the container.
   * Allows partial updates of transform properties for optimized manipulation.
   * @example
   * ```ts
   * // Basic transform update
   * container.updateTransform({
   *     x: 100,
   *     y: 200,
   *     rotation: Math.PI / 4
   * });
   *
   * // Scale and rotate around center
   * sprite.updateTransform({
   *     pivotX: sprite.width / 2,
   *     pivotY: sprite.height / 2,
   *     scaleX: 2,
   *     scaleY: 2,
   *     rotation: Math.PI
   * });
   *
   * // Update position only
   * button.updateTransform({
   *     x: button.x + 10, // Move right
   *     y: button.y      // Keep same y
   * });
   * ```
   * @param opts - Transform options to update
   * @param opts.x - The x position
   * @param opts.y - The y position
   * @param opts.scaleX - The x-axis scale factor
   * @param opts.scaleY - The y-axis scale factor
   * @param opts.rotation - The rotation in radians
   * @param opts.skewX - The x-axis skew factor
   * @param opts.skewY - The y-axis skew factor
   * @param opts.pivotX - The x-axis pivot point
   * @param opts.pivotY - The y-axis pivot point
   * @returns This container, for chaining
   * @see {@link Container#setFromMatrix} For matrix-based transforms
   * @see {@link Container#position} For direct position access
   */
  updateTransform(t) {
    return this.position.set(
      typeof t.x == "number" ? t.x : this.position.x,
      typeof t.y == "number" ? t.y : this.position.y
    ), this.scale.set(
      typeof t.scaleX == "number" ? t.scaleX || 1 : this.scale.x,
      typeof t.scaleY == "number" ? t.scaleY || 1 : this.scale.y
    ), this.rotation = typeof t.rotation == "number" ? t.rotation : this.rotation, this.skew.set(
      typeof t.skewX == "number" ? t.skewX : this.skew.x,
      typeof t.skewY == "number" ? t.skewY : this.skew.y
    ), this.pivot.set(
      typeof t.pivotX == "number" ? t.pivotX : this.pivot.x,
      typeof t.pivotY == "number" ? t.pivotY : this.pivot.y
    ), this.origin.set(
      typeof t.originX == "number" ? t.originX : this.origin.x,
      typeof t.originY == "number" ? t.originY : this.origin.y
    ), this;
  }
  /**
   * Updates the local transform properties by decomposing the given matrix.
   * Extracts position, scale, rotation, and skew from a transformation matrix.
   * @example
   * ```ts
   * // Basic matrix transform
   * const matrix = new Matrix()
   *     .translate(100, 100)
   *     .rotate(Math.PI / 4)
   *     .scale(2, 2);
   *
   * container.setFromMatrix(matrix);
   *
   * // Copy transform from another container
   * const source = new Container();
   * source.position.set(100, 100);
   * source.rotation = Math.PI / 2;
   *
   * target.setFromMatrix(source.localTransform);
   *
   * // Reset transform
   * container.setFromMatrix(Matrix.IDENTITY);
   * ```
   * @param matrix - The matrix to use for updating the transform
   * @see {@link Container#updateTransform} For property-based updates
   * @see {@link Matrix#decompose} For matrix decomposition details
   */
  setFromMatrix(t) {
    t.decompose(this);
  }
  /** Updates the local transform. */
  updateLocalTransform() {
    const t = this._didContainerChangeTick;
    if (this._didLocalTransformChangeId === t)
      return;
    this._didLocalTransformChangeId = t;
    const e = this.localTransform, i = this._scale, s = this._pivot, o = this._origin, l = this._position, c = i._x, d = i._y, f = s._x, m = s._y, y = -o._x, b = -o._y;
    e.a = this._cx * c, e.b = this._sx * c, e.c = this._cy * d, e.d = this._sy * d, e.tx = l._x - (f * e.a + m * e.c) + (y * e.a + b * e.c) - y, e.ty = l._y - (f * e.b + m * e.d) + (y * e.b + b * e.d) - b;
  }
  // / ///// color related stuff
  set alpha(t) {
    t !== this.localAlpha && (this.localAlpha = t, this._updateFlags |= nh, this._onUpdate());
  }
  /**
   * The opacity of the object relative to its parent's opacity.
   * Value ranges from 0 (fully transparent) to 1 (fully opaque).
   * @example
   * ```ts
   * // Basic transparency
   * sprite.alpha = 0.5; // 50% opacity
   *
   * // Inherited opacity
   * container.alpha = 0.5;
   * const child = new Sprite(texture);
   * child.alpha = 0.5;
   * container.addChild(child);
   * // child's effective opacity is 0.25 (0.5 * 0.5)
   * ```
   * @default 1
   * @see {@link Container#visible} For toggling visibility
   * @see {@link Container#renderable} For render control
   */
  get alpha() {
    return this.localAlpha;
  }
  set tint(t) {
    const i = Pe.shared.setValue(t ?? 16777215).toBgrNumber();
    i !== this.localColor && (this.localColor = i, this._updateFlags |= nh, this._onUpdate());
  }
  /**
   * The tint applied to the sprite.
   *
   * This can be any valid {@link ColorSource}.
   * @example
   * ```ts
   * // Basic color tinting
   * container.tint = 0xff0000; // Red tint
   * container.tint = 'red';    // Same as above
   * container.tint = '#00ff00'; // Green
   * container.tint = 'rgb(0,0,255)'; // Blue
   *
   * // Remove tint
   * container.tint = 0xffffff; // White = no tint
   * container.tint = null;     // Also removes tint
   * ```
   * @default 0xFFFFFF
   * @see {@link Container#alpha} For transparency
   * @see {@link Container#visible} For visibility control
   */
  get tint() {
    return jc(this.localColor);
  }
  // / //////////////// blend related stuff
  set blendMode(t) {
    this.localBlendMode !== t && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this._updateFlags |= eg, this.localBlendMode = t, this._onUpdate());
  }
  /**
   * The blend mode to be applied to the sprite. Controls how pixels are blended when rendering.
   *
   * Setting to 'normal' will reset to default blending.
   * > [!NOTE] More blend modes are available after importing the `pixi.js/advanced-blend-modes` sub-export.
   * @example
   * ```ts
   * // Basic blend modes
   * sprite.blendMode = 'add';        // Additive blending
   * sprite.blendMode = 'multiply';   // Multiply colors
   * sprite.blendMode = 'screen';     // Screen blend
   *
   * // Reset blend mode
   * sprite.blendMode = 'normal';     // Normal blending
   * ```
   * @default 'normal'
   * @see {@link Container#alpha} For transparency
   * @see {@link Container#tint} For color adjustments
   */
  get blendMode() {
    return this.localBlendMode;
  }
  // / ///////// VISIBILITY / RENDERABLE /////////////////
  /**
   * The visibility of the object. If false the object will not be drawn,
   * and the transform will not be updated.
   * @example
   * ```ts
   * // Basic visibility toggle
   * sprite.visible = false; // Hide sprite
   * sprite.visible = true;  // Show sprite
   * ```
   * @default true
   * @see {@link Container#renderable} For render-only control
   * @see {@link Container#alpha} For transparency
   */
  get visible() {
    return !!(this.localDisplayStatus & 2);
  }
  set visible(t) {
    const e = t ? 2 : 0;
    (this.localDisplayStatus & 2) !== e && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this._updateFlags |= Cl, this.localDisplayStatus ^= 2, this._onUpdate());
  }
  /** @ignore */
  get culled() {
    return !(this.localDisplayStatus & 4);
  }
  /** @ignore */
  set culled(t) {
    const e = t ? 0 : 4;
    (this.localDisplayStatus & 4) !== e && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this._updateFlags |= Cl, this.localDisplayStatus ^= 4, this._onUpdate());
  }
  /**
   * Controls whether this object can be rendered. If false the object will not be drawn,
   * but the transform will still be updated. This is different from visible, which skips
   * transform updates.
   * @example
   * ```ts
   * // Basic render control
   * sprite.renderable = false; // Skip rendering
   * sprite.renderable = true;  // Enable rendering
   * ```
   * @default true
   * @see {@link Container#visible} For skipping transform updates
   * @see {@link Container#alpha} For transparency
   */
  get renderable() {
    return !!(this.localDisplayStatus & 1);
  }
  set renderable(t) {
    const e = t ? 1 : 0;
    (this.localDisplayStatus & 1) !== e && (this._updateFlags |= Cl, this.localDisplayStatus ^= 1, this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this._onUpdate());
  }
  /**
   * Whether or not the object should be rendered.
   * @advanced
   */
  get isRenderable() {
    return this.localDisplayStatus === 7 && this.groupAlpha > 0;
  }
  /**
   * Removes all internal references and listeners as well as removes children from the display list.
   * Do not use a Container after calling `destroy`.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @example
   * ```ts
   * container.destroy();
   * container.destroy(true);
   * container.destroy({ children: true });
   * container.destroy({ children: true, texture: true, textureSource: true });
   * ```
   */
  destroy(t = !1) {
    if (this.destroyed)
      return;
    this.destroyed = !0;
    let e;
    if (this.children.length && (e = this.removeChildren(0, this.children.length)), this.removeFromParent(), this.parent = null, this._maskEffect = null, this._filterEffect = null, this.effects = null, this._position = null, this._scale = null, this._pivot = null, this._origin = null, this._skew = null, this.emit("destroyed", this), this.removeAllListeners(), (typeof t == "boolean" ? t : t?.children) && e)
      for (let s = 0; s < e.length; ++s)
        e[s].destroy(t);
    this.renderGroup?.destroy(), this.renderGroup = null;
  }
}
Nt.mixin(
  Rn,
  QM,
  rA,
  hA,
  lA,
  oA,
  eA,
  nA,
  uA,
  XM,
  ZM,
  sA,
  JM
);
class d1 extends Rn {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor(t) {
    super(t), this.canBundle = !0, this.allowChildren = !1, this._roundPixels = 0, this._lastUsed = -1, this._gpuData = /* @__PURE__ */ Object.create(null), this._bounds = new Cn(0, 1, 0, 0), this._boundsDirty = !0;
  }
  /**
   * The local bounds of the view in its own coordinate space.
   * Bounds are automatically updated when the view's content changes.
   * @example
   * ```ts
   * // Get bounds dimensions
   * const bounds = view.bounds;
   * console.log(`Width: ${bounds.maxX - bounds.minX}`);
   * console.log(`Height: ${bounds.maxY - bounds.minY}`);
   * ```
   * @returns The rectangular bounds of the view
   * @see {@link Bounds} For bounds operations
   */
  get bounds() {
    return this._boundsDirty ? (this.updateBounds(), this._boundsDirty = !1, this._bounds) : this._bounds;
  }
  /**
   * Whether or not to round the x/y position of the sprite.
   * @example
   * ```ts
   * // Enable pixel rounding for crisp rendering
   * view.roundPixels = true;
   * ```
   * @default false
   */
  get roundPixels() {
    return !!this._roundPixels;
  }
  set roundPixels(t) {
    this._roundPixels = t ? 1 : 0;
  }
  /**
   * Checks if the object contains the given point in local coordinates.
   * Uses the view's bounds for hit testing.
   * @example
   * ```ts
   * // Basic point check
   * const localPoint = { x: 50, y: 25 };
   * const contains = view.containsPoint(localPoint);
   * console.log('Point is inside:', contains);
   * ```
   * @param point - The point to check in local coordinates
   * @returns True if the point is within the view's bounds
   * @see {@link ViewContainer#bounds} For the bounds used in hit testing
   * @see {@link Container#toLocal} For converting global coordinates to local
   */
  containsPoint(t) {
    const e = this.bounds, { x: i, y: s } = t;
    return i >= e.minX && i <= e.maxX && s >= e.minY && s <= e.maxY;
  }
  /** @private */
  onViewUpdate() {
    if (this._didViewChangeTick++, this._boundsDirty = !0, this.didViewUpdate)
      return;
    this.didViewUpdate = !0;
    const t = this.renderGroup || this.parentRenderGroup;
    t && t.onChildViewUpdate(this);
  }
  destroy(t) {
    super.destroy(t), this._bounds = null;
    for (const e in this._gpuData)
      this._gpuData[e].destroy?.();
    this._gpuData = null;
  }
  /**
   * Collects renderables for the view container.
   * @param instructionSet - The instruction set to collect renderables for.
   * @param renderer - The renderer to collect renderables for.
   * @param currentLayer - The current render layer.
   * @internal
   */
  collectRenderablesSimple(t, e, i) {
    const { renderPipes: s } = e;
    s.blendMode.pushBlendMode(this, this.groupBlendMode, t), s[this.renderPipeId].addRenderable(this, t), this.didViewUpdate = !1;
    const l = this.children, c = l.length;
    for (let d = 0; d < c; d++)
      l[d].collectRenderables(t, e, i);
    s.blendMode.popBlendMode(t);
  }
}
class ja extends d1 {
  /**
   * @param options - The options for creating the sprite.
   */
  constructor(t = Tt.EMPTY) {
    t instanceof Tt && (t = { texture: t });
    const { texture: e = Tt.EMPTY, anchor: i, roundPixels: s, width: o, height: l, ...c } = t;
    super({
      label: "Sprite",
      ...c
    }), this.renderPipeId = "sprite", this.batched = !0, this._visualBounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 }, this._anchor = new _n(
      {
        _onUpdate: () => {
          this.onViewUpdate();
        }
      }
    ), i ? this.anchor = i : e.defaultAnchor && (this.anchor = e.defaultAnchor), this.texture = e, this.allowChildren = !1, this.roundPixels = s ?? !1, o !== void 0 && (this.width = o), l !== void 0 && (this.height = l);
  }
  /**
   * Creates a new sprite based on a source texture, image, video, or canvas element.
   * This is a convenience method that automatically creates and manages textures.
   * @example
   * ```ts
   * // Create from path or URL
   * const sprite = Sprite.from('assets/image.png');
   *
   * // Create from existing texture
   * const sprite = Sprite.from(texture);
   *
   * // Create from canvas
   * const canvas = document.createElement('canvas');
   * const sprite = Sprite.from(canvas, true); // Skip caching new texture
   * ```
   * @param source - The source to create the sprite from. Can be a path to an image, a texture,
   * or any valid texture source (canvas, video, etc.)
   * @param skipCache - Whether to skip adding to the texture cache when creating a new texture
   * @returns A new sprite based on the source
   * @see {@link Texture.from} For texture creation details
   * @see {@link Assets} For asset loading and management
   */
  static from(t, e = !1) {
    return t instanceof Tt ? new ja(t) : new ja(Tt.from(t, e));
  }
  set texture(t) {
    t || (t = Tt.EMPTY);
    const e = this._texture;
    e !== t && (e && e.dynamic && e.off("update", this.onViewUpdate, this), t.dynamic && t.on("update", this.onViewUpdate, this), this._texture = t, this._width && this._setWidth(this._width, this._texture.orig.width), this._height && this._setHeight(this._height, this._texture.orig.height), this.onViewUpdate());
  }
  /**
   * The texture that is displayed by the sprite. When changed, automatically updates
   * the sprite dimensions and manages texture event listeners.
   * @example
   * ```ts
   * // Create sprite with texture
   * const sprite = new Sprite({
   *     texture: Texture.from('sprite.png')
   * });
   *
   * // Update texture
   * sprite.texture = Texture.from('newSprite.png');
   *
   * // Use texture from spritesheet
   * const sheet = await Assets.load('spritesheet.json');
   * sprite.texture = sheet.textures['frame1.png'];
   *
   * // Reset to empty texture
   * sprite.texture = Texture.EMPTY;
   * ```
   * @see {@link Texture} For texture creation and management
   * @see {@link Assets} For asset loading
   */
  get texture() {
    return this._texture;
  }
  /**
   * The bounds of the sprite, taking into account the texture's trim area.
   * @example
   * ```ts
   * const texture = new Texture({
   *     source: new TextureSource({ width: 300, height: 300 }),
   *     frame: new Rectangle(196, 66, 58, 56),
   *     trim: new Rectangle(4, 4, 58, 56),
   *     orig: new Rectangle(0, 0, 64, 64),
   *     rotate: 2,
   * });
   * const sprite = new Sprite(texture);
   * const visualBounds = sprite.visualBounds;
   * // console.log(visualBounds); // { minX: -4, maxX: 62, minY: -4, maxY: 60 }
   */
  get visualBounds() {
    return n1(this._visualBounds, this._anchor, this._texture), this._visualBounds;
  }
  /**
   * @deprecated
   * @ignore
   */
  get sourceBounds() {
    return zt("8.6.1", "Sprite.sourceBounds is deprecated, use visualBounds instead."), this.visualBounds;
  }
  /** @private */
  updateBounds() {
    const t = this._anchor, e = this._texture, i = this._bounds, { width: s, height: o } = e.orig;
    i.minX = -t._x * s, i.maxX = i.minX + s, i.minY = -t._y * o, i.maxY = i.minY + o;
  }
  /**
   * Destroys this sprite renderable and optionally its texture.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @example
   * sprite.destroy();
   * sprite.destroy(true);
   * sprite.destroy({ texture: true, textureSource: true });
   */
  destroy(t = !1) {
    if (super.destroy(t), typeof t == "boolean" ? t : t?.texture) {
      const i = typeof t == "boolean" ? t : t?.textureSource;
      this._texture.destroy(i);
    }
    this._texture = null, this._visualBounds = null, this._bounds = null, this._anchor = null, this._gpuData = null;
  }
  /**
   * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}
   * and passed to the constructor.
   *
   * - The default is `(0,0)`, this means the sprite's origin is the top left.
   * - Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.
   * - Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.
   *
   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
   * @example
   * ```ts
   * // Center the anchor point
   * sprite.anchor = 0.5; // Sets both x and y to 0.5
   * sprite.position.set(400, 300); // Sprite will be centered at this position
   *
   * // Set specific x/y anchor points
   * sprite.anchor = {
   *     x: 1, // Right edge
   *     y: 0  // Top edge
   * };
   *
   * // Using individual coordinates
   * sprite.anchor.set(0.5, 1); // Center-bottom
   *
   * // For rotation around center
   * sprite.anchor.set(0.5);
   * sprite.rotation = Math.PI / 4; // 45 degrees around center
   *
   * // For scaling from center
   * sprite.anchor.set(0.5);
   * sprite.scale.set(2); // Scales from center point
   * ```
   */
  get anchor() {
    return this._anchor;
  }
  set anchor(t) {
    typeof t == "number" ? this._anchor.set(t) : this._anchor.copyFrom(t);
  }
  /**
   * The width of the sprite, setting this will actually modify the scale to achieve the value set.
   * @example
   * ```ts
   * // Set width directly
   * sprite.width = 200;
   * console.log(sprite.scale.x); // Scale adjusted to match width
   *
   * // Set width while preserving aspect ratio
   * const ratio = sprite.height / sprite.width;
   * sprite.width = 300;
   * sprite.height = 300 * ratio;
   *
   * // For better performance when setting both width and height
   * sprite.setSize(300, 400); // Avoids recalculating bounds twice
   *
   * // Reset to original texture size
   * sprite.width = sprite.texture.orig.width;
   * ```
   */
  get width() {
    return Math.abs(this.scale.x) * this._texture.orig.width;
  }
  set width(t) {
    this._setWidth(t, this._texture.orig.width), this._width = t;
  }
  /**
   * The height of the sprite, setting this will actually modify the scale to achieve the value set.
   * @example
   * ```ts
   * // Set height directly
   * sprite.height = 150;
   * console.log(sprite.scale.y); // Scale adjusted to match height
   *
   * // Set height while preserving aspect ratio
   * const ratio = sprite.width / sprite.height;
   * sprite.height = 200;
   * sprite.width = 200 * ratio;
   *
   * // For better performance when setting both width and height
   * sprite.setSize(300, 400); // Avoids recalculating bounds twice
   *
   * // Reset to original texture size
   * sprite.height = sprite.texture.orig.height;
   * ```
   */
  get height() {
    return Math.abs(this.scale.y) * this._texture.orig.height;
  }
  set height(t) {
    this._setHeight(t, this._texture.orig.height), this._height = t;
  }
  /**
   * Retrieves the size of the Sprite as a [Size]{@link Size} object based on the texture dimensions and scale.
   * This is faster than getting width and height separately as it only calculates the bounds once.
   * @example
   * ```ts
   * // Basic size retrieval
   * const sprite = new Sprite(Texture.from('sprite.png'));
   * const size = sprite.getSize();
   * console.log(`Size: ${size.width}x${size.height}`);
   *
   * // Reuse existing size object
   * const reuseSize = { width: 0, height: 0 };
   * sprite.getSize(reuseSize);
   * ```
   * @param out - Optional object to store the size in, to avoid allocating a new object
   * @returns The size of the Sprite
   * @see {@link Sprite#width} For getting just the width
   * @see {@link Sprite#height} For getting just the height
   * @see {@link Sprite#setSize} For setting both width and height
   */
  getSize(t) {
    return t || (t = {}), t.width = Math.abs(this.scale.x) * this._texture.orig.width, t.height = Math.abs(this.scale.y) * this._texture.orig.height, t;
  }
  /**
   * Sets the size of the Sprite to the specified width and height.
   * This is faster than setting width and height separately as it only recalculates bounds once.
   * @example
   * ```ts
   * // Basic size setting
   * const sprite = new Sprite(Texture.from('sprite.png'));
   * sprite.setSize(100, 200); // Width: 100, Height: 200
   *
   * // Set uniform size
   * sprite.setSize(100); // Sets both width and height to 100
   *
   * // Set size with object
   * sprite.setSize({
   *     width: 200,
   *     height: 300
   * });
   *
   * // Reset to texture size
   * sprite.setSize(
   *     sprite.texture.orig.width,
   *     sprite.texture.orig.height
   * );
   * ```
   * @param value - This can be either a number or a {@link Size} object
   * @param height - The height to set. Defaults to the value of `width` if not provided
   * @see {@link Sprite#width} For setting width only
   * @see {@link Sprite#height} For setting height only
   * @see {@link Sprite#texture} For the source dimensions
   */
  setSize(t, e) {
    typeof t == "object" ? (e = t.height ?? t.width, t = t.width) : e ?? (e = t), t !== void 0 && this._setWidth(t, this._texture.orig.width), e !== void 0 && this._setHeight(e, this._texture.orig.height);
  }
}
const mA = new Cn();
function f1(n, t, e) {
  const i = mA;
  n.measurable = !0, Qm(n, e, i), t.addBoundsMask(i), n.measurable = !1;
}
function p1(n, t, e) {
  const i = mr.get();
  n.measurable = !0;
  const s = Mn.get().identity(), o = m1(n, e, s);
  tg(n, i, o), n.measurable = !1, t.addBoundsMask(i), Mn.return(s), mr.return(i);
}
function m1(n, t, e) {
  return n ? (n !== t && (m1(n.parent, t, e), n.updateLocalTransform(), e.append(n.localTransform)), e) : ($t("Mask bounds, renderable is not inside the root container"), e);
}
class g1 {
  constructor(t) {
    this.priority = 0, this.inverse = !1, this.pipe = "alphaMask", t?.mask && this.init(t.mask);
  }
  init(t) {
    this.mask = t, this.renderMaskToTexture = !(t instanceof ja), this.mask.renderable = this.renderMaskToTexture, this.mask.includeInBuild = !this.renderMaskToTexture, this.mask.measurable = !1;
  }
  reset() {
    this.mask.measurable = !0, this.mask = null;
  }
  addBounds(t, e) {
    this.inverse || f1(this.mask, t, e);
  }
  addLocalBounds(t, e) {
    p1(this.mask, t, e);
  }
  containsPoint(t, e) {
    const i = this.mask;
    return e(i, t);
  }
  destroy() {
    this.reset();
  }
  static test(t) {
    return t instanceof ja;
  }
}
g1.extension = W.MaskEffect;
class y1 {
  constructor(t) {
    this.priority = 0, this.pipe = "colorMask", t?.mask && this.init(t.mask);
  }
  init(t) {
    this.mask = t;
  }
  destroy() {
  }
  static test(t) {
    return typeof t == "number";
  }
}
y1.extension = W.MaskEffect;
class b1 {
  constructor(t) {
    this.priority = 0, this.pipe = "stencilMask", t?.mask && this.init(t.mask);
  }
  init(t) {
    this.mask = t, this.mask.includeInBuild = !1, this.mask.measurable = !1;
  }
  reset() {
    this.mask.measurable = !0, this.mask.includeInBuild = !0, this.mask = null;
  }
  addBounds(t, e) {
    f1(this.mask, t, e);
  }
  addLocalBounds(t, e) {
    p1(this.mask, t, e);
  }
  containsPoint(t, e) {
    const i = this.mask;
    return e(i, t);
  }
  destroy() {
    this.reset();
  }
  static test(t) {
    return t instanceof Rn;
  }
}
b1.extension = W.MaskEffect;
const gA = {
  createCanvas: (n, t) => {
    const e = document.createElement("canvas");
    return e.width = n, e.height = t, e;
  },
  createImage: () => new Image(),
  getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
  getWebGLRenderingContext: () => WebGLRenderingContext,
  getNavigator: () => navigator,
  getBaseUrl: () => document.baseURI ?? window.location.href,
  getFontFaceSet: () => document.fonts,
  fetch: (n, t) => fetch(n, t),
  parseXML: (n) => new DOMParser().parseFromString(n, "text/xml")
};
let x_ = gA;
const ve = {
  /**
   * Returns the current adapter.
   * @returns {environment.Adapter} The current adapter.
   */
  get() {
    return x_;
  },
  /**
   * Sets the current adapter.
   * @param adapter - The new adapter.
   */
  set(n) {
    x_ = n;
  }
};
class gr extends rn {
  constructor(t) {
    t.resource || (t.resource = ve.get().createCanvas()), t.width || (t.width = t.resource.width, t.autoDensity || (t.width /= t.resolution)), t.height || (t.height = t.resource.height, t.autoDensity || (t.height /= t.resolution)), super(t), this.uploadMethodId = "image", this.autoDensity = t.autoDensity, this.resizeCanvas(), this.transparent = !!t.transparent;
  }
  resizeCanvas() {
    this.autoDensity && "style" in this.resource && (this.resource.style.width = `${this.width}px`, this.resource.style.height = `${this.height}px`), (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight) && (this.resource.width = this.pixelWidth, this.resource.height = this.pixelHeight);
  }
  resize(t = this.width, e = this.height, i = this._resolution) {
    const s = super.resize(t, e, i);
    return s && this.resizeCanvas(), s;
  }
  static test(t) {
    return globalThis.HTMLCanvasElement && t instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && t instanceof OffscreenCanvas;
  }
  /**
   * Returns the 2D rendering context for the canvas.
   * Caches the context after creating it.
   * @returns The 2D rendering context of the canvas.
   */
  get context2D() {
    return this._context2D || (this._context2D = this.resource.getContext("2d"));
  }
}
gr.extension = W.TextureSource;
class Gl extends rn {
  constructor(t) {
    super(t), this.uploadMethodId = "image", this.autoGarbageCollect = !0;
  }
  static test(t) {
    return globalThis.HTMLImageElement && t instanceof HTMLImageElement || typeof ImageBitmap < "u" && t instanceof ImageBitmap || globalThis.VideoFrame && t instanceof VideoFrame;
  }
}
Gl.extension = W.TextureSource;
var Ya = /* @__PURE__ */ ((n) => (n[n.INTERACTION = 50] = "INTERACTION", n[n.HIGH = 25] = "HIGH", n[n.NORMAL = 0] = "NORMAL", n[n.LOW = -25] = "LOW", n[n.UTILITY = -50] = "UTILITY", n))(Ya || {});
class bp {
  /**
   * Constructor
   * @private
   * @param fn - The listener function to be added for one update
   * @param context - The listener context
   * @param priority - The priority for emitting
   * @param once - If the handler should fire once
   */
  constructor(t, e = null, i = 0, s = !1) {
    this.next = null, this.previous = null, this._destroyed = !1, this._fn = t, this._context = e, this.priority = i, this._once = s;
  }
  /**
   * Simple compare function to figure out if a function and context match.
   * @param fn - The listener function to be added for one update
   * @param context - The listener context
   * @returns `true` if the listener match the arguments
   */
  match(t, e = null) {
    return this._fn === t && this._context === e;
  }
  /**
   * Emit by calling the current function.
   * @param ticker - The ticker emitting.
   * @returns Next ticker
   */
  emit(t) {
    this._fn && (this._context ? this._fn.call(this._context, t) : this._fn(t));
    const e = this.next;
    return this._once && this.destroy(!0), this._destroyed && (this.next = null), e;
  }
  /**
   * Connect to the list.
   * @param previous - Input node, previous listener
   */
  connect(t) {
    this.previous = t, t.next && (t.next.previous = this), this.next = t.next, t.next = this;
  }
  /**
   * Destroy and don't use after this.
   * @param hard - `true` to remove the `next` reference, this
   *        is considered a hard destroy. Soft destroy maintains the next reference.
   * @returns The listener to redirect while emitting or removing.
   */
  destroy(t = !1) {
    this._destroyed = !0, this._fn = null, this._context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);
    const e = this.next;
    return this.next = t ? null : e, this.previous = null, e;
  }
}
const v1 = class Yn {
  constructor() {
    this.autoStart = !1, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = !1, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = !1, this._lastFrame = -1, this._head = new bp(null, null, 1 / 0), this.deltaMS = 1 / Yn.targetFPMS, this.elapsedMS = 1 / Yn.targetFPMS, this._tick = (t) => {
      this._requestId = null, this.started && (this.update(t), this.started && this._requestId === null && this._head.next && (this._requestId = requestAnimationFrame(this._tick)));
    };
  }
  /**
   * Conditionally requests a new animation frame.
   * If a frame has not already been requested, and if the internal
   * emitter has listeners, a new frame is requested.
   */
  _requestIfNeeded() {
    this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick));
  }
  /** Conditionally cancels a pending animation frame. */
  _cancelIfNeeded() {
    this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null);
  }
  /**
   * Conditionally requests a new animation frame.
   * If the ticker has been started it checks if a frame has not already
   * been requested, and if the internal emitter has listeners. If these
   * conditions are met, a new frame is requested. If the ticker has not
   * been started, but autoStart is `true`, then the ticker starts now,
   * and continues with the previous conditions to request a new frame.
   */
  _startIfPossible() {
    this.started ? this._requestIfNeeded() : this.autoStart && this.start();
  }
  /**
   * Register a handler for tick events.
   * @param fn - The listener function to add. Receives the Ticker instance as parameter
   * @param context - The context for the listener
   * @param priority - The priority of the listener
   * @example
   * ```ts
   * // Access time properties through the ticker parameter
   * ticker.add((ticker) => {
   *     // Use deltaTime (dimensionless scalar) for frame-independent animations
   *     sprite.rotation += 0.1 * ticker.deltaTime;
   *
   *     // Use deltaMS (milliseconds) for time-based calculations
   *     const progress = ticker.deltaMS / animationDuration;
   *
   *     // Use elapsedMS for raw timing measurements
   *     console.log(`Raw frame time: ${ticker.elapsedMS}ms`);
   * });
   * ```
   */
  add(t, e, i = Ya.NORMAL) {
    return this._addListener(new bp(t, e, i));
  }
  /**
   * Add a handler for the tick event which is only executed once on the next frame.
   * @example
   * ```ts
   * // Basic one-time update
   * ticker.addOnce(() => {
   *     console.log('Runs next frame only');
   * });
   *
   * // With specific context
   * const game = {
   *     init(ticker) {
   *         this.loadResources();
   *         console.log('Game initialized');
   *     }
   * };
   * ticker.addOnce(game.init, game);
   *
   * // With priority
   * ticker.addOnce(
   *     () => {
   *         // High priority one-time setup
   *         physics.init();
   *     },
   *     undefined,
   *     UPDATE_PRIORITY.HIGH
   * );
   * ```
   * @param fn - The listener function to be added for one update
   * @param context - The listener context
   * @param priority - The priority for emitting (default: UPDATE_PRIORITY.NORMAL)
   * @returns This instance of a ticker
   * @see {@link Ticker#add} For continuous updates
   * @see {@link Ticker#remove} For removing handlers
   */
  addOnce(t, e, i = Ya.NORMAL) {
    return this._addListener(new bp(t, e, i, !0));
  }
  /**
   * Internally adds the event handler so that it can be sorted by priority.
   * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run
   * before the rendering.
   * @private
   * @param listener - Current listener being added.
   * @returns This instance of a ticker
   */
  _addListener(t) {
    let e = this._head.next, i = this._head;
    if (!e)
      t.connect(i);
    else {
      for (; e; ) {
        if (t.priority > e.priority) {
          t.connect(i);
          break;
        }
        i = e, e = e.next;
      }
      t.previous || t.connect(i);
    }
    return this._startIfPossible(), this;
  }
  /**
   * Removes any handlers matching the function and context parameters.
   * If no handlers are left after removing, then it cancels the animation frame.
   * @example
   * ```ts
   * // Basic removal
   * const onTick = () => {
   *     sprite.rotation += 0.1;
   * };
   * ticker.add(onTick);
   * ticker.remove(onTick);
   *
   * // Remove with context
   * const game = {
   *     update(ticker) {
   *         this.physics.update(ticker.deltaTime);
   *     }
   * };
   * ticker.add(game.update, game);
   * ticker.remove(game.update, game);
   *
   * // Remove all matching handlers
   * // (if same function was added multiple times)
   * ticker.add(onTick);
   * ticker.add(onTick);
   * ticker.remove(onTick); // Removes all instances
   * ```
   * @param fn - The listener function to be removed
   * @param context - The listener context to be removed
   * @returns This instance of a ticker
   * @see {@link Ticker#add} For adding handlers
   * @see {@link Ticker#addOnce} For one-time handlers
   */
  remove(t, e) {
    let i = this._head.next;
    for (; i; )
      i.match(t, e) ? i = i.destroy() : i = i.next;
    return this._head.next || this._cancelIfNeeded(), this;
  }
  /**
   * The number of listeners on this ticker, calculated by walking through linked list.
   * @example
   * ```ts
   * // Check number of active listeners
   * const ticker = new Ticker();
   * console.log(ticker.count); // 0
   *
   * // Add some listeners
   * ticker.add(() => {});
   * ticker.add(() => {});
   * console.log(ticker.count); // 2
   *
   * // Check after cleanup
   * ticker.destroy();
   * console.log(ticker.count); // 0
   * ```
   * @readonly
   * @see {@link Ticker#add} For adding listeners
   * @see {@link Ticker#remove} For removing listeners
   */
  get count() {
    if (!this._head)
      return 0;
    let t = 0, e = this._head;
    for (; e = e.next; )
      t++;
    return t;
  }
  /**
   * Starts the ticker. If the ticker has listeners a new animation frame is requested at this point.
   * @example
   * ```ts
   * // Basic manual start
   * const ticker = new Ticker();
   * ticker.add(() => {
   *     // Animation code here
   * });
   * ticker.start();
   * ```
   * @see {@link Ticker#stop} For stopping the ticker
   * @see {@link Ticker#autoStart} For automatic starting
   * @see {@link Ticker#started} For checking ticker state
   */
  start() {
    this.started || (this.started = !0, this._requestIfNeeded());
  }
  /**
   * Stops the ticker. If the ticker has requested an animation frame it is canceled at this point.
   * @example
   * ```ts
   * // Basic stop
   * const ticker = new Ticker();
   * ticker.stop();
   * ```
   * @see {@link Ticker#start} For starting the ticker
   * @see {@link Ticker#started} For checking ticker state
   * @see {@link Ticker#destroy} For cleaning up the ticker
   */
  stop() {
    this.started && (this.started = !1, this._cancelIfNeeded());
  }
  /**
   * Destroy the ticker and don't use after this. Calling this method removes all references to internal events.
   * @example
   * ```ts
   * // Clean up with active listeners
   * const ticker = new Ticker();
   * ticker.add(() => {});
   * ticker.destroy(); // Removes all listeners
   * ```
   * @see {@link Ticker#stop} For stopping without destroying
   * @see {@link Ticker#remove} For removing specific listeners
   */
  destroy() {
    if (!this._protected) {
      this.stop();
      let t = this._head.next;
      for (; t; )
        t = t.destroy(!0);
      this._head.destroy(), this._head = null;
    }
  }
  /**
   * Triggers an update.
   *
   * An update entails setting the
   * current {@link Ticker#elapsedMS|elapsedMS},
   * the current {@link Ticker#deltaTime|deltaTime},
   * invoking all listeners with current deltaTime,
   * and then finally setting {@link Ticker#lastTime|lastTime}
   * with the value of currentTime that was provided.
   *
   * This method will be called automatically by animation
   * frame callbacks if the ticker instance has been started
   * and listeners are added.
   * @example
   * ```ts
   * // Basic manual update
   * const ticker = new Ticker();
   * ticker.update(performance.now());
   * ```
   * @param currentTime - The current time of execution (defaults to performance.now())
   * @see {@link Ticker#deltaTime} For frame delta value
   * @see {@link Ticker#elapsedMS} For raw elapsed time
   */
  update(t = performance.now()) {
    let e;
    if (t > this.lastTime) {
      if (e = this.elapsedMS = t - this.lastTime, e > this._maxElapsedMS && (e = this._maxElapsedMS), e *= this.speed, this._minElapsedMS) {
        const o = t - this._lastFrame | 0;
        if (o < this._minElapsedMS)
          return;
        this._lastFrame = t - o % this._minElapsedMS;
      }
      this.deltaMS = e, this.deltaTime = this.deltaMS * Yn.targetFPMS;
      const i = this._head;
      let s = i.next;
      for (; s; )
        s = s.emit(this);
      i.next || this._cancelIfNeeded();
    } else
      this.deltaTime = this.deltaMS = this.elapsedMS = 0;
    this.lastTime = t;
  }
  /**
   * The frames per second at which this ticker is running.
   * The default is approximately 60 in most modern browsers.
   * > [!NOTE] This does not factor in the value of
   * > {@link Ticker#speed|speed}, which is specific
   * > to scaling {@link Ticker#deltaTime|deltaTime}.
   * @example
   * ```ts
   * // Basic FPS monitoring
   * ticker.add(() => {
   *     console.log(`Current FPS: ${Math.round(ticker.FPS)}`);
   * });
   * ```
   * @readonly
   */
  get FPS() {
    return 1e3 / this.elapsedMS;
  }
  /**
   * Manages the maximum amount of milliseconds allowed to
   * elapse between invoking {@link Ticker#update|update}.
   *
   * This value is used to cap {@link Ticker#deltaTime|deltaTime},
   * but does not effect the measured value of {@link Ticker#FPS|FPS}.
   *
   * When setting this property it is clamped to a value between
   * `0` and `Ticker.targetFPMS * 1000`.
   * @example
   * ```ts
   * // Set minimum acceptable frame rate
   * const ticker = new Ticker();
   * ticker.minFPS = 30; // Never go below 30 FPS
   *
   * // Use with maxFPS for frame rate clamping
   * ticker.minFPS = 30;
   * ticker.maxFPS = 60;
   *
   * // Monitor delta capping
   * ticker.add(() => {
   *     // Delta time will be capped based on minFPS
   *     console.log(`Delta time: ${ticker.deltaTime}`);
   * });
   * ```
   * @default 10
   */
  get minFPS() {
    return 1e3 / this._maxElapsedMS;
  }
  set minFPS(t) {
    const e = Math.min(this.maxFPS, t), i = Math.min(Math.max(0, e) / 1e3, Yn.targetFPMS);
    this._maxElapsedMS = 1 / i;
  }
  /**
   * Manages the minimum amount of milliseconds required to
   * elapse between invoking {@link Ticker#update|update}.
   *
   * This will effect the measured value of {@link Ticker#FPS|FPS}.
   *
   * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.
   * Otherwise it will be at least `minFPS`
   * @example
   * ```ts
   * // Set minimum acceptable frame rate
   * const ticker = new Ticker();
   * ticker.maxFPS = 60; // Never go above 60 FPS
   *
   * // Use with maxFPS for frame rate clamping
   * ticker.minFPS = 30;
   * ticker.maxFPS = 60;
   *
   * // Monitor delta capping
   * ticker.add(() => {
   *     // Delta time will be capped based on maxFPS
   *     console.log(`Delta time: ${ticker.deltaTime}`);
   * });
   * ```
   * @default 0
   */
  get maxFPS() {
    return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0;
  }
  set maxFPS(t) {
    if (t === 0)
      this._minElapsedMS = 0;
    else {
      const e = Math.max(this.minFPS, t);
      this._minElapsedMS = 1 / (e / 1e3);
    }
  }
  /**
   * The shared ticker instance used by {@link AnimatedSprite} and by
   * {@link VideoSource} to update animation frames / video textures.
   *
   * It may also be used by {@link Application} if created with the `sharedTicker` option property set to true.
   *
   * The property {@link Ticker#autoStart|autoStart} is set to `true` for this instance.
   * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.
   * @example
   * import { Ticker } from 'pixi.js';
   *
   * const ticker = Ticker.shared;
   * // Set this to prevent starting this ticker when listeners are added.
   * // By default this is true only for the Ticker.shared instance.
   * ticker.autoStart = false;
   *
   * // FYI, call this to ensure the ticker is stopped. It should be stopped
   * // if you have not attempted to render anything yet.
   * ticker.stop();
   *
   * // Call this when you are ready for a running shared ticker.
   * ticker.start();
   * @example
   * import { autoDetectRenderer, Container } from 'pixi.js';
   *
   * // You may use the shared ticker to render...
   * const renderer = autoDetectRenderer();
   * const stage = new Container();
   * document.body.appendChild(renderer.view);
   * ticker.add((time) => renderer.render(stage));
   *
   * // Or you can just update it manually.
   * ticker.autoStart = false;
   * ticker.stop();
   * const animate = (time) => {
   *     ticker.update(time);
   *     renderer.render(stage);
   *     requestAnimationFrame(animate);
   * };
   * animate(performance.now());
   * @type {Ticker}
   * @readonly
   */
  static get shared() {
    if (!Yn._shared) {
      const t = Yn._shared = new Yn();
      t.autoStart = !0, t._protected = !0;
    }
    return Yn._shared;
  }
  /**
   * The system ticker instance used by {@link PrepareBase} for core timing
   * functionality that shouldn't usually need to be paused, unlike the `shared`
   * ticker which drives visual animations and rendering which may want to be paused.
   *
   * The property {@link Ticker#autoStart|autoStart} is set to `true` for this instance.
   * @type {Ticker}
   * @readonly
   * @advanced
   */
  static get system() {
    if (!Yn._system) {
      const t = Yn._system = new Yn();
      t.autoStart = !0, t._protected = !0;
    }
    return Yn._system;
  }
};
v1.targetFPMS = 0.06;
let Kn = v1, vp;
async function yA() {
  return vp ?? (vp = (async () => {
    const t = ve.get().createCanvas(1, 1).getContext("webgl");
    if (!t)
      return "premultiply-alpha-on-upload";
    const e = await new Promise((l) => {
      const c = document.createElement("video");
      c.onloadeddata = () => l(c), c.onerror = () => l(null), c.autoplay = !1, c.crossOrigin = "anonymous", c.preload = "auto", c.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=", c.load();
    });
    if (!e)
      return "premultiply-alpha-on-upload";
    const i = t.createTexture();
    t.bindTexture(t.TEXTURE_2D, i);
    const s = t.createFramebuffer();
    t.bindFramebuffer(t.FRAMEBUFFER, s), t.framebufferTexture2D(
      t.FRAMEBUFFER,
      t.COLOR_ATTACHMENT0,
      t.TEXTURE_2D,
      i,
      0
    ), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, t.NONE), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, e);
    const o = new Uint8Array(4);
    return t.readPixels(0, 0, 1, 1, t.RGBA, t.UNSIGNED_BYTE, o), t.deleteFramebuffer(s), t.deleteTexture(i), t.getExtension("WEBGL_lose_context")?.loseContext(), o[0] <= o[3] ? "premultiplied-alpha" : "premultiply-alpha-on-upload";
  })()), vp;
}
const _h = class x1 extends rn {
  constructor(t) {
    super(t), this.isReady = !1, this.uploadMethodId = "video", t = {
      ...x1.defaultOptions,
      ...t
    }, this._autoUpdate = !0, this._isConnectedToTicker = !1, this._updateFPS = t.updateFPS || 0, this._msToNextUpdate = 0, this.autoPlay = t.autoPlay !== !1, this.alphaMode = t.alphaMode ?? "premultiply-alpha-on-upload", this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this), this._videoFrameRequestCallbackHandle = null, this._load = null, this._resolve = null, this._reject = null, this._onCanPlay = this._onCanPlay.bind(this), this._onCanPlayThrough = this._onCanPlayThrough.bind(this), this._onError = this._onError.bind(this), this._onPlayStart = this._onPlayStart.bind(this), this._onPlayStop = this._onPlayStop.bind(this), this._onSeeked = this._onSeeked.bind(this), t.autoLoad !== !1 && this.load();
  }
  /** Update the video frame if the source is not destroyed and meets certain conditions. */
  updateFrame() {
    if (!this.destroyed) {
      if (this._updateFPS) {
        const t = Kn.shared.elapsedMS * this.resource.playbackRate;
        this._msToNextUpdate = Math.floor(this._msToNextUpdate - t);
      }
      (!this._updateFPS || this._msToNextUpdate <= 0) && (this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0), this.isValid && this.update();
    }
  }
  /** Callback to update the video frame and potentially request the next frame update. */
  _videoFrameRequestCallback() {
    this.updateFrame(), this.destroyed ? this._videoFrameRequestCallbackHandle = null : this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(
      this._videoFrameRequestCallback
    );
  }
  /**
   * Checks if the resource has valid dimensions.
   * @returns {boolean} True if width and height are set, otherwise false.
   */
  get isValid() {
    return !!this.resource.videoWidth && !!this.resource.videoHeight;
  }
  /**
   * Start preloading the video resource.
   * @returns {Promise<this>} Handle the validate event
   */
  async load() {
    if (this._load)
      return this._load;
    const t = this.resource, e = this.options;
    return (t.readyState === t.HAVE_ENOUGH_DATA || t.readyState === t.HAVE_FUTURE_DATA) && t.width && t.height && (t.complete = !0), t.addEventListener("play", this._onPlayStart), t.addEventListener("pause", this._onPlayStop), t.addEventListener("seeked", this._onSeeked), this._isSourceReady() ? this._mediaReady() : (e.preload || t.addEventListener("canplay", this._onCanPlay), t.addEventListener("canplaythrough", this._onCanPlayThrough), t.addEventListener("error", this._onError, !0)), this.alphaMode = await yA(), this._load = new Promise((i, s) => {
      this.isValid ? i(this) : (this._resolve = i, this._reject = s, e.preloadTimeoutMs !== void 0 && (this._preloadTimeout = setTimeout(() => {
        this._onError(new ErrorEvent(`Preload exceeded timeout of ${e.preloadTimeoutMs}ms`));
      })), t.load());
    }), this._load;
  }
  /**
   * Handle video error events.
   * @param event - The error event
   */
  _onError(t) {
    this.resource.removeEventListener("error", this._onError, !0), this.emit("error", t), this._reject && (this._reject(t), this._reject = null, this._resolve = null);
  }
  /**
   * Checks if the underlying source is playing.
   * @returns True if playing.
   */
  _isSourcePlaying() {
    const t = this.resource;
    return !t.paused && !t.ended;
  }
  /**
   * Checks if the underlying source is ready for playing.
   * @returns True if ready.
   */
  _isSourceReady() {
    return this.resource.readyState > 2;
  }
  /** Runs the update loop when the video is ready to play. */
  _onPlayStart() {
    this.isValid || this._mediaReady(), this._configureAutoUpdate();
  }
  /** Stops the update loop when a pause event is triggered. */
  _onPlayStop() {
    this._configureAutoUpdate();
  }
  /** Handles behavior when the video completes seeking to the current playback position. */
  _onSeeked() {
    this._autoUpdate && !this._isSourcePlaying() && (this._msToNextUpdate = 0, this.updateFrame(), this._msToNextUpdate = 0);
  }
  _onCanPlay() {
    this.resource.removeEventListener("canplay", this._onCanPlay), this._mediaReady();
  }
  _onCanPlayThrough() {
    this.resource.removeEventListener("canplaythrough", this._onCanPlay), this._preloadTimeout && (clearTimeout(this._preloadTimeout), this._preloadTimeout = void 0), this._mediaReady();
  }
  /** Fired when the video is loaded and ready to play. */
  _mediaReady() {
    const t = this.resource;
    this.isValid && (this.isReady = !0, this.resize(t.videoWidth, t.videoHeight)), this._msToNextUpdate = 0, this.updateFrame(), this._msToNextUpdate = 0, this._resolve && (this._resolve(this), this._resolve = null, this._reject = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && this.resource.play();
  }
  /** Cleans up resources and event listeners associated with this texture. */
  destroy() {
    this._configureAutoUpdate();
    const t = this.resource;
    t && (t.removeEventListener("play", this._onPlayStart), t.removeEventListener("pause", this._onPlayStop), t.removeEventListener("seeked", this._onSeeked), t.removeEventListener("canplay", this._onCanPlay), t.removeEventListener("canplaythrough", this._onCanPlayThrough), t.removeEventListener("error", this._onError, !0), t.pause(), t.src = "", t.load()), super.destroy();
  }
  /** Should the base texture automatically update itself, set to true by default. */
  get autoUpdate() {
    return this._autoUpdate;
  }
  set autoUpdate(t) {
    t !== this._autoUpdate && (this._autoUpdate = t, this._configureAutoUpdate());
  }
  /**
   * How many times a second to update the texture from the video.
   * Leave at 0 to update at every render.
   * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.
   */
  get updateFPS() {
    return this._updateFPS;
  }
  set updateFPS(t) {
    t !== this._updateFPS && (this._updateFPS = t, this._configureAutoUpdate());
  }
  /**
   * Configures the updating mechanism based on the current state and settings.
   *
   * This method decides between using the browser's native video frame callback or a custom ticker
   * for updating the video frame. It ensures optimal performance and responsiveness
   * based on the video's state, playback status, and the desired frames-per-second setting.
   *
   * - If `_autoUpdate` is enabled and the video source is playing:
   *   - It will prefer the native video frame callback if available and no specific FPS is set.
   *   - Otherwise, it will use a custom ticker for manual updates.
   * - If `_autoUpdate` is disabled or the video isn't playing, any active update mechanisms are halted.
   */
  _configureAutoUpdate() {
    this._autoUpdate && this._isSourcePlaying() ? !this._updateFPS && this.resource.requestVideoFrameCallback ? (this._isConnectedToTicker && (Kn.shared.remove(this.updateFrame, this), this._isConnectedToTicker = !1, this._msToNextUpdate = 0), this._videoFrameRequestCallbackHandle === null && (this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(
      this._videoFrameRequestCallback
    ))) : (this._videoFrameRequestCallbackHandle !== null && (this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker || (Kn.shared.add(this.updateFrame, this), this._isConnectedToTicker = !0, this._msToNextUpdate = 0)) : (this._videoFrameRequestCallbackHandle !== null && (this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker && (Kn.shared.remove(this.updateFrame, this), this._isConnectedToTicker = !1, this._msToNextUpdate = 0));
  }
  static test(t) {
    return globalThis.HTMLVideoElement && t instanceof HTMLVideoElement;
  }
};
_h.extension = W.TextureSource;
_h.defaultOptions = {
  ...rn.defaultOptions,
  /** If true, the video will start loading immediately. */
  autoLoad: !0,
  /** If true, the video will start playing as soon as it is loaded. */
  autoPlay: !0,
  /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */
  updateFPS: 0,
  /** If true, the video will be loaded with the `crossorigin` attribute. */
  crossorigin: !0,
  /** If true, the video will loop when it ends. */
  loop: !1,
  /** If true, the video will be muted. */
  muted: !0,
  /** If true, the video will play inline. */
  playsinline: !0,
  /** If true, the video will be preloaded. */
  preload: !1
};
_h.MIME_TYPES = {
  ogv: "video/ogg",
  mov: "video/quicktime",
  m4v: "video/mp4"
};
let bA = _h;
const Ga = (n, t, e = !1) => (Array.isArray(n) || (n = [n]), t ? n.map((i) => typeof i == "string" || e ? t(i) : i) : n);
class vA {
  constructor() {
    this._parsers = [], this._cache = /* @__PURE__ */ new Map(), this._cacheMap = /* @__PURE__ */ new Map();
  }
  /** Clear all entries. */
  reset() {
    this._cacheMap.clear(), this._cache.clear();
  }
  /**
   * Check if the key exists
   * @param key - The key to check
   */
  has(t) {
    return this._cache.has(t);
  }
  /**
   * Fetch entry by key
   * @param key - The key of the entry to get
   */
  get(t) {
    const e = this._cache.get(t);
    return e || $t(`[Assets] Asset id ${t} was not found in the Cache`), e;
  }
  /**
   * Set a value by key or keys name
   * @param key - The key or keys to set
   * @param value - The value to store in the cache or from which cacheable assets will be derived.
   */
  set(t, e) {
    const i = Ga(t);
    let s;
    for (let d = 0; d < this.parsers.length; d++) {
      const f = this.parsers[d];
      if (f.test(e)) {
        s = f.getCacheableAssets(i, e);
        break;
      }
    }
    const o = new Map(Object.entries(s || {}));
    s || i.forEach((d) => {
      o.set(d, e);
    });
    const l = [...o.keys()], c = {
      cacheKeys: l,
      keys: i
    };
    i.forEach((d) => {
      this._cacheMap.set(d, c);
    }), l.forEach((d) => {
      const f = s ? s[d] : e;
      this._cache.has(d) && this._cache.get(d) !== f && $t("[Cache] already has key:", d), this._cache.set(d, o.get(d));
    });
  }
  /**
   * Remove entry by key
   *
   * This function will also remove any associated alias from the cache also.
   * @param key - The key of the entry to remove
   */
  remove(t) {
    if (!this._cacheMap.has(t)) {
      $t(`[Assets] Asset id ${t} was not found in the Cache`);
      return;
    }
    const e = this._cacheMap.get(t);
    e.cacheKeys.forEach((s) => {
      this._cache.delete(s);
    }), e.keys.forEach((s) => {
      this._cacheMap.delete(s);
    });
  }
  /**
   * All loader parsers registered
   * @advanced
   */
  get parsers() {
    return this._parsers;
  }
}
const Sn = new vA(), fm = [];
Nt.handleByList(W.TextureSource, fm);
function _1(n = {}) {
  const t = n && n.resource, e = t ? n.resource : n, i = t ? n : { resource: n };
  for (let s = 0; s < fm.length; s++) {
    const o = fm[s];
    if (o.test(e))
      return new o(i);
  }
  throw new Error(`Could not find a source type for resource: ${i.resource}`);
}
function xA(n = {}, t = !1) {
  const e = n && n.resource, i = e ? n.resource : n, s = e ? n : { resource: n };
  if (!t && Sn.has(i))
    return Sn.get(i);
  const o = new Tt({ source: _1(s) });
  return o.on("destroy", () => {
    Sn.has(i) && Sn.remove(i);
  }), t || Sn.set(i, o), o;
}
function _A(n, t = !1) {
  return typeof n == "string" ? Sn.get(n) : n instanceof rn ? new Tt({ source: n }) : xA(n, t);
}
Tt.from = _A;
rn.from = _1;
Nt.add(g1, y1, b1, bA, Gl, gr, Zm);
var S1 = /* @__PURE__ */ ((n) => (n[n.Low = 0] = "Low", n[n.Normal = 1] = "Normal", n[n.High = 2] = "High", n))(S1 || {});
function vi(n) {
  if (typeof n != "string")
    throw new TypeError(`Path must be a string. Received ${JSON.stringify(n)}`);
}
function il(n) {
  return n.split("?")[0].split("#")[0];
}
function SA(n) {
  return n.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function TA(n, t, e) {
  return n.replace(new RegExp(SA(t), "g"), e);
}
function wA(n, t) {
  let e = "", i = 0, s = -1, o = 0, l = -1;
  for (let c = 0; c <= n.length; ++c) {
    if (c < n.length)
      l = n.charCodeAt(c);
    else {
      if (l === 47)
        break;
      l = 47;
    }
    if (l === 47) {
      if (!(s === c - 1 || o === 1)) if (s !== c - 1 && o === 2) {
        if (e.length < 2 || i !== 2 || e.charCodeAt(e.length - 1) !== 46 || e.charCodeAt(e.length - 2) !== 46) {
          if (e.length > 2) {
            const d = e.lastIndexOf("/");
            if (d !== e.length - 1) {
              d === -1 ? (e = "", i = 0) : (e = e.slice(0, d), i = e.length - 1 - e.lastIndexOf("/")), s = c, o = 0;
              continue;
            }
          } else if (e.length === 2 || e.length === 1) {
            e = "", i = 0, s = c, o = 0;
            continue;
          }
        }
      } else
        e.length > 0 ? e += `/${n.slice(s + 1, c)}` : e = n.slice(s + 1, c), i = c - s - 1;
      s = c, o = 0;
    } else l === 46 && o !== -1 ? ++o : o = -1;
  }
  return e;
}
const Ul = {
  /**
   * Converts a path to posix format.
   * @param path - The path to convert to posix
   * @example
   * ```ts
   * // Convert a Windows path to POSIX format
   * path.toPosix('C:\\Users\\User\\Documents\\file.txt');
   * // -> 'C:/Users/User/Documents/file.txt'
   * ```
   */
  toPosix(n) {
    return TA(n, "\\", "/");
  },
  /**
   * Checks if the path is a URL e.g. http://, https://
   * @param path - The path to check
   * @example
   * ```ts
   * // Check if a path is a URL
   * path.isUrl('http://www.example.com');
   * // -> true
   * path.isUrl('C:/Users/User/Documents/file.txt');
   * // -> false
   * ```
   */
  isUrl(n) {
    return /^https?:/.test(this.toPosix(n));
  },
  /**
   * Checks if the path is a data URL
   * @param path - The path to check
   * @example
   * ```ts
   * // Check if a path is a data URL
   * path.isDataUrl('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA...');
   * // -> true
   * ```
   */
  isDataUrl(n) {
    return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(n);
  },
  /**
   * Checks if the path is a blob URL
   * @param path - The path to check
   * @example
   * ```ts
   * // Check if a path is a blob URL
   * path.isBlobUrl('blob:http://www.example.com/12345678-1234-1234-1234-123456789012');
   * // -> true
   * ```
   */
  isBlobUrl(n) {
    return n.startsWith("blob:");
  },
  /**
   * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/
   * This will return true for windows file paths
   * @param path - The path to check
   * @example
   * ```ts
   * // Check if a path has a protocol
   * path.hasProtocol('http://www.example.com');
   * // -> true
   * path.hasProtocol('C:/Users/User/Documents/file.txt');
   * // -> true
   * ```
   */
  hasProtocol(n) {
    return /^[^/:]+:/.test(this.toPosix(n));
  },
  /**
   * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/
   * @param path - The path to get the protocol from
   * @example
   * ```ts
   * // Get the protocol from a URL
   * path.getProtocol('http://www.example.com/path/to/resource');
   * // -> 'http://'
   * // Get the protocol from a file path
   * path.getProtocol('C:/Users/User/Documents/file.txt');
   * // -> 'C:/'
   * ```
   */
  getProtocol(n) {
    vi(n), n = this.toPosix(n);
    const t = /^file:\/\/\//.exec(n);
    if (t)
      return t[0];
    const e = /^[^/:]+:\/{0,2}/.exec(n);
    return e ? e[0] : "";
  },
  /**
   * Converts URL to an absolute path.
   * When loading from a Web Worker, we must use absolute paths.
   * If the URL is already absolute we return it as is
   * If it's not, we convert it
   * @param url - The URL to test
   * @param customBaseUrl - The base URL to use
   * @param customRootUrl - The root URL to use
   * @example
   * ```ts
   * // Convert a relative URL to an absolute path
   * path.toAbsolute('images/texture.png', 'http://example.com/assets/');
   * // -> 'http://example.com/assets/images/texture.png'
   * ```
   */
  toAbsolute(n, t, e) {
    if (vi(n), this.isDataUrl(n) || this.isBlobUrl(n))
      return n;
    const i = il(this.toPosix(t ?? ve.get().getBaseUrl())), s = il(this.toPosix(e ?? this.rootname(i)));
    return n = this.toPosix(n), n.startsWith("/") ? Ul.join(s, n.slice(1)) : this.isAbsolute(n) ? n : this.join(i, n);
  },
  /**
   * Normalizes the given path, resolving '..' and '.' segments
   * @param path - The path to normalize
   * @example
   * ```ts
   * // Normalize a path with relative segments
   * path.normalize('http://www.example.com/foo/bar/../baz');
   * // -> 'http://www.example.com/foo/baz'
   * // Normalize a file path with relative segments
   * path.normalize('C:\\Users\\User\\Documents\\..\\file.txt');
   * // -> 'C:/Users/User/file.txt'
   * ```
   */
  normalize(n) {
    if (vi(n), n.length === 0)
      return ".";
    if (this.isDataUrl(n) || this.isBlobUrl(n))
      return n;
    n = this.toPosix(n);
    let t = "";
    const e = n.startsWith("/");
    this.hasProtocol(n) && (t = this.rootname(n), n = n.slice(t.length));
    const i = n.endsWith("/");
    return n = wA(n), n.length > 0 && i && (n += "/"), e ? `/${n}` : t + n;
  },
  /**
   * Determines if path is an absolute path.
   * Absolute paths can be urls, data urls, or paths on disk
   * @param path - The path to test
   * @example
   * ```ts
   * // Check if a path is absolute
   * path.isAbsolute('http://www.example.com/foo/bar');
   * // -> true
   * path.isAbsolute('C:/Users/User/Documents/file.txt');
   * // -> true
   * ```
   */
  isAbsolute(n) {
    return vi(n), n = this.toPosix(n), this.hasProtocol(n) ? !0 : n.startsWith("/");
  },
  /**
   * Joins all given path segments together using the platform-specific separator as a delimiter,
   * then normalizes the resulting path
   * @param segments - The segments of the path to join
   * @example
   * ```ts
   * // Join multiple path segments
   * path.join('assets', 'images', 'sprite.png');
   * // -> 'assets/images/sprite.png'
   * // Join with relative segments
   * path.join('assets', 'images', '../textures', 'sprite.png');
   * // -> 'assets/textures/sprite.png'
   * ```
   */
  join(...n) {
    if (n.length === 0)
      return ".";
    let t;
    for (let e = 0; e < n.length; ++e) {
      const i = n[e];
      if (vi(i), i.length > 0)
        if (t === void 0)
          t = i;
        else {
          const s = n[e - 1] ?? "";
          this.joinExtensions.includes(this.extname(s).toLowerCase()) ? t += `/../${i}` : t += `/${i}`;
        }
    }
    return t === void 0 ? "." : this.normalize(t);
  },
  /**
   * Returns the directory name of a path
   * @param path - The path to parse
   * @example
   * ```ts
   * // Get the directory name of a path
   * path.dirname('http://www.example.com/foo/bar/baz.png');
   * // -> 'http://www.example.com/foo/bar'
   * // Get the directory name of a file path
   * path.dirname('C:/Users/User/Documents/file.txt');
   * // -> 'C:/Users/User/Documents'
   * ```
   */
  dirname(n) {
    if (vi(n), n.length === 0)
      return ".";
    n = this.toPosix(n);
    let t = n.charCodeAt(0);
    const e = t === 47;
    let i = -1, s = !0;
    const o = this.getProtocol(n), l = n;
    n = n.slice(o.length);
    for (let c = n.length - 1; c >= 1; --c)
      if (t = n.charCodeAt(c), t === 47) {
        if (!s) {
          i = c;
          break;
        }
      } else
        s = !1;
    return i === -1 ? e ? "/" : this.isUrl(l) ? o + n : o : e && i === 1 ? "//" : o + n.slice(0, i);
  },
  /**
   * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/
   * @param path - The path to parse
   * @example
   * ```ts
   * // Get the root of a URL
   * path.rootname('http://www.example.com/foo/bar/baz.png');
   * // -> 'http://www.example.com/'
   * // Get the root of a file path
   * path.rootname('C:/Users/User/Documents/file.txt');
   * // -> 'C:/'
   * ```
   */
  rootname(n) {
    vi(n), n = this.toPosix(n);
    let t = "";
    if (n.startsWith("/") ? t = "/" : t = this.getProtocol(n), this.isUrl(n)) {
      const e = n.indexOf("/", t.length);
      e !== -1 ? t = n.slice(0, e) : t = n, t.endsWith("/") || (t += "/");
    }
    return t;
  },
  /**
   * Returns the last portion of a path
   * @param path - The path to test
   * @param ext - Optional extension to remove
   * @example
   * ```ts
   * // Get the basename of a URL
   * path.basename('http://www.example.com/foo/bar/baz.png');
   * // -> 'baz.png'
   * // Get the basename of a file path
   * path.basename('C:/Users/User/Documents/file.txt');
   * // -> 'file.txt'
   * ```
   */
  basename(n, t) {
    vi(n), t && vi(t), n = il(this.toPosix(n));
    let e = 0, i = -1, s = !0, o;
    if (t !== void 0 && t.length > 0 && t.length <= n.length) {
      if (t.length === n.length && t === n)
        return "";
      let l = t.length - 1, c = -1;
      for (o = n.length - 1; o >= 0; --o) {
        const d = n.charCodeAt(o);
        if (d === 47) {
          if (!s) {
            e = o + 1;
            break;
          }
        } else
          c === -1 && (s = !1, c = o + 1), l >= 0 && (d === t.charCodeAt(l) ? --l === -1 && (i = o) : (l = -1, i = c));
      }
      return e === i ? i = c : i === -1 && (i = n.length), n.slice(e, i);
    }
    for (o = n.length - 1; o >= 0; --o)
      if (n.charCodeAt(o) === 47) {
        if (!s) {
          e = o + 1;
          break;
        }
      } else i === -1 && (s = !1, i = o + 1);
    return i === -1 ? "" : n.slice(e, i);
  },
  /**
   * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last
   * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than
   * the first character of the basename of path, an empty string is returned.
   * @param path - The path to parse
   * @example
   * ```ts
   * // Get the extension of a URL
   * path.extname('http://www.example.com/foo/bar/baz.png');
   * // -> '.png'
   * // Get the extension of a file path
   * path.extname('C:/Users/User/Documents/file.txt');
   * // -> '.txt'
   * ```
   */
  extname(n) {
    vi(n), n = il(this.toPosix(n));
    let t = -1, e = 0, i = -1, s = !0, o = 0;
    for (let l = n.length - 1; l >= 0; --l) {
      const c = n.charCodeAt(l);
      if (c === 47) {
        if (!s) {
          e = l + 1;
          break;
        }
        continue;
      }
      i === -1 && (s = !1, i = l + 1), c === 46 ? t === -1 ? t = l : o !== 1 && (o = 1) : t !== -1 && (o = -1);
    }
    return t === -1 || i === -1 || o === 0 || o === 1 && t === i - 1 && t === e + 1 ? "" : n.slice(t, i);
  },
  /**
   * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.
   * @param path - The path to parse
   * @example
   * ```ts
   * // Parse a URL
   * const parsed = path.parse('http://www.example.com/foo/bar/baz.png');
   * // -> {
   * //   root: 'http://www.example.com/',
   * //   dir: 'http://www.example.com/foo/bar',
   * //   base: 'baz.png',
   * //   ext: '.png',
   * //   name: 'baz'
   * // }
   * // Parse a file path
   * const parsedFile = path.parse('C:/Users/User/Documents/file.txt');
   * // -> {
   * //   root: 'C:/',
   * //   dir: 'C:/Users/User/Documents',
   * //   base: 'file.txt',
   * //   ext: '.txt',
   * //   name: 'file'
   * // }
   * ```
   */
  parse(n) {
    vi(n);
    const t = { root: "", dir: "", base: "", ext: "", name: "" };
    if (n.length === 0)
      return t;
    n = il(this.toPosix(n));
    let e = n.charCodeAt(0);
    const i = this.isAbsolute(n);
    let s;
    t.root = this.rootname(n), i || this.hasProtocol(n) ? s = 1 : s = 0;
    let o = -1, l = 0, c = -1, d = !0, f = n.length - 1, m = 0;
    for (; f >= s; --f) {
      if (e = n.charCodeAt(f), e === 47) {
        if (!d) {
          l = f + 1;
          break;
        }
        continue;
      }
      c === -1 && (d = !1, c = f + 1), e === 46 ? o === -1 ? o = f : m !== 1 && (m = 1) : o !== -1 && (m = -1);
    }
    return o === -1 || c === -1 || m === 0 || m === 1 && o === c - 1 && o === l + 1 ? c !== -1 && (l === 0 && i ? t.base = t.name = n.slice(1, c) : t.base = t.name = n.slice(l, c)) : (l === 0 && i ? (t.name = n.slice(1, o), t.base = n.slice(1, c)) : (t.name = n.slice(l, o), t.base = n.slice(l, c)), t.ext = n.slice(o, c)), t.dir = this.dirname(n), t;
  },
  sep: "/",
  delimiter: ":",
  joinExtensions: [".html"]
};
function T1(n, t, e, i, s) {
  const o = t[e];
  for (let l = 0; l < o.length; l++) {
    const c = o[l];
    e < t.length - 1 ? T1(n.replace(i[e], c), t, e + 1, i, s) : s.push(n.replace(i[e], c));
  }
}
function CA(n) {
  const t = /\{(.*?)\}/g, e = n.match(t), i = [];
  if (e) {
    const s = [];
    e.forEach((o) => {
      const l = o.substring(1, o.length - 1).split(",");
      s.push(l);
    }), T1(n, s, 0, e, i);
  } else
    i.push(n);
  return i;
}
const __ = (n) => !Array.isArray(n);
class w1 {
  constructor() {
    this._defaultBundleIdentifierOptions = {
      connector: "-",
      createBundleAssetId: (t, e) => `${t}${this._bundleIdConnector}${e}`,
      extractAssetIdFromBundle: (t, e) => e.replace(`${t}${this._bundleIdConnector}`, "")
    }, this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector, this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId, this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle, this._assetMap = {}, this._preferredOrder = [], this._parsers = [], this._resolverHash = {}, this._bundles = {};
  }
  /**
   * Override how the resolver deals with generating bundle ids.
   * must be called before any bundles are added
   * @param bundleIdentifier - the bundle identifier options
   */
  setBundleIdentifier(t) {
    if (this._bundleIdConnector = t.connector ?? this._bundleIdConnector, this._createBundleAssetId = t.createBundleAssetId ?? this._createBundleAssetId, this._extractAssetIdFromBundle = t.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle, this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar")
      throw new Error("[Resolver] GenerateBundleAssetId are not working correctly");
  }
  /**
   * Let the resolver know which assets you prefer to use when resolving assets.
   * Multiple prefer user defined rules can be added.
   * @example
   * resolver.prefer({
   *     // first look for something with the correct format, and then then correct resolution
   *     priority: ['format', 'resolution'],
   *     params:{
   *         format:'webp', // prefer webp images
   *         resolution: 2, // prefer a resolution of 2
   *     }
   * })
   * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);
   * resolver.resolveUrl('foo') // => 'bar@2x.webp'
   * @param preferOrders - the prefer options
   */
  prefer(...t) {
    t.forEach((e) => {
      this._preferredOrder.push(e), e.priority || (e.priority = Object.keys(e.params));
    }), this._resolverHash = {};
  }
  /**
   * Set the base path to prepend to all urls when resolving
   * @example
   * resolver.basePath = 'https://home.com/';
   * resolver.add('foo', 'bar.ong');
   * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'
   * @param basePath - the base path to use
   */
  set basePath(t) {
    this._basePath = t;
  }
  get basePath() {
    return this._basePath;
  }
  /**
   * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the
   * default value for browsers is `window.location.origin`
   * @example
   * // Application hosted on https://home.com/some-path/index.html
   * resolver.basePath = 'https://home.com/some-path/';
   * resolver.rootPath = 'https://home.com/';
   * resolver.add('foo', '/bar.png');
   * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'
   * @param rootPath - the root path to use
   */
  set rootPath(t) {
    this._rootPath = t;
  }
  get rootPath() {
    return this._rootPath;
  }
  /**
   * All the active URL parsers that help the parser to extract information and create
   * an asset object-based on parsing the URL itself.
   *
   * Can be added using the extensions API
   * @example
   * resolver.add('foo', [
   *     {
   *         resolution: 2,
   *         format: 'png',
   *         src: 'image@2x.png',
   *     },
   *     {
   *         resolution:1,
   *         format:'png',
   *         src: 'image.png',
   *     },
   * ]);
   *
   * // With a url parser the information such as resolution and file format could extracted from the url itself:
   * extensions.add({
   *     extension: ExtensionType.ResolveParser,
   *     test: loadTextures.test, // test if url ends in an image
   *     parse: (value: string) =>
   *     ({
   *         resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),
   *         format: value.split('.').pop(),
   *         src: value,
   *     }),
   * });
   *
   * // Now resolution and format can be extracted from the url
   * resolver.add('foo', [
   *     'image@2x.png',
   *     'image.png',
   * ]);
   */
  get parsers() {
    return this._parsers;
  }
  /** Used for testing, this resets the resolver to its initial state */
  reset() {
    this.setBundleIdentifier(this._defaultBundleIdentifierOptions), this._assetMap = {}, this._preferredOrder = [], this._resolverHash = {}, this._rootPath = null, this._basePath = null, this._manifest = null, this._bundles = {}, this._defaultSearchParams = null;
  }
  /**
   * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.
   * @param searchParams - the default url parameters to append when resolving urls
   */
  setDefaultSearchParams(t) {
    if (typeof t == "string")
      this._defaultSearchParams = t;
    else {
      const e = t;
      this._defaultSearchParams = Object.keys(e).map((i) => `${encodeURIComponent(i)}=${encodeURIComponent(e[i])}`).join("&");
    }
  }
  /**
   * Returns the aliases for a given asset
   * @param asset - the asset to get the aliases for
   */
  getAlias(t) {
    const { alias: e, src: i } = t;
    return Ga(
      e || i,
      (o) => typeof o == "string" ? o : Array.isArray(o) ? o.map((l) => l?.src ?? l) : o?.src ? o.src : o,
      !0
    );
  }
  /**
   * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.
   * generally a manifest would be built using a tool.
   * @param manifest - the manifest to add to the resolver
   */
  addManifest(t) {
    this._manifest && $t("[Resolver] Manifest already exists, this will be overwritten"), this._manifest = t, t.bundles.forEach((e) => {
      this.addBundle(e.name, e.assets);
    });
  }
  /**
   * This adds a bundle of assets in one go so that you can resolve them as a group.
   * For example you could add a bundle for each screen in you pixi app
   * @example
   * resolver.addBundle('animals', [
   *  { alias: 'bunny', src: 'bunny.png' },
   *  { alias: 'chicken', src: 'chicken.png' },
   *  { alias: 'thumper', src: 'thumper.png' },
   * ]);
   * // or
   * resolver.addBundle('animals', {
   *     bunny: 'bunny.png',
   *     chicken: 'chicken.png',
   *     thumper: 'thumper.png',
   * });
   *
   * const resolvedAssets = await resolver.resolveBundle('animals');
   * @param bundleId - The id of the bundle to add
   * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key
   */
  addBundle(t, e) {
    const i = [];
    let s = e;
    Array.isArray(e) || (s = Object.entries(e).map(([o, l]) => typeof l == "string" || Array.isArray(l) ? { alias: o, src: l } : { alias: o, ...l })), s.forEach((o) => {
      const l = o.src, c = o.alias;
      let d;
      if (typeof c == "string") {
        const f = this._createBundleAssetId(t, c);
        i.push(f), d = [c, f];
      } else {
        const f = c.map((m) => this._createBundleAssetId(t, m));
        i.push(...f), d = [...c, ...f];
      }
      this.add({
        ...o,
        alias: d,
        src: l
      });
    }), this._bundles[t] = i;
  }
  /**
   * Tells the resolver what keys are associated with witch asset.
   * The most important thing the resolver does
   * @example
   * // Single key, single asset:
   * resolver.add({alias: 'foo', src: 'bar.png');
   * resolver.resolveUrl('foo') // => 'bar.png'
   *
   * // Multiple keys, single asset:
   * resolver.add({alias: ['foo', 'boo'], src: 'bar.png'});
   * resolver.resolveUrl('foo') // => 'bar.png'
   * resolver.resolveUrl('boo') // => 'bar.png'
   *
   * // Multiple keys, multiple assets:
   * resolver.add({alias: ['foo', 'boo'], src: ['bar.png', 'bar.webp']});
   * resolver.resolveUrl('foo') // => 'bar.png'
   *
   * // Add custom data attached to the resolver
   * Resolver.add({
   *     alias: 'bunnyBooBooSmooth',
   *     src: 'bunny{png,webp}',
   *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options
   * });
   *
   * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }
   * @param aliases - the UnresolvedAsset or array of UnresolvedAssets to add to the resolver
   */
  add(t) {
    const e = [];
    Array.isArray(t) ? e.push(...t) : e.push(t);
    let i;
    i = (o) => {
      this.hasKey(o) && $t(`[Resolver] already has key: ${o} overwriting`);
    }, Ga(e).forEach((o) => {
      const { src: l } = o;
      let { data: c, format: d, loadParser: f, parser: m } = o;
      const y = Ga(l).map((x) => typeof x == "string" ? CA(x) : Array.isArray(x) ? x : [x]), b = this.getAlias(o);
      Array.isArray(b) ? b.forEach(i) : i(b);
      const v = [];
      y.forEach((x) => {
        x.forEach((S) => {
          let _ = {};
          if (typeof S != "object") {
            _.src = S;
            for (let C = 0; C < this._parsers.length; C++) {
              const R = this._parsers[C];
              if (R.test(S)) {
                _ = R.parse(S);
                break;
              }
            }
          } else
            c = S.data ?? c, d = S.format ?? d, (S.loadParser || S.parser) && (f = S.loadParser ?? f, m = S.parser ?? m), _ = {
              ..._,
              ...S
            };
          if (!b)
            throw new Error(`[Resolver] alias is undefined for this asset: ${_.src}`);
          _ = this._buildResolvedAsset(_, {
            aliases: b,
            data: c,
            format: d,
            loadParser: f,
            parser: m
          }), v.push(_);
        });
      }), b.forEach((x) => {
        this._assetMap[x] = v;
      });
    });
  }
  // TODO: this needs an overload like load did in Assets
  /**
   * If the resolver has had a manifest set via setManifest, this will return the assets urls for
   * a given bundleId or bundleIds.
   * @example
   * // Manifest Example
   * const manifest = {
   *     bundles: [
   *         {
   *             name: 'load-screen',
   *             assets: [
   *                 {
   *                     alias: 'background',
   *                     src: 'sunset.png',
   *                 },
   *                 {
   *                     alias: 'bar',
   *                     src: 'load-bar.{png,webp}',
   *                 },
   *             ],
   *         },
   *         {
   *             name: 'game-screen',
   *             assets: [
   *                 {
   *                     alias: 'character',
   *                     src: 'robot.png',
   *                 },
   *                 {
   *                     alias: 'enemy',
   *                     src: 'bad-guy.png',
   *                 },
   *             ],
   *         },
   *     ]
   * };
   *
   * resolver.setManifest(manifest);
   * const resolved = resolver.resolveBundle('load-screen');
   * @param bundleIds - The bundle ids to resolve
   * @returns All the bundles assets or a hash of assets for each bundle specified
   */
  resolveBundle(t) {
    const e = __(t);
    t = Ga(t);
    const i = {};
    return t.forEach((s) => {
      const o = this._bundles[s];
      if (o) {
        const l = this.resolve(o), c = {};
        for (const d in l) {
          const f = l[d];
          c[this._extractAssetIdFromBundle(s, d)] = f;
        }
        i[s] = c;
      }
    }), e ? i[t[0]] : i;
  }
  /**
   * Does exactly what resolve does, but returns just the URL rather than the whole asset object
   * @param key - The key or keys to resolve
   * @returns - The URLs associated with the key(s)
   */
  resolveUrl(t) {
    const e = this.resolve(t);
    if (typeof t != "string") {
      const i = {};
      for (const s in e)
        i[s] = e[s].src;
      return i;
    }
    return e.src;
  }
  resolve(t) {
    const e = __(t);
    t = Ga(t);
    const i = {};
    return t.forEach((s) => {
      if (!this._resolverHash[s])
        if (this._assetMap[s]) {
          let o = this._assetMap[s];
          const l = this._getPreferredOrder(o);
          l?.priority.forEach((c) => {
            l.params[c].forEach((d) => {
              const f = o.filter((m) => m[c] ? m[c] === d : !1);
              f.length && (o = f);
            });
          }), this._resolverHash[s] = o[0];
        } else
          this._resolverHash[s] = this._buildResolvedAsset({
            alias: [s],
            src: s
          }, {});
      i[s] = this._resolverHash[s];
    }), e ? i[t[0]] : i;
  }
  /**
   * Checks if an asset with a given key exists in the resolver
   * @param key - The key of the asset
   */
  hasKey(t) {
    return !!this._assetMap[t];
  }
  /**
   * Checks if a bundle with the given key exists in the resolver
   * @param key - The key of the bundle
   */
  hasBundle(t) {
    return !!this._bundles[t];
  }
  /**
   * Internal function for figuring out what prefer criteria an asset should use.
   * @param assets
   */
  _getPreferredOrder(t) {
    for (let e = 0; e < t.length; e++) {
      const i = t[e], s = this._preferredOrder.find((o) => o.params.format.includes(i.format));
      if (s)
        return s;
    }
    return this._preferredOrder[0];
  }
  /**
   * Appends the default url parameters to the url
   * @param url - The url to append the default parameters to
   * @returns - The url with the default parameters appended
   */
  _appendDefaultSearchParams(t) {
    if (!this._defaultSearchParams)
      return t;
    const e = /\?/.test(t) ? "&" : "?";
    return `${t}${e}${this._defaultSearchParams}`;
  }
  _buildResolvedAsset(t, e) {
    const { aliases: i, data: s, loadParser: o, parser: l, format: c } = e;
    return (this._basePath || this._rootPath) && (t.src = Ul.toAbsolute(t.src, this._basePath, this._rootPath)), t.alias = i ?? t.alias ?? [t.src], t.src = this._appendDefaultSearchParams(t.src), t.data = { ...s || {}, ...t.data }, t.loadParser = o ?? t.loadParser, t.parser = l ?? t.parser, t.format = c ?? t.format ?? EA(t.src), t;
  }
}
w1.RETINA_PREFIX = /@([0-9\.]+)x/;
function EA(n) {
  return n.split(".").pop().split("?").shift().split("#").shift();
}
const S_ = (n, t) => {
  const e = t.split("?")[1];
  return e && (n += `?${e}`), n;
}, C1 = class bl {
  constructor(t, e) {
    this.linkedSheets = [];
    let i = t;
    t?.source instanceof rn && (i = {
      texture: t,
      data: e
    });
    const { texture: s, data: o, cachePrefix: l = "" } = i;
    this.cachePrefix = l, this._texture = s instanceof Tt ? s : null, this.textureSource = s.source, this.textures = {}, this.animations = {}, this.data = o;
    const c = parseFloat(o.meta.scale);
    c ? (this.resolution = c, s.source.resolution = this.resolution) : this.resolution = s.source._resolution, this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null;
  }
  /**
   * Parser spritesheet from loaded data. This is done asynchronously
   * to prevent creating too many Texture within a single process.
   */
  parse() {
    return new Promise((t) => {
      this._callback = t, this._batchIndex = 0, this._frameKeys.length <= bl.BATCH_SIZE ? (this._processFrames(0), this._processAnimations(), this._parseComplete()) : this._nextBatch();
    });
  }
  /**
   * Process a batch of frames
   * @param initialFrameIndex - The index of frame to start.
   */
  _processFrames(t) {
    let e = t;
    const i = bl.BATCH_SIZE;
    for (; e - t < i && e < this._frameKeys.length; ) {
      const s = this._frameKeys[e], o = this._frames[s], l = o.frame;
      if (l) {
        let c = null, d = null;
        const f = o.trimmed !== !1 && o.sourceSize ? o.sourceSize : o.frame, m = new ne(
          0,
          0,
          Math.floor(f.w) / this.resolution,
          Math.floor(f.h) / this.resolution
        );
        o.rotated ? c = new ne(
          Math.floor(l.x) / this.resolution,
          Math.floor(l.y) / this.resolution,
          Math.floor(l.h) / this.resolution,
          Math.floor(l.w) / this.resolution
        ) : c = new ne(
          Math.floor(l.x) / this.resolution,
          Math.floor(l.y) / this.resolution,
          Math.floor(l.w) / this.resolution,
          Math.floor(l.h) / this.resolution
        ), o.trimmed !== !1 && o.spriteSourceSize && (d = new ne(
          Math.floor(o.spriteSourceSize.x) / this.resolution,
          Math.floor(o.spriteSourceSize.y) / this.resolution,
          Math.floor(l.w) / this.resolution,
          Math.floor(l.h) / this.resolution
        )), this.textures[s] = new Tt({
          source: this.textureSource,
          frame: c,
          orig: m,
          trim: d,
          rotate: o.rotated ? 2 : 0,
          defaultAnchor: o.anchor,
          defaultBorders: o.borders,
          label: s.toString()
        });
      }
      e++;
    }
  }
  /** Parse animations config. */
  _processAnimations() {
    const t = this.data.animations || {};
    for (const e in t) {
      this.animations[e] = [];
      for (let i = 0; i < t[e].length; i++) {
        const s = t[e][i];
        this.animations[e].push(this.textures[s]);
      }
    }
  }
  /** The parse has completed. */
  _parseComplete() {
    const t = this._callback;
    this._callback = null, this._batchIndex = 0, t.call(this, this.textures);
  }
  /** Begin the next batch of textures. */
  _nextBatch() {
    this._processFrames(this._batchIndex * bl.BATCH_SIZE), this._batchIndex++, setTimeout(() => {
      this._batchIndex * bl.BATCH_SIZE < this._frameKeys.length ? this._nextBatch() : (this._processAnimations(), this._parseComplete());
    }, 0);
  }
  /**
   * Destroy Spritesheet and don't use after this.
   * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well
   */
  destroy(t = !1) {
    for (const e in this.textures)
      this.textures[e].destroy();
    this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, t && (this._texture?.destroy(), this.textureSource.destroy()), this._texture = null, this.textureSource = null, this.linkedSheets = [];
  }
};
C1.BATCH_SIZE = 1e3;
let T_ = C1;
const MA = [
  "jpg",
  "png",
  "jpeg",
  "avif",
  "webp",
  "basis",
  "etc2",
  "bc7",
  "bc6h",
  "bc5",
  "bc4",
  "bc3",
  "bc2",
  "bc1",
  "eac",
  "astc"
];
function E1(n, t, e) {
  const i = {};
  if (n.forEach((s) => {
    i[s] = t;
  }), Object.keys(t.textures).forEach((s) => {
    i[`${t.cachePrefix}${s}`] = t.textures[s];
  }), !e) {
    const s = Ul.dirname(n[0]);
    t.linkedSheets.forEach((o, l) => {
      const c = E1([`${s}/${t.data.meta.related_multi_packs[l]}`], o, !0);
      Object.assign(i, c);
    });
  }
  return i;
}
const AA = {
  extension: W.Asset,
  /** Handle the caching of the related Spritesheet Textures */
  cache: {
    test: (n) => n instanceof T_,
    getCacheableAssets: (n, t) => E1(n, t, !1)
  },
  /** Resolve the resolution of the asset. */
  resolver: {
    extension: {
      type: W.ResolveParser,
      name: "resolveSpritesheet"
    },
    test: (n) => {
      const e = n.split("?")[0].split("."), i = e.pop(), s = e.pop();
      return i === "json" && MA.includes(s);
    },
    parse: (n) => {
      const t = n.split(".");
      return {
        resolution: parseFloat(w1.RETINA_PREFIX.exec(n)?.[1] ?? "1"),
        format: t[t.length - 2],
        src: n
      };
    }
  },
  /**
   * Loader plugin that parses sprite sheets!
   * once the JSON has been loaded this checks to see if the JSON is spritesheet data.
   * If it is, we load the spritesheets image and parse the data into Spritesheet
   * All textures in the sprite sheet are then added to the cache
   */
  loader: {
    /** used for deprecation purposes */
    name: "spritesheetLoader",
    id: "spritesheet",
    extension: {
      type: W.LoadParser,
      priority: S1.Normal,
      name: "spritesheetLoader"
    },
    async testParse(n, t) {
      return Ul.extname(t.src).toLowerCase() === ".json" && !!n.frames;
    },
    async parse(n, t, e) {
      const {
        texture: i,
        // if user need to use preloaded texture
        imageFilename: s,
        // if user need to use custom filename (not from jsonFile.meta.image)
        textureOptions: o,
        // if user need to set texture options on texture
        cachePrefix: l
        // if user need to use custom cache prefix
      } = t?.data ?? {};
      let c = Ul.dirname(t.src);
      c && c.lastIndexOf("/") !== c.length - 1 && (c += "/");
      let d;
      if (i instanceof Tt)
        d = i;
      else {
        const y = S_(c + (s ?? n.meta.image), t.src);
        d = (await e.load([{ src: y, data: o }]))[y];
      }
      const f = new T_({
        texture: d.source,
        data: n,
        cachePrefix: l
      });
      await f.parse();
      const m = n?.meta?.related_multi_packs;
      if (Array.isArray(m)) {
        const y = [];
        for (const v of m) {
          if (typeof v != "string")
            continue;
          let x = c + v;
          t.data?.ignoreMultiPack || (x = S_(x, t.src), y.push(e.load({
            src: x,
            data: {
              textureOptions: o,
              ignoreMultiPack: !0
            }
          })));
        }
        const b = await Promise.all(y);
        f.linkedSheets = b, b.forEach((v) => {
          v.linkedSheets = [f].concat(f.linkedSheets.filter((x) => x !== v));
        });
      }
      return f;
    },
    async unload(n, t, e) {
      await e.unload(n.textureSource._sourceOrigin), n.destroy(!1);
    }
  }
};
Nt.add(AA);
class M1 {
  constructor(t) {
    this._lastTransform = "", this._observer = null, this._tickerAttached = !1, this.updateTranslation = () => {
      if (!this._canvas)
        return;
      const e = this._canvas.getBoundingClientRect(), i = this._canvas.width, s = this._canvas.height, o = e.width / i * this._renderer.resolution, l = e.height / s * this._renderer.resolution, c = e.left, d = e.top, f = `translate(${c}px, ${d}px) scale(${o}, ${l})`;
      f !== this._lastTransform && (this._domElement.style.transform = f, this._lastTransform = f);
    }, this._domElement = t.domElement, this._renderer = t.renderer, !(globalThis.OffscreenCanvas && this._renderer.canvas instanceof OffscreenCanvas) && (this._canvas = this._renderer.canvas, this._attachObserver());
  }
  /** The canvas element that this CanvasObserver is associated with. */
  get canvas() {
    return this._canvas;
  }
  /** Attaches the DOM element to the canvas parent if it is not already attached. */
  ensureAttached() {
    !this._domElement.parentNode && this._canvas.parentNode && (this._canvas.parentNode.appendChild(this._domElement), this.updateTranslation());
  }
  /** Sets up a ResizeObserver if available. This ensures that the DOM element is kept in sync with the canvas size . */
  _attachObserver() {
    "ResizeObserver" in globalThis ? (this._observer && (this._observer.disconnect(), this._observer = null), this._observer = new ResizeObserver((t) => {
      for (const e of t) {
        if (e.target !== this._canvas)
          continue;
        const i = this.canvas.width, s = this.canvas.height, o = e.contentRect.width / i * this._renderer.resolution, l = e.contentRect.height / s * this._renderer.resolution;
        (this._lastScaleX !== o || this._lastScaleY !== l) && (this.updateTranslation(), this._lastScaleX = o, this._lastScaleY = l);
      }
    }), this._observer.observe(this._canvas)) : this._tickerAttached || Kn.shared.add(this.updateTranslation, this, Ya.HIGH);
  }
  /** Destroys the CanvasObserver instance, cleaning up observers and Ticker. */
  destroy() {
    this._observer ? (this._observer.disconnect(), this._observer = null) : this._tickerAttached && Kn.shared.remove(this.updateTranslation), this._domElement = null, this._renderer = null, this._canvas = null, this._tickerAttached = !1, this._lastTransform = "", this._lastScaleX = null, this._lastScaleY = null;
  }
}
class Xl {
  /**
   * @param manager - The event boundary which manages this event. Propagation can only occur
   *  within the boundary's jurisdiction.
   */
  constructor(t) {
    this.bubbles = !0, this.cancelBubble = !0, this.cancelable = !1, this.composed = !1, this.defaultPrevented = !1, this.eventPhase = Xl.prototype.NONE, this.propagationStopped = !1, this.propagationImmediatelyStopped = !1, this.layer = new Ut(), this.page = new Ut(), this.NONE = 0, this.CAPTURING_PHASE = 1, this.AT_TARGET = 2, this.BUBBLING_PHASE = 3, this.manager = t;
  }
  /** @readonly */
  get layerX() {
    return this.layer.x;
  }
  /** @readonly */
  get layerY() {
    return this.layer.y;
  }
  /** @readonly */
  get pageX() {
    return this.page.x;
  }
  /** @readonly */
  get pageY() {
    return this.page.y;
  }
  /**
   * Fallback for the deprecated `InteractionEvent.data`.
   * @deprecated since 7.0.0
   */
  get data() {
    return this;
  }
  /**
   * The propagation path for this event. Alias for {@link EventBoundary.propagationPath}.
   * @advanced
   */
  composedPath() {
    return this.manager && (!this.path || this.path[this.path.length - 1] !== this.target) && (this.path = this.target ? this.manager.propagationPath(this.target) : []), this.path;
  }
  /**
   * Unimplemented method included for implementing the DOM interface `Event`. It will throw an `Error`.
   * @deprecated
   * @ignore
   * @param _type
   * @param _bubbles
   * @param _cancelable
   */
  initEvent(t, e, i) {
    throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
  }
  /**
   * Unimplemented method included for implementing the DOM interface `UIEvent`. It will throw an `Error`.
   * @ignore
   * @deprecated
   * @param _typeArg
   * @param _bubblesArg
   * @param _cancelableArg
   * @param _viewArg
   * @param _detailArg
   */
  initUIEvent(t, e, i, s, o) {
    throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
  }
  /**
   * Prevent default behavior of both PixiJS and the user agent.
   * @example
   * ```ts
   * sprite.on('click', (event) => {
   *     // Prevent both browser's default click behavior
   *     // and PixiJS's default handling
   *     event.preventDefault();
   *
   *     // Custom handling
   *     customClickHandler();
   * });
   * ```
   * @remarks
   * - Only works if the native event is cancelable
   * - Does not stop event propagation
   */
  preventDefault() {
    this.nativeEvent instanceof Event && this.nativeEvent.cancelable && this.nativeEvent.preventDefault(), this.defaultPrevented = !0;
  }
  /**
   * Stop this event from propagating to any additional listeners, including those
   * on the current target and any following targets in the propagation path.
   * @example
   * ```ts
   * container.on('pointerdown', (event) => {
   *     // Stop all further event handling
   *     event.stopImmediatePropagation();
   *
   *     // These handlers won't be called:
   *     // - Other pointerdown listeners on this container
   *     // - Any pointerdown listeners on parent containers
   * });
   * ```
   * @remarks
   * - Immediately stops all event propagation
   * - Prevents other listeners on same target from being called
   * - More aggressive than stopPropagation()
   */
  stopImmediatePropagation() {
    this.propagationImmediatelyStopped = !0;
  }
  /**
   * Stop this event from propagating to the next target in the propagation path.
   * The rest of the listeners on the current target will still be notified.
   * @example
   * ```ts
   * child.on('pointermove', (event) => {
   *     // Handle event on child
   *     updateChild();
   *
   *     // Prevent parent handlers from being called
   *     event.stopPropagation();
   * });
   *
   * // This won't be called if child handles the event
   * parent.on('pointermove', (event) => {
   *     updateParent();
   * });
   * ```
   * @remarks
   * - Stops event bubbling to parent containers
   * - Does not prevent other listeners on same target
   * - Less aggressive than stopImmediatePropagation()
   */
  stopPropagation() {
    this.propagationStopped = !0;
  }
}
var xp = /iPhone/i, w_ = /iPod/i, C_ = /iPad/i, E_ = /\biOS-universal(?:.+)Mac\b/i, _p = /\bAndroid(?:.+)Mobile\b/i, M_ = /Android/i, Ca = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i, Tc = /Silk/i, lr = /Windows Phone/i, A_ = /\bWindows(?:.+)ARM\b/i, R_ = /BlackBerry/i, P_ = /BB10/i, B_ = /Opera Mini/i, k_ = /\b(CriOS|Chrome)(?:.+)Mobile/i, O_ = /Mobile(?:.+)Firefox\b/i, D_ = function(n) {
  return typeof n < "u" && n.platform === "MacIntel" && typeof n.maxTouchPoints == "number" && n.maxTouchPoints > 1 && typeof MSStream > "u";
};
function RA(n) {
  return function(t) {
    return t.test(n);
  };
}
function G_(n) {
  var t = {
    userAgent: "",
    platform: "",
    maxTouchPoints: 0
  };
  !n && typeof navigator < "u" ? t = {
    userAgent: navigator.userAgent,
    platform: navigator.platform,
    maxTouchPoints: navigator.maxTouchPoints || 0
  } : typeof n == "string" ? t.userAgent = n : n && n.userAgent && (t = {
    userAgent: n.userAgent,
    platform: n.platform,
    maxTouchPoints: n.maxTouchPoints || 0
  });
  var e = t.userAgent, i = e.split("[FBAN");
  typeof i[1] < "u" && (e = i[0]), i = e.split("Twitter"), typeof i[1] < "u" && (e = i[0]);
  var s = RA(e), o = {
    apple: {
      phone: s(xp) && !s(lr),
      ipod: s(w_),
      tablet: !s(xp) && (s(C_) || D_(t)) && !s(lr),
      universal: s(E_),
      device: (s(xp) || s(w_) || s(C_) || s(E_) || D_(t)) && !s(lr)
    },
    amazon: {
      phone: s(Ca),
      tablet: !s(Ca) && s(Tc),
      device: s(Ca) || s(Tc)
    },
    android: {
      phone: !s(lr) && s(Ca) || !s(lr) && s(_p),
      tablet: !s(lr) && !s(Ca) && !s(_p) && (s(Tc) || s(M_)),
      device: !s(lr) && (s(Ca) || s(Tc) || s(_p) || s(M_)) || s(/\bokhttp\b/i)
    },
    windows: {
      phone: s(lr),
      tablet: s(A_),
      device: s(lr) || s(A_)
    },
    other: {
      blackberry: s(R_),
      blackberry10: s(P_),
      opera: s(B_),
      firefox: s(O_),
      chrome: s(k_),
      device: s(R_) || s(P_) || s(B_) || s(O_) || s(k_)
    },
    any: !1,
    phone: !1,
    tablet: !1
  };
  return o.any = o.apple.device || o.android.device || o.windows.device || o.other.device, o.phone = o.apple.phone || o.android.phone || o.windows.phone, o.tablet = o.apple.tablet || o.android.tablet || o.windows.tablet, o;
}
const PA = G_.default ?? G_, BA = PA(globalThis.navigator), kA = 9, U_ = 100, OA = 0, DA = 0, N_ = 2, I_ = 1, GA = -1e3, UA = -1e3, NA = 2, ng = class A1 {
  // eslint-disable-next-line jsdoc/require-param
  /**
   * @param {WebGLRenderer|WebGPURenderer} renderer - A reference to the current renderer
   */
  constructor(t, e = BA) {
    this._mobileInfo = e, this.debug = !1, this._activateOnTab = !0, this._deactivateOnMouseMove = !0, this._isActive = !1, this._isMobileAccessibility = !1, this._div = null, this._pool = [], this._renderId = 0, this._children = [], this._androidUpdateCount = 0, this._androidUpdateFrequency = 500, this._hookDiv = null, (e.tablet || e.phone) && this._createTouchHook(), this._renderer = t;
  }
  /**
   * Value of `true` if accessibility is currently active and accessibility layers are showing.
   * @type {boolean}
   * @readonly
   */
  get isActive() {
    return this._isActive;
  }
  /**
   * Value of `true` if accessibility is enabled for touch devices.
   * @type {boolean}
   * @readonly
   */
  get isMobileAccessibility() {
    return this._isMobileAccessibility;
  }
  /**
   * The DOM element that will sit over the PixiJS element. This is where the div overlays will go.
   * @readonly
   */
  get hookDiv() {
    return this._hookDiv;
  }
  /**
   * Creates the touch hooks.
   * @private
   */
  _createTouchHook() {
    const t = document.createElement("button");
    t.style.width = `${I_}px`, t.style.height = `${I_}px`, t.style.position = "absolute", t.style.top = `${GA}px`, t.style.left = `${UA}px`, t.style.zIndex = NA.toString(), t.style.backgroundColor = "#FF0000", t.title = "select to enable accessibility for this content", t.addEventListener("focus", () => {
      this._isMobileAccessibility = !0, this._activate(), this._destroyTouchHook();
    }), document.body.appendChild(t), this._hookDiv = t;
  }
  /**
   * Destroys the touch hooks.
   * @private
   */
  _destroyTouchHook() {
    this._hookDiv && (document.body.removeChild(this._hookDiv), this._hookDiv = null);
  }
  /**
   * Activating will cause the Accessibility layer to be shown.
   * This is called when a user presses the tab key.
   * @private
   */
  _activate() {
    if (this._isActive)
      return;
    this._isActive = !0, this._div || (this._div = document.createElement("div"), this._div.style.position = "absolute", this._div.style.top = `${OA}px`, this._div.style.left = `${DA}px`, this._div.style.pointerEvents = "none", this._div.style.zIndex = N_.toString(), this._canvasObserver = new M1({
      domElement: this._div,
      renderer: this._renderer
    })), this._activateOnTab && (this._onKeyDown = this._onKeyDown.bind(this), globalThis.addEventListener("keydown", this._onKeyDown, !1)), this._deactivateOnMouseMove && (this._onMouseMove = this._onMouseMove.bind(this), globalThis.document.addEventListener("mousemove", this._onMouseMove, !0));
    const t = this._renderer.view.canvas;
    if (t.parentNode)
      this._canvasObserver.ensureAttached(), this._initAccessibilitySetup();
    else {
      const e = new MutationObserver(() => {
        t.parentNode && (e.disconnect(), this._canvasObserver.ensureAttached(), this._initAccessibilitySetup());
      });
      e.observe(document.body, { childList: !0, subtree: !0 });
    }
  }
  // New method to handle initialization after div is ready
  _initAccessibilitySetup() {
    this._renderer.runners.postrender.add(this), this._renderer.lastObjectRendered && this._updateAccessibleObjects(this._renderer.lastObjectRendered);
  }
  /**
   * Deactivates the accessibility system. Removes listeners and accessibility elements.
   * @private
   */
  _deactivate() {
    if (!(!this._isActive || this._isMobileAccessibility)) {
      this._isActive = !1, globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0), this._activateOnTab && globalThis.addEventListener("keydown", this._onKeyDown, !1), this._renderer.runners.postrender.remove(this);
      for (const t of this._children)
        t._accessibleDiv && t._accessibleDiv.parentNode && (t._accessibleDiv.parentNode.removeChild(t._accessibleDiv), t._accessibleDiv = null), t._accessibleActive = !1;
      this._pool.forEach((t) => {
        t.parentNode && t.parentNode.removeChild(t);
      }), this._div && this._div.parentNode && this._div.parentNode.removeChild(this._div), this._pool = [], this._children = [];
    }
  }
  /**
   * This recursive function will run through the scene graph and add any new accessible objects to the DOM layer.
   * @private
   * @param {Container} container - The Container to check.
   */
  _updateAccessibleObjects(t) {
    if (!t.visible || !t.accessibleChildren)
      return;
    t.accessible && (t._accessibleActive || this._addChild(t), t._renderId = this._renderId);
    const e = t.children;
    if (e)
      for (let i = 0; i < e.length; i++)
        this._updateAccessibleObjects(e[i]);
  }
  /**
   * Runner init called, view is available at this point.
   * @ignore
   */
  init(t) {
    const i = {
      accessibilityOptions: {
        ...A1.defaultOptions,
        ...t?.accessibilityOptions || {}
      }
    };
    this.debug = i.accessibilityOptions.debug, this._activateOnTab = i.accessibilityOptions.activateOnTab, this._deactivateOnMouseMove = i.accessibilityOptions.deactivateOnMouseMove, i.accessibilityOptions.enabledByDefault ? this._activate() : this._activateOnTab && (this._onKeyDown = this._onKeyDown.bind(this), globalThis.addEventListener("keydown", this._onKeyDown, !1)), this._renderer.runners.postrender.remove(this);
  }
  /**
   * Updates the accessibility layer during rendering.
   * - Removes divs for containers no longer in the scene
   * - Updates the position and dimensions of the root div
   * - Updates positions of active accessibility divs
   * Only fires while the accessibility system is active.
   * @ignore
   */
  postrender() {
    const t = performance.now();
    if (this._mobileInfo.android.device && t < this._androidUpdateCount || (this._androidUpdateCount = t + this._androidUpdateFrequency, !this._renderer.renderingToScreen || !this._renderer.view.canvas))
      return;
    const e = /* @__PURE__ */ new Set();
    if (this._renderer.lastObjectRendered) {
      this._updateAccessibleObjects(this._renderer.lastObjectRendered);
      for (const i of this._children)
        i._renderId === this._renderId && e.add(this._children.indexOf(i));
    }
    for (let i = this._children.length - 1; i >= 0; i--) {
      const s = this._children[i];
      e.has(i) || (s._accessibleDiv && s._accessibleDiv.parentNode && (s._accessibleDiv.parentNode.removeChild(s._accessibleDiv), this._pool.push(s._accessibleDiv), s._accessibleDiv = null), s._accessibleActive = !1, a1(this._children, i, 1));
    }
    this._renderer.renderingToScreen && this._canvasObserver.ensureAttached();
    for (let i = 0; i < this._children.length; i++) {
      const s = this._children[i];
      if (!s._accessibleActive || !s._accessibleDiv)
        continue;
      const o = s._accessibleDiv, l = s.hitArea || s.getBounds().rectangle;
      if (s.hitArea) {
        const c = s.worldTransform;
        o.style.left = `${c.tx + l.x * c.a}px`, o.style.top = `${c.ty + l.y * c.d}px`, o.style.width = `${l.width * c.a}px`, o.style.height = `${l.height * c.d}px`;
      } else
        this._capHitArea(l), o.style.left = `${l.x}px`, o.style.top = `${l.y}px`, o.style.width = `${l.width}px`, o.style.height = `${l.height}px`;
    }
    this._renderId++;
  }
  /**
   * private function that will visually add the information to the
   * accessibility div
   * @param {HTMLElement} div -
   */
  _updateDebugHTML(t) {
    t.innerHTML = `type: ${t.type}</br> title : ${t.title}</br> tabIndex: ${t.tabIndex}`;
  }
  /**
   * Adjust the hit area based on the bounds of a display object
   * @param {Rectangle} hitArea - Bounds of the child
   */
  _capHitArea(t) {
    t.x < 0 && (t.width += t.x, t.x = 0), t.y < 0 && (t.height += t.y, t.y = 0);
    const { width: e, height: i } = this._renderer;
    t.x + t.width > e && (t.width = e - t.x), t.y + t.height > i && (t.height = i - t.y);
  }
  /**
   * Creates or reuses a div element for a Container and adds it to the accessibility layer.
   * Sets up ARIA attributes, event listeners, and positioning based on the container's properties.
   * @private
   * @param {Container} container - The child to make accessible.
   */
  _addChild(t) {
    let e = this._pool.pop();
    e || (t.accessibleType === "button" ? e = document.createElement("button") : (e = document.createElement(t.accessibleType), e.style.cssText = `
                        color: transparent;
                        pointer-events: none;
                        padding: 0;
                        margin: 0;
                        border: 0;
                        outline: 0;
                        background: transparent;
                        box-sizing: border-box;
                        user-select: none;
                        -webkit-user-select: none;
                        -moz-user-select: none;
                        -ms-user-select: none;
                    `, t.accessibleText && (e.innerText = t.accessibleText)), e.style.width = `${U_}px`, e.style.height = `${U_}px`, e.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent", e.style.position = "absolute", e.style.zIndex = N_.toString(), e.style.borderStyle = "none", navigator.userAgent.toLowerCase().includes("chrome") ? e.setAttribute("aria-live", "off") : e.setAttribute("aria-live", "polite"), navigator.userAgent.match(/rv:.*Gecko\//) ? e.setAttribute("aria-relevant", "additions") : e.setAttribute("aria-relevant", "text"), e.addEventListener("click", this._onClick.bind(this)), e.addEventListener("focus", this._onFocus.bind(this)), e.addEventListener("focusout", this._onFocusOut.bind(this))), e.style.pointerEvents = t.accessiblePointerEvents, e.type = t.accessibleType, t.accessibleTitle && t.accessibleTitle !== null ? e.title = t.accessibleTitle : (!t.accessibleHint || t.accessibleHint === null) && (e.title = `container ${t.tabIndex}`), t.accessibleHint && t.accessibleHint !== null && e.setAttribute("aria-label", t.accessibleHint), t.interactive ? e.tabIndex = t.tabIndex : e.tabIndex = 0, this.debug && this._updateDebugHTML(e), t._accessibleActive = !0, t._accessibleDiv = e, e.container = t, this._children.push(t), this._div.appendChild(t._accessibleDiv);
  }
  /**
   * Dispatch events with the EventSystem.
   * @param e
   * @param type
   * @private
   */
  _dispatchEvent(t, e) {
    const { container: i } = t.target, s = this._renderer.events.rootBoundary, o = Object.assign(new Xl(s), { target: i });
    s.rootTarget = this._renderer.lastObjectRendered, e.forEach((l) => s.dispatchEvent(o, l));
  }
  /**
   * Maps the div button press to pixi's EventSystem (click)
   * @private
   * @param {MouseEvent} e - The click event.
   */
  _onClick(t) {
    this._dispatchEvent(t, ["click", "pointertap", "tap"]);
  }
  /**
   * Maps the div focus events to pixi's EventSystem (mouseover)
   * @private
   * @param {FocusEvent} e - The focus event.
   */
  _onFocus(t) {
    t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "assertive"), this._dispatchEvent(t, ["mouseover"]);
  }
  /**
   * Maps the div focus events to pixi's EventSystem (mouseout)
   * @private
   * @param {FocusEvent} e - The focusout event.
   */
  _onFocusOut(t) {
    t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "polite"), this._dispatchEvent(t, ["mouseout"]);
  }
  /**
   * Is called when a key is pressed
   * @private
   * @param {KeyboardEvent} e - The keydown event.
   */
  _onKeyDown(t) {
    t.keyCode !== kA || !this._activateOnTab || this._activate();
  }
  /**
   * Is called when the mouse moves across the renderer element
   * @private
   * @param {MouseEvent} e - The mouse event.
   */
  _onMouseMove(t) {
    t.movementX === 0 && t.movementY === 0 || this._deactivate();
  }
  /**
   * Destroys the accessibility system. Removes all elements and listeners.
   * > [!IMPORTANT] This is typically called automatically when the {@link Application} is destroyed.
   * > A typically user should not need to call this method directly.
   */
  destroy() {
    this._deactivate(), this._destroyTouchHook(), this._canvasObserver?.destroy(), this._canvasObserver = null, this._div = null, this._pool = null, this._children = null, this._renderer = null, this._activateOnTab && globalThis.removeEventListener("keydown", this._onKeyDown);
  }
  /**
   * Enables or disables the accessibility system.
   * @param enabled - Whether to enable or disable accessibility.
   * @example
   * ```js
   * app.renderer.accessibility.setAccessibilityEnabled(true); // Enable accessibility
   * app.renderer.accessibility.setAccessibilityEnabled(false); // Disable accessibility
   * ```
   */
  setAccessibilityEnabled(t) {
    t ? this._activate() : this._deactivate();
  }
};
ng.extension = {
  type: [
    W.WebGLSystem,
    W.WebGPUSystem
  ],
  name: "accessibility"
};
ng.defaultOptions = {
  /**
   * Whether to enable accessibility features on initialization
   * @default false
   */
  enabledByDefault: !1,
  /**
   * Whether to visually show the accessibility divs for debugging
   * @default false
   */
  debug: !1,
  /**
   * Whether to activate accessibility when tab key is pressed
   * @default true
   */
  activateOnTab: !0,
  /**
   * Whether to deactivate accessibility when mouse moves
   * @default true
   */
  deactivateOnMouseMove: !0
};
let IA = ng;
const zA = {
  accessible: !1,
  accessibleTitle: null,
  accessibleHint: null,
  tabIndex: 0,
  accessibleType: "button",
  accessibleText: null,
  accessiblePointerEvents: "auto",
  accessibleChildren: !0,
  _accessibleActive: !1,
  _accessibleDiv: null,
  _renderId: -1
}, Sp = /* @__PURE__ */ Object.create(null), z_ = /* @__PURE__ */ Object.create(null);
function Nl(n, t) {
  let e = z_[n];
  return e === void 0 && (Sp[t] === void 0 && (Sp[t] = 1), z_[n] = e = Sp[t]++), e;
}
let wc;
function R1() {
  return (!wc || wc?.isContextLost()) && (wc = ve.get().createCanvas().getContext("webgl", {})), wc;
}
let Cc;
function LA() {
  if (!Cc) {
    Cc = "mediump";
    const n = R1();
    n && n.getShaderPrecisionFormat && (Cc = n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT).precision ? "highp" : "mediump");
  }
  return Cc;
}
function FA(n, t, e) {
  return t ? n : e ? (n = n.replace("out vec4 finalColor;", ""), `

        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${n}
        `) : `

        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${n}
        `;
}
function HA(n, t, e) {
  const i = e ? t.maxSupportedFragmentPrecision : t.maxSupportedVertexPrecision;
  if (n.substring(0, 9) !== "precision") {
    let s = e ? t.requestedFragmentPrecision : t.requestedVertexPrecision;
    return s === "highp" && i !== "highp" && (s = "mediump"), `precision ${s} float;
${n}`;
  } else if (i !== "highp" && n.substring(0, 15) === "precision highp")
    return n.replace("precision highp", "precision mediump");
  return n;
}
function $A(n, t) {
  return t ? `#version 300 es
${n}` : n;
}
const WA = {}, VA = {};
function jA(n, { name: t = "pixi-program" }, e = !0) {
  t = t.replace(/\s+/g, "-"), t += e ? "-fragment" : "-vertex";
  const i = e ? WA : VA;
  return i[t] ? (i[t]++, t += `-${i[t]}`) : i[t] = 1, n.indexOf("#define SHADER_NAME") !== -1 ? n : `${`#define SHADER_NAME ${t}`}
${n}`;
}
function YA(n, t) {
  return t ? n.replace("#version 300 es", "") : n;
}
const Tp = {
  // strips any version headers..
  stripVersion: YA,
  // adds precision string if not already present
  ensurePrecision: HA,
  // add some defines if WebGL1 to make it more compatible with WebGL2 shaders
  addProgramDefines: FA,
  // add the program name to the shader
  setProgramName: jA,
  // add the version string to the shader header
  insertVersion: $A
}, rl = /* @__PURE__ */ Object.create(null), P1 = class pm {
  /**
   * Creates a shiny new GlProgram. Used by WebGL renderer.
   * @param options - The options for the program.
   */
  constructor(t) {
    t = { ...pm.defaultOptions, ...t };
    const e = t.fragment.indexOf("#version 300 es") !== -1, i = {
      stripVersion: e,
      ensurePrecision: {
        requestedFragmentPrecision: t.preferredFragmentPrecision,
        requestedVertexPrecision: t.preferredVertexPrecision,
        maxSupportedVertexPrecision: "highp",
        maxSupportedFragmentPrecision: LA()
      },
      setProgramName: {
        name: t.name
      },
      addProgramDefines: e,
      insertVersion: e
    };
    let s = t.fragment, o = t.vertex;
    Object.keys(Tp).forEach((l) => {
      const c = i[l];
      s = Tp[l](s, c, !0), o = Tp[l](o, c, !1);
    }), this.fragment = s, this.vertex = o, this.transformFeedbackVaryings = t.transformFeedbackVaryings, this._key = Nl(`${this.vertex}:${this.fragment}`, "gl-program");
  }
  /** destroys the program */
  destroy() {
    this.fragment = null, this.vertex = null, this._attributeData = null, this._uniformData = null, this._uniformBlockData = null, this.transformFeedbackVaryings = null, rl[this._cacheKey] = null;
  }
  /**
   * Helper function that creates a program for a given source.
   * It will check the program cache if the program has already been created.
   * If it has that one will be returned, if not a new one will be created and cached.
   * @param options - The options for the program.
   * @returns A program using the same source
   */
  static from(t) {
    const e = `${t.vertex}:${t.fragment}`;
    return rl[e] || (rl[e] = new pm(t), rl[e]._cacheKey = e), rl[e];
  }
};
P1.defaultOptions = {
  preferredVertexPrecision: "highp",
  preferredFragmentPrecision: "mediump"
};
let eo = P1;
const L_ = {
  uint8x2: { size: 2, stride: 2, normalised: !1 },
  uint8x4: { size: 4, stride: 4, normalised: !1 },
  sint8x2: { size: 2, stride: 2, normalised: !1 },
  sint8x4: { size: 4, stride: 4, normalised: !1 },
  unorm8x2: { size: 2, stride: 2, normalised: !0 },
  unorm8x4: { size: 4, stride: 4, normalised: !0 },
  snorm8x2: { size: 2, stride: 2, normalised: !0 },
  snorm8x4: { size: 4, stride: 4, normalised: !0 },
  uint16x2: { size: 2, stride: 4, normalised: !1 },
  uint16x4: { size: 4, stride: 8, normalised: !1 },
  sint16x2: { size: 2, stride: 4, normalised: !1 },
  sint16x4: { size: 4, stride: 8, normalised: !1 },
  unorm16x2: { size: 2, stride: 4, normalised: !0 },
  unorm16x4: { size: 4, stride: 8, normalised: !0 },
  snorm16x2: { size: 2, stride: 4, normalised: !0 },
  snorm16x4: { size: 4, stride: 8, normalised: !0 },
  float16x2: { size: 2, stride: 4, normalised: !1 },
  float16x4: { size: 4, stride: 8, normalised: !1 },
  float32: { size: 1, stride: 4, normalised: !1 },
  float32x2: { size: 2, stride: 8, normalised: !1 },
  float32x3: { size: 3, stride: 12, normalised: !1 },
  float32x4: { size: 4, stride: 16, normalised: !1 },
  uint32: { size: 1, stride: 4, normalised: !1 },
  uint32x2: { size: 2, stride: 8, normalised: !1 },
  uint32x3: { size: 3, stride: 12, normalised: !1 },
  uint32x4: { size: 4, stride: 16, normalised: !1 },
  sint32: { size: 1, stride: 4, normalised: !1 },
  sint32x2: { size: 2, stride: 8, normalised: !1 },
  sint32x3: { size: 3, stride: 12, normalised: !1 },
  sint32x4: { size: 4, stride: 16, normalised: !1 }
};
function Jr(n) {
  return L_[n] ?? L_.float32;
}
const XA = {
  f32: "float32",
  "vec2<f32>": "float32x2",
  "vec3<f32>": "float32x3",
  "vec4<f32>": "float32x4",
  vec2f: "float32x2",
  vec3f: "float32x3",
  vec4f: "float32x4",
  i32: "sint32",
  "vec2<i32>": "sint32x2",
  "vec3<i32>": "sint32x3",
  "vec4<i32>": "sint32x4",
  u32: "uint32",
  "vec2<u32>": "uint32x2",
  "vec3<u32>": "uint32x3",
  "vec4<u32>": "uint32x4",
  bool: "uint32",
  "vec2<bool>": "uint32x2",
  "vec3<bool>": "uint32x3",
  "vec4<bool>": "uint32x4"
};
function qA({ source: n, entryPoint: t }) {
  const e = {}, i = n.indexOf(`fn ${t}`);
  if (i !== -1) {
    const s = n.indexOf("->", i);
    if (s !== -1) {
      const o = n.substring(i, s), l = /@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g;
      let c;
      for (; (c = l.exec(o)) !== null; ) {
        const d = XA[c[3]] ?? "float32";
        e[c[2]] = {
          location: parseInt(c[1], 10),
          format: d,
          stride: Jr(d).stride,
          offset: 0,
          instance: !1,
          start: 0
        };
      }
    }
  }
  return e;
}
function wp(n) {
  const t = /(^|[^/])@(group|binding)\(\d+\)[^;]+;/g, e = /@group\((\d+)\)/, i = /@binding\((\d+)\)/, s = /var(<[^>]+>)? (\w+)/, o = /:\s*(\w+)/, l = /struct\s+(\w+)\s*{([^}]+)}/g, c = /(\w+)\s*:\s*([\w\<\>]+)/g, d = /struct\s+(\w+)/, f = n.match(t)?.map((y) => ({
    group: parseInt(y.match(e)[1], 10),
    binding: parseInt(y.match(i)[1], 10),
    name: y.match(s)[2],
    isUniform: y.match(s)[1] === "<uniform>",
    type: y.match(o)[1]
  }));
  if (!f)
    return {
      groups: [],
      structs: []
    };
  const m = n.match(l)?.map((y) => {
    const b = y.match(d)[1], v = y.match(c).reduce((x, S) => {
      const [_, C] = S.split(":");
      return x[_.trim()] = C.trim(), x;
    }, {});
    return v ? { name: b, members: v } : null;
  }).filter(({ name: y }) => f.some((b) => b.type === y)) ?? [];
  return {
    groups: f,
    structs: m
  };
}
var vl = /* @__PURE__ */ ((n) => (n[n.VERTEX = 1] = "VERTEX", n[n.FRAGMENT = 2] = "FRAGMENT", n[n.COMPUTE = 4] = "COMPUTE", n))(vl || {});
function KA({ groups: n }) {
  const t = [];
  for (let e = 0; e < n.length; e++) {
    const i = n[e];
    t[i.group] || (t[i.group] = []), i.isUniform ? t[i.group].push({
      binding: i.binding,
      visibility: vl.VERTEX | vl.FRAGMENT,
      buffer: {
        type: "uniform"
      }
    }) : i.type === "sampler" ? t[i.group].push({
      binding: i.binding,
      visibility: vl.FRAGMENT,
      sampler: {
        type: "filtering"
      }
    }) : i.type === "texture_2d" && t[i.group].push({
      binding: i.binding,
      visibility: vl.FRAGMENT,
      texture: {
        sampleType: "float",
        viewDimension: "2d",
        multisampled: !1
      }
    });
  }
  return t;
}
function ZA({ groups: n }) {
  const t = [];
  for (let e = 0; e < n.length; e++) {
    const i = n[e];
    t[i.group] || (t[i.group] = {}), t[i.group][i.name] = i.binding;
  }
  return t;
}
function QA(n, t) {
  const e = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Set(), s = [...n.structs, ...t.structs].filter((l) => e.has(l.name) ? !1 : (e.add(l.name), !0)), o = [...n.groups, ...t.groups].filter((l) => {
    const c = `${l.name}-${l.binding}`;
    return i.has(c) ? !1 : (i.add(c), !0);
  });
  return { structs: s, groups: o };
}
const sl = /* @__PURE__ */ Object.create(null);
class Ns {
  /**
   * Create a new GpuProgram
   * @param options - The options for the gpu program
   */
  constructor(t) {
    this._layoutKey = 0, this._attributeLocationsKey = 0;
    const { fragment: e, vertex: i, layout: s, gpuLayout: o, name: l } = t;
    if (this.name = l, this.fragment = e, this.vertex = i, e.source === i.source) {
      const c = wp(e.source);
      this.structsAndGroups = c;
    } else {
      const c = wp(i.source), d = wp(e.source);
      this.structsAndGroups = QA(c, d);
    }
    this.layout = s ?? ZA(this.structsAndGroups), this.gpuLayout = o ?? KA(this.structsAndGroups), this.autoAssignGlobalUniforms = this.layout[0]?.globalUniforms !== void 0, this.autoAssignLocalUniforms = this.layout[1]?.localUniforms !== void 0, this._generateProgramKey();
  }
  // TODO maker this pure
  _generateProgramKey() {
    const { vertex: t, fragment: e } = this, i = t.source + e.source + t.entryPoint + e.entryPoint;
    this._layoutKey = Nl(i, "program");
  }
  get attributeData() {
    return this._attributeData ?? (this._attributeData = qA(this.vertex)), this._attributeData;
  }
  /** destroys the program */
  destroy() {
    this.gpuLayout = null, this.layout = null, this.structsAndGroups = null, this.fragment = null, this.vertex = null, sl[this._cacheKey] = null;
  }
  /**
   * Helper function that creates a program for a given source.
   * It will check the program cache if the program has already been created.
   * If it has that one will be returned, if not a new one will be created and cached.
   * @param options - The options for the program.
   * @returns A program using the same source
   */
  static from(t) {
    const e = `${t.vertex.source}:${t.fragment.source}:${t.fragment.entryPoint}:${t.vertex.entryPoint}`;
    return sl[e] || (sl[e] = new Ns(t), sl[e]._cacheKey = e), sl[e];
  }
}
const B1 = [
  "f32",
  "i32",
  "vec2<f32>",
  "vec3<f32>",
  "vec4<f32>",
  "mat2x2<f32>",
  "mat3x3<f32>",
  "mat4x4<f32>",
  "mat3x2<f32>",
  "mat4x2<f32>",
  "mat2x3<f32>",
  "mat4x3<f32>",
  "mat2x4<f32>",
  "mat3x4<f32>",
  "vec2<i32>",
  "vec3<i32>",
  "vec4<i32>"
], JA = B1.reduce((n, t) => (n[t] = !0, n), {});
function tR(n, t) {
  switch (n) {
    case "f32":
      return 0;
    case "vec2<f32>":
      return new Float32Array(2 * t);
    case "vec3<f32>":
      return new Float32Array(3 * t);
    case "vec4<f32>":
      return new Float32Array(4 * t);
    case "mat2x2<f32>":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3x3<f32>":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4x4<f32>":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
}
const k1 = class O1 {
  /**
   * Create a new Uniform group
   * @param uniformStructures - The structures of the uniform group
   * @param options - The optional parameters of this uniform group
   */
  constructor(t, e) {
    this._touched = 0, this.uid = Ee("uniform"), this._resourceType = "uniformGroup", this._resourceId = Ee("resource"), this.isUniformGroup = !0, this._dirtyId = 0, this.destroyed = !1, e = { ...O1.defaultOptions, ...e }, this.uniformStructures = t;
    const i = {};
    for (const s in t) {
      const o = t[s];
      if (o.name = s, o.size = o.size ?? 1, !JA[o.type]) {
        const l = o.type.match(/^array<(\w+(?:<\w+>)?),\s*(\d+)>$/);
        if (l) {
          const [, c, d] = l;
          throw new Error(
            `Uniform type ${o.type} is not supported. Use type: '${c}', size: ${d} instead.`
          );
        }
        throw new Error(`Uniform type ${o.type} is not supported. Supported uniform types are: ${B1.join(", ")}`);
      }
      o.value ?? (o.value = tR(o.type, o.size)), i[s] = o.value;
    }
    this.uniforms = i, this._dirtyId = 1, this.ubo = e.ubo, this.isStatic = e.isStatic, this._signature = Nl(Object.keys(i).map(
      (s) => `${s}-${t[s].type}`
    ).join("-"), "uniform-group");
  }
  /** Call this if you want the uniform groups data to be uploaded to the GPU only useful if `isStatic` is true. */
  update() {
    this._dirtyId++;
  }
};
k1.defaultOptions = {
  /** if true the UniformGroup is handled as an Uniform buffer object. */
  ubo: !1,
  /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */
  isStatic: !1
};
let Pn = k1;
class yr {
  /**
   * Create a new instance eof the Bind Group.
   * @param resources - The resources that are bound together for use by a shader.
   */
  constructor(t) {
    this.resources = /* @__PURE__ */ Object.create(null), this._dirty = !0;
    let e = 0;
    for (const i in t) {
      const s = t[i];
      this.setResource(s, e++);
    }
    this._updateKey();
  }
  /**
   * Updates the key if its flagged as dirty. This is used internally to
   * match this bind group to a WebGPU BindGroup.
   * @internal
   */
  _updateKey() {
    if (!this._dirty)
      return;
    this._dirty = !1;
    const t = [];
    let e = 0;
    for (const i in this.resources)
      t[e++] = this.resources[i]._resourceId;
    this._key = t.join("|");
  }
  /**
   * Set a resource at a given index. this function will
   * ensure that listeners will be removed from the current resource
   * and added to the new resource.
   * @param resource - The resource to set.
   * @param index - The index to set the resource at.
   */
  setResource(t, e) {
    const i = this.resources[e];
    t !== i && (i && t.off?.("change", this.onResourceChange, this), t.on?.("change", this.onResourceChange, this), this.resources[e] = t, this._dirty = !0);
  }
  /**
   * Returns the resource at the current specified index.
   * @param index - The index of the resource to get.
   * @returns - The resource at the specified index.
   */
  getResource(t) {
    return this.resources[t];
  }
  /**
   * Used internally to 'touch' each resource, to ensure that the GC
   * knows that all resources in this bind group are still being used.
   * @param tick - The current tick.
   * @internal
   */
  _touch(t) {
    const e = this.resources;
    for (const i in e)
      e[i]._touched = t;
  }
  /** Destroys this bind group and removes all listeners. */
  destroy() {
    const t = this.resources;
    for (const e in t)
      t[e]?.off?.("change", this.onResourceChange, this);
    this.resources = null;
  }
  onResourceChange(t) {
    if (this._dirty = !0, t.destroyed) {
      const e = this.resources;
      for (const i in e)
        e[i] === t && (e[i] = null);
    } else
      this._updateKey();
  }
}
var Ti = /* @__PURE__ */ ((n) => (n[n.WEBGL = 1] = "WEBGL", n[n.WEBGPU = 2] = "WEBGPU", n[n.BOTH = 3] = "BOTH", n))(Ti || {});
class fi extends Jn {
  constructor(t) {
    super(), this.uid = Ee("shader"), this._uniformBindMap = /* @__PURE__ */ Object.create(null), this._ownedBindGroups = [];
    let {
      gpuProgram: e,
      glProgram: i,
      groups: s,
      resources: o,
      compatibleRenderers: l,
      groupMap: c
    } = t;
    this.gpuProgram = e, this.glProgram = i, l === void 0 && (l = 0, e && (l |= Ti.WEBGPU), i && (l |= Ti.WEBGL)), this.compatibleRenderers = l;
    const d = {};
    if (!o && !s && (o = {}), o && s)
      throw new Error("[Shader] Cannot have both resources and groups");
    if (!e && s && !c)
      throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");
    if (!e && s && c)
      for (const f in c)
        for (const m in c[f]) {
          const y = c[f][m];
          d[y] = {
            group: f,
            binding: m,
            name: y
          };
        }
    else if (e && s && !c) {
      const f = e.structsAndGroups.groups;
      c = {}, f.forEach((m) => {
        c[m.group] = c[m.group] || {}, c[m.group][m.binding] = m.name, d[m.name] = m;
      });
    } else if (o) {
      s = {}, c = {}, e && e.structsAndGroups.groups.forEach((y) => {
        c[y.group] = c[y.group] || {}, c[y.group][y.binding] = y.name, d[y.name] = y;
      });
      let f = 0;
      for (const m in o)
        d[m] || (s[99] || (s[99] = new yr(), this._ownedBindGroups.push(s[99])), d[m] = { group: 99, binding: f, name: m }, c[99] = c[99] || {}, c[99][f] = m, f++);
      for (const m in o) {
        const y = m;
        let b = o[m];
        !b.source && !b._resourceType && (b = new Pn(b));
        const v = d[y];
        v && (s[v.group] || (s[v.group] = new yr(), this._ownedBindGroups.push(s[v.group])), s[v.group].setResource(b, v.binding));
      }
    }
    this.groups = s, this._uniformBindMap = c, this.resources = this._buildResourceAccessor(s, d);
  }
  /**
   * Sometimes a resource group will be provided later (for example global uniforms)
   * In such cases, this method can be used to let the shader know about the group.
   * @param name - the name of the resource group
   * @param groupIndex - the index of the group (should match the webGPU shader group location)
   * @param bindIndex - the index of the bind point (should match the webGPU shader bind point)
   */
  addResource(t, e, i) {
    var s, o;
    (s = this._uniformBindMap)[e] || (s[e] = {}), (o = this._uniformBindMap[e])[i] || (o[i] = t), this.groups[e] || (this.groups[e] = new yr(), this._ownedBindGroups.push(this.groups[e]));
  }
  _buildResourceAccessor(t, e) {
    const i = {};
    for (const s in e) {
      const o = e[s];
      Object.defineProperty(i, o.name, {
        get() {
          return t[o.group].getResource(o.binding);
        },
        set(l) {
          t[o.group].setResource(l, o.binding);
        }
      });
    }
    return i;
  }
  /**
   * Use to destroy the shader when its not longer needed.
   * It will destroy the resources and remove listeners.
   * @param destroyPrograms - if the programs should be destroyed as well.
   * Make sure its not being used by other shaders!
   */
  destroy(t = !1) {
    this.emit("destroy", this), t && (this.gpuProgram?.destroy(), this.glProgram?.destroy()), this.gpuProgram = null, this.glProgram = null, this.removeAllListeners(), this._uniformBindMap = null, this._ownedBindGroups.forEach((e) => {
      e.destroy();
    }), this._ownedBindGroups = null, this.resources = null, this.groups = null;
  }
  static from(t) {
    const { gpu: e, gl: i, ...s } = t;
    let o, l;
    return e && (o = Ns.from(e)), i && (l = eo.from(i)), new fi({
      gpuProgram: o,
      glProgram: l,
      ...s
    });
  }
}
const eR = {
  normal: 0,
  add: 1,
  multiply: 2,
  screen: 3,
  overlay: 4,
  erase: 5,
  "normal-npm": 6,
  "add-npm": 7,
  "screen-npm": 8,
  min: 9,
  max: 10
}, Cp = 0, Ep = 1, Mp = 2, Ap = 3, Rp = 4, Pp = 5, mm = class D1 {
  constructor() {
    this.data = 0, this.blendMode = "normal", this.polygonOffset = 0, this.blend = !0, this.depthMask = !0;
  }
  /**
   * Activates blending of the computed fragment color values.
   * @default true
   */
  get blend() {
    return !!(this.data & 1 << Cp);
  }
  set blend(t) {
    !!(this.data & 1 << Cp) !== t && (this.data ^= 1 << Cp);
  }
  /**
   * Activates adding an offset to depth values of polygon's fragments
   * @default false
   */
  get offsets() {
    return !!(this.data & 1 << Ep);
  }
  set offsets(t) {
    !!(this.data & 1 << Ep) !== t && (this.data ^= 1 << Ep);
  }
  /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */
  set cullMode(t) {
    if (t === "none") {
      this.culling = !1;
      return;
    }
    this.culling = !0, this.clockwiseFrontFace = t === "front";
  }
  get cullMode() {
    return this.culling ? this.clockwiseFrontFace ? "front" : "back" : "none";
  }
  /**
   * Activates culling of polygons.
   * @default false
   */
  get culling() {
    return !!(this.data & 1 << Mp);
  }
  set culling(t) {
    !!(this.data & 1 << Mp) !== t && (this.data ^= 1 << Mp);
  }
  /**
   * Activates depth comparisons and updates to the depth buffer.
   * @default false
   */
  get depthTest() {
    return !!(this.data & 1 << Ap);
  }
  set depthTest(t) {
    !!(this.data & 1 << Ap) !== t && (this.data ^= 1 << Ap);
  }
  /**
   * Enables or disables writing to the depth buffer.
   * @default true
   */
  get depthMask() {
    return !!(this.data & 1 << Pp);
  }
  set depthMask(t) {
    !!(this.data & 1 << Pp) !== t && (this.data ^= 1 << Pp);
  }
  /**
   * Specifies whether or not front or back-facing polygons can be culled.
   * @default false
   */
  get clockwiseFrontFace() {
    return !!(this.data & 1 << Rp);
  }
  set clockwiseFrontFace(t) {
    !!(this.data & 1 << Rp) !== t && (this.data ^= 1 << Rp);
  }
  /**
   * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.
   * Setting this mode to anything other than NO_BLEND will automatically switch blending on.
   * @default 'normal'
   */
  get blendMode() {
    return this._blendMode;
  }
  set blendMode(t) {
    this.blend = t !== "none", this._blendMode = t, this._blendModeId = eR[t] || 0;
  }
  /**
   * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.
   * @default 0
   */
  get polygonOffset() {
    return this._polygonOffset;
  }
  set polygonOffset(t) {
    this.offsets = !!t, this._polygonOffset = t;
  }
  toString() {
    return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;
  }
  /**
   * A quickly getting an instance of a State that is configured for 2d rendering.
   * @returns a new State with values set for 2d rendering
   */
  static for2d() {
    const t = new D1();
    return t.depthTest = !1, t.blend = !0, t;
  }
};
mm.default2d = mm.for2d();
let wi = mm;
const G1 = class gm extends fi {
  /**
   * @param options - The optional parameters of this filter.
   */
  constructor(t) {
    t = { ...gm.defaultOptions, ...t }, super(t), this.enabled = !0, this._state = wi.for2d(), this.blendMode = t.blendMode, this.padding = t.padding, typeof t.antialias == "boolean" ? this.antialias = t.antialias ? "on" : "off" : this.antialias = t.antialias, this.resolution = t.resolution, this.blendRequired = t.blendRequired, this.clipToViewport = t.clipToViewport, this.addResource("uTexture", 0, 1);
  }
  /**
   * Applies the filter
   * @param filterManager - The renderer to retrieve the filter from
   * @param input - The input render target.
   * @param output - The target to output to.
   * @param clearMode - Should the output be cleared before rendering to it
   */
  apply(t, e, i, s) {
    t.applyFilter(this, e, i, s);
  }
  /**
   * Get the blend mode of the filter.
   * @default "normal"
   */
  get blendMode() {
    return this._state.blendMode;
  }
  /** Sets the blend mode of the filter. */
  set blendMode(t) {
    this._state.blendMode = t;
  }
  /**
   * A short hand function to create a filter based of a vertex and fragment shader src.
   * @param options
   * @returns A shiny new PixiJS filter!
   */
  static from(t) {
    const { gpu: e, gl: i, ...s } = t;
    let o, l;
    return e && (o = Ns.from(e)), i && (l = eo.from(i)), new gm({
      gpuProgram: o,
      glProgram: l,
      ...s
    });
  }
};
G1.defaultOptions = {
  blendMode: "normal",
  resolution: 1,
  padding: 0,
  antialias: "off",
  blendRequired: !1,
  clipToViewport: !0
};
let nR = G1;
const ym = [];
Nt.handleByNamedList(W.Environment, ym);
async function iR(n) {
  if (!n)
    for (let t = 0; t < ym.length; t++) {
      const e = ym[t];
      if (e.value.test()) {
        await e.value.load();
        return;
      }
    }
}
let al;
function U1() {
  if (typeof al == "boolean")
    return al;
  try {
    al = new Function("param1", "param2", "param3", "return param1[param2] === param3;")({ a: "b" }, "a", "b") === !0;
  } catch {
    al = !1;
  }
  return al;
}
function F_(n, t, e = 2) {
  const i = t && t.length, s = i ? t[0] * e : n.length;
  let o = N1(n, 0, s, e, !0);
  const l = [];
  if (!o || o.next === o.prev) return l;
  let c, d, f;
  if (i && (o = lR(n, t, o, e)), n.length > 80 * e) {
    c = n[0], d = n[1];
    let m = c, y = d;
    for (let b = e; b < s; b += e) {
      const v = n[b], x = n[b + 1];
      v < c && (c = v), x < d && (d = x), v > m && (m = v), x > y && (y = x);
    }
    f = Math.max(m - c, y - d), f = f !== 0 ? 32767 / f : 0;
  }
  return Il(o, l, e, c, d, f, 0), l;
}
function N1(n, t, e, i, s) {
  let o;
  if (s === vR(n, t, e, i) > 0)
    for (let l = t; l < e; l += i) o = H_(l / i | 0, n[l], n[l + 1], o);
  else
    for (let l = e - i; l >= t; l -= i) o = H_(l / i | 0, n[l], n[l + 1], o);
  return o && Xa(o, o.next) && (Ll(o), o = o.next), o;
}
function Us(n, t) {
  if (!n) return n;
  t || (t = n);
  let e = n, i;
  do
    if (i = !1, !e.steiner && (Xa(e, e.next) || Ue(e.prev, e, e.next) === 0)) {
      if (Ll(e), e = t = e.prev, e === e.next) break;
      i = !0;
    } else
      e = e.next;
  while (i || e !== t);
  return t;
}
function Il(n, t, e, i, s, o, l) {
  if (!n) return;
  !l && o && fR(n, i, s, o);
  let c = n;
  for (; n.prev !== n.next; ) {
    const d = n.prev, f = n.next;
    if (o ? sR(n, i, s, o) : rR(n)) {
      t.push(d.i, n.i, f.i), Ll(n), n = f.next, c = f.next;
      continue;
    }
    if (n = f, n === c) {
      l ? l === 1 ? (n = aR(Us(n), t), Il(n, t, e, i, s, o, 2)) : l === 2 && oR(n, t, e, i, s, o) : Il(Us(n), t, e, i, s, o, 1);
      break;
    }
  }
}
function rR(n) {
  const t = n.prev, e = n, i = n.next;
  if (Ue(t, e, i) >= 0) return !1;
  const s = t.x, o = e.x, l = i.x, c = t.y, d = e.y, f = i.y, m = Math.min(s, o, l), y = Math.min(c, d, f), b = Math.max(s, o, l), v = Math.max(c, d, f);
  let x = i.next;
  for (; x !== t; ) {
    if (x.x >= m && x.x <= b && x.y >= y && x.y <= v && xl(s, c, o, d, l, f, x.x, x.y) && Ue(x.prev, x, x.next) >= 0) return !1;
    x = x.next;
  }
  return !0;
}
function sR(n, t, e, i) {
  const s = n.prev, o = n, l = n.next;
  if (Ue(s, o, l) >= 0) return !1;
  const c = s.x, d = o.x, f = l.x, m = s.y, y = o.y, b = l.y, v = Math.min(c, d, f), x = Math.min(m, y, b), S = Math.max(c, d, f), _ = Math.max(m, y, b), C = bm(v, x, t, e, i), R = bm(S, _, t, e, i);
  let w = n.prevZ, E = n.nextZ;
  for (; w && w.z >= C && E && E.z <= R; ) {
    if (w.x >= v && w.x <= S && w.y >= x && w.y <= _ && w !== s && w !== l && xl(c, m, d, y, f, b, w.x, w.y) && Ue(w.prev, w, w.next) >= 0 || (w = w.prevZ, E.x >= v && E.x <= S && E.y >= x && E.y <= _ && E !== s && E !== l && xl(c, m, d, y, f, b, E.x, E.y) && Ue(E.prev, E, E.next) >= 0)) return !1;
    E = E.nextZ;
  }
  for (; w && w.z >= C; ) {
    if (w.x >= v && w.x <= S && w.y >= x && w.y <= _ && w !== s && w !== l && xl(c, m, d, y, f, b, w.x, w.y) && Ue(w.prev, w, w.next) >= 0) return !1;
    w = w.prevZ;
  }
  for (; E && E.z <= R; ) {
    if (E.x >= v && E.x <= S && E.y >= x && E.y <= _ && E !== s && E !== l && xl(c, m, d, y, f, b, E.x, E.y) && Ue(E.prev, E, E.next) >= 0) return !1;
    E = E.nextZ;
  }
  return !0;
}
function aR(n, t) {
  let e = n;
  do {
    const i = e.prev, s = e.next.next;
    !Xa(i, s) && z1(i, e, e.next, s) && zl(i, s) && zl(s, i) && (t.push(i.i, e.i, s.i), Ll(e), Ll(e.next), e = n = s), e = e.next;
  } while (e !== n);
  return Us(e);
}
function oR(n, t, e, i, s, o) {
  let l = n;
  do {
    let c = l.next.next;
    for (; c !== l.prev; ) {
      if (l.i !== c.i && gR(l, c)) {
        let d = L1(l, c);
        l = Us(l, l.next), d = Us(d, d.next), Il(l, t, e, i, s, o, 0), Il(d, t, e, i, s, o, 0);
        return;
      }
      c = c.next;
    }
    l = l.next;
  } while (l !== n);
}
function lR(n, t, e, i) {
  const s = [];
  for (let o = 0, l = t.length; o < l; o++) {
    const c = t[o] * i, d = o < l - 1 ? t[o + 1] * i : n.length, f = N1(n, c, d, i, !1);
    f === f.next && (f.steiner = !0), s.push(mR(f));
  }
  s.sort(uR);
  for (let o = 0; o < s.length; o++)
    e = cR(s[o], e);
  return e;
}
function uR(n, t) {
  let e = n.x - t.x;
  if (e === 0 && (e = n.y - t.y, e === 0)) {
    const i = (n.next.y - n.y) / (n.next.x - n.x), s = (t.next.y - t.y) / (t.next.x - t.x);
    e = i - s;
  }
  return e;
}
function cR(n, t) {
  const e = hR(n, t);
  if (!e)
    return t;
  const i = L1(e, n);
  return Us(i, i.next), Us(e, e.next);
}
function hR(n, t) {
  let e = t;
  const i = n.x, s = n.y;
  let o = -1 / 0, l;
  if (Xa(n, e)) return e;
  do {
    if (Xa(n, e.next)) return e.next;
    if (s <= e.y && s >= e.next.y && e.next.y !== e.y) {
      const y = e.x + (s - e.y) * (e.next.x - e.x) / (e.next.y - e.y);
      if (y <= i && y > o && (o = y, l = e.x < e.next.x ? e : e.next, y === i))
        return l;
    }
    e = e.next;
  } while (e !== t);
  if (!l) return null;
  const c = l, d = l.x, f = l.y;
  let m = 1 / 0;
  e = l;
  do {
    if (i >= e.x && e.x >= d && i !== e.x && I1(s < f ? i : o, s, d, f, s < f ? o : i, s, e.x, e.y)) {
      const y = Math.abs(s - e.y) / (i - e.x);
      zl(e, n) && (y < m || y === m && (e.x > l.x || e.x === l.x && dR(l, e))) && (l = e, m = y);
    }
    e = e.next;
  } while (e !== c);
  return l;
}
function dR(n, t) {
  return Ue(n.prev, n, t.prev) < 0 && Ue(t.next, n, n.next) < 0;
}
function fR(n, t, e, i) {
  let s = n;
  do
    s.z === 0 && (s.z = bm(s.x, s.y, t, e, i)), s.prevZ = s.prev, s.nextZ = s.next, s = s.next;
  while (s !== n);
  s.prevZ.nextZ = null, s.prevZ = null, pR(s);
}
function pR(n) {
  let t, e = 1;
  do {
    let i = n, s;
    n = null;
    let o = null;
    for (t = 0; i; ) {
      t++;
      let l = i, c = 0;
      for (let f = 0; f < e && (c++, l = l.nextZ, !!l); f++)
        ;
      let d = e;
      for (; c > 0 || d > 0 && l; )
        c !== 0 && (d === 0 || !l || i.z <= l.z) ? (s = i, i = i.nextZ, c--) : (s = l, l = l.nextZ, d--), o ? o.nextZ = s : n = s, s.prevZ = o, o = s;
      i = l;
    }
    o.nextZ = null, e *= 2;
  } while (t > 1);
  return n;
}
function bm(n, t, e, i, s) {
  return n = (n - e) * s | 0, t = (t - i) * s | 0, n = (n | n << 8) & 16711935, n = (n | n << 4) & 252645135, n = (n | n << 2) & 858993459, n = (n | n << 1) & 1431655765, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, n | t << 1;
}
function mR(n) {
  let t = n, e = n;
  do
    (t.x < e.x || t.x === e.x && t.y < e.y) && (e = t), t = t.next;
  while (t !== n);
  return e;
}
function I1(n, t, e, i, s, o, l, c) {
  return (s - l) * (t - c) >= (n - l) * (o - c) && (n - l) * (i - c) >= (e - l) * (t - c) && (e - l) * (o - c) >= (s - l) * (i - c);
}
function xl(n, t, e, i, s, o, l, c) {
  return !(n === l && t === c) && I1(n, t, e, i, s, o, l, c);
}
function gR(n, t) {
  return n.next.i !== t.i && n.prev.i !== t.i && !yR(n, t) && // doesn't intersect other edges
  (zl(n, t) && zl(t, n) && bR(n, t) && // locally visible
  (Ue(n.prev, n, t.prev) || Ue(n, t.prev, t)) || // does not create opposite-facing sectors
  Xa(n, t) && Ue(n.prev, n, n.next) > 0 && Ue(t.prev, t, t.next) > 0);
}
function Ue(n, t, e) {
  return (t.y - n.y) * (e.x - t.x) - (t.x - n.x) * (e.y - t.y);
}
function Xa(n, t) {
  return n.x === t.x && n.y === t.y;
}
function z1(n, t, e, i) {
  const s = Mc(Ue(n, t, e)), o = Mc(Ue(n, t, i)), l = Mc(Ue(e, i, n)), c = Mc(Ue(e, i, t));
  return !!(s !== o && l !== c || s === 0 && Ec(n, e, t) || o === 0 && Ec(n, i, t) || l === 0 && Ec(e, n, i) || c === 0 && Ec(e, t, i));
}
function Ec(n, t, e) {
  return t.x <= Math.max(n.x, e.x) && t.x >= Math.min(n.x, e.x) && t.y <= Math.max(n.y, e.y) && t.y >= Math.min(n.y, e.y);
}
function Mc(n) {
  return n > 0 ? 1 : n < 0 ? -1 : 0;
}
function yR(n, t) {
  let e = n;
  do {
    if (e.i !== n.i && e.next.i !== n.i && e.i !== t.i && e.next.i !== t.i && z1(e, e.next, n, t)) return !0;
    e = e.next;
  } while (e !== n);
  return !1;
}
function zl(n, t) {
  return Ue(n.prev, n, n.next) < 0 ? Ue(n, t, n.next) >= 0 && Ue(n, n.prev, t) >= 0 : Ue(n, t, n.prev) < 0 || Ue(n, n.next, t) < 0;
}
function bR(n, t) {
  let e = n, i = !1;
  const s = (n.x + t.x) / 2, o = (n.y + t.y) / 2;
  do
    e.y > o != e.next.y > o && e.next.y !== e.y && s < (e.next.x - e.x) * (o - e.y) / (e.next.y - e.y) + e.x && (i = !i), e = e.next;
  while (e !== n);
  return i;
}
function L1(n, t) {
  const e = vm(n.i, n.x, n.y), i = vm(t.i, t.x, t.y), s = n.next, o = t.prev;
  return n.next = t, t.prev = n, e.next = s, s.prev = e, i.next = e, e.prev = i, o.next = i, i.prev = o, i;
}
function H_(n, t, e, i) {
  const s = vm(n, t, e);
  return i ? (s.next = i.next, s.prev = i, i.next.prev = s, i.next = s) : (s.prev = s, s.next = s), s;
}
function Ll(n) {
  n.next.prev = n.prev, n.prev.next = n.next, n.prevZ && (n.prevZ.nextZ = n.nextZ), n.nextZ && (n.nextZ.prevZ = n.prevZ);
}
function vm(n, t, e) {
  return {
    i: n,
    // vertex index in coordinates array
    x: t,
    y: e,
    // vertex coordinates
    prev: null,
    // previous and next vertex nodes in a polygon ring
    next: null,
    z: 0,
    // z-order curve value
    prevZ: null,
    // previous and next nodes in z-order
    nextZ: null,
    steiner: !1
    // indicates whether this is a steiner point
  };
}
function vR(n, t, e, i) {
  let s = 0;
  for (let o = t, l = e - i; o < e; o += i)
    s += (n[l] - n[o]) * (n[o + 1] + n[l + 1]), l = o;
  return s;
}
const xR = F_.default || F_;
var Xn = /* @__PURE__ */ ((n) => (n[n.NONE = 0] = "NONE", n[n.COLOR = 16384] = "COLOR", n[n.STENCIL = 1024] = "STENCIL", n[n.DEPTH = 256] = "DEPTH", n[n.COLOR_DEPTH = 16640] = "COLOR_DEPTH", n[n.COLOR_STENCIL = 17408] = "COLOR_STENCIL", n[n.DEPTH_STENCIL = 1280] = "DEPTH_STENCIL", n[n.ALL = 17664] = "ALL", n))(Xn || {});
class F1 {
  /**
   * @param name - The function name that will be executed on the listeners added to this Runner.
   */
  constructor(t) {
    this.items = [], this._name = t;
  }
  /* jsdoc/check-param-names */
  /**
   * Dispatch/Broadcast Runner to all listeners added to the queue.
   * @param {...any} params - (optional) parameters to pass to each listener
   */
  /* jsdoc/check-param-names */
  emit(t, e, i, s, o, l, c, d) {
    const { name: f, items: m } = this;
    for (let y = 0, b = m.length; y < b; y++)
      m[y][f](t, e, i, s, o, l, c, d);
    return this;
  }
  /**
   * Add a listener to the Runner
   *
   * Runners do not need to have scope or functions passed to them.
   * All that is required is to pass the listening object and ensure that it has contains a function that has the same name
   * as the name provided to the Runner when it was created.
   *
   * Eg A listener passed to this Runner will require a 'complete' function.
   *
   * ```ts
   * import { Runner } from 'pixi.js';
   *
   * const complete = new Runner('complete');
   * ```
   *
   * The scope used will be the object itself.
   * @param {any} item - The object that will be listening.
   */
  add(t) {
    return t[this._name] && (this.remove(t), this.items.push(t)), this;
  }
  /**
   * Remove a single listener from the dispatch queue.
   * @param {any} item - The listener that you would like to remove.
   */
  remove(t) {
    const e = this.items.indexOf(t);
    return e !== -1 && this.items.splice(e, 1), this;
  }
  /**
   * Check to see if the listener is already in the Runner
   * @param {any} item - The listener that you would like to check.
   */
  contains(t) {
    return this.items.indexOf(t) !== -1;
  }
  /** Remove all listeners from the Runner */
  removeAll() {
    return this.items.length = 0, this;
  }
  /** Remove all references, don't use after this. */
  destroy() {
    this.removeAll(), this.items = null, this._name = null;
  }
  /**
   * `true` if there are no this Runner contains no listeners
   * @readonly
   */
  get empty() {
    return this.items.length === 0;
  }
  /**
   * The name of the runner.
   * @readonly
   */
  get name() {
    return this._name;
  }
}
const _R = [
  "init",
  "destroy",
  "contextChange",
  "resolutionChange",
  "resetState",
  "renderEnd",
  "renderStart",
  "render",
  "update",
  "postrender",
  "prerender"
], H1 = class $1 extends Jn {
  /**
   * Set up a system with a collection of SystemClasses and runners.
   * Systems are attached dynamically to this class when added.
   * @param config - the config for the system manager
   */
  constructor(t) {
    super(), this.uid = Ee("renderer"), this.runners = /* @__PURE__ */ Object.create(null), this.renderPipes = /* @__PURE__ */ Object.create(null), this._initOptions = {}, this._systemsHash = /* @__PURE__ */ Object.create(null), this.type = t.type, this.name = t.name, this.config = t;
    const e = [..._R, ...this.config.runners ?? []];
    this._addRunners(...e), this._unsafeEvalCheck();
  }
  /**
   * Initialize the renderer.
   * @param options - The options to use to create the renderer.
   */
  async init(t = {}) {
    const e = t.skipExtensionImports === !0 ? !0 : t.manageImports === !1;
    await iR(e), this._addSystems(this.config.systems), this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors);
    for (const i in this._systemsHash)
      t = { ...this._systemsHash[i].constructor.defaultOptions, ...t };
    t = { ...$1.defaultOptions, ...t }, this._roundPixels = t.roundPixels ? 1 : 0;
    for (let i = 0; i < this.runners.init.items.length; i++)
      await this.runners.init.items[i].init(t);
    this._initOptions = t;
  }
  render(t, e) {
    let i = t;
    if (i instanceof Rn && (i = { container: i }, e && (zt(ae, "passing a second argument is deprecated, please use render options instead"), i.target = e.renderTexture)), i.target || (i.target = this.view.renderTarget), i.target === this.view.renderTarget && (this._lastObjectRendered = i.container, i.clearColor ?? (i.clearColor = this.background.colorRgba), i.clear ?? (i.clear = this.background.clearBeforeRender)), i.clearColor) {
      const s = Array.isArray(i.clearColor) && i.clearColor.length === 4;
      i.clearColor = s ? i.clearColor : Pe.shared.setValue(i.clearColor).toArray();
    }
    i.transform || (i.container.updateLocalTransform(), i.transform = i.container.localTransform), i.container.visible && (i.container.enableRenderGroup(), this.runners.prerender.emit(i), this.runners.renderStart.emit(i), this.runners.render.emit(i), this.runners.renderEnd.emit(i), this.runners.postrender.emit(i));
  }
  /**
   * Resizes the WebGL view to the specified width and height.
   * @param desiredScreenWidth - The desired width of the screen.
   * @param desiredScreenHeight - The desired height of the screen.
   * @param resolution - The resolution / device pixel ratio of the renderer.
   */
  resize(t, e, i) {
    const s = this.view.resolution;
    this.view.resize(t, e, i), this.emit("resize", this.view.screen.width, this.view.screen.height, this.view.resolution), i !== void 0 && i !== s && this.runners.resolutionChange.emit(i);
  }
  /**
   * Clears the render target.
   * @param options - The options to use when clearing the render target.
   * @param options.target - The render target to clear.
   * @param options.clearColor - The color to clear with.
   * @param options.clear - The clear mode to use.
   * @advanced
   */
  clear(t = {}) {
    const e = this;
    t.target || (t.target = e.renderTarget.renderTarget), t.clearColor || (t.clearColor = this.background.colorRgba), t.clear ?? (t.clear = Xn.ALL);
    const { clear: i, clearColor: s, target: o } = t;
    Pe.shared.setValue(s ?? this.background.colorRgba), e.renderTarget.clear(o, i, Pe.shared.toArray());
  }
  /** The resolution / device pixel ratio of the renderer. */
  get resolution() {
    return this.view.resolution;
  }
  set resolution(t) {
    this.view.resolution = t, this.runners.resolutionChange.emit(t);
  }
  /**
   * Same as view.width, actual number of pixels in the canvas by horizontal.
   * @type {number}
   * @readonly
   * @default 800
   */
  get width() {
    return this.view.texture.frame.width;
  }
  /**
   * Same as view.height, actual number of pixels in the canvas by vertical.
   * @default 600
   */
  get height() {
    return this.view.texture.frame.height;
  }
  // NOTE: this was `view` in v7
  /**
   * The canvas element that everything is drawn to.
   * @type {environment.ICanvas}
   */
  get canvas() {
    return this.view.canvas;
  }
  /**
   * the last object rendered by the renderer. Useful for other plugins like interaction managers
   * @readonly
   */
  get lastObjectRendered() {
    return this._lastObjectRendered;
  }
  /**
   * Flag if we are rendering to the screen vs renderTexture
   * @readonly
   * @default true
   */
  get renderingToScreen() {
    return this.renderTarget.renderingToScreen;
  }
  /**
   * Measurements of the screen. (0, 0, screenWidth, screenHeight).
   *
   * Its safe to use as filterArea or hitArea for the whole stage.
   */
  get screen() {
    return this.view.screen;
  }
  /**
   * Create a bunch of runners based of a collection of ids
   * @param runnerIds - the runner ids to add
   */
  _addRunners(...t) {
    t.forEach((e) => {
      this.runners[e] = new F1(e);
    });
  }
  _addSystems(t) {
    let e;
    for (e in t) {
      const i = t[e];
      this._addSystem(i.value, i.name);
    }
  }
  /**
   * Add a new system to the renderer.
   * @param ClassRef - Class reference
   * @param name - Property name for system, if not specified
   *        will use a static `name` property on the class itself. This
   *        name will be assigned as s property on the Renderer so make
   *        sure it doesn't collide with properties on Renderer.
   * @returns Return instance of renderer
   */
  _addSystem(t, e) {
    const i = new t(this);
    if (this[e])
      throw new Error(`Whoops! The name "${e}" is already in use`);
    this[e] = i, this._systemsHash[e] = i;
    for (const s in this.runners)
      this.runners[s].add(i);
    return this;
  }
  _addPipes(t, e) {
    const i = e.reduce((s, o) => (s[o.name] = o.value, s), {});
    t.forEach((s) => {
      const o = s.value, l = s.name, c = i[l];
      this.renderPipes[l] = new o(
        this,
        c ? new c() : null
      ), this.runners.destroy.add(this.renderPipes[l]);
    });
  }
  destroy(t = !1) {
    this.runners.destroy.items.reverse(), this.runners.destroy.emit(t), Object.values(this.runners).forEach((e) => {
      e.destroy();
    }), (t === !0 || typeof t == "object" && t.releaseGlobalResources) && to.release(), this._systemsHash = null, this.renderPipes = null;
  }
  /**
   * Generate a texture from a container.
   * @param options - options or container target to use when generating the texture
   * @returns a texture
   */
  generateTexture(t) {
    return this.textureGenerator.generateTexture(t);
  }
  /**
   * Whether the renderer will round coordinates to whole pixels when rendering.
   * Can be overridden on a per scene item basis.
   */
  get roundPixels() {
    return !!this._roundPixels;
  }
  /**
   * Overridable function by `pixi.js/unsafe-eval` to silence
   * throwing an error if platform doesn't support unsafe-evals.
   * @private
   * @ignore
   */
  _unsafeEvalCheck() {
    if (!U1())
      throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");
  }
  /**
   * Resets the rendering state of the renderer.
   * This is useful when you want to use the WebGL context directly and need to ensure PixiJS's internal state
   * stays synchronized. When modifying the WebGL context state externally, calling this method before the next Pixi
   * render will reset all internal caches and ensure it executes correctly.
   *
   * This is particularly useful when combining PixiJS with other rendering engines like Three.js:
   * ```js
   * // Reset Three.js state
   * threeRenderer.resetState();
   *
   * // Render a Three.js scene
   * threeRenderer.render(threeScene, threeCamera);
   *
   * // Reset PixiJS state since Three.js modified the WebGL context
   * pixiRenderer.resetState();
   *
   * // Now render Pixi content
   * pixiRenderer.render(pixiScene);
   * ```
   * @advanced
   */
  resetState() {
    this.runners.resetState.emit();
  }
};
H1.defaultOptions = {
  /**
   * Default resolution / device pixel ratio of the renderer.
   * @default 1
   */
  resolution: 1,
  /**
   * Should the `failIfMajorPerformanceCaveat` flag be enabled as a context option used in the `isWebGLSupported`
   * function. If set to true, a WebGL renderer can fail to be created if the browser thinks there could be
   * performance issues when using WebGL.
   *
   * In PixiJS v6 this has changed from true to false by default, to allow WebGL to work in as many
   * scenarios as possible. However, some users may have a poor experience, for example, if a user has a gpu or
   * driver version blacklisted by the
   * browser.
   *
   * If your application requires high performance rendering, you may wish to set this to false.
   * We recommend one of two options if you decide to set this flag to false:
   *
   * 1: Use the Canvas renderer as a fallback in case high performance WebGL is
   *    not supported.
   *
   * 2: Call `isWebGLSupported` (which if found in the utils package) in your code before attempting to create a
   *    PixiJS renderer, and show an error message to the user if the function returns false, explaining that their
   *    device & browser combination does not support high performance WebGL.
   *    This is a much better strategy than trying to create a PixiJS renderer and finding it then fails.
   * @default false
   */
  failIfMajorPerformanceCaveat: !1,
  /**
   * Should round pixels be forced when rendering?
   * @default false
   */
  roundPixels: !1
};
let Sh = H1, Ac;
function SR(n) {
  return Ac !== void 0 || (Ac = (() => {
    const t = {
      stencil: !0,
      failIfMajorPerformanceCaveat: n ?? Sh.defaultOptions.failIfMajorPerformanceCaveat
    };
    try {
      if (!ve.get().getWebGLRenderingContext())
        return !1;
      let i = ve.get().createCanvas().getContext("webgl", t);
      const s = !!i?.getContextAttributes()?.stencil;
      if (i) {
        const o = i.getExtension("WEBGL_lose_context");
        o && o.loseContext();
      }
      return i = null, s;
    } catch {
      return !1;
    }
  })()), Ac;
}
let Rc;
async function TR(n = {}) {
  return Rc !== void 0 || (Rc = await (async () => {
    const t = ve.get().getNavigator().gpu;
    if (!t)
      return !1;
    try {
      return await (await t.requestAdapter(n)).requestDevice(), !0;
    } catch {
      return !1;
    }
  })()), Rc;
}
const $_ = ["webgl", "webgpu", "canvas"];
async function wR(n) {
  let t = [];
  n.preference ? (t.push(n.preference), $_.forEach((o) => {
    o !== n.preference && t.push(o);
  })) : t = $_.slice();
  let e, i = {};
  for (let o = 0; o < t.length; o++) {
    const l = t[o];
    if (l === "webgpu" && await TR()) {
      const { WebGPURenderer: c } = await Promise.resolve().then(() => vk);
      e = c, i = { ...n, ...n.webgpu };
      break;
    } else if (l === "webgl" && SR(
      n.failIfMajorPerformanceCaveat ?? Sh.defaultOptions.failIfMajorPerformanceCaveat
    )) {
      const { WebGLRenderer: c } = await Promise.resolve().then(() => tk);
      e = c, i = { ...n, ...n.webgl };
      break;
    } else if (l === "canvas")
      throw i = { ...n }, new Error("CanvasRenderer is not yet implemented");
  }
  if (delete i.webgpu, delete i.webgl, !e)
    throw new Error("No available renderer for the current environment");
  const s = new e();
  return await s.init(i), s;
}
const ih = "8.13.2";
class W1 {
  static init() {
    globalThis.__PIXI_APP_INIT__?.(this, ih);
  }
  static destroy() {
  }
}
W1.extension = W.Application;
class V1 {
  constructor(t) {
    this._renderer = t;
  }
  init() {
    globalThis.__PIXI_RENDERER_INIT__?.(this._renderer, ih);
  }
  destroy() {
    this._renderer = null;
  }
}
V1.extension = {
  type: [
    W.WebGLSystem,
    W.WebGPUSystem
  ],
  name: "initHook",
  priority: -10
};
const j1 = class xm {
  constructor(...t) {
    this.stage = new Rn(), t[0] !== void 0 && zt(ae, "Application constructor options are deprecated, please use Application.init() instead.");
  }
  /**
   * Initializes the PixiJS application with the specified options.
   *
   * This method must be called after creating a new Application instance.
   * @param options - Configuration options for the application and renderer
   * @returns A promise that resolves when initialization is complete
   * @example
   * ```js
   * const app = new Application();
   *
   * // Initialize with custom options
   * await app.init({
   *     width: 800,
   *     height: 600,
   *     backgroundColor: 0x1099bb,
   *     preference: 'webgl', // or 'webgpu'
   * });
   * ```
   */
  async init(t) {
    t = { ...t }, this.renderer = await wR(t), xm._plugins.forEach((e) => {
      e.init.call(this, t);
    });
  }
  /**
   * Renders the current stage to the screen.
   *
   * When using the default setup with {@link TickerPlugin} (enabled by default), you typically don't need to call
   * this method directly as rendering is handled automatically.
   *
   * Only use this method if you've disabled the {@link TickerPlugin} or need custom
   * render timing control.
   * @example
   * ```js
   * // Example 1: Default setup (TickerPlugin handles rendering)
   * const app = new Application();
   * await app.init();
   * // No need to call render() - TickerPlugin handles it
   *
   * // Example 2: Custom rendering loop (if TickerPlugin is disabled)
   * const app = new Application();
   * await app.init({ autoStart: false }); // Disable automatic rendering
   *
   * function animate() {
   *     app.render();
   *     requestAnimationFrame(animate);
   * }
   * animate();
   * ```
   */
  render() {
    this.renderer.render({ container: this.stage });
  }
  /**
   * Reference to the renderer's canvas element. This is the HTML element
   * that displays your application's graphics.
   * @readonly
   * @type {HTMLCanvasElement}
   * @example
   * ```js
   * // Create a new application
   * const app = new Application();
   * // Initialize the application
   * await app.init({...});
   * // Add canvas to the page
   * document.body.appendChild(app.canvas);
   *
   * // Access the canvas directly
   * console.log(app.canvas); // HTMLCanvasElement
   * ```
   */
  get canvas() {
    return this.renderer.canvas;
  }
  /**
   * Reference to the renderer's canvas element.
   * @type {HTMLCanvasElement}
   * @deprecated since 8.0.0
   * @see {@link Application#canvas}
   */
  get view() {
    return zt(ae, "Application.view is deprecated, please use Application.canvas instead."), this.renderer.canvas;
  }
  /**
   * Reference to the renderer's screen rectangle. This represents the visible area of your application.
   *
   * It's commonly used for:
   * - Setting filter areas for full-screen effects
   * - Defining hit areas for screen-wide interaction
   * - Determining the visible bounds of your application
   * @readonly
   * @example
   * ```js
   * // Use as filter area for a full-screen effect
   * const blurFilter = new BlurFilter();
   * sprite.filterArea = app.screen;
   *
   * // Use as hit area for screen-wide interaction
   * const screenSprite = new Sprite();
   * screenSprite.hitArea = app.screen;
   *
   * // Get screen dimensions
   * console.log(app.screen.width, app.screen.height);
   * ```
   * @see {@link Rectangle} For all available properties and methods
   */
  get screen() {
    return this.renderer.screen;
  }
  /**
   * Destroys the application and all of its resources.
   *
   * This method should be called when you want to completely
   * clean up the application and free all associated memory.
   * @param rendererDestroyOptions - Options for destroying the renderer:
   *  - `false` or `undefined`: Preserves the canvas element (default)
   *  - `true`: Removes the canvas element
   *  - `{ removeView: boolean }`: Object with removeView property to control canvas removal
   * @param options - Options for destroying the application:
   *  - `false` or `undefined`: Basic cleanup (default)
   *  - `true`: Complete cleanup including children
   *  - Detailed options object:
   *    - `children`: Remove children
   *    - `texture`: Destroy textures
   *    - `textureSource`: Destroy texture sources
   *    - `context`: Destroy WebGL context
   * @example
   * ```js
   * // Basic cleanup
   * app.destroy();
   *
   * // Remove canvas and do complete cleanup
   * app.destroy(true, true);
   *
   * // Remove canvas with explicit options
   * app.destroy({ removeView: true }, true);
   *
   * // Detailed cleanup with specific options
   * app.destroy(
   *     { removeView: true },
   *     {
   *         children: true,
   *         texture: true,
   *         textureSource: true,
   *         context: true
   *     }
   * );
   * ```
   * > [!WARNING] After calling destroy, the application instance should no longer be used.
   * > All properties will be null and further operations will throw errors.
   */
  destroy(t = !1, e = !1) {
    const i = xm._plugins.slice(0);
    i.reverse(), i.forEach((s) => {
      s.destroy.call(this);
    }), this.stage.destroy(e), this.stage = null, this.renderer.destroy(t), this.renderer = null;
  }
};
j1._plugins = [];
let Y1 = j1;
Nt.handleByList(W.Application, Y1._plugins);
Nt.add(W1);
class X1 {
  /**
   * Initialize the plugin with scope of application instance
   * @private
   * @param {object} [options] - See application options
   */
  static init(t) {
    Object.defineProperty(
      this,
      "resizeTo",
      {
        set(e) {
          globalThis.removeEventListener("resize", this.queueResize), this._resizeTo = e, e && (globalThis.addEventListener("resize", this.queueResize), this.resize());
        },
        get() {
          return this._resizeTo;
        }
      }
    ), this.queueResize = () => {
      this._resizeTo && (this._cancelResize(), this._resizeId = requestAnimationFrame(() => this.resize()));
    }, this._cancelResize = () => {
      this._resizeId && (cancelAnimationFrame(this._resizeId), this._resizeId = null);
    }, this.resize = () => {
      if (!this._resizeTo)
        return;
      this._cancelResize();
      let e, i;
      if (this._resizeTo === globalThis.window)
        e = globalThis.innerWidth, i = globalThis.innerHeight;
      else {
        const { clientWidth: s, clientHeight: o } = this._resizeTo;
        e = s, i = o;
      }
      this.renderer.resize(e, i), this.render();
    }, this._resizeId = null, this._resizeTo = null, this.resizeTo = t.resizeTo || null;
  }
  /**
   * Clean up the ticker, scoped to application
   * @private
   */
  static destroy() {
    globalThis.removeEventListener("resize", this.queueResize), this._cancelResize(), this._cancelResize = null, this.queueResize = null, this.resizeTo = null, this.resize = null;
  }
}
X1.extension = W.Application;
class q1 {
  /**
   * Initialize the plugin with scope of application instance
   * @private
   * @param {object} [options] - See application options
   */
  static init(t) {
    t = Object.assign({
      autoStart: !0,
      sharedTicker: !1
    }, t), Object.defineProperty(
      this,
      "ticker",
      {
        set(e) {
          this._ticker && this._ticker.remove(this.render, this), this._ticker = e, e && e.add(this.render, this, Ya.LOW);
        },
        get() {
          return this._ticker;
        }
      }
    ), this.stop = () => {
      this._ticker.stop();
    }, this.start = () => {
      this._ticker.start();
    }, this._ticker = null, this.ticker = t.sharedTicker ? Kn.shared : new Kn(), t.autoStart && this.start();
  }
  /**
   * Clean up the ticker, scoped to application.
   * @private
   */
  static destroy() {
    if (this._ticker) {
      const t = this._ticker;
      this.ticker = null, t.destroy();
    }
  }
}
q1.extension = W.Application;
class CR extends Jn {
  constructor() {
    super(...arguments), this.chars = /* @__PURE__ */ Object.create(null), this.lineHeight = 0, this.fontFamily = "", this.fontMetrics = { fontSize: 0, ascent: 0, descent: 0 }, this.baseLineOffset = 0, this.distanceField = { type: "none", range: 0 }, this.pages = [], this.applyFillAsTint = !0, this.baseMeasurementFontSize = 100, this.baseRenderedFontSize = 100;
  }
  /**
   * The name of the font face.
   * @deprecated since 8.0.0 Use `fontFamily` instead.
   */
  get font() {
    return zt(ae, "BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead."), this.fontFamily;
  }
  /**
   * The map of base page textures (i.e., sheets of glyphs).
   * @deprecated since 8.0.0 Use `pages` instead.
   */
  get pageTextures() {
    return zt(ae, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."), this.pages;
  }
  /**
   * The size of the font face in pixels.
   * @deprecated since 8.0.0 Use `fontMetrics.fontSize` instead.
   */
  get size() {
    return zt(ae, "BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead."), this.fontMetrics.fontSize;
  }
  /**
   * The kind of distance field for this font or "none".
   * @deprecated since 8.0.0 Use `distanceField.type` instead.
   */
  get distanceFieldRange() {
    return zt(ae, "BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead."), this.distanceField.range;
  }
  /**
   * The range of the distance field in pixels.
   * @deprecated since 8.0.0 Use `distanceField.range` instead.
   */
  get distanceFieldType() {
    return zt(ae, "BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead."), this.distanceField.type;
  }
  destroy(t = !1) {
    this.emit("destroy", this), this.removeAllListeners();
    for (const e in this.chars)
      this.chars[e].texture?.destroy();
    this.chars = null, t && (this.pages.forEach((e) => e.texture.destroy(!0)), this.pages = null);
  }
}
/**
 * tiny-lru
 *
 * @copyright 2025 Jason Mulligan <jason.mulligan@avoidwork.com>
 * @license BSD-3-Clause
 * @version 11.4.5
 */
class ER {
  /**
   * Creates a new LRU cache instance.
   * Note: Constructor does not validate parameters. Use lru() factory function for parameter validation.
   *
   * @constructor
   * @param {number} [max=0] - Maximum number of items to store. 0 means unlimited.
   * @param {number} [ttl=0] - Time to live in milliseconds. 0 means no expiration.
   * @param {boolean} [resetTtl=false] - Whether to reset TTL when accessing existing items via get().
   * @example
   * const cache = new LRU(1000, 60000, true); // 1000 items, 1 minute TTL, reset on access
   * @see {@link lru} For parameter validation
   * @since 1.0.0
   */
  constructor(t = 0, e = 0, i = !1) {
    this.first = null, this.items = /* @__PURE__ */ Object.create(null), this.last = null, this.max = t, this.resetTtl = i, this.size = 0, this.ttl = e;
  }
  /**
   * Removes all items from the cache.
   *
   * @method clear
   * @memberof LRU
   * @returns {LRU} The LRU instance for method chaining.
   * @example
   * cache.clear();
   * console.log(cache.size); // 0
   * @since 1.0.0
   */
  clear() {
    return this.first = null, this.items = /* @__PURE__ */ Object.create(null), this.last = null, this.size = 0, this;
  }
  /**
   * Removes an item from the cache by key.
   *
   * @method delete
   * @memberof LRU
   * @param {string} key - The key of the item to delete.
   * @returns {LRU} The LRU instance for method chaining.
   * @example
   * cache.set('key1', 'value1');
   * cache.delete('key1');
   * console.log(cache.has('key1')); // false
   * @see {@link LRU#has}
   * @see {@link LRU#clear}
   * @since 1.0.0
   */
  delete(t) {
    if (this.has(t)) {
      const e = this.items[t];
      delete this.items[t], this.size--, e.prev !== null && (e.prev.next = e.next), e.next !== null && (e.next.prev = e.prev), this.first === e && (this.first = e.next), this.last === e && (this.last = e.prev);
    }
    return this;
  }
  /**
   * Returns an array of [key, value] pairs for the specified keys.
   * Order follows LRU order (least to most recently used).
   *
   * @method entries
   * @memberof LRU
   * @param {string[]} [keys=this.keys()] - Array of keys to get entries for. Defaults to all keys.
   * @returns {Array<Array<*>>} Array of [key, value] pairs in LRU order.
   * @example
   * cache.set('a', 1).set('b', 2);
   * console.log(cache.entries()); // [['a', 1], ['b', 2]]
   * console.log(cache.entries(['a'])); // [['a', 1]]
   * @see {@link LRU#keys}
   * @see {@link LRU#values}
   * @since 11.1.0
   */
  entries(t = this.keys()) {
    return t.map((e) => [e, this.get(e)]);
  }
  /**
   * Removes the least recently used item from the cache.
   *
   * @method evict
   * @memberof LRU
   * @param {boolean} [bypass=false] - Whether to force eviction even when cache is empty.
   * @returns {LRU} The LRU instance for method chaining.
   * @example
   * cache.set('old', 'value').set('new', 'value');
   * cache.evict(); // Removes 'old' item
   * @see {@link LRU#setWithEvicted}
   * @since 1.0.0
   */
  evict(t = !1) {
    if (t || this.size > 0) {
      const e = this.first;
      delete this.items[e.key], --this.size === 0 ? (this.first = null, this.last = null) : (this.first = e.next, this.first.prev = null);
    }
    return this;
  }
  /**
   * Returns the expiration timestamp for a given key.
   *
   * @method expiresAt
   * @memberof LRU
   * @param {string} key - The key to check expiration for.
   * @returns {number|undefined} The expiration timestamp in milliseconds, or undefined if key doesn't exist.
   * @example
   * const cache = new LRU(100, 5000); // 5 second TTL
   * cache.set('key1', 'value1');
   * console.log(cache.expiresAt('key1')); // timestamp 5 seconds from now
   * @see {@link LRU#get}
   * @see {@link LRU#has}
   * @since 1.0.0
   */
  expiresAt(t) {
    let e;
    return this.has(t) && (e = this.items[t].expiry), e;
  }
  /**
   * Retrieves a value from the cache by key. Updates the item's position to most recently used.
   *
   * @method get
   * @memberof LRU
   * @param {string} key - The key to retrieve.
   * @returns {*} The value associated with the key, or undefined if not found or expired.
   * @example
   * cache.set('key1', 'value1');
   * console.log(cache.get('key1')); // 'value1'
   * console.log(cache.get('nonexistent')); // undefined
   * @see {@link LRU#set}
   * @see {@link LRU#has}
   * @since 1.0.0
   */
  get(t) {
    const e = this.items[t];
    if (e !== void 0) {
      if (this.ttl > 0 && e.expiry <= Date.now()) {
        this.delete(t);
        return;
      }
      return this.moveToEnd(e), e.value;
    }
  }
  /**
   * Checks if a key exists in the cache.
   *
   * @method has
   * @memberof LRU
   * @param {string} key - The key to check for.
   * @returns {boolean} True if the key exists, false otherwise.
   * @example
   * cache.set('key1', 'value1');
   * console.log(cache.has('key1')); // true
   * console.log(cache.has('nonexistent')); // false
   * @see {@link LRU#get}
   * @see {@link LRU#delete}
   * @since 9.0.0
   */
  has(t) {
    return t in this.items;
  }
  /**
   * Efficiently moves an item to the end of the LRU list (most recently used position).
   * This is an internal optimization method that avoids the overhead of the full set() operation
   * when only LRU position needs to be updated.
   *
   * @method moveToEnd
   * @memberof LRU
   * @param {Object} item - The cache item with prev/next pointers to reposition.
   * @private
   * @since 11.3.5
   */
  moveToEnd(t) {
    this.last !== t && (t.prev !== null && (t.prev.next = t.next), t.next !== null && (t.next.prev = t.prev), this.first === t && (this.first = t.next), t.prev = this.last, t.next = null, this.last !== null && (this.last.next = t), this.last = t, this.first === null && (this.first = t));
  }
  /**
   * Returns an array of all keys in the cache, ordered from least to most recently used.
   *
   * @method keys
   * @memberof LRU
   * @returns {string[]} Array of keys in LRU order.
   * @example
   * cache.set('a', 1).set('b', 2);
   * cache.get('a'); // Move 'a' to most recent
   * console.log(cache.keys()); // ['b', 'a']
   * @see {@link LRU#values}
   * @see {@link LRU#entries}
   * @since 9.0.0
   */
  keys() {
    const t = [];
    let e = this.first;
    for (; e !== null; )
      t.push(e.key), e = e.next;
    return t;
  }
  /**
   * Sets a value in the cache and returns any evicted item.
   *
   * @method setWithEvicted
   * @memberof LRU
   * @param {string} key - The key to set.
   * @param {*} value - The value to store.
   * @param {boolean} [resetTtl=this.resetTtl] - Whether to reset the TTL for this operation.
   * @returns {Object|null} The evicted item (if any) with shape {key, value, expiry, prev, next}, or null.
   * @example
   * const cache = new LRU(2);
   * cache.set('a', 1).set('b', 2);
   * const evicted = cache.setWithEvicted('c', 3); // evicted = {key: 'a', value: 1, ...}
   * @see {@link LRU#set}
   * @see {@link LRU#evict}
   * @since 11.3.0
   */
  setWithEvicted(t, e, i = this.resetTtl) {
    let s = null;
    if (this.has(t))
      this.set(t, e, !0, i);
    else {
      this.max > 0 && this.size === this.max && (s = { ...this.first }, this.evict(!0));
      let o = this.items[t] = {
        expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
        key: t,
        prev: this.last,
        next: null,
        value: e
      };
      ++this.size === 1 ? this.first = o : this.last.next = o, this.last = o;
    }
    return s;
  }
  /**
   * Sets a value in the cache. Updates the item's position to most recently used.
   *
   * @method set
   * @memberof LRU
   * @param {string} key - The key to set.
   * @param {*} value - The value to store.
   * @param {boolean} [bypass=false] - Internal parameter for setWithEvicted method.
   * @param {boolean} [resetTtl=this.resetTtl] - Whether to reset the TTL for this operation.
   * @returns {LRU} The LRU instance for method chaining.
   * @example
   * cache.set('key1', 'value1')
   *      .set('key2', 'value2')
   *      .set('key3', 'value3');
   * @see {@link LRU#get}
   * @see {@link LRU#setWithEvicted}
   * @since 1.0.0
   */
  set(t, e, i = !1, s = this.resetTtl) {
    let o = this.items[t];
    return i || o !== void 0 ? (o.value = e, i === !1 && s && (o.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl), this.moveToEnd(o)) : (this.max > 0 && this.size === this.max && this.evict(!0), o = this.items[t] = {
      expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
      key: t,
      prev: this.last,
      next: null,
      value: e
    }, ++this.size === 1 ? this.first = o : this.last.next = o, this.last = o), this;
  }
  /**
   * Returns an array of all values in the cache for the specified keys.
   * Order follows LRU order (least to most recently used).
   *
   * @method values
   * @memberof LRU
   * @param {string[]} [keys=this.keys()] - Array of keys to get values for. Defaults to all keys.
   * @returns {Array<*>} Array of values corresponding to the keys in LRU order.
   * @example
   * cache.set('a', 1).set('b', 2);
   * console.log(cache.values()); // [1, 2]
   * console.log(cache.values(['a'])); // [1]
   * @see {@link LRU#keys}
   * @see {@link LRU#entries}
   * @since 11.1.0
   */
  values(t = this.keys()) {
    return t.map((e) => this.get(e));
  }
}
function K1(n = 1e3, t = 0, e = !1) {
  if (isNaN(n) || n < 0)
    throw new TypeError("Invalid max value");
  if (isNaN(t) || t < 0)
    throw new TypeError("Invalid ttl value");
  if (typeof e != "boolean")
    throw new TypeError("Invalid resetTtl value");
  return new ER(n, t, e);
}
const MR = [
  "serif",
  "sans-serif",
  "monospace",
  "cursive",
  "fantasy",
  "system-ui"
];
function rh(n) {
  const t = typeof n.fontSize == "number" ? `${n.fontSize}px` : n.fontSize;
  let e = n.fontFamily;
  Array.isArray(n.fontFamily) || (e = n.fontFamily.split(","));
  for (let i = e.length - 1; i >= 0; i--) {
    let s = e[i].trim();
    !/([\"\'])[^\'\"]+\1/.test(s) && !MR.includes(s) && (s = `"${s}"`), e[i] = s;
  }
  return `${n.fontStyle} ${n.fontVariant} ${n.fontWeight} ${t} ${e.join(",")}`;
}
const Bp = {
  // TextMetrics requires getImageData readback for measuring fonts.
  willReadFrequently: !0
}, Ei = class mt {
  /**
   * Checking that we can use modern canvas 2D API.
   *
   * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.
   * @see TextMetrics.experimentalLetterSpacing
   * @see https://developer.mozilla.org/en-US/docs/Web/API/ICanvasRenderingContext2D/letterSpacing
   * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441
   */
  static get experimentalLetterSpacingSupported() {
    let t = mt._experimentalLetterSpacingSupported;
    if (t === void 0) {
      const e = ve.get().getCanvasRenderingContext2D().prototype;
      t = mt._experimentalLetterSpacingSupported = "letterSpacing" in e || "textLetterSpacing" in e;
    }
    return t;
  }
  /**
   * @param text - the text that was measured
   * @param style - the style that was measured
   * @param width - the measured width of the text
   * @param height - the measured height of the text
   * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style
   * @param lineWidths - an array of the line widths for each line matched to `lines`
   * @param lineHeight - the measured line height for this style
   * @param maxLineWidth - the maximum line width for all measured lines
   * @param {FontMetrics} fontProperties - the font properties object from TextMetrics.measureFont
   */
  constructor(t, e, i, s, o, l, c, d, f) {
    this.text = t, this.style = e, this.width = i, this.height = s, this.lines = o, this.lineWidths = l, this.lineHeight = c, this.maxLineWidth = d, this.fontProperties = f;
  }
  /**
   * Measures the supplied string of text and returns a Rectangle.
   * @param text - The text to measure.
   * @param style - The text style to use for measuring
   * @param canvas - optional specification of the canvas to use for measuring.
   * @param wordWrap
   * @returns Measured width and height of the text.
   */
  static measureText(t = " ", e, i = mt._canvas, s = e.wordWrap) {
    const o = `${t}-${e.styleKey}-wordWrap-${s}`;
    if (mt._measurementCache.has(o))
      return mt._measurementCache.get(o);
    const l = rh(e), c = mt.measureFont(l);
    c.fontSize === 0 && (c.fontSize = e.fontSize, c.ascent = e.fontSize);
    const d = mt.__context;
    d.font = l;
    const m = (s ? mt._wordWrap(t, e, i) : t).split(/(?:\r\n|\r|\n)/), y = new Array(m.length);
    let b = 0;
    for (let R = 0; R < m.length; R++) {
      const w = mt._measureText(m[R], e.letterSpacing, d);
      y[R] = w, b = Math.max(b, w);
    }
    const v = e._stroke?.width || 0;
    let x = b + v;
    e.dropShadow && (x += e.dropShadow.distance);
    const S = e.lineHeight || c.fontSize;
    let _ = Math.max(S, c.fontSize + v) + (m.length - 1) * (S + e.leading);
    e.dropShadow && (_ += e.dropShadow.distance);
    const C = new mt(
      t,
      e,
      x,
      _,
      m,
      y,
      S + e.leading,
      b,
      c
    );
    return mt._measurementCache.set(o, C), C;
  }
  static _measureText(t, e, i) {
    let s = !1;
    mt.experimentalLetterSpacingSupported && (mt.experimentalLetterSpacing ? (i.letterSpacing = `${e}px`, i.textLetterSpacing = `${e}px`, s = !0) : (i.letterSpacing = "0px", i.textLetterSpacing = "0px"));
    const o = i.measureText(t);
    let l = o.width;
    const c = -o.actualBoundingBoxLeft;
    let f = o.actualBoundingBoxRight - c;
    if (l > 0)
      if (s)
        l -= e, f -= e;
      else {
        const m = (mt.graphemeSegmenter(t).length - 1) * e;
        l += m, f += m;
      }
    return Math.max(l, f);
  }
  /**
   * Applies newlines to a string to have it optimally fit into the horizontal
   * bounds set by the Text object's wordWrapWidth property.
   * @param text - String to apply word wrapping to
   * @param style - the style to use when wrapping
   * @param canvas - optional specification of the canvas to use for measuring.
   * @returns New string with new lines applied where required
   */
  static _wordWrap(t, e, i = mt._canvas) {
    const s = i.getContext("2d", Bp);
    let o = 0, l = "", c = "";
    const d = /* @__PURE__ */ Object.create(null), { letterSpacing: f, whiteSpace: m } = e, y = mt._collapseSpaces(m), b = mt._collapseNewlines(m);
    let v = !y;
    const x = e.wordWrapWidth + f, S = mt._tokenize(t);
    for (let _ = 0; _ < S.length; _++) {
      let C = S[_];
      if (mt._isNewline(C)) {
        if (!b) {
          c += mt._addLine(l), v = !y, l = "", o = 0;
          continue;
        }
        C = " ";
      }
      if (y) {
        const w = mt.isBreakingSpace(C), E = mt.isBreakingSpace(l[l.length - 1]);
        if (w && E)
          continue;
      }
      const R = mt._getFromCache(C, f, d, s);
      if (R > x)
        if (l !== "" && (c += mt._addLine(l), l = "", o = 0), mt.canBreakWords(C, e.breakWords)) {
          const w = mt.wordWrapSplit(C);
          for (let E = 0; E < w.length; E++) {
            let P = w[E], k = P, G = 1;
            for (; w[E + G]; ) {
              const F = w[E + G];
              if (!mt.canBreakChars(k, F, C, E, e.breakWords))
                P += F;
              else
                break;
              k = F, G++;
            }
            E += G - 1;
            const $ = mt._getFromCache(P, f, d, s);
            $ + o > x && (c += mt._addLine(l), v = !1, l = "", o = 0), l += P, o += $;
          }
        } else {
          l.length > 0 && (c += mt._addLine(l), l = "", o = 0);
          const w = _ === S.length - 1;
          c += mt._addLine(C, !w), v = !1, l = "", o = 0;
        }
      else
        R + o > x && (v = !1, c += mt._addLine(l), l = "", o = 0), (l.length > 0 || !mt.isBreakingSpace(C) || v) && (l += C, o += R);
    }
    return c += mt._addLine(l, !1), c;
  }
  /**
   * Convenience function for logging each line added during the wordWrap method.
   * @param line    - The line of text to add
   * @param newLine - Add new line character to end
   * @returns A formatted line
   */
  static _addLine(t, e = !0) {
    return t = mt._trimRight(t), t = e ? `${t}
` : t, t;
  }
  /**
   * Gets & sets the widths of calculated characters in a cache object
   * @param key            - The key
   * @param letterSpacing  - The letter spacing
   * @param cache          - The cache
   * @param context        - The canvas context
   * @returns The from cache.
   */
  static _getFromCache(t, e, i, s) {
    let o = i[t];
    return typeof o != "number" && (o = mt._measureText(t, e, s) + e, i[t] = o), o;
  }
  /**
   * Determines whether we should collapse breaking spaces.
   * @param whiteSpace - The TextStyle property whiteSpace
   * @returns Should collapse
   */
  static _collapseSpaces(t) {
    return t === "normal" || t === "pre-line";
  }
  /**
   * Determines whether we should collapse newLine chars.
   * @param whiteSpace - The white space
   * @returns should collapse
   */
  static _collapseNewlines(t) {
    return t === "normal";
  }
  /**
   * Trims breaking whitespaces from string.
   * @param text - The text
   * @returns Trimmed string
   */
  static _trimRight(t) {
    if (typeof t != "string")
      return "";
    for (let e = t.length - 1; e >= 0; e--) {
      const i = t[e];
      if (!mt.isBreakingSpace(i))
        break;
      t = t.slice(0, -1);
    }
    return t;
  }
  /**
   * Determines if char is a newline.
   * @param char - The character
   * @returns True if newline, False otherwise.
   */
  static _isNewline(t) {
    return typeof t != "string" ? !1 : mt._newlines.includes(t.charCodeAt(0));
  }
  /**
   * Determines if char is a breaking whitespace.
   *
   * It allows one to determine whether char should be a breaking whitespace
   * For example certain characters in CJK langs or numbers.
   * It must return a boolean.
   * @param char - The character
   * @param [_nextChar] - The next character
   * @returns True if whitespace, False otherwise.
   */
  static isBreakingSpace(t, e) {
    return typeof t != "string" ? !1 : mt._breakingSpaces.includes(t.charCodeAt(0));
  }
  /**
   * Splits a string into words, breaking-spaces and newLine characters
   * @param text - The text
   * @returns A tokenized array
   */
  static _tokenize(t) {
    const e = [];
    let i = "";
    if (typeof t != "string")
      return e;
    for (let s = 0; s < t.length; s++) {
      const o = t[s], l = t[s + 1];
      if (mt.isBreakingSpace(o, l) || mt._isNewline(o)) {
        i !== "" && (e.push(i), i = ""), o === "\r" && l === `
` ? (e.push(`\r
`), s++) : e.push(o);
        continue;
      }
      i += o;
    }
    return i !== "" && e.push(i), e;
  }
  /**
   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
   *
   * It allows one to customise which words should break
   * Examples are if the token is CJK or numbers.
   * It must return a boolean.
   * @param _token - The token
   * @param breakWords - The style attr break words
   * @returns Whether to break word or not
   */
  static canBreakWords(t, e) {
    return e;
  }
  /**
   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
   *
   * It allows one to determine whether a pair of characters
   * should be broken by newlines
   * For example certain characters in CJK langs or numbers.
   * It must return a boolean.
   * @param _char - The character
   * @param _nextChar - The next character
   * @param _token - The token/word the characters are from
   * @param _index - The index in the token of the char
   * @param _breakWords - The style attr break words
   * @returns whether to break word or not
   */
  static canBreakChars(t, e, i, s, o) {
    return !0;
  }
  /**
   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
   *
   * It is called when a token (usually a word) has to be split into separate pieces
   * in order to determine the point to break a word.
   * It must return an array of characters.
   * @param token - The token to split
   * @returns The characters of the token
   * @see CanvasTextMetrics.graphemeSegmenter
   */
  static wordWrapSplit(t) {
    return mt.graphemeSegmenter(t);
  }
  /**
   * Calculates the ascent, descent and fontSize of a given font-style
   * @param font - String representing the style of the font
   * @returns Font properties object
   */
  static measureFont(t) {
    if (mt._fonts[t])
      return mt._fonts[t];
    const e = mt._context;
    e.font = t;
    const i = e.measureText(mt.METRICS_STRING + mt.BASELINE_SYMBOL), s = {
      ascent: i.actualBoundingBoxAscent,
      descent: i.actualBoundingBoxDescent,
      fontSize: i.actualBoundingBoxAscent + i.actualBoundingBoxDescent
    };
    return mt._fonts[t] = s, s;
  }
  /**
   * Clear font metrics in metrics cache.
   * @param {string} [font] - font name. If font name not set then clear cache for all fonts.
   */
  static clearMetrics(t = "") {
    t ? delete mt._fonts[t] : mt._fonts = {};
  }
  /**
   * Cached canvas element for measuring text
   * TODO: this should be private, but isn't because of backward compat, will fix later.
   * @ignore
   */
  static get _canvas() {
    if (!mt.__canvas) {
      let t;
      try {
        const e = new OffscreenCanvas(0, 0);
        if (e.getContext("2d", Bp)?.measureText)
          return mt.__canvas = e, e;
        t = ve.get().createCanvas();
      } catch {
        t = ve.get().createCanvas();
      }
      t.width = t.height = 10, mt.__canvas = t;
    }
    return mt.__canvas;
  }
  /**
   * TODO: this should be private, but isn't because of backward compat, will fix later.
   * @ignore
   */
  static get _context() {
    return mt.__context || (mt.__context = mt._canvas.getContext("2d", Bp)), mt.__context;
  }
};
Ei.METRICS_STRING = "|q";
Ei.BASELINE_SYMBOL = "M";
Ei.BASELINE_MULTIPLIER = 1.4;
Ei.HEIGHT_MULTIPLIER = 2;
Ei.graphemeSegmenter = (() => {
  if (typeof Intl?.Segmenter == "function") {
    const n = new Intl.Segmenter();
    return (t) => {
      const e = n.segment(t), i = [];
      let s = 0;
      for (const o of e)
        i[s++] = o.segment;
      return i;
    };
  }
  return (n) => [...n];
})();
Ei.experimentalLetterSpacing = !1;
Ei._fonts = {};
Ei._newlines = [
  10,
  // line feed
  13
  // carriage return
];
Ei._breakingSpaces = [
  9,
  // character tabulation
  32,
  // space
  8192,
  // en quad
  8193,
  // em quad
  8194,
  // en space
  8195,
  // em space
  8196,
  // three-per-em space
  8197,
  // four-per-em space
  8198,
  // six-per-em space
  8200,
  // punctuation space
  8201,
  // thin space
  8202,
  // hair space
  8287,
  // medium mathematical space
  12288
  // ideographic space
];
Ei._measurementCache = K1(1e3);
let Li = Ei;
const W_ = [{ offset: 0, color: "white" }, { offset: 1, color: "black" }], ig = class _m {
  constructor(...t) {
    this.uid = Ee("fillGradient"), this._tick = 0, this.type = "linear", this.colorStops = [];
    let e = AR(t);
    e = { ...e.type === "radial" ? _m.defaultRadialOptions : _m.defaultLinearOptions, ...KS(e) }, this._textureSize = e.textureSize, this._wrapMode = e.wrapMode, e.type === "radial" ? (this.center = e.center, this.outerCenter = e.outerCenter ?? this.center, this.innerRadius = e.innerRadius, this.outerRadius = e.outerRadius, this.scale = e.scale, this.rotation = e.rotation) : (this.start = e.start, this.end = e.end), this.textureSpace = e.textureSpace, this.type = e.type, e.colorStops.forEach((s) => {
      this.addColorStop(s.offset, s.color);
    });
  }
  /**
   * Adds a color stop to the gradient
   * @param offset - Position of the stop (0-1)
   * @param color - Color of the stop
   * @returns This gradient instance for chaining
   */
  addColorStop(t, e) {
    return this.colorStops.push({ offset: t, color: Pe.shared.setValue(e).toHexa() }), this;
  }
  /**
   * Builds the internal texture and transform for the gradient.
   * Called automatically when the gradient is first used.
   * @internal
   */
  buildLinearGradient() {
    if (this.texture)
      return;
    let { x: t, y: e } = this.start, { x: i, y: s } = this.end, o = i - t, l = s - e;
    const c = o < 0 || l < 0;
    if (this._wrapMode === "clamp-to-edge") {
      if (o < 0) {
        const _ = t;
        t = i, i = _, o *= -1;
      }
      if (l < 0) {
        const _ = e;
        e = s, s = _, l *= -1;
      }
    }
    const d = this.colorStops.length ? this.colorStops : W_, f = this._textureSize, { canvas: m, context: y } = j_(f, 1), b = c ? y.createLinearGradient(this._textureSize, 0, 0, 0) : y.createLinearGradient(0, 0, this._textureSize, 0);
    V_(b, d), y.fillStyle = b, y.fillRect(0, 0, f, 1), this.texture = new Tt({
      source: new Gl({
        resource: m,
        addressMode: this._wrapMode
      })
    });
    const v = Math.sqrt(o * o + l * l), x = Math.atan2(l, o), S = new bt();
    S.scale(v / f, 1), S.rotate(x), S.translate(t, e), this.textureSpace === "local" && S.scale(f, f), this.transform = S;
  }
  /**
   * Builds the internal texture and transform for the gradient.
   * Called automatically when the gradient is first used.
   * @internal
   */
  buildGradient() {
    this.texture || this._tick++, this.type === "linear" ? this.buildLinearGradient() : this.buildRadialGradient();
  }
  /**
   * Builds the internal texture and transform for the radial gradient.
   * Called automatically when the gradient is first used.
   * @internal
   */
  buildRadialGradient() {
    if (this.texture)
      return;
    const t = this.colorStops.length ? this.colorStops : W_, e = this._textureSize, { canvas: i, context: s } = j_(e, e), { x: o, y: l } = this.center, { x: c, y: d } = this.outerCenter, f = this.innerRadius, m = this.outerRadius, y = c - m, b = d - m, v = e / (m * 2), x = (o - y) * v, S = (l - b) * v, _ = s.createRadialGradient(
      x,
      S,
      f * v,
      (c - y) * v,
      (d - b) * v,
      m * v
    );
    V_(_, t), s.fillStyle = t[t.length - 1].color, s.fillRect(0, 0, e, e), s.fillStyle = _, s.translate(x, S), s.rotate(this.rotation), s.scale(1, this.scale), s.translate(-x, -S), s.fillRect(0, 0, e, e), this.texture = new Tt({
      source: new Gl({
        resource: i,
        addressMode: this._wrapMode
      })
    });
    const C = new bt();
    C.scale(1 / v, 1 / v), C.translate(y, b), this.textureSpace === "local" && C.scale(e, e), this.transform = C;
  }
  /** Destroys the gradient, releasing resources. This will also destroy the internal texture. */
  destroy() {
    this.texture?.destroy(!0), this.texture = null, this.transform = null, this.colorStops = [], this.start = null, this.end = null, this.center = null, this.outerCenter = null;
  }
  /**
   * Returns a unique key for this gradient instance.
   * This key is used for caching and texture management.
   * @returns {string} Unique key for the gradient
   */
  get styleKey() {
    return `fill-gradient-${this.uid}-${this._tick}`;
  }
};
ig.defaultLinearOptions = {
  start: { x: 0, y: 0 },
  end: { x: 0, y: 1 },
  colorStops: [],
  textureSpace: "local",
  type: "linear",
  textureSize: 256,
  wrapMode: "clamp-to-edge"
};
ig.defaultRadialOptions = {
  center: { x: 0.5, y: 0.5 },
  innerRadius: 0,
  outerRadius: 0.5,
  colorStops: [],
  scale: 1,
  textureSpace: "local",
  type: "radial",
  textureSize: 256,
  wrapMode: "clamp-to-edge"
};
let vr = ig;
function V_(n, t) {
  for (let e = 0; e < t.length; e++) {
    const i = t[e];
    n.addColorStop(i.offset, i.color);
  }
}
function j_(n, t) {
  const e = ve.get().createCanvas(n, t), i = e.getContext("2d");
  return { canvas: e, context: i };
}
function AR(n) {
  let t = n[0] ?? {};
  return (typeof t == "number" || n[1]) && (zt("8.5.2", "use options object instead"), t = {
    type: "linear",
    start: { x: n[0], y: n[1] },
    end: { x: n[2], y: n[3] },
    textureSpace: n[4],
    textureSize: n[5] ?? vr.defaultLinearOptions.textureSize
  }), t;
}
const Y_ = {
  repeat: {
    addressModeU: "repeat",
    addressModeV: "repeat"
  },
  "repeat-x": {
    addressModeU: "repeat",
    addressModeV: "clamp-to-edge"
  },
  "repeat-y": {
    addressModeU: "clamp-to-edge",
    addressModeV: "repeat"
  },
  "no-repeat": {
    addressModeU: "clamp-to-edge",
    addressModeV: "clamp-to-edge"
  }
};
class Th {
  constructor(t, e) {
    this.uid = Ee("fillPattern"), this._tick = 0, this.transform = new bt(), this.texture = t, this.transform.scale(
      1 / t.frame.width,
      1 / t.frame.height
    ), e && (t.source.style.addressModeU = Y_[e].addressModeU, t.source.style.addressModeV = Y_[e].addressModeV);
  }
  /**
   * Sets the transform for the pattern
   * @param transform - The transform matrix to apply to the pattern.
   * If not provided, the pattern will use the default transform.
   */
  setTransform(t) {
    const e = this.texture;
    this.transform.copyFrom(t), this.transform.invert(), this.transform.scale(
      1 / e.frame.width,
      1 / e.frame.height
    ), this._tick++;
  }
  /** Internal texture used to render the gradient */
  get texture() {
    return this._texture;
  }
  set texture(t) {
    this._texture !== t && (this._texture = t, this._tick++);
  }
  /**
   * Returns a unique key for this instance.
   * This key is used for caching.
   * @returns {string} Unique key for the instance
   */
  get styleKey() {
    return `fill-pattern-${this.uid}-${this._tick}`;
  }
  /** Destroys the fill pattern, releasing resources. This will also destroy the internal texture. */
  destroy() {
    this.texture.destroy(!0), this.texture = null;
  }
}
var kp, X_;
function RR() {
  if (X_) return kp;
  X_ = 1, kp = e;
  var n = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 }, t = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
  function e(o) {
    var l = [];
    return o.replace(t, function(c, d, f) {
      var m = d.toLowerCase();
      for (f = s(f), m == "m" && f.length > 2 && (l.push([d].concat(f.splice(0, 2))), m = "l", d = d == "m" ? "l" : "L"); ; ) {
        if (f.length == n[m])
          return f.unshift(d), l.push(f);
        if (f.length < n[m]) throw new Error("malformed path data");
        l.push([d].concat(f.splice(0, n[m])));
      }
    }), l;
  }
  var i = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
  function s(o) {
    var l = o.match(i);
    return l ? l.map(Number) : [];
  }
  return kp;
}
var PR = RR();
const BR = /* @__PURE__ */ xh(PR);
function kR(n, t) {
  const e = BR(n), i = [];
  let s = null, o = 0, l = 0;
  for (let c = 0; c < e.length; c++) {
    const d = e[c], f = d[0], m = d;
    switch (f) {
      case "M":
        o = m[1], l = m[2], t.moveTo(o, l);
        break;
      case "m":
        o += m[1], l += m[2], t.moveTo(o, l);
        break;
      case "H":
        o = m[1], t.lineTo(o, l);
        break;
      case "h":
        o += m[1], t.lineTo(o, l);
        break;
      case "V":
        l = m[1], t.lineTo(o, l);
        break;
      case "v":
        l += m[1], t.lineTo(o, l);
        break;
      case "L":
        o = m[1], l = m[2], t.lineTo(o, l);
        break;
      case "l":
        o += m[1], l += m[2], t.lineTo(o, l);
        break;
      case "C":
        o = m[5], l = m[6], t.bezierCurveTo(
          m[1],
          m[2],
          // First control point
          m[3],
          m[4],
          // Second control point
          o,
          l
          // End point
        );
        break;
      case "c":
        t.bezierCurveTo(
          o + m[1],
          l + m[2],
          // First control point
          o + m[3],
          l + m[4],
          // Second control point
          o + m[5],
          l + m[6]
          // End point
        ), o += m[5], l += m[6];
        break;
      case "S":
        o = m[3], l = m[4], t.bezierCurveToShort(
          m[1],
          m[2],
          // Control point
          o,
          l
          // End point
        );
        break;
      case "s":
        t.bezierCurveToShort(
          o + m[1],
          l + m[2],
          // Control point
          o + m[3],
          l + m[4]
          // End point
        ), o += m[3], l += m[4];
        break;
      case "Q":
        o = m[3], l = m[4], t.quadraticCurveTo(
          m[1],
          m[2],
          // Control point
          o,
          l
          // End point
        );
        break;
      case "q":
        t.quadraticCurveTo(
          o + m[1],
          l + m[2],
          // Control point
          o + m[3],
          l + m[4]
          // End point
        ), o += m[3], l += m[4];
        break;
      case "T":
        o = m[1], l = m[2], t.quadraticCurveToShort(
          o,
          l
          // End point
        );
        break;
      case "t":
        o += m[1], l += m[2], t.quadraticCurveToShort(
          o,
          l
          // End point
        );
        break;
      case "A":
        o = m[6], l = m[7], t.arcToSvg(
          m[1],
          // rx
          m[2],
          // ry
          m[3],
          // x-axis-rotation
          m[4],
          // large-arc-flag
          m[5],
          // sweep-flag
          o,
          l
          // End point
        );
        break;
      case "a":
        o += m[6], l += m[7], t.arcToSvg(
          m[1],
          // rx
          m[2],
          // ry
          m[3],
          // x-axis-rotation
          m[4],
          // large-arc-flag
          m[5],
          // sweep-flag
          o,
          l
          // End point
        );
        break;
      case "Z":
      case "z":
        t.closePath(), i.length > 0 && (s = i.pop(), s ? (o = s.startX, l = s.startY) : (o = 0, l = 0)), s = null;
        break;
      default:
        $t(`Unknown SVG path command: ${f}`);
    }
    f !== "Z" && f !== "z" && s === null && (s = { startX: o, startY: l }, i.push(s));
  }
  return t;
}
class rg {
  /**
   * @param x - The X coordinate of the center of this circle
   * @param y - The Y coordinate of the center of this circle
   * @param radius - The radius of the circle
   */
  constructor(t = 0, e = 0, i = 0) {
    this.type = "circle", this.x = t, this.y = e, this.radius = i;
  }
  /**
   * Creates a clone of this Circle instance.
   * @example
   * ```ts
   * // Basic circle cloning
   * const original = new Circle(100, 100, 50);
   * const copy = original.clone();
   *
   * // Clone and modify
   * const modified = original.clone();
   * modified.radius = 75;
   *
   * // Verify independence
   * console.log(original.radius); // 50
   * console.log(modified.radius); // 75
   * ```
   * @returns A copy of the Circle
   * @see {@link Circle.copyFrom} For copying into existing circle
   * @see {@link Circle.copyTo} For copying to another circle
   */
  clone() {
    return new rg(this.x, this.y, this.radius);
  }
  /**
   * Checks whether the x and y coordinates given are contained within this circle.
   *
   * Uses the distance formula to determine if a point is inside the circle's radius.
   *
   * Commonly used for hit testing in PixiJS events and graphics.
   * @example
   * ```ts
   * // Basic containment check
   * const circle = new Circle(100, 100, 50);
   * const isInside = circle.contains(120, 120);
   *
   * // Check mouse position
   * const circle = new Circle(0, 0, 100);
   * container.hitArea = circle;
   * container.on('pointermove', (e) => {
   *     // only called if pointer is within circle
   * });
   * ```
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coordinates are within this Circle
   * @see {@link Circle.strokeContains} For checking stroke intersection
   * @see {@link Circle.getBounds} For getting bounding box
   */
  contains(t, e) {
    if (this.radius <= 0)
      return !1;
    const i = this.radius * this.radius;
    let s = this.x - t, o = this.y - e;
    return s *= s, o *= o, s + o <= i;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this circle including the stroke.
   * @example
   * ```ts
   * // Basic stroke check
   * const circle = new Circle(100, 100, 50);
   * const isOnStroke = circle.strokeContains(150, 100, 4); // 4px line width
   *
   * // Check with different alignments
   * const innerStroke = circle.strokeContains(150, 100, 4, 1);   // Inside
   * const centerStroke = circle.strokeContains(150, 100, 4, 0.5); // Centered
   * const outerStroke = circle.strokeContains(150, 100, 4, 0);   // Outside
   * ```
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @param width - The width of the line to check
   * @param alignment - The alignment of the stroke, 0.5 by default
   * @returns Whether the x/y coordinates are within this Circle's stroke
   * @see {@link Circle.contains} For checking fill containment
   * @see {@link Circle.getBounds} For getting stroke bounds
   */
  strokeContains(t, e, i, s = 0.5) {
    if (this.radius === 0)
      return !1;
    const o = this.x - t, l = this.y - e, c = this.radius, d = (1 - s) * i, f = Math.sqrt(o * o + l * l);
    return f <= c + d && f > c - (i - d);
  }
  /**
   * Returns the framing rectangle of the circle as a Rectangle object.
   * @example
   * ```ts
   * // Basic bounds calculation
   * const circle = new Circle(100, 100, 50);
   * const bounds = circle.getBounds();
   * // bounds: x=50, y=50, width=100, height=100
   *
   * // Reuse existing rectangle
   * const rect = new Rectangle();
   * circle.getBounds(rect);
   * ```
   * @param out - Optional Rectangle object to store the result
   * @returns The framing rectangle
   * @see {@link Rectangle} For rectangle properties
   * @see {@link Circle.contains} For point containment
   */
  getBounds(t) {
    return t || (t = new ne()), t.x = this.x - this.radius, t.y = this.y - this.radius, t.width = this.radius * 2, t.height = this.radius * 2, t;
  }
  /**
   * Copies another circle to this one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Circle(100, 100, 50);
   * const target = new Circle();
   * target.copyFrom(source);
   * ```
   * @param circle - The circle to copy from
   * @returns Returns itself
   * @see {@link Circle.copyTo} For copying to another circle
   * @see {@link Circle.clone} For creating new circle copy
   */
  copyFrom(t) {
    return this.x = t.x, this.y = t.y, this.radius = t.radius, this;
  }
  /**
   * Copies this circle to another one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Circle(100, 100, 50);
   * const target = new Circle();
   * source.copyTo(target);
   * ```
   * @param circle - The circle to copy to
   * @returns Returns given parameter
   * @see {@link Circle.copyFrom} For copying from another circle
   * @see {@link Circle.clone} For creating new circle copy
   */
  copyTo(t) {
    return t.copyFrom(this), t;
  }
  toString() {
    return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
  }
}
class sg {
  /**
   * @param x - The X coordinate of the center of this ellipse
   * @param y - The Y coordinate of the center of this ellipse
   * @param halfWidth - The half width of this ellipse
   * @param halfHeight - The half height of this ellipse
   */
  constructor(t = 0, e = 0, i = 0, s = 0) {
    this.type = "ellipse", this.x = t, this.y = e, this.halfWidth = i, this.halfHeight = s;
  }
  /**
   * Creates a clone of this Ellipse instance.
   * @example
   * ```ts
   * // Basic cloning
   * const original = new Ellipse(100, 100, 50, 25);
   * const copy = original.clone();
   *
   * // Clone and modify
   * const modified = original.clone();
   * modified.halfWidth *= 2;
   * modified.halfHeight *= 2;
   *
   * // Verify independence
   * console.log(original.halfWidth);  // 50
   * console.log(modified.halfWidth);  // 100
   * ```
   * @returns A copy of the ellipse
   * @see {@link Ellipse.copyFrom} For copying into existing ellipse
   * @see {@link Ellipse.copyTo} For copying to another ellipse
   */
  clone() {
    return new sg(this.x, this.y, this.halfWidth, this.halfHeight);
  }
  /**
   * Checks whether the x and y coordinates given are contained within this ellipse.
   * Uses normalized coordinates and the ellipse equation to determine containment.
   * @example
   * ```ts
   * // Basic containment check
   * const ellipse = new Ellipse(100, 100, 50, 25);
   * const isInside = ellipse.contains(120, 110);
   * ```
   * @remarks
   * - Uses ellipse equation (x/a + y/b  1)
   * - Returns false if dimensions are 0 or negative
   * - Normalized to center (0,0) for calculation
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coords are within this ellipse
   * @see {@link Ellipse.strokeContains} For checking stroke intersection
   * @see {@link Ellipse.getBounds} For getting containing rectangle
   */
  contains(t, e) {
    if (this.halfWidth <= 0 || this.halfHeight <= 0)
      return !1;
    let i = (t - this.x) / this.halfWidth, s = (e - this.y) / this.halfHeight;
    return i *= i, s *= s, i + s <= 1;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this ellipse including stroke.
   * @example
   * ```ts
   * // Basic stroke check
   * const ellipse = new Ellipse(100, 100, 50, 25);
   * const isOnStroke = ellipse.strokeContains(150, 100, 4); // 4px line width
   *
   * // Check with different alignments
   * const innerStroke = ellipse.strokeContains(150, 100, 4, 1);   // Inside
   * const centerStroke = ellipse.strokeContains(150, 100, 4, 0.5); // Centered
   * const outerStroke = ellipse.strokeContains(150, 100, 4, 0);   // Outside
   * ```
   * @remarks
   * - Uses normalized ellipse equations
   * - Considers stroke alignment
   * - Returns false if dimensions are 0
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @param strokeWidth - The width of the line to check
   * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)
   * @returns Whether the x/y coords are within this ellipse's stroke
   * @see {@link Ellipse.contains} For checking fill containment
   * @see {@link Ellipse.getBounds} For getting stroke bounds
   */
  strokeContains(t, e, i, s = 0.5) {
    const { halfWidth: o, halfHeight: l } = this;
    if (o <= 0 || l <= 0)
      return !1;
    const c = i * (1 - s), d = i - c, f = o - d, m = l - d, y = o + c, b = l + c, v = t - this.x, x = e - this.y, S = v * v / (f * f) + x * x / (m * m), _ = v * v / (y * y) + x * x / (b * b);
    return S > 1 && _ <= 1;
  }
  /**
   * Returns the framing rectangle of the ellipse as a Rectangle object.
   * @example
   * ```ts
   * // Basic bounds calculation
   * const ellipse = new Ellipse(100, 100, 50, 25);
   * const bounds = ellipse.getBounds();
   * // bounds: x=50, y=75, width=100, height=50
   *
   * // Reuse existing rectangle
   * const rect = new Rectangle();
   * ellipse.getBounds(rect);
   * ```
   * @remarks
   * - Creates Rectangle if none provided
   * - Top-left is (x-halfWidth, y-halfHeight)
   * - Width is halfWidth * 2
   * - Height is halfHeight * 2
   * @param out - Optional Rectangle object to store the result
   * @returns The framing rectangle
   * @see {@link Rectangle} For rectangle properties
   * @see {@link Ellipse.contains} For checking if a point is inside
   */
  getBounds(t) {
    return t || (t = new ne()), t.x = this.x - this.halfWidth, t.y = this.y - this.halfHeight, t.width = this.halfWidth * 2, t.height = this.halfHeight * 2, t;
  }
  /**
   * Copies another ellipse to this one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Ellipse(100, 100, 50, 25);
   * const target = new Ellipse();
   * target.copyFrom(source);
   * ```
   * @param ellipse - The ellipse to copy from
   * @returns Returns itself
   * @see {@link Ellipse.copyTo} For copying to another ellipse
   * @see {@link Ellipse.clone} For creating new ellipse copy
   */
  copyFrom(t) {
    return this.x = t.x, this.y = t.y, this.halfWidth = t.halfWidth, this.halfHeight = t.halfHeight, this;
  }
  /**
   * Copies this ellipse to another one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Ellipse(100, 100, 50, 25);
   * const target = new Ellipse();
   * source.copyTo(target);
   * ```
   * @param ellipse - The ellipse to copy to
   * @returns Returns given parameter
   * @see {@link Ellipse.copyFrom} For copying from another ellipse
   * @see {@link Ellipse.clone} For creating new ellipse copy
   */
  copyTo(t) {
    return t.copyFrom(this), t;
  }
  toString() {
    return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;
  }
}
function OR(n, t, e, i, s, o) {
  const l = n - e, c = t - i, d = s - e, f = o - i, m = l * d + c * f, y = d * d + f * f;
  let b = -1;
  y !== 0 && (b = m / y);
  let v, x;
  b < 0 ? (v = e, x = i) : b > 1 ? (v = s, x = o) : (v = e + b * d, x = i + b * f);
  const S = n - v, _ = t - x;
  return S * S + _ * _;
}
let DR, GR;
class El {
  /**
   * @param points - This can be an array of Points
   *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or
   *  the arguments passed can be all the points of the polygon e.g.
   *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat
   *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.
   */
  constructor(...t) {
    this.type = "polygon";
    let e = Array.isArray(t[0]) ? t[0] : t;
    if (typeof e[0] != "number") {
      const i = [];
      for (let s = 0, o = e.length; s < o; s++)
        i.push(e[s].x, e[s].y);
      e = i;
    }
    this.points = e, this.closePath = !0;
  }
  /**
   * Determines whether the polygon's points are arranged in a clockwise direction.
   * Uses the shoelace formula (surveyor's formula) to calculate the signed area.
   *
   * A positive area indicates clockwise winding, while negative indicates counter-clockwise.
   *
   * The formula sums up the cross products of adjacent vertices:
   * For each pair of adjacent points (x1,y1) and (x2,y2), we calculate (x1*y2 - x2*y1)
   * The final sum divided by 2 gives the signed area - positive for clockwise.
   * @example
   * ```ts
   * // Check polygon winding
   * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);
   * console.log(polygon.isClockwise()); // Check direction
   *
   * // Use in path construction
   * const hole = new Polygon([25, 25, 75, 25, 75, 75, 25, 75]);
   * if (hole.isClockwise() === shape.isClockwise()) {
   *     hole.points.reverse(); // Reverse for proper hole winding
   * }
   * ```
   * @returns `true` if the polygon's points are arranged clockwise, `false` if counter-clockwise
   */
  isClockwise() {
    let t = 0;
    const e = this.points, i = e.length;
    for (let s = 0; s < i; s += 2) {
      const o = e[s], l = e[s + 1], c = e[(s + 2) % i], d = e[(s + 3) % i];
      t += (c - o) * (d + l);
    }
    return t < 0;
  }
  /**
   * Checks if this polygon completely contains another polygon.
   * Used for detecting holes in shapes, like when parsing SVG paths.
   * @example
   * ```ts
   * // Basic containment check
   * const outerSquare = new Polygon([0,0, 100,0, 100,100, 0,100]); // A square
   * const innerSquare = new Polygon([25,25, 75,25, 75,75, 25,75]); // A smaller square inside
   *
   * outerSquare.containsPolygon(innerSquare); // Returns true
   * innerSquare.containsPolygon(outerSquare); // Returns false
   * ```
   * @remarks
   * - Uses bounds check for quick rejection
   * - Tests all points for containment
   * @param polygon - The polygon to test for containment
   * @returns True if this polygon completely contains the other polygon
   * @see {@link Polygon.contains} For single point testing
   * @see {@link Polygon.getBounds} For bounds calculation
   */
  containsPolygon(t) {
    const e = this.getBounds(DR), i = t.getBounds(GR);
    if (!e.containsRect(i))
      return !1;
    const s = t.points;
    for (let o = 0; o < s.length; o += 2) {
      const l = s[o], c = s[o + 1];
      if (!this.contains(l, c))
        return !1;
    }
    return !0;
  }
  /**
   * Creates a clone of this polygon.
   * @example
   * ```ts
   * // Basic cloning
   * const original = new Polygon([0, 0, 100, 0, 50, 100]);
   * const copy = original.clone();
   *
   * // Clone and modify
   * const modified = original.clone();
   * modified.points[0] = 10; // Modify first x coordinate
   * ```
   * @returns A copy of the polygon
   * @see {@link Polygon.copyFrom} For copying into existing polygon
   * @see {@link Polygon.copyTo} For copying to another polygon
   */
  clone() {
    const t = this.points.slice(), e = new El(t);
    return e.closePath = this.closePath, e;
  }
  /**
   * Checks whether the x and y coordinates passed to this function are contained within this polygon.
   * Uses raycasting algorithm for point-in-polygon testing.
   * @example
   * ```ts
   * // Basic containment check
   * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);
   * const isInside = polygon.contains(25, 25); // true
   * ```
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coordinates are within this polygon
   * @see {@link Polygon.strokeContains} For checking stroke intersection
   * @see {@link Polygon.containsPolygon} For polygon-in-polygon testing
   */
  contains(t, e) {
    let i = !1;
    const s = this.points.length / 2;
    for (let o = 0, l = s - 1; o < s; l = o++) {
      const c = this.points[o * 2], d = this.points[o * 2 + 1], f = this.points[l * 2], m = this.points[l * 2 + 1];
      d > e != m > e && t < (f - c) * ((e - d) / (m - d)) + c && (i = !i);
    }
    return i;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this polygon including the stroke.
   * @example
   * ```ts
   * // Basic stroke check
   * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);
   * const isOnStroke = polygon.strokeContains(25, 25, 4); // 4px line width
   *
   * // Check with different alignments
   * const innerStroke = polygon.strokeContains(25, 25, 4, 1);   // Inside
   * const centerStroke = polygon.strokeContains(25, 25, 4, 0.5); // Centered
   * const outerStroke = polygon.strokeContains(25, 25, 4, 0);   // Outside
   * ```
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @param strokeWidth - The width of the line to check
   * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)
   * @returns Whether the x/y coordinates are within this polygon's stroke
   * @see {@link Polygon.contains} For checking fill containment
   * @see {@link Polygon.getBounds} For getting stroke bounds
   */
  strokeContains(t, e, i, s = 0.5) {
    const o = i * i, l = o * (1 - s), c = o - l, { points: d } = this, f = d.length - (this.closePath ? 0 : 2);
    for (let m = 0; m < f; m += 2) {
      const y = d[m], b = d[m + 1], v = d[(m + 2) % d.length], x = d[(m + 3) % d.length], S = OR(t, e, y, b, v, x), _ = Math.sign((v - y) * (e - b) - (x - b) * (t - y));
      if (S <= (_ < 0 ? c : l))
        return !0;
    }
    return !1;
  }
  /**
   * Returns the framing rectangle of the polygon as a Rectangle object.
   * @example
   * ```ts
   * // Basic bounds calculation
   * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);
   * const bounds = polygon.getBounds();
   * // bounds: x=0, y=0, width=100, height=100
   *
   * // Reuse existing rectangle
   * const rect = new Rectangle();
   * polygon.getBounds(rect);
   * ```
   * @param out - Optional rectangle to store the result
   * @returns The framing rectangle
   * @see {@link Rectangle} For rectangle properties
   * @see {@link Polygon.contains} For checking if a point is inside
   */
  getBounds(t) {
    t || (t = new ne());
    const e = this.points;
    let i = 1 / 0, s = -1 / 0, o = 1 / 0, l = -1 / 0;
    for (let c = 0, d = e.length; c < d; c += 2) {
      const f = e[c], m = e[c + 1];
      i = f < i ? f : i, s = f > s ? f : s, o = m < o ? m : o, l = m > l ? m : l;
    }
    return t.x = i, t.width = s - i, t.y = o, t.height = l - o, t;
  }
  /**
   * Copies another polygon to this one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Polygon([0, 0, 100, 0, 50, 100]);
   * const target = new Polygon();
   * target.copyFrom(source);
   * ```
   * @param polygon - The polygon to copy from
   * @returns Returns itself
   * @see {@link Polygon.copyTo} For copying to another polygon
   * @see {@link Polygon.clone} For creating new polygon copy
   */
  copyFrom(t) {
    return this.points = t.points.slice(), this.closePath = t.closePath, this;
  }
  /**
   * Copies this polygon to another one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Polygon([0, 0, 100, 0, 50, 100]);
   * const target = new Polygon();
   * source.copyTo(target);
   * ```
   * @param polygon - The polygon to copy to
   * @returns Returns given parameter
   * @see {@link Polygon.copyFrom} For copying from another polygon
   * @see {@link Polygon.clone} For creating new polygon copy
   */
  copyTo(t) {
    return t.copyFrom(this), t;
  }
  toString() {
    return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((t, e) => `${t}, ${e}`, "")}]`;
  }
  /**
   * Get the last X coordinate of the polygon.
   * @example
   * ```ts
   * // Basic coordinate access
   * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);
   * console.log(polygon.lastX); // 300
   * ```
   * @readonly
   * @returns The x-coordinate of the last vertex
   * @see {@link Polygon.lastY} For last Y coordinate
   * @see {@link Polygon.points} For raw points array
   */
  get lastX() {
    return this.points[this.points.length - 2];
  }
  /**
   * Get the last Y coordinate of the polygon.
   * @example
   * ```ts
   * // Basic coordinate access
   * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);
   * console.log(polygon.lastY); // 400
   * ```
   * @readonly
   * @returns The y-coordinate of the last vertex
   * @see {@link Polygon.lastX} For last X coordinate
   * @see {@link Polygon.points} For raw points array
   */
  get lastY() {
    return this.points[this.points.length - 1];
  }
  /**
   * Get the last X coordinate of the polygon.
   * @readonly
   * @deprecated since 8.11.0, use {@link Polygon.lastX} instead.
   */
  get x() {
    return zt("8.11.0", "Polygon.lastX is deprecated, please use Polygon.lastX instead."), this.points[this.points.length - 2];
  }
  /**
   * Get the last Y coordinate of the polygon.
   * @readonly
   * @deprecated since 8.11.0, use {@link Polygon.lastY} instead.
   */
  get y() {
    return zt("8.11.0", "Polygon.y is deprecated, please use Polygon.lastY instead."), this.points[this.points.length - 1];
  }
  /**
   * Get the first X coordinate of the polygon.
   * @example
   * ```ts
   * // Basic coordinate access
   * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);
   * console.log(polygon.x); // 0
   * ```
   * @readonly
   * @returns The x-coordinate of the first vertex
   * @see {@link Polygon.startY} For first Y coordinate
   * @see {@link Polygon.points} For raw points array
   */
  get startX() {
    return this.points[0];
  }
  /**
   * Get the first Y coordinate of the polygon.
   * @example
   * ```ts
   * // Basic coordinate access
   * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);
   * console.log(polygon.y); // 0
   * ```
   * @readonly
   * @returns The y-coordinate of the first vertex
   * @see {@link Polygon.startX} For first X coordinate
   * @see {@link Polygon.points} For raw points array
   */
  get startY() {
    return this.points[1];
  }
}
const Pc = (n, t, e, i, s, o, l) => {
  const c = n - e, d = t - i, f = Math.sqrt(c * c + d * d);
  return f >= s - o && f <= s + l;
};
class ag {
  /**
   * @param x - The X coordinate of the upper-left corner of the rounded rectangle
   * @param y - The Y coordinate of the upper-left corner of the rounded rectangle
   * @param width - The overall width of this rounded rectangle
   * @param height - The overall height of this rounded rectangle
   * @param radius - Controls the radius of the rounded corners
   */
  constructor(t = 0, e = 0, i = 0, s = 0, o = 20) {
    this.type = "roundedRectangle", this.x = t, this.y = e, this.width = i, this.height = s, this.radius = o;
  }
  /**
   * Returns the framing rectangle of the rounded rectangle as a Rectangle object
   * @example
   * ```ts
   * // Basic bounds calculation
   * const rect = new RoundedRectangle(100, 100, 200, 150, 20);
   * const bounds = rect.getBounds();
   * // bounds: x=100, y=100, width=200, height=150
   *
   * // Reuse existing rectangle
   * const out = new Rectangle();
   * rect.getBounds(out);
   * ```
   * @remarks
   * - Rectangle matches outer dimensions
   * - Ignores corner radius
   * @param out - Optional rectangle to store the result
   * @returns The framing rectangle
   * @see {@link Rectangle} For rectangle properties
   * @see {@link RoundedRectangle.contains} For checking if a point is inside
   */
  getBounds(t) {
    return t || (t = new ne()), t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t;
  }
  /**
   * Creates a clone of this Rounded Rectangle.
   * @example
   * ```ts
   * // Basic cloning
   * const original = new RoundedRectangle(100, 100, 200, 150, 20);
   * const copy = original.clone();
   *
   * // Clone and modify
   * const modified = original.clone();
   * modified.radius = 30;
   * modified.width *= 2;
   *
   * // Verify independence
   * console.log(original.radius);  // 20
   * console.log(modified.radius);  // 30
   * ```
   * @returns A copy of the rounded rectangle
   * @see {@link RoundedRectangle.copyFrom} For copying into existing rectangle
   * @see {@link RoundedRectangle.copyTo} For copying to another rectangle
   */
  clone() {
    return new ag(this.x, this.y, this.width, this.height, this.radius);
  }
  /**
   * Copies another rectangle to this one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new RoundedRectangle(100, 100, 200, 150, 20);
   * const target = new RoundedRectangle();
   * target.copyFrom(source);
   *
   * // Chain with other operations
   * const rect = new RoundedRectangle()
   *     .copyFrom(source)
   *     .getBounds(rect);
   * ```
   * @param rectangle - The rectangle to copy from
   * @returns Returns itself
   * @see {@link RoundedRectangle.copyTo} For copying to another rectangle
   * @see {@link RoundedRectangle.clone} For creating new rectangle copy
   */
  copyFrom(t) {
    return this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this;
  }
  /**
   * Copies this rectangle to another one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new RoundedRectangle(100, 100, 200, 150, 20);
   * const target = new RoundedRectangle();
   * source.copyTo(target);
   *
   * // Chain with other operations
   * const result = source
   *     .copyTo(new RoundedRectangle())
   *     .getBounds();
   * ```
   * @param rectangle - The rectangle to copy to
   * @returns Returns given parameter
   * @see {@link RoundedRectangle.copyFrom} For copying from another rectangle
   * @see {@link RoundedRectangle.clone} For creating new rectangle copy
   */
  copyTo(t) {
    return t.copyFrom(this), t;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this Rounded Rectangle
   * @example
   * ```ts
   * // Basic containment check
   * const rect = new RoundedRectangle(100, 100, 200, 150, 20);
   * const isInside = rect.contains(150, 125); // true
   * // Check corner radius
   * const corner = rect.contains(100, 100); // false if within corner curve
   * ```
   * @remarks
   * - Returns false if width/height is 0 or negative
   * - Handles rounded corners with radius check
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coordinates are within this Rounded Rectangle
   * @see {@link RoundedRectangle.strokeContains} For checking stroke intersection
   * @see {@link RoundedRectangle.getBounds} For getting containing rectangle
   */
  contains(t, e) {
    if (this.width <= 0 || this.height <= 0)
      return !1;
    if (t >= this.x && t <= this.x + this.width && e >= this.y && e <= this.y + this.height) {
      const i = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
      if (e >= this.y + i && e <= this.y + this.height - i || t >= this.x + i && t <= this.x + this.width - i)
        return !0;
      let s = t - (this.x + i), o = e - (this.y + i);
      const l = i * i;
      if (s * s + o * o <= l || (s = t - (this.x + this.width - i), s * s + o * o <= l) || (o = e - (this.y + this.height - i), s * s + o * o <= l) || (s = t - (this.x + i), s * s + o * o <= l))
        return !0;
    }
    return !1;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.
   * @example
   * ```ts
   * // Basic stroke check
   * const rect = new RoundedRectangle(100, 100, 200, 150, 20);
   * const isOnStroke = rect.strokeContains(150, 100, 4); // 4px line width
   *
   * // Check with different alignments
   * const innerStroke = rect.strokeContains(150, 100, 4, 1);   // Inside
   * const centerStroke = rect.strokeContains(150, 100, 4, 0.5); // Centered
   * const outerStroke = rect.strokeContains(150, 100, 4, 0);   // Outside
   * ```
   * @param pX - The X coordinate of the point to test
   * @param pY - The Y coordinate of the point to test
   * @param strokeWidth - The width of the line to check
   * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)
   * @returns Whether the x/y coordinates are within this rectangle's stroke
   * @see {@link RoundedRectangle.contains} For checking fill containment
   * @see {@link RoundedRectangle.getBounds} For getting stroke bounds
   */
  strokeContains(t, e, i, s = 0.5) {
    const { x: o, y: l, width: c, height: d, radius: f } = this, m = i * (1 - s), y = i - m, b = o + f, v = l + f, x = c - f * 2, S = d - f * 2, _ = o + c, C = l + d;
    return (t >= o - m && t <= o + y || t >= _ - y && t <= _ + m) && e >= v && e <= v + S || (e >= l - m && e <= l + y || e >= C - y && e <= C + m) && t >= b && t <= b + x ? !0 : (
      // Top-left
      t < b && e < v && Pc(
        t,
        e,
        b,
        v,
        f,
        y,
        m
      ) || t > _ - f && e < v && Pc(
        t,
        e,
        _ - f,
        v,
        f,
        y,
        m
      ) || t > _ - f && e > C - f && Pc(
        t,
        e,
        _ - f,
        C - f,
        f,
        y,
        m
      ) || t < b && e > C - f && Pc(
        t,
        e,
        b,
        C - f,
        f,
        y,
        m
      )
    );
  }
  toString() {
    return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
  }
}
const Z1 = {};
function og(n, t, e) {
  let i = 2166136261;
  for (let s = 0; s < t; s++)
    i ^= n[s].uid, i = Math.imul(i, 16777619), i >>>= 0;
  return Z1[i] || UR(n, t, i, e);
}
function UR(n, t, e, i) {
  const s = {};
  let o = 0;
  for (let c = 0; c < i; c++) {
    const d = c < t ? n[c] : Tt.EMPTY.source;
    s[o++] = d.source, s[o++] = d.style;
  }
  const l = new yr(s);
  return Z1[e] = l, l;
}
class Fa {
  constructor(t) {
    typeof t == "number" ? this.rawBinaryData = new ArrayBuffer(t) : t instanceof Uint8Array ? this.rawBinaryData = t.buffer : this.rawBinaryData = t, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData), this.size = this.rawBinaryData.byteLength;
  }
  /** View on the raw binary data as a `Int8Array`. */
  get int8View() {
    return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View;
  }
  /** View on the raw binary data as a `Uint8Array`. */
  get uint8View() {
    return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View;
  }
  /**  View on the raw binary data as a `Int16Array`. */
  get int16View() {
    return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View;
  }
  /** View on the raw binary data as a `Int32Array`. */
  get int32View() {
    return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View;
  }
  /** View on the raw binary data as a `Float64Array`. */
  get float64View() {
    return this._float64Array || (this._float64Array = new Float64Array(this.rawBinaryData)), this._float64Array;
  }
  /** View on the raw binary data as a `BigUint64Array`. */
  get bigUint64View() {
    return this._bigUint64Array || (this._bigUint64Array = new BigUint64Array(this.rawBinaryData)), this._bigUint64Array;
  }
  /**
   * Returns the view of the given type.
   * @param type - One of `int8`, `uint8`, `int16`,
   *    `uint16`, `int32`, `uint32`, and `float32`.
   * @returns - typed array of given type
   */
  view(t) {
    return this[`${t}View`];
  }
  /** Destroys all buffer references. Do not use after calling this. */
  destroy() {
    this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this.uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null;
  }
  /**
   * Returns the size of the given type in bytes.
   * @param type - One of `int8`, `uint8`, `int16`,
   *   `uint16`, `int32`, `uint32`, and `float32`.
   * @returns - size of the type in bytes
   */
  static sizeOf(t) {
    switch (t) {
      case "int8":
      case "uint8":
        return 1;
      case "int16":
      case "uint16":
        return 2;
      case "int32":
      case "uint32":
      case "float32":
        return 4;
      default:
        throw new Error(`${t} isn't a valid view type`);
    }
  }
}
function Sm(n, t) {
  const e = n.byteLength / 8 | 0, i = new Float64Array(n, 0, e);
  new Float64Array(t, 0, e).set(i);
  const o = n.byteLength - e * 8;
  if (o > 0) {
    const l = new Uint8Array(n, e * 8, o);
    new Uint8Array(t, e * 8, o).set(l);
  }
}
const NR = {
  normal: "normal-npm",
  add: "add-npm",
  screen: "screen-npm"
};
var Ye = /* @__PURE__ */ ((n) => (n[n.DISABLED = 0] = "DISABLED", n[n.RENDERING_MASK_ADD = 1] = "RENDERING_MASK_ADD", n[n.MASK_ACTIVE = 2] = "MASK_ACTIVE", n[n.INVERSE_MASK_ACTIVE = 3] = "INVERSE_MASK_ACTIVE", n[n.RENDERING_MASK_REMOVE = 4] = "RENDERING_MASK_REMOVE", n[n.NONE = 5] = "NONE", n))(Ye || {});
function Fl(n, t) {
  return t.alphaMode === "no-premultiply-alpha" && NR[n] || n;
}
const IR = [
  "precision mediump float;",
  "void main(void){",
  "float test = 0.1;",
  "%forloop%",
  "gl_FragColor = vec4(0.0);",
  "}"
].join(`
`);
function zR(n) {
  let t = "";
  for (let e = 0; e < n; ++e)
    e > 0 && (t += `
else `), e < n - 1 && (t += `if(test == ${e}.0){}`);
  return t;
}
function Q1(n, t) {
  if (n === 0)
    throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
  const e = t.createShader(t.FRAGMENT_SHADER);
  try {
    for (; ; ) {
      const i = IR.replace(/%forloop%/gi, zR(n));
      if (t.shaderSource(e, i), t.compileShader(e), !t.getShaderParameter(e, t.COMPILE_STATUS))
        n = n / 2 | 0;
      else
        break;
    }
  } finally {
    t.deleteShader(e);
  }
  return n;
}
let Ea = null;
function LR() {
  if (Ea)
    return Ea;
  const n = R1();
  return Ea = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS), Ea = Q1(
    Ea,
    n
  ), n.getExtension("WEBGL_lose_context")?.loseContext(), Ea;
}
class FR {
  constructor() {
    this.ids = /* @__PURE__ */ Object.create(null), this.textures = [], this.count = 0;
  }
  /** Clear the textures and their locations. */
  clear() {
    for (let t = 0; t < this.count; t++) {
      const e = this.textures[t];
      this.textures[t] = null, this.ids[e.uid] = null;
    }
    this.count = 0;
  }
}
class HR {
  constructor() {
    this.renderPipeId = "batch", this.action = "startBatch", this.start = 0, this.size = 0, this.textures = new FR(), this.blendMode = "normal", this.topology = "triangle-strip", this.canBundle = !0;
  }
  destroy() {
    this.textures = null, this.gpuBindGroup = null, this.bindGroup = null, this.batcher = null;
  }
}
const Ml = [];
let sh = 0;
to.register({
  clear: () => {
    if (Ml.length > 0)
      for (const n of Ml)
        n && n.destroy();
    Ml.length = 0, sh = 0;
  }
});
function q_() {
  return sh > 0 ? Ml[--sh] : new HR();
}
function K_(n) {
  Ml[sh++] = n;
}
let ol = 0;
const J1 = class tT {
  constructor(t) {
    this.uid = Ee("batcher"), this.dirty = !0, this.batchIndex = 0, this.batches = [], this._elements = [], t = { ...tT.defaultOptions, ...t }, t.maxTextures || (zt("v8.8.0", "maxTextures is a required option for Batcher now, please pass it in the options"), t.maxTextures = LR());
    const { maxTextures: e, attributesInitialSize: i, indicesInitialSize: s } = t;
    this.attributeBuffer = new Fa(i * 4), this.indexBuffer = new Uint16Array(s), this.maxTextures = e;
  }
  begin() {
    this.elementSize = 0, this.elementStart = 0, this.indexSize = 0, this.attributeSize = 0;
    for (let t = 0; t < this.batchIndex; t++)
      K_(this.batches[t]);
    this.batchIndex = 0, this._batchIndexStart = 0, this._batchIndexSize = 0, this.dirty = !0;
  }
  add(t) {
    this._elements[this.elementSize++] = t, t._indexStart = this.indexSize, t._attributeStart = this.attributeSize, t._batcher = this, this.indexSize += t.indexSize, this.attributeSize += t.attributeSize * this.vertexSize;
  }
  checkAndUpdateTexture(t, e) {
    const i = t._batch.textures.ids[e._source.uid];
    return !i && i !== 0 ? !1 : (t._textureId = i, t.texture = e, !0);
  }
  updateElement(t) {
    this.dirty = !0;
    const e = this.attributeBuffer;
    t.packAsQuad ? this.packQuadAttributes(
      t,
      e.float32View,
      e.uint32View,
      t._attributeStart,
      t._textureId
    ) : this.packAttributes(
      t,
      e.float32View,
      e.uint32View,
      t._attributeStart,
      t._textureId
    );
  }
  /**
   * breaks the batcher. This happens when a batch gets too big,
   * or we need to switch to a different type of rendering (a filter for example)
   * @param instructionSet
   */
  break(t) {
    const e = this._elements;
    if (!e[this.elementStart])
      return;
    let i = q_(), s = i.textures;
    s.clear();
    const o = e[this.elementStart];
    let l = Fl(o.blendMode, o.texture._source), c = o.topology;
    this.attributeSize * 4 > this.attributeBuffer.size && this._resizeAttributeBuffer(this.attributeSize * 4), this.indexSize > this.indexBuffer.length && this._resizeIndexBuffer(this.indexSize);
    const d = this.attributeBuffer.float32View, f = this.attributeBuffer.uint32View, m = this.indexBuffer;
    let y = this._batchIndexSize, b = this._batchIndexStart, v = "startBatch";
    const x = this.maxTextures;
    for (let S = this.elementStart; S < this.elementSize; ++S) {
      const _ = e[S];
      e[S] = null;
      const R = _.texture._source, w = Fl(_.blendMode, R), E = l !== w || c !== _.topology;
      if (R._batchTick === ol && !E) {
        _._textureId = R._textureBindLocation, y += _.indexSize, _.packAsQuad ? (this.packQuadAttributes(
          _,
          d,
          f,
          _._attributeStart,
          _._textureId
        ), this.packQuadIndex(
          m,
          _._indexStart,
          _._attributeStart / this.vertexSize
        )) : (this.packAttributes(
          _,
          d,
          f,
          _._attributeStart,
          _._textureId
        ), this.packIndex(
          _,
          m,
          _._indexStart,
          _._attributeStart / this.vertexSize
        )), _._batch = i;
        continue;
      }
      R._batchTick = ol, (s.count >= x || E) && (this._finishBatch(
        i,
        b,
        y - b,
        s,
        l,
        c,
        t,
        v
      ), v = "renderBatch", b = y, l = w, c = _.topology, i = q_(), s = i.textures, s.clear(), ++ol), _._textureId = R._textureBindLocation = s.count, s.ids[R.uid] = s.count, s.textures[s.count++] = R, _._batch = i, y += _.indexSize, _.packAsQuad ? (this.packQuadAttributes(
        _,
        d,
        f,
        _._attributeStart,
        _._textureId
      ), this.packQuadIndex(
        m,
        _._indexStart,
        _._attributeStart / this.vertexSize
      )) : (this.packAttributes(
        _,
        d,
        f,
        _._attributeStart,
        _._textureId
      ), this.packIndex(
        _,
        m,
        _._indexStart,
        _._attributeStart / this.vertexSize
      ));
    }
    s.count > 0 && (this._finishBatch(
      i,
      b,
      y - b,
      s,
      l,
      c,
      t,
      v
    ), b = y, ++ol), this.elementStart = this.elementSize, this._batchIndexStart = b, this._batchIndexSize = y;
  }
  _finishBatch(t, e, i, s, o, l, c, d) {
    t.gpuBindGroup = null, t.bindGroup = null, t.action = d, t.batcher = this, t.textures = s, t.blendMode = o, t.topology = l, t.start = e, t.size = i, ++ol, this.batches[this.batchIndex++] = t, c.add(t);
  }
  finish(t) {
    this.break(t);
  }
  /**
   * Resizes the attribute buffer to the given size (1 = 1 float32)
   * @param size - the size in vertices to ensure (not bytes!)
   */
  ensureAttributeBuffer(t) {
    t * 4 <= this.attributeBuffer.size || this._resizeAttributeBuffer(t * 4);
  }
  /**
   * Resizes the index buffer to the given size (1 = 1 float32)
   * @param size - the size in vertices to ensure (not bytes!)
   */
  ensureIndexBuffer(t) {
    t <= this.indexBuffer.length || this._resizeIndexBuffer(t);
  }
  _resizeAttributeBuffer(t) {
    const e = Math.max(t, this.attributeBuffer.size * 2), i = new Fa(e);
    Sm(this.attributeBuffer.rawBinaryData, i.rawBinaryData), this.attributeBuffer = i;
  }
  _resizeIndexBuffer(t) {
    const e = this.indexBuffer;
    let i = Math.max(t, e.length * 1.5);
    i += i % 2;
    const s = i > 65535 ? new Uint32Array(i) : new Uint16Array(i);
    if (s.BYTES_PER_ELEMENT !== e.BYTES_PER_ELEMENT)
      for (let o = 0; o < e.length; o++)
        s[o] = e[o];
    else
      Sm(e.buffer, s.buffer);
    this.indexBuffer = s;
  }
  packQuadIndex(t, e, i) {
    t[e] = i + 0, t[e + 1] = i + 1, t[e + 2] = i + 2, t[e + 3] = i + 0, t[e + 4] = i + 2, t[e + 5] = i + 3;
  }
  packIndex(t, e, i, s) {
    const o = t.indices, l = t.indexSize, c = t.indexOffset, d = t.attributeOffset;
    for (let f = 0; f < l; f++)
      e[i++] = s + o[f + c] - d;
  }
  destroy() {
    if (this.batches !== null) {
      for (let t = 0; t < this.batches.length; t++)
        K_(this.batches[t]);
      this.batches = null;
      for (let t = 0; t < this._elements.length; t++)
        this._elements[t] && (this._elements[t]._batch = null);
      this._elements = null, this.indexBuffer = null, this.attributeBuffer.destroy(), this.attributeBuffer = null;
    }
  }
};
J1.defaultOptions = {
  maxTextures: null,
  attributesInitialSize: 4,
  indicesInitialSize: 6
};
let $R = J1;
var Qt = /* @__PURE__ */ ((n) => (n[n.MAP_READ = 1] = "MAP_READ", n[n.MAP_WRITE = 2] = "MAP_WRITE", n[n.COPY_SRC = 4] = "COPY_SRC", n[n.COPY_DST = 8] = "COPY_DST", n[n.INDEX = 16] = "INDEX", n[n.VERTEX = 32] = "VERTEX", n[n.UNIFORM = 64] = "UNIFORM", n[n.STORAGE = 128] = "STORAGE", n[n.INDIRECT = 256] = "INDIRECT", n[n.QUERY_RESOLVE = 512] = "QUERY_RESOLVE", n[n.STATIC = 1024] = "STATIC", n))(Qt || {});
class Zn extends Jn {
  /**
   * Creates a new Buffer with the given options
   * @param options - the options for the buffer
   */
  constructor(t) {
    let { data: e, size: i } = t;
    const { usage: s, label: o, shrinkToFit: l } = t;
    super(), this.uid = Ee("buffer"), this._resourceType = "buffer", this._resourceId = Ee("resource"), this._touched = 0, this._updateID = 1, this._dataInt32 = null, this.shrinkToFit = !0, this.destroyed = !1, e instanceof Array && (e = new Float32Array(e)), this._data = e, i ?? (i = e?.byteLength);
    const c = !!e;
    this.descriptor = {
      size: i,
      usage: s,
      mappedAtCreation: c,
      label: o
    }, this.shrinkToFit = l ?? !0;
  }
  /** the data in the buffer */
  get data() {
    return this._data;
  }
  set data(t) {
    this.setDataWithSize(t, t.length, !0);
  }
  get dataInt32() {
    return this._dataInt32 || (this._dataInt32 = new Int32Array(this.data.buffer)), this._dataInt32;
  }
  /** whether the buffer is static or not */
  get static() {
    return !!(this.descriptor.usage & Qt.STATIC);
  }
  set static(t) {
    t ? this.descriptor.usage |= Qt.STATIC : this.descriptor.usage &= ~Qt.STATIC;
  }
  /**
   * Sets the data in the buffer to the given value. This will immediately update the buffer on the GPU.
   * If you only want to update a subset of the buffer, you can pass in the size of the data.
   * @param value - the data to set
   * @param size - the size of the data in bytes
   * @param syncGPU - should the buffer be updated on the GPU immediately?
   */
  setDataWithSize(t, e, i) {
    if (this._updateID++, this._updateSize = e * t.BYTES_PER_ELEMENT, this._data === t) {
      i && this.emit("update", this);
      return;
    }
    const s = this._data;
    if (this._data = t, this._dataInt32 = null, !s || s.length !== t.length) {
      !this.shrinkToFit && s && t.byteLength < s.byteLength ? i && this.emit("update", this) : (this.descriptor.size = t.byteLength, this._resourceId = Ee("resource"), this.emit("change", this));
      return;
    }
    i && this.emit("update", this);
  }
  /**
   * updates the buffer on the GPU to reflect the data in the buffer.
   * By default it will update the entire buffer. If you only want to update a subset of the buffer,
   * you can pass in the size of the buffer to update.
   * @param sizeInBytes - the new size of the buffer in bytes
   */
  update(t) {
    this._updateSize = t ?? this._updateSize, this._updateID++, this.emit("update", this);
  }
  /** Destroys the buffer */
  destroy() {
    this.destroyed = !0, this.emit("destroy", this), this.emit("change", this), this._data = null, this.descriptor = null, this.removeAllListeners();
  }
}
function eT(n, t) {
  if (!(n instanceof Zn)) {
    let e = t ? Qt.INDEX : Qt.VERTEX;
    n instanceof Array && (t ? (n = new Uint32Array(n), e = Qt.INDEX | Qt.COPY_DST) : (n = new Float32Array(n), e = Qt.VERTEX | Qt.COPY_DST)), n = new Zn({
      data: n,
      label: t ? "index-mesh-buffer" : "vertex-mesh-buffer",
      usage: e
    });
  }
  return n;
}
function WR(n, t, e) {
  const i = n.getAttribute(t);
  if (!i)
    return e.minX = 0, e.minY = 0, e.maxX = 0, e.maxY = 0, e;
  const s = i.buffer.data;
  let o = 1 / 0, l = 1 / 0, c = -1 / 0, d = -1 / 0;
  const f = s.BYTES_PER_ELEMENT, m = (i.offset || 0) / f, y = (i.stride || 8) / f;
  for (let b = m; b < s.length; b += y) {
    const v = s[b], x = s[b + 1];
    v > c && (c = v), x > d && (d = x), v < o && (o = v), x < l && (l = x);
  }
  return e.minX = o, e.minY = l, e.maxX = c, e.maxY = d, e;
}
function VR(n) {
  return (n instanceof Zn || Array.isArray(n) || n.BYTES_PER_ELEMENT) && (n = {
    buffer: n
  }), n.buffer = eT(n.buffer, !1), n;
}
class ql extends Jn {
  /**
   * Create a new instance of a geometry
   * @param options - The options for the geometry.
   */
  constructor(t = {}) {
    super(), this.uid = Ee("geometry"), this._layoutKey = 0, this.instanceCount = 1, this._bounds = new Cn(), this._boundsDirty = !0;
    const { attributes: e, indexBuffer: i, topology: s } = t;
    if (this.buffers = [], this.attributes = {}, e)
      for (const o in e)
        this.addAttribute(o, e[o]);
    this.instanceCount = t.instanceCount ?? 1, i && this.addIndex(i), this.topology = s || "triangle-list";
  }
  onBufferUpdate() {
    this._boundsDirty = !0, this.emit("update", this);
  }
  /**
   * Returns the requested attribute.
   * @param id - The name of the attribute required
   * @returns - The attribute requested.
   */
  getAttribute(t) {
    return this.attributes[t];
  }
  /**
   * Returns the index buffer
   * @returns - The index buffer.
   */
  getIndex() {
    return this.indexBuffer;
  }
  /**
   * Returns the requested buffer.
   * @param id - The name of the buffer required.
   * @returns - The buffer requested.
   */
  getBuffer(t) {
    return this.getAttribute(t).buffer;
  }
  /**
   * Used to figure out how many vertices there are in this geometry
   * @returns the number of vertices in the geometry
   */
  getSize() {
    for (const t in this.attributes) {
      const e = this.attributes[t];
      return e.buffer.data.length / (e.stride / 4 || e.size);
    }
    return 0;
  }
  /**
   * Adds an attribute to the geometry.
   * @param name - The name of the attribute to add.
   * @param attributeOption - The attribute option to add.
   */
  addAttribute(t, e) {
    const i = VR(e);
    this.buffers.indexOf(i.buffer) === -1 && (this.buffers.push(i.buffer), i.buffer.on("update", this.onBufferUpdate, this), i.buffer.on("change", this.onBufferUpdate, this)), this.attributes[t] = i;
  }
  /**
   * Adds an index buffer to the geometry.
   * @param indexBuffer - The index buffer to add. Can be a Buffer, TypedArray, or an array of numbers.
   */
  addIndex(t) {
    this.indexBuffer = eT(t, !0), this.buffers.push(this.indexBuffer);
  }
  /** Returns the bounds of the geometry. */
  get bounds() {
    return this._boundsDirty ? (this._boundsDirty = !1, WR(this, "aPosition", this._bounds)) : this._bounds;
  }
  /**
   * destroys the geometry.
   * @param destroyBuffers - destroy the buffers associated with this geometry
   */
  destroy(t = !1) {
    this.emit("destroy", this), this.removeAllListeners(), t && this.buffers.forEach((e) => e.destroy()), this.attributes = null, this.buffers = null, this.indexBuffer = null, this._bounds = null;
  }
}
const jR = new Float32Array(1), YR = new Uint32Array(1);
class XR extends ql {
  constructor() {
    const e = new Zn({
      data: jR,
      label: "attribute-batch-buffer",
      usage: Qt.VERTEX | Qt.COPY_DST,
      shrinkToFit: !1
    }), i = new Zn({
      data: YR,
      label: "index-batch-buffer",
      usage: Qt.INDEX | Qt.COPY_DST,
      // | BufferUsage.STATIC,
      shrinkToFit: !1
    }), s = 24;
    super({
      attributes: {
        aPosition: {
          buffer: e,
          format: "float32x2",
          stride: s,
          offset: 0
        },
        aUV: {
          buffer: e,
          format: "float32x2",
          stride: s,
          offset: 8
        },
        aColor: {
          buffer: e,
          format: "unorm8x4",
          stride: s,
          offset: 16
        },
        aTextureIdAndRound: {
          buffer: e,
          format: "uint16x2",
          stride: s,
          offset: 20
        }
      },
      indexBuffer: i
    });
  }
}
function Z_(n, t, e) {
  if (n)
    for (const i in n) {
      const s = i.toLocaleLowerCase(), o = t[s];
      if (o) {
        let l = n[i];
        i === "header" && (l = l.replace(/@in\s+[^;]+;\s*/g, "").replace(/@out\s+[^;]+;\s*/g, "")), e && o.push(`//----${e}----//`), o.push(l);
      } else
        $t(`${i} placement hook does not exist in shader`);
    }
}
const qR = /\{\{(.*?)\}\}/g;
function Q_(n) {
  const t = {};
  return (n.match(qR)?.map((i) => i.replace(/[{()}]/g, "")) ?? []).forEach((i) => {
    t[i] = [];
  }), t;
}
function J_(n, t) {
  let e;
  const i = /@in\s+([^;]+);/g;
  for (; (e = i.exec(n)) !== null; )
    t.push(e[1]);
}
function t0(n, t, e = !1) {
  const i = [];
  J_(t, i), n.forEach((c) => {
    c.header && J_(c.header, i);
  });
  const s = i;
  e && s.sort();
  const o = s.map((c, d) => `       @location(${d}) ${c},`).join(`
`);
  let l = t.replace(/@in\s+[^;]+;\s*/g, "");
  return l = l.replace("{{in}}", `
${o}
`), l;
}
function e0(n, t) {
  let e;
  const i = /@out\s+([^;]+);/g;
  for (; (e = i.exec(n)) !== null; )
    t.push(e[1]);
}
function KR(n) {
  const e = /\b(\w+)\s*:/g.exec(n);
  return e ? e[1] : "";
}
function ZR(n) {
  const t = /@.*?\s+/g;
  return n.replace(t, "");
}
function QR(n, t) {
  const e = [];
  e0(t, e), n.forEach((d) => {
    d.header && e0(d.header, e);
  });
  let i = 0;
  const s = e.sort().map((d) => d.indexOf("builtin") > -1 ? d : `@location(${i++}) ${d}`).join(`,
`), o = e.sort().map((d) => `       var ${ZR(d)};`).join(`
`), l = `return VSOutput(
            ${e.sort().map((d) => ` ${KR(d)}`).join(`,
`)});`;
  let c = t.replace(/@out\s+[^;]+;\s*/g, "");
  return c = c.replace("{{struct}}", `
${s}
`), c = c.replace("{{start}}", `
${o}
`), c = c.replace("{{return}}", `
${l}
`), c;
}
function n0(n, t) {
  let e = n;
  for (const i in t) {
    const s = t[i];
    s.join(`
`).length ? e = e.replace(`{{${i}}}`, `//-----${i} START-----//
${s.join(`
`)}
//----${i} FINISH----//`) : e = e.replace(`{{${i}}}`, "");
  }
  return e;
}
const qr = /* @__PURE__ */ Object.create(null), Op = /* @__PURE__ */ new Map();
let JR = 0;
function tP({
  template: n,
  bits: t
}) {
  const e = nT(n, t);
  if (qr[e])
    return qr[e];
  const { vertex: i, fragment: s } = nP(n, t);
  return qr[e] = iT(i, s, t), qr[e];
}
function eP({
  template: n,
  bits: t
}) {
  const e = nT(n, t);
  return qr[e] || (qr[e] = iT(n.vertex, n.fragment, t)), qr[e];
}
function nP(n, t) {
  const e = t.map((l) => l.vertex).filter((l) => !!l), i = t.map((l) => l.fragment).filter((l) => !!l);
  let s = t0(e, n.vertex, !0);
  s = QR(e, s);
  const o = t0(i, n.fragment, !0);
  return {
    vertex: s,
    fragment: o
  };
}
function nT(n, t) {
  return t.map((e) => (Op.has(e) || Op.set(e, JR++), Op.get(e))).sort((e, i) => e - i).join("-") + n.vertex + n.fragment;
}
function iT(n, t, e) {
  const i = Q_(n), s = Q_(t);
  return e.forEach((o) => {
    Z_(o.vertex, i, o.name), Z_(o.fragment, s, o.name);
  }), {
    vertex: n0(n, i),
    fragment: n0(t, s)
  };
}
const iP = (
  /* wgsl */
  `
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;
        var uv = aUV;

        {{start}}

        vColor = vec4<f32>(1., 1., 1., 1.);

        {{main}}

        vUV = uv;

        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);

        vColor *= globalUniforms.uWorldColorAlpha;

        {{end}}

        {{return}}
    };
`
), rP = (
  /* wgsl */
  `
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;

    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {

        {{start}}

        var outColor:vec4<f32>;

        {{main}}

        var finalColor:vec4<f32> = outColor * vColor;

        {{end}}

        return finalColor;
      };
`
), sP = (
  /* glsl */
  `
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = uWorldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;
        vec2 uv = aUV;

        {{start}}

        vColor = vec4(1.);

        {{main}}

        vUV = uv;

        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= uWorldColorAlpha;

        {{end}}
    }
`
), aP = (
  /* glsl */
  `

    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {

        {{start}}

        vec4 outColor;

        {{main}}

        finalColor = outColor * vColor;

        {{end}}
    }
`
), oP = {
  name: "global-uniforms-bit",
  vertex: {
    header: (
      /* wgsl */
      `
        struct GlobalUniforms {
            uProjectionMatrix:mat3x3<f32>,
            uWorldTransformMatrix:mat3x3<f32>,
            uWorldColorAlpha: vec4<f32>,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        `
    )
  }
}, lP = {
  name: "global-uniforms-bit",
  vertex: {
    header: (
      /* glsl */
      `
          uniform mat3 uProjectionMatrix;
          uniform mat3 uWorldTransformMatrix;
          uniform vec4 uWorldColorAlpha;
          uniform vec2 uResolution;
        `
    )
  }
};
function Kl({ bits: n, name: t }) {
  const e = tP({
    template: {
      fragment: rP,
      vertex: iP
    },
    bits: [
      oP,
      ...n
    ]
  });
  return Ns.from({
    name: t,
    vertex: {
      source: e.vertex,
      entryPoint: "main"
    },
    fragment: {
      source: e.fragment,
      entryPoint: "main"
    }
  });
}
function Zl({ bits: n, name: t }) {
  return new eo({
    name: t,
    ...eP({
      template: {
        vertex: sP,
        fragment: aP
      },
      bits: [
        lP,
        ...n
      ]
    })
  });
}
const lg = {
  name: "color-bit",
  vertex: {
    header: (
      /* wgsl */
      `
            @in aColor: vec4<f32>;
        `
    ),
    main: (
      /* wgsl */
      `
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        `
    )
  }
}, ug = {
  name: "color-bit",
  vertex: {
    header: (
      /* glsl */
      `
            in vec4 aColor;
        `
    ),
    main: (
      /* glsl */
      `
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        `
    )
  }
}, Dp = {};
function uP(n) {
  const t = [];
  if (n === 1)
    t.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;"), t.push("@group(1) @binding(1) var textureSampler1: sampler;");
  else {
    let e = 0;
    for (let i = 0; i < n; i++)
      t.push(`@group(1) @binding(${e++}) var textureSource${i + 1}: texture_2d<f32>;`), t.push(`@group(1) @binding(${e++}) var textureSampler${i + 1}: sampler;`);
  }
  return t.join(`
`);
}
function cP(n) {
  const t = [];
  if (n === 1)
    t.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");
  else {
    t.push("switch vTextureId {");
    for (let e = 0; e < n; e++)
      e === n - 1 ? t.push("  default:{") : t.push(`  case ${e}:{`), t.push(`      outColor = textureSampleGrad(textureSource${e + 1}, textureSampler${e + 1}, vUV, uvDx, uvDy);`), t.push("      break;}");
    t.push("}");
  }
  return t.join(`
`);
}
function cg(n) {
  return Dp[n] || (Dp[n] = {
    name: "texture-batch-bit",
    vertex: {
      header: `
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `,
      main: `
                vTextureId = aTextureIdAndRound.y;
            `,
      end: `
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            `
    },
    fragment: {
      header: `
                @in @interpolate(flat) vTextureId: u32;

                ${uP(n)}
            `,
      main: `
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);

                ${cP(n)}
            `
    }
  }), Dp[n];
}
const Gp = {};
function hP(n) {
  const t = [];
  for (let e = 0; e < n; e++)
    e > 0 && t.push("else"), e < n - 1 && t.push(`if(vTextureId < ${e}.5)`), t.push("{"), t.push(`	outColor = texture(uTextures[${e}], vUV);`), t.push("}");
  return t.join(`
`);
}
function hg(n) {
  return Gp[n] || (Gp[n] = {
    name: "texture-batch-bit",
    vertex: {
      header: `
                in vec2 aTextureIdAndRound;
                out float vTextureId;

            `,
      main: `
                vTextureId = aTextureIdAndRound.y;
            `,
      end: `
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            `
    },
    fragment: {
      header: `
                in float vTextureId;

                uniform sampler2D uTextures[${n}];

            `,
      main: `

                ${hP(n)}
            `
    }
  }), Gp[n];
}
const Ql = {
  name: "round-pixels-bit",
  vertex: {
    header: (
      /* wgsl */
      `
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32>
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
    )
  }
}, Jl = {
  name: "round-pixels-bit",
  vertex: {
    header: (
      /* glsl */
      `
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
    )
  }
}, i0 = {};
function dg(n) {
  let t = i0[n];
  if (t)
    return t;
  const e = new Int32Array(n);
  for (let i = 0; i < n; i++)
    e[i] = i;
  return t = i0[n] = new Pn({
    uTextures: { value: e, type: "i32", size: n }
  }, { isStatic: !0 }), t;
}
class dP extends fi {
  constructor(t) {
    const e = Zl({
      name: "batch",
      bits: [
        ug,
        hg(t),
        Jl
      ]
    }), i = Kl({
      name: "batch",
      bits: [
        lg,
        cg(t),
        Ql
      ]
    });
    super({
      glProgram: e,
      gpuProgram: i,
      resources: {
        batchSamplers: dg(t)
      }
    });
  }
}
let Up = null;
const rT = class sT extends $R {
  constructor(t) {
    super(t), this.geometry = new XR(), this.name = sT.extension.name, this.vertexSize = 6, Up ?? (Up = new dP(t.maxTextures)), this.shader = Up;
  }
  /**
   * Packs the attributes of a DefaultBatchableMeshElement into the provided views.
   * @param element - The DefaultBatchableMeshElement to pack.
   * @param float32View - The Float32Array view to pack into.
   * @param uint32View - The Uint32Array view to pack into.
   * @param index - The starting index in the views.
   * @param textureId - The texture ID to use.
   */
  packAttributes(t, e, i, s, o) {
    const l = o << 16 | t.roundPixels & 65535, c = t.transform, d = c.a, f = c.b, m = c.c, y = c.d, b = c.tx, v = c.ty, { positions: x, uvs: S } = t, _ = t.color, C = t.attributeOffset, R = C + t.attributeSize;
    for (let w = C; w < R; w++) {
      const E = w * 2, P = x[E], k = x[E + 1];
      e[s++] = d * P + m * k + b, e[s++] = y * k + f * P + v, e[s++] = S[E], e[s++] = S[E + 1], i[s++] = _, i[s++] = l;
    }
  }
  /**
   * Packs the attributes of a DefaultBatchableQuadElement into the provided views.
   * @param element - The DefaultBatchableQuadElement to pack.
   * @param float32View - The Float32Array view to pack into.
   * @param uint32View - The Uint32Array view to pack into.
   * @param index - The starting index in the views.
   * @param textureId - The texture ID to use.
   */
  packQuadAttributes(t, e, i, s, o) {
    const l = t.texture, c = t.transform, d = c.a, f = c.b, m = c.c, y = c.d, b = c.tx, v = c.ty, x = t.bounds, S = x.maxX, _ = x.minX, C = x.maxY, R = x.minY, w = l.uvs, E = t.color, P = o << 16 | t.roundPixels & 65535;
    e[s + 0] = d * _ + m * R + b, e[s + 1] = y * R + f * _ + v, e[s + 2] = w.x0, e[s + 3] = w.y0, i[s + 4] = E, i[s + 5] = P, e[s + 6] = d * S + m * R + b, e[s + 7] = y * R + f * S + v, e[s + 8] = w.x1, e[s + 9] = w.y1, i[s + 10] = E, i[s + 11] = P, e[s + 12] = d * S + m * C + b, e[s + 13] = y * C + f * S + v, e[s + 14] = w.x2, e[s + 15] = w.y2, i[s + 16] = E, i[s + 17] = P, e[s + 18] = d * _ + m * C + b, e[s + 19] = y * C + f * _ + v, e[s + 20] = w.x3, e[s + 21] = w.y3, i[s + 22] = E, i[s + 23] = P;
  }
};
rT.extension = {
  type: [
    W.Batcher
  ],
  name: "default"
};
let fg = rT;
function fP(n, t, e, i, s, o, l, c = null) {
  let d = 0;
  e *= t, s *= o;
  const f = c.a, m = c.b, y = c.c, b = c.d, v = c.tx, x = c.ty;
  for (; d < l; ) {
    const S = n[e], _ = n[e + 1];
    i[s] = f * S + y * _ + v, i[s + 1] = m * S + b * _ + x, s += o, e += t, d++;
  }
}
function pP(n, t, e, i) {
  let s = 0;
  for (t *= e; s < i; )
    n[t] = 0, n[t + 1] = 0, t += e, s++;
}
function aT(n, t, e, i, s) {
  const o = t.a, l = t.b, c = t.c, d = t.d, f = t.tx, m = t.ty;
  e || (e = 0), i || (i = 2), s || (s = n.length / i - e);
  let y = e * i;
  for (let b = 0; b < s; b++) {
    const v = n[y], x = n[y + 1];
    n[y] = o * v + c * x + f, n[y + 1] = l * v + d * x + m, y += i;
  }
}
const mP = new bt();
class pg {
  constructor() {
    this.packAsQuad = !1, this.batcherName = "default", this.topology = "triangle-list", this.applyTransform = !0, this.roundPixels = 0, this._batcher = null, this._batch = null;
  }
  get uvs() {
    return this.geometryData.uvs;
  }
  get positions() {
    return this.geometryData.vertices;
  }
  get indices() {
    return this.geometryData.indices;
  }
  get blendMode() {
    return this.renderable && this.applyTransform ? this.renderable.groupBlendMode : "normal";
  }
  get color() {
    const t = this.baseColor, e = t >> 16 | t & 65280 | (t & 255) << 16, i = this.renderable;
    return i ? l1(e, i.groupColor) + (this.alpha * i.groupAlpha * 255 << 24) : e + (this.alpha * 255 << 24);
  }
  get transform() {
    return this.renderable?.groupTransform || mP;
  }
  copyTo(t) {
    t.indexOffset = this.indexOffset, t.indexSize = this.indexSize, t.attributeOffset = this.attributeOffset, t.attributeSize = this.attributeSize, t.baseColor = this.baseColor, t.alpha = this.alpha, t.texture = this.texture, t.geometryData = this.geometryData, t.topology = this.topology;
  }
  reset() {
    this.applyTransform = !0, this.renderable = null, this.topology = "triangle-list";
  }
  destroy() {
    this.renderable = null, this.texture = null, this.geometryData = null, this._batcher = null, this._batch = null;
  }
}
const Hl = {
  extension: {
    type: W.ShapeBuilder,
    name: "circle"
  },
  build(n, t) {
    let e, i, s, o, l, c;
    if (n.type === "circle") {
      const E = n;
      if (l = c = E.radius, l <= 0)
        return !1;
      e = E.x, i = E.y, s = o = 0;
    } else if (n.type === "ellipse") {
      const E = n;
      if (l = E.halfWidth, c = E.halfHeight, l <= 0 || c <= 0)
        return !1;
      e = E.x, i = E.y, s = o = 0;
    } else {
      const E = n, P = E.width / 2, k = E.height / 2;
      e = E.x + P, i = E.y + k, l = c = Math.max(0, Math.min(E.radius, Math.min(P, k))), s = P - l, o = k - c;
    }
    if (s < 0 || o < 0)
      return !1;
    const d = Math.ceil(2.3 * Math.sqrt(l + c)), f = d * 8 + (s ? 4 : 0) + (o ? 4 : 0);
    if (f === 0)
      return !1;
    if (d === 0)
      return t[0] = t[6] = e + s, t[1] = t[3] = i + o, t[2] = t[4] = e - s, t[5] = t[7] = i - o, !0;
    let m = 0, y = d * 4 + (s ? 2 : 0) + 2, b = y, v = f, x = s + l, S = o, _ = e + x, C = e - x, R = i + S;
    if (t[m++] = _, t[m++] = R, t[--y] = R, t[--y] = C, o) {
      const E = i - S;
      t[b++] = C, t[b++] = E, t[--v] = E, t[--v] = _;
    }
    for (let E = 1; E < d; E++) {
      const P = Math.PI / 2 * (E / d), k = s + Math.cos(P) * l, G = o + Math.sin(P) * c, $ = e + k, F = e - k, j = i + G, H = i - G;
      t[m++] = $, t[m++] = j, t[--y] = j, t[--y] = F, t[b++] = F, t[b++] = H, t[--v] = H, t[--v] = $;
    }
    x = s, S = o + c, _ = e + x, C = e - x, R = i + S;
    const w = i - S;
    return t[m++] = _, t[m++] = R, t[--v] = w, t[--v] = _, s && (t[m++] = C, t[m++] = R, t[--v] = w, t[--v] = C), !0;
  },
  triangulate(n, t, e, i, s, o) {
    if (n.length === 0)
      return;
    let l = 0, c = 0;
    for (let m = 0; m < n.length; m += 2)
      l += n[m], c += n[m + 1];
    l /= n.length / 2, c /= n.length / 2;
    let d = i;
    t[d * e] = l, t[d * e + 1] = c;
    const f = d++;
    for (let m = 0; m < n.length; m += 2)
      t[d * e] = n[m], t[d * e + 1] = n[m + 1], m > 0 && (s[o++] = d, s[o++] = f, s[o++] = d - 1), d++;
    s[o++] = f + 1, s[o++] = f, s[o++] = d - 1;
  }
}, gP = { ...Hl, extension: { ...Hl.extension, name: "ellipse" } }, yP = { ...Hl, extension: { ...Hl.extension, name: "roundedRectangle" } }, oT = 1e-4, r0 = 1e-4;
function bP(n) {
  const t = n.length;
  if (t < 6)
    return 1;
  let e = 0;
  for (let i = 0, s = n[t - 2], o = n[t - 1]; i < t; i += 2) {
    const l = n[i], c = n[i + 1];
    e += (l - s) * (c + o), s = l, o = c;
  }
  return e < 0 ? -1 : 1;
}
function s0(n, t, e, i, s, o, l, c) {
  const d = n - e * s, f = t - i * s, m = n + e * o, y = t + i * o;
  let b, v;
  l ? (b = i, v = -e) : (b = -i, v = e);
  const x = d + b, S = f + v, _ = m + b, C = y + v;
  return c.push(x, S), c.push(_, C), 2;
}
function _s(n, t, e, i, s, o, l, c) {
  const d = e - n, f = i - t;
  let m = Math.atan2(d, f), y = Math.atan2(s - n, o - t);
  c && m < y ? m += Math.PI * 2 : !c && m > y && (y += Math.PI * 2);
  let b = m;
  const v = y - m, x = Math.abs(v), S = Math.sqrt(d * d + f * f), _ = (15 * x * Math.sqrt(S) / Math.PI >> 0) + 1, C = v / _;
  if (b += C, c) {
    l.push(n, t), l.push(e, i);
    for (let R = 1, w = b; R < _; R++, w += C)
      l.push(n, t), l.push(
        n + Math.sin(w) * S,
        t + Math.cos(w) * S
      );
    l.push(n, t), l.push(s, o);
  } else {
    l.push(e, i), l.push(n, t);
    for (let R = 1, w = b; R < _; R++, w += C)
      l.push(
        n + Math.sin(w) * S,
        t + Math.cos(w) * S
      ), l.push(n, t);
    l.push(s, o), l.push(n, t);
  }
  return _ * 2;
}
function vP(n, t, e, i, s, o) {
  const l = oT;
  if (n.length === 0)
    return;
  const c = t;
  let d = c.alignment;
  if (t.alignment !== 0.5) {
    let J = bP(n);
    d = (d - 0.5) * J + 0.5;
  }
  const f = new Ut(n[0], n[1]), m = new Ut(n[n.length - 2], n[n.length - 1]), y = i, b = Math.abs(f.x - m.x) < l && Math.abs(f.y - m.y) < l;
  if (y) {
    n = n.slice(), b && (n.pop(), n.pop(), m.set(n[n.length - 2], n[n.length - 1]));
    const J = (f.x + m.x) * 0.5, D = (m.y + f.y) * 0.5;
    n.unshift(J, D), n.push(J, D);
  }
  const v = s, x = n.length / 2;
  let S = n.length;
  const _ = v.length / 2, C = c.width / 2, R = C * C, w = c.miterLimit * c.miterLimit;
  let E = n[0], P = n[1], k = n[2], G = n[3], $ = 0, F = 0, j = -(P - G), H = E - k, M = 0, Y = 0, L = Math.sqrt(j * j + H * H);
  j /= L, H /= L, j *= C, H *= C;
  const Q = d, B = (1 - Q) * 2, I = Q * 2;
  y || (c.cap === "round" ? S += _s(
    E - j * (B - I) * 0.5,
    P - H * (B - I) * 0.5,
    E - j * B,
    P - H * B,
    E + j * I,
    P + H * I,
    v,
    !0
  ) + 2 : c.cap === "square" && (S += s0(E, P, j, H, B, I, !0, v))), v.push(
    E - j * B,
    P - H * B
  ), v.push(
    E + j * I,
    P + H * I
  );
  for (let J = 1; J < x - 1; ++J) {
    E = n[(J - 1) * 2], P = n[(J - 1) * 2 + 1], k = n[J * 2], G = n[J * 2 + 1], $ = n[(J + 1) * 2], F = n[(J + 1) * 2 + 1], j = -(P - G), H = E - k, L = Math.sqrt(j * j + H * H), j /= L, H /= L, j *= C, H *= C, M = -(G - F), Y = k - $, L = Math.sqrt(M * M + Y * Y), M /= L, Y /= L, M *= C, Y *= C;
    const D = k - E, q = P - G, ot = k - $, at = F - G, lt = D * ot + q * at, dt = q * ot - at * D, ht = dt < 0;
    if (Math.abs(dt) < 1e-3 * Math.abs(lt)) {
      v.push(
        k - j * B,
        G - H * B
      ), v.push(
        k + j * I,
        G + H * I
      ), lt >= 0 && (c.join === "round" ? S += _s(
        k,
        G,
        k - j * B,
        G - H * B,
        k - M * B,
        G - Y * B,
        v,
        !1
      ) + 4 : S += 2, v.push(
        k - M * I,
        G - Y * I
      ), v.push(
        k + M * B,
        G + Y * B
      ));
      continue;
    }
    const Vt = (-j + E) * (-H + G) - (-j + k) * (-H + P), Rt = (-M + $) * (-Y + G) - (-M + k) * (-Y + F), Dt = (D * Rt - ot * Vt) / dt, gt = (at * Vt - q * Rt) / dt, Pt = (Dt - k) * (Dt - k) + (gt - G) * (gt - G), Et = k + (Dt - k) * B, It = G + (gt - G) * B, wt = k - (Dt - k) * I, Yt = G - (gt - G) * I, Ie = Math.min(D * D + q * q, ot * ot + at * at), Gt = ht ? B : I, pe = Ie + Gt * Gt * R;
    Pt <= pe ? c.join === "bevel" || Pt / R > w ? (ht ? (v.push(Et, It), v.push(k + j * I, G + H * I), v.push(Et, It), v.push(k + M * I, G + Y * I)) : (v.push(k - j * B, G - H * B), v.push(wt, Yt), v.push(k - M * B, G - Y * B), v.push(wt, Yt)), S += 2) : c.join === "round" ? ht ? (v.push(Et, It), v.push(k + j * I, G + H * I), S += _s(
      k,
      G,
      k + j * I,
      G + H * I,
      k + M * I,
      G + Y * I,
      v,
      !0
    ) + 4, v.push(Et, It), v.push(k + M * I, G + Y * I)) : (v.push(k - j * B, G - H * B), v.push(wt, Yt), S += _s(
      k,
      G,
      k - j * B,
      G - H * B,
      k - M * B,
      G - Y * B,
      v,
      !1
    ) + 4, v.push(k - M * B, G - Y * B), v.push(wt, Yt)) : (v.push(Et, It), v.push(wt, Yt)) : (v.push(k - j * B, G - H * B), v.push(k + j * I, G + H * I), c.join === "round" ? ht ? S += _s(
      k,
      G,
      k + j * I,
      G + H * I,
      k + M * I,
      G + Y * I,
      v,
      !0
    ) + 2 : S += _s(
      k,
      G,
      k - j * B,
      G - H * B,
      k - M * B,
      G - Y * B,
      v,
      !1
    ) + 2 : c.join === "miter" && Pt / R <= w && (ht ? (v.push(wt, Yt), v.push(wt, Yt)) : (v.push(Et, It), v.push(Et, It)), S += 2), v.push(k - M * B, G - Y * B), v.push(k + M * I, G + Y * I), S += 2);
  }
  E = n[(x - 2) * 2], P = n[(x - 2) * 2 + 1], k = n[(x - 1) * 2], G = n[(x - 1) * 2 + 1], j = -(P - G), H = E - k, L = Math.sqrt(j * j + H * H), j /= L, H /= L, j *= C, H *= C, v.push(k - j * B, G - H * B), v.push(k + j * I, G + H * I), y || (c.cap === "round" ? S += _s(
    k - j * (B - I) * 0.5,
    G - H * (B - I) * 0.5,
    k - j * B,
    G - H * B,
    k + j * I,
    G + H * I,
    v,
    !1
  ) + 2 : c.cap === "square" && (S += s0(k, G, j, H, B, I, !1, v)));
  const rt = r0 * r0;
  for (let J = _; J < S + _ - 2; ++J)
    E = v[J * 2], P = v[J * 2 + 1], k = v[(J + 1) * 2], G = v[(J + 1) * 2 + 1], $ = v[(J + 2) * 2], F = v[(J + 2) * 2 + 1], !(Math.abs(E * (G - F) + k * (F - P) + $ * (P - G)) < rt) && o.push(J, J + 1, J + 2);
}
function xP(n, t, e, i) {
  const s = oT;
  if (n.length === 0)
    return;
  const o = n[0], l = n[1], c = n[n.length - 2], d = n[n.length - 1], f = t || Math.abs(o - c) < s && Math.abs(l - d) < s, m = e, y = n.length / 2, b = m.length / 2;
  for (let v = 0; v < y; v++)
    m.push(n[v * 2]), m.push(n[v * 2 + 1]);
  for (let v = 0; v < y - 1; v++)
    i.push(b + v, b + v + 1);
  f && i.push(b + y - 1, b);
}
function lT(n, t, e, i, s, o, l) {
  const c = xR(n, t, 2);
  if (!c)
    return;
  for (let f = 0; f < c.length; f += 3)
    o[l++] = c[f] + s, o[l++] = c[f + 1] + s, o[l++] = c[f + 2] + s;
  let d = s * i;
  for (let f = 0; f < n.length; f += 2)
    e[d] = n[f], e[d + 1] = n[f + 1], d += i;
}
const _P = [], SP = {
  extension: {
    type: W.ShapeBuilder,
    name: "polygon"
  },
  build(n, t) {
    for (let e = 0; e < n.points.length; e++)
      t[e] = n.points[e];
    return !0;
  },
  triangulate(n, t, e, i, s, o) {
    lT(n, _P, t, e, i, s, o);
  }
}, TP = {
  extension: {
    type: W.ShapeBuilder,
    name: "rectangle"
  },
  build(n, t) {
    const e = n, i = e.x, s = e.y, o = e.width, l = e.height;
    return o > 0 && l > 0 ? (t[0] = i, t[1] = s, t[2] = i + o, t[3] = s, t[4] = i + o, t[5] = s + l, t[6] = i, t[7] = s + l, !0) : !1;
  },
  triangulate(n, t, e, i, s, o) {
    let l = 0;
    i *= e, t[i + l] = n[0], t[i + l + 1] = n[1], l += e, t[i + l] = n[2], t[i + l + 1] = n[3], l += e, t[i + l] = n[6], t[i + l + 1] = n[7], l += e, t[i + l] = n[4], t[i + l + 1] = n[5], l += e;
    const c = i / e;
    s[o++] = c, s[o++] = c + 1, s[o++] = c + 2, s[o++] = c + 1, s[o++] = c + 3, s[o++] = c + 2;
  }
}, wP = {
  extension: {
    type: W.ShapeBuilder,
    name: "triangle"
  },
  build(n, t) {
    return t[0] = n.x, t[1] = n.y, t[2] = n.x2, t[3] = n.y2, t[4] = n.x3, t[5] = n.y3, !0;
  },
  triangulate(n, t, e, i, s, o) {
    let l = 0;
    i *= e, t[i + l] = n[0], t[i + l + 1] = n[1], l += e, t[i + l] = n[2], t[i + l + 1] = n[3], l += e, t[i + l] = n[4], t[i + l + 1] = n[5];
    const c = i / e;
    s[o++] = c, s[o++] = c + 1, s[o++] = c + 2;
  }
}, CP = new bt(), EP = new ne();
function MP(n, t, e, i) {
  const s = t.matrix ? n.copyFrom(t.matrix).invert() : n.identity();
  if (t.textureSpace === "local") {
    const l = e.getBounds(EP);
    t.width && l.pad(t.width);
    const { x: c, y: d } = l, f = 1 / l.width, m = 1 / l.height, y = -c * f, b = -d * m, v = s.a, x = s.b, S = s.c, _ = s.d;
    s.a *= f, s.b *= f, s.c *= m, s.d *= m, s.tx = y * v + b * S + s.tx, s.ty = y * x + b * _ + s.ty;
  } else
    s.translate(t.texture.frame.x, t.texture.frame.y), s.scale(1 / t.texture.source.width, 1 / t.texture.source.height);
  const o = t.texture.source.style;
  return !(t.fill instanceof vr) && o.addressMode === "clamp-to-edge" && (o.addressMode = "repeat", o.update()), i && s.append(CP.copyFrom(i).invert()), s;
}
const wh = {};
Nt.handleByMap(W.ShapeBuilder, wh);
Nt.add(TP, SP, wP, Hl, gP, yP);
const AP = new ne(), RP = new bt();
function PP(n, t) {
  const { geometryData: e, batches: i } = t;
  i.length = 0, e.indices.length = 0, e.vertices.length = 0, e.uvs.length = 0;
  for (let s = 0; s < n.instructions.length; s++) {
    const o = n.instructions[s];
    if (o.action === "texture")
      BP(o.data, i, e);
    else if (o.action === "fill" || o.action === "stroke") {
      const l = o.action === "stroke", c = o.data.path.shapePath, d = o.data.style, f = o.data.hole;
      l && f && a0(f.shapePath, d, !0, i, e), f && (c.shapePrimitives[c.shapePrimitives.length - 1].holes = f.shapePath.shapePrimitives), a0(c, d, l, i, e);
    }
  }
}
function BP(n, t, e) {
  const i = [], s = wh.rectangle, o = AP;
  o.x = n.dx, o.y = n.dy, o.width = n.dw, o.height = n.dh;
  const l = n.transform;
  if (!s.build(o, i))
    return;
  const { vertices: c, uvs: d, indices: f } = e, m = f.length, y = c.length / 2;
  l && aT(i, l), s.triangulate(i, c, 2, y, f, m);
  const b = n.image, v = b.uvs;
  d.push(
    v.x0,
    v.y0,
    v.x1,
    v.y1,
    v.x3,
    v.y3,
    v.x2,
    v.y2
  );
  const x = Qe.get(pg);
  x.indexOffset = m, x.indexSize = f.length - m, x.attributeOffset = y, x.attributeSize = c.length / 2 - y, x.baseColor = n.style, x.alpha = n.alpha, x.texture = b, x.geometryData = e, t.push(x);
}
function a0(n, t, e, i, s) {
  const { vertices: o, uvs: l, indices: c } = s;
  n.shapePrimitives.forEach(({ shape: d, transform: f, holes: m }) => {
    const y = [], b = wh[d.type];
    if (!b.build(d, y))
      return;
    const v = c.length, x = o.length / 2;
    let S = "triangle-list";
    if (f && aT(y, f), e) {
      const w = d.closePath ?? !0, E = t;
      E.pixelLine ? (xP(y, w, o, c), S = "line-list") : vP(y, E, !1, w, o, c);
    } else if (m) {
      const w = [], E = y.slice();
      kP(m).forEach((k) => {
        w.push(E.length / 2), E.push(...k);
      }), lT(E, w, o, 2, x, c, v);
    } else
      b.triangulate(y, o, 2, x, c, v);
    const _ = l.length / 2, C = t.texture;
    if (C !== Tt.WHITE) {
      const w = MP(RP, t, d, f);
      fP(o, 2, x, l, _, 2, o.length / 2 - x, w);
    } else
      pP(l, _, 2, o.length / 2 - x);
    const R = Qe.get(pg);
    R.indexOffset = v, R.indexSize = c.length - v, R.attributeOffset = x, R.attributeSize = o.length / 2 - x, R.baseColor = t.color, R.alpha = t.alpha, R.texture = C, R.geometryData = s, R.topology = S, i.push(R);
  });
}
function kP(n) {
  const t = [];
  for (let e = 0; e < n.length; e++) {
    const i = n[e].shape, s = [];
    wh[i.type].build(i, s) && t.push(s);
  }
  return t;
}
class OP {
  constructor() {
    this.batches = [], this.geometryData = {
      vertices: [],
      uvs: [],
      indices: []
    };
  }
}
class DP {
  constructor() {
    this.instructions = new h1();
  }
  init(t) {
    this.batcher = new fg({
      maxTextures: t
    }), this.instructions.reset();
  }
  /**
   * @deprecated since version 8.0.0
   * Use `batcher.geometry` instead.
   * @see {Batcher#geometry}
   */
  get geometry() {
    return zt(NM, "GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead."), this.batcher.geometry;
  }
  destroy() {
    this.batcher.destroy(), this.instructions.destroy(), this.batcher = null, this.instructions = null;
  }
}
const mg = class Tm {
  constructor(t) {
    this._gpuContextHash = {}, this._graphicsDataContextHash = /* @__PURE__ */ Object.create(null), this._renderer = t, t.renderableGC.addManagedHash(this, "_gpuContextHash"), t.renderableGC.addManagedHash(this, "_graphicsDataContextHash");
  }
  /**
   * Runner init called, update the default options
   * @ignore
   */
  init(t) {
    Tm.defaultOptions.bezierSmoothness = t?.bezierSmoothness ?? Tm.defaultOptions.bezierSmoothness;
  }
  /**
   * Returns the render data for a given GraphicsContext.
   * @param context - The GraphicsContext to get the render data for.
   * @internal
   */
  getContextRenderData(t) {
    return this._graphicsDataContextHash[t.uid] || this._initContextRenderData(t);
  }
  /**
   * Updates the GPU context for a given GraphicsContext.
   * If the context is dirty, it will rebuild the batches and geometry data.
   * @param context - The GraphicsContext to update.
   * @returns The updated GpuGraphicsContext.
   * @internal
   */
  updateGpuContext(t) {
    let e = this._gpuContextHash[t.uid] || this._initContext(t);
    if (t.dirty) {
      e ? this._cleanGraphicsContextData(t) : e = this._initContext(t), PP(t, e);
      const i = t.batchMode;
      t.customShader || i === "no-batch" ? e.isBatchable = !1 : i === "auto" ? e.isBatchable = e.geometryData.vertices.length < 400 : e.isBatchable = !0, t.dirty = !1;
    }
    return e;
  }
  /**
   * Returns the GpuGraphicsContext for a given GraphicsContext.
   * If it does not exist, it will initialize a new one.
   * @param context - The GraphicsContext to get the GpuGraphicsContext for.
   * @returns The GpuGraphicsContext for the given GraphicsContext.
   * @internal
   */
  getGpuContext(t) {
    return this._gpuContextHash[t.uid] || this._initContext(t);
  }
  _initContextRenderData(t) {
    const e = Qe.get(DP, {
      maxTextures: this._renderer.limits.maxBatchableTextures
    }), { batches: i, geometryData: s } = this._gpuContextHash[t.uid], o = s.vertices.length, l = s.indices.length;
    for (let m = 0; m < i.length; m++)
      i[m].applyTransform = !1;
    const c = e.batcher;
    c.ensureAttributeBuffer(o), c.ensureIndexBuffer(l), c.begin();
    for (let m = 0; m < i.length; m++) {
      const y = i[m];
      c.add(y);
    }
    c.finish(e.instructions);
    const d = c.geometry;
    d.indexBuffer.setDataWithSize(c.indexBuffer, c.indexSize, !0), d.buffers[0].setDataWithSize(c.attributeBuffer.float32View, c.attributeSize, !0);
    const f = c.batches;
    for (let m = 0; m < f.length; m++) {
      const y = f[m];
      y.bindGroup = og(
        y.textures.textures,
        y.textures.count,
        this._renderer.limits.maxBatchableTextures
      );
    }
    return this._graphicsDataContextHash[t.uid] = e, e;
  }
  _initContext(t) {
    const e = new OP();
    return e.context = t, this._gpuContextHash[t.uid] = e, t.on("destroy", this.onGraphicsContextDestroy, this), this._gpuContextHash[t.uid];
  }
  onGraphicsContextDestroy(t) {
    this._cleanGraphicsContextData(t), t.off("destroy", this.onGraphicsContextDestroy, this), this._gpuContextHash[t.uid] = null;
  }
  _cleanGraphicsContextData(t) {
    const e = this._gpuContextHash[t.uid];
    e.isBatchable || this._graphicsDataContextHash[t.uid] && (Qe.return(this.getContextRenderData(t)), this._graphicsDataContextHash[t.uid] = null), e.batches && e.batches.forEach((i) => {
      Qe.return(i);
    });
  }
  destroy() {
    for (const t in this._gpuContextHash)
      this._gpuContextHash[t] && this.onGraphicsContextDestroy(this._gpuContextHash[t].context);
  }
};
mg.extension = {
  type: [
    W.WebGLSystem,
    W.WebGPUSystem,
    W.CanvasSystem
  ],
  name: "graphicsContext"
};
mg.defaultOptions = {
  /**
   * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)
   * @default 0.5
   */
  bezierSmoothness: 0.5
};
let gg = mg;
const GP = 8, Bc = 11920929e-14, UP = 1;
function uT(n, t, e, i, s, o, l, c, d, f) {
  const y = Math.min(
    0.99,
    // a value of 1.0 actually inverts smoothing, so we cap it at 0.99
    Math.max(0, f ?? gg.defaultOptions.bezierSmoothness)
  );
  let b = (UP - y) / 1;
  return b *= b, NP(t, e, i, s, o, l, c, d, n, b), n;
}
function NP(n, t, e, i, s, o, l, c, d, f) {
  wm(n, t, e, i, s, o, l, c, d, f, 0), d.push(l, c);
}
function wm(n, t, e, i, s, o, l, c, d, f, m) {
  if (m > GP)
    return;
  const y = (n + e) / 2, b = (t + i) / 2, v = (e + s) / 2, x = (i + o) / 2, S = (s + l) / 2, _ = (o + c) / 2, C = (y + v) / 2, R = (b + x) / 2, w = (v + S) / 2, E = (x + _) / 2, P = (C + w) / 2, k = (R + E) / 2;
  if (m > 0) {
    let G = l - n, $ = c - t;
    const F = Math.abs((e - l) * $ - (i - c) * G), j = Math.abs((s - l) * $ - (o - c) * G);
    if (F > Bc && j > Bc) {
      if ((F + j) * (F + j) <= f * (G * G + $ * $)) {
        d.push(P, k);
        return;
      }
    } else if (F > Bc) {
      if (F * F <= f * (G * G + $ * $)) {
        d.push(P, k);
        return;
      }
    } else if (j > Bc) {
      if (j * j <= f * (G * G + $ * $)) {
        d.push(P, k);
        return;
      }
    } else if (G = P - (n + l) / 2, $ = k - (t + c) / 2, G * G + $ * $ <= f) {
      d.push(P, k);
      return;
    }
  }
  wm(n, t, y, b, C, R, P, k, d, f, m + 1), wm(P, k, w, E, S, _, l, c, d, f, m + 1);
}
const IP = 8, zP = 11920929e-14, LP = 1;
function FP(n, t, e, i, s, o, l, c) {
  const f = Math.min(
    0.99,
    // a value of 1.0 actually inverts smoothing, so we cap it at 0.99
    Math.max(0, c ?? gg.defaultOptions.bezierSmoothness)
  );
  let m = (LP - f) / 1;
  return m *= m, HP(t, e, i, s, o, l, n, m), n;
}
function HP(n, t, e, i, s, o, l, c) {
  Cm(l, n, t, e, i, s, o, c, 0), l.push(s, o);
}
function Cm(n, t, e, i, s, o, l, c, d) {
  if (d > IP)
    return;
  const f = (t + i) / 2, m = (e + s) / 2, y = (i + o) / 2, b = (s + l) / 2, v = (f + y) / 2, x = (m + b) / 2;
  let S = o - t, _ = l - e;
  const C = Math.abs((i - o) * _ - (s - l) * S);
  if (C > zP) {
    if (C * C <= c * (S * S + _ * _)) {
      n.push(v, x);
      return;
    }
  } else if (S = v - (t + o) / 2, _ = x - (e + l) / 2, S * S + _ * _ <= c) {
    n.push(v, x);
    return;
  }
  Cm(n, t, e, f, m, v, x, c, d + 1), Cm(n, v, x, y, b, o, l, c, d + 1);
}
function cT(n, t, e, i, s, o, l, c) {
  let d = Math.abs(s - o);
  (!l && s > o || l && o > s) && (d = 2 * Math.PI - d), c || (c = Math.max(6, Math.floor(6 * Math.pow(i, 1 / 3) * (d / Math.PI)))), c = Math.max(c, 3);
  let f = d / c, m = s;
  f *= l ? -1 : 1;
  for (let y = 0; y < c + 1; y++) {
    const b = Math.cos(m), v = Math.sin(m), x = t + b * i, S = e + v * i;
    n.push(x, S), m += f;
  }
}
function $P(n, t, e, i, s, o) {
  const l = n[n.length - 2], d = n[n.length - 1] - e, f = l - t, m = s - e, y = i - t, b = Math.abs(d * y - f * m);
  if (b < 1e-8 || o === 0) {
    (n[n.length - 2] !== t || n[n.length - 1] !== e) && n.push(t, e);
    return;
  }
  const v = d * d + f * f, x = m * m + y * y, S = d * m + f * y, _ = o * Math.sqrt(v) / b, C = o * Math.sqrt(x) / b, R = _ * S / v, w = C * S / x, E = _ * y + C * f, P = _ * m + C * d, k = f * (C + R), G = d * (C + R), $ = y * (_ + w), F = m * (_ + w), j = Math.atan2(G - P, k - E), H = Math.atan2(F - P, $ - E);
  cT(
    n,
    E + t,
    P + e,
    o,
    j,
    H,
    f * m > y * d
  );
}
const Al = Math.PI * 2, Np = {
  centerX: 0,
  centerY: 0,
  ang1: 0,
  ang2: 0
}, Ip = ({ x: n, y: t }, e, i, s, o, l, c, d) => {
  n *= e, t *= i;
  const f = s * n - o * t, m = o * n + s * t;
  return d.x = f + l, d.y = m + c, d;
};
function WP(n, t) {
  const e = t === -1.5707963267948966 ? -0.551915024494 : 1.3333333333333333 * Math.tan(t / 4), i = t === 1.5707963267948966 ? 0.551915024494 : e, s = Math.cos(n), o = Math.sin(n), l = Math.cos(n + t), c = Math.sin(n + t);
  return [
    {
      x: s - o * i,
      y: o + s * i
    },
    {
      x: l + c * i,
      y: c - l * i
    },
    {
      x: l,
      y: c
    }
  ];
}
const o0 = (n, t, e, i) => {
  const s = n * i - t * e < 0 ? -1 : 1;
  let o = n * e + t * i;
  return o > 1 && (o = 1), o < -1 && (o = -1), s * Math.acos(o);
}, VP = (n, t, e, i, s, o, l, c, d, f, m, y, b) => {
  const v = Math.pow(s, 2), x = Math.pow(o, 2), S = Math.pow(m, 2), _ = Math.pow(y, 2);
  let C = v * x - v * _ - x * S;
  C < 0 && (C = 0), C /= v * _ + x * S, C = Math.sqrt(C) * (l === c ? -1 : 1);
  const R = C * s / o * y, w = C * -o / s * m, E = f * R - d * w + (n + e) / 2, P = d * R + f * w + (t + i) / 2, k = (m - R) / s, G = (y - w) / o, $ = (-m - R) / s, F = (-y - w) / o, j = o0(1, 0, k, G);
  let H = o0(k, G, $, F);
  c === 0 && H > 0 && (H -= Al), c === 1 && H < 0 && (H += Al), b.centerX = E, b.centerY = P, b.ang1 = j, b.ang2 = H;
};
function jP(n, t, e, i, s, o, l, c = 0, d = 0, f = 0) {
  if (o === 0 || l === 0)
    return;
  const m = Math.sin(c * Al / 360), y = Math.cos(c * Al / 360), b = y * (t - i) / 2 + m * (e - s) / 2, v = -m * (t - i) / 2 + y * (e - s) / 2;
  if (b === 0 && v === 0)
    return;
  o = Math.abs(o), l = Math.abs(l);
  const x = Math.pow(b, 2) / Math.pow(o, 2) + Math.pow(v, 2) / Math.pow(l, 2);
  x > 1 && (o *= Math.sqrt(x), l *= Math.sqrt(x)), VP(
    t,
    e,
    i,
    s,
    o,
    l,
    d,
    f,
    m,
    y,
    b,
    v,
    Np
  );
  let { ang1: S, ang2: _ } = Np;
  const { centerX: C, centerY: R } = Np;
  let w = Math.abs(_) / (Al / 4);
  Math.abs(1 - w) < 1e-7 && (w = 1);
  const E = Math.max(Math.ceil(w), 1);
  _ /= E;
  let P = n[n.length - 2], k = n[n.length - 1];
  const G = { x: 0, y: 0 };
  for (let $ = 0; $ < E; $++) {
    const F = WP(S, _), { x: j, y: H } = Ip(F[0], o, l, y, m, C, R, G), { x: M, y: Y } = Ip(F[1], o, l, y, m, C, R, G), { x: L, y: Q } = Ip(F[2], o, l, y, m, C, R, G);
    uT(
      n,
      P,
      k,
      j,
      H,
      M,
      Y,
      L,
      Q
    ), P = L, k = Q, S += _;
  }
}
function YP(n, t, e) {
  const i = (l, c) => {
    const d = c.x - l.x, f = c.y - l.y, m = Math.sqrt(d * d + f * f), y = d / m, b = f / m;
    return { len: m, nx: y, ny: b };
  }, s = (l, c) => {
    l === 0 ? n.moveTo(c.x, c.y) : n.lineTo(c.x, c.y);
  };
  let o = t[t.length - 1];
  for (let l = 0; l < t.length; l++) {
    const c = t[l % t.length], d = c.radius ?? e;
    if (d <= 0) {
      s(l, c), o = c;
      continue;
    }
    const f = t[(l + 1) % t.length], m = i(c, o), y = i(c, f);
    if (m.len < 1e-4 || y.len < 1e-4) {
      s(l, c), o = c;
      continue;
    }
    let b = Math.asin(m.nx * y.ny - m.ny * y.nx), v = 1, x = !1;
    m.nx * y.nx - m.ny * -y.ny < 0 ? b < 0 ? b = Math.PI + b : (b = Math.PI - b, v = -1, x = !0) : b > 0 && (v = -1, x = !0);
    const S = b / 2;
    let _, C = Math.abs(
      Math.cos(S) * d / Math.sin(S)
    );
    C > Math.min(m.len / 2, y.len / 2) ? (C = Math.min(m.len / 2, y.len / 2), _ = Math.abs(C * Math.sin(S) / Math.cos(S))) : _ = d;
    const R = c.x + y.nx * C + -y.ny * _ * v, w = c.y + y.ny * C + y.nx * _ * v, E = Math.atan2(m.ny, m.nx) + Math.PI / 2 * v, P = Math.atan2(y.ny, y.nx) - Math.PI / 2 * v;
    l === 0 && n.moveTo(
      R + Math.cos(E) * _,
      w + Math.sin(E) * _
    ), n.arc(R, w, _, E, P, x), o = c;
  }
}
function XP(n, t, e, i) {
  const s = (c, d) => Math.sqrt((c.x - d.x) ** 2 + (c.y - d.y) ** 2), o = (c, d, f) => ({
    x: c.x + (d.x - c.x) * f,
    y: c.y + (d.y - c.y) * f
  }), l = t.length;
  for (let c = 0; c < l; c++) {
    const d = t[(c + 1) % l], f = d.radius ?? e;
    if (f <= 0) {
      c === 0 ? n.moveTo(d.x, d.y) : n.lineTo(d.x, d.y);
      continue;
    }
    const m = t[c], y = t[(c + 2) % l], b = s(m, d);
    let v;
    if (b < 1e-4)
      v = d;
    else {
      const _ = Math.min(b / 2, f);
      v = o(
        d,
        m,
        _ / b
      );
    }
    const x = s(y, d);
    let S;
    if (x < 1e-4)
      S = d;
    else {
      const _ = Math.min(x / 2, f);
      S = o(
        d,
        y,
        _ / x
      );
    }
    c === 0 ? n.moveTo(v.x, v.y) : n.lineTo(v.x, v.y), n.quadraticCurveTo(d.x, d.y, S.x, S.y, i);
  }
}
const qP = new ne();
class KP {
  constructor(t) {
    this.shapePrimitives = [], this._currentPoly = null, this._bounds = new Cn(), this._graphicsPath2D = t, this.signed = t.checkForHoles;
  }
  /**
   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.
   * @param x - The x-coordinate for the starting point.
   * @param y - The y-coordinate for the starting point.
   * @returns The instance of the current object for chaining.
   */
  moveTo(t, e) {
    return this.startPoly(t, e), this;
  }
  /**
   * Connects the current point to a new point with a straight line. This method updates the current path.
   * @param x - The x-coordinate of the new point to connect to.
   * @param y - The y-coordinate of the new point to connect to.
   * @returns The instance of the current object for chaining.
   */
  lineTo(t, e) {
    this._ensurePoly();
    const i = this._currentPoly.points, s = i[i.length - 2], o = i[i.length - 1];
    return (s !== t || o !== e) && i.push(t, e), this;
  }
  /**
   * Adds an arc to the path. The arc is centered at (x, y)
   *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.
   * @param x - The x-coordinate of the arc's center.
   * @param y - The y-coordinate of the arc's center.
   * @param radius - The radius of the arc.
   * @param startAngle - The starting angle of the arc, in radians.
   * @param endAngle - The ending angle of the arc, in radians.
   * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.
   * @returns The instance of the current object for chaining.
   */
  arc(t, e, i, s, o, l) {
    this._ensurePoly(!1);
    const c = this._currentPoly.points;
    return cT(c, t, e, i, s, o, l), this;
  }
  /**
   * Adds an arc to the path with the arc tangent to the line joining two specified points.
   * The arc radius is specified by `radius`.
   * @param x1 - The x-coordinate of the first point.
   * @param y1 - The y-coordinate of the first point.
   * @param x2 - The x-coordinate of the second point.
   * @param y2 - The y-coordinate of the second point.
   * @param radius - The radius of the arc.
   * @returns The instance of the current object for chaining.
   */
  arcTo(t, e, i, s, o) {
    this._ensurePoly();
    const l = this._currentPoly.points;
    return $P(l, t, e, i, s, o), this;
  }
  /**
   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.
   * @param rx - The x-radius of the ellipse.
   * @param ry - The y-radius of the ellipse.
   * @param xAxisRotation - The rotation of the ellipse's x-axis relative
   * to the x-axis of the coordinate system, in degrees.
   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.
   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.
   * @param x - The x-coordinate of the arc's end point.
   * @param y - The y-coordinate of the arc's end point.
   * @returns The instance of the current object for chaining.
   */
  arcToSvg(t, e, i, s, o, l, c) {
    const d = this._currentPoly.points;
    return jP(
      d,
      this._currentPoly.lastX,
      this._currentPoly.lastY,
      l,
      c,
      t,
      e,
      i,
      s,
      o
    ), this;
  }
  /**
   * Adds a cubic Bezier curve to the path.
   * It requires three points: the first two are control points and the third one is the end point.
   * The starting point is the last point in the current path.
   * @param cp1x - The x-coordinate of the first control point.
   * @param cp1y - The y-coordinate of the first control point.
   * @param cp2x - The x-coordinate of the second control point.
   * @param cp2y - The y-coordinate of the second control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothness - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */
  bezierCurveTo(t, e, i, s, o, l, c) {
    this._ensurePoly();
    const d = this._currentPoly;
    return uT(
      this._currentPoly.points,
      d.lastX,
      d.lastY,
      t,
      e,
      i,
      s,
      o,
      l,
      c
    ), this;
  }
  /**
   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.
   * The starting point is the last point in the current path.
   * @param cp1x - The x-coordinate of the control point.
   * @param cp1y - The y-coordinate of the control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothing - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */
  quadraticCurveTo(t, e, i, s, o) {
    this._ensurePoly();
    const l = this._currentPoly;
    return FP(
      this._currentPoly.points,
      l.lastX,
      l.lastY,
      t,
      e,
      i,
      s,
      o
    ), this;
  }
  /**
   * Closes the current path by drawing a straight line back to the start.
   * If the shape is already closed or there are no points in the path, this method does nothing.
   * @returns The instance of the current object for chaining.
   */
  closePath() {
    return this.endPoly(!0), this;
  }
  /**
   * Adds another path to the current path. This method allows for the combination of multiple paths into one.
   * @param path - The `GraphicsPath` object representing the path to add.
   * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.
   * @returns The instance of the current object for chaining.
   */
  addPath(t, e) {
    this.endPoly(), e && !e.isIdentity() && (t = t.clone(!0), t.transform(e));
    const i = this.shapePrimitives, s = i.length;
    for (let o = 0; o < t.instructions.length; o++) {
      const l = t.instructions[o];
      this[l.action](...l.data);
    }
    if (t.checkForHoles && i.length - s > 1) {
      let o = null;
      for (let l = s; l < i.length; l++) {
        const c = i[l];
        if (c.shape.type === "polygon") {
          const d = c.shape, f = o?.shape;
          f && f.containsPolygon(d) ? (o.holes || (o.holes = []), o.holes.push(c), i.copyWithin(l, l + 1), i.length--, l--) : o = c;
        }
      }
    }
    return this;
  }
  /**
   * Finalizes the drawing of the current path. Optionally, it can close the path.
   * @param closePath - A boolean indicating whether to close the path after finishing. False by default.
   */
  finish(t = !1) {
    this.endPoly(t);
  }
  /**
   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.
   * @param x - The x-coordinate of the top-left corner of the rectangle.
   * @param y - The y-coordinate of the top-left corner of the rectangle.
   * @param w - The width of the rectangle.
   * @param h - The height of the rectangle.
   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.
   * @returns The instance of the current object for chaining.
   */
  rect(t, e, i, s, o) {
    return this.drawShape(new ne(t, e, i, s), o), this;
  }
  /**
   * Draws a circle shape. This method adds a new circle path to the current drawing.
   * @param x - The x-coordinate of the center of the circle.
   * @param y - The y-coordinate of the center of the circle.
   * @param radius - The radius of the circle.
   * @param transform - An optional `Matrix` object to apply a transformation to the circle.
   * @returns The instance of the current object for chaining.
   */
  circle(t, e, i, s) {
    return this.drawShape(new rg(t, e, i), s), this;
  }
  /**
   * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.
   * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]
   * representing the x and y coordinates of the polygon's vertices, in sequence.
   * @param close - A boolean indicating whether to close the polygon path. True by default.
   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.
   * @returns The instance of the current object for chaining.
   */
  poly(t, e, i) {
    const s = new El(t);
    return s.closePath = e, this.drawShape(s, i), this;
  }
  /**
   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.
   * @param x - The x-coordinate of the center of the polygon.
   * @param y - The y-coordinate of the center of the polygon.
   * @param radius - The radius of the circumscribed circle of the polygon.
   * @param sides - The number of sides of the polygon. Must be 3 or more.
   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.
   * @returns The instance of the current object for chaining.
   */
  regularPoly(t, e, i, s, o = 0, l) {
    s = Math.max(s | 0, 3);
    const c = -1 * Math.PI / 2 + o, d = Math.PI * 2 / s, f = [];
    for (let m = 0; m < s; m++) {
      const y = c - m * d;
      f.push(
        t + i * Math.cos(y),
        e + i * Math.sin(y)
      );
    }
    return this.poly(f, !0, l), this;
  }
  /**
   * Draws a polygon with rounded corners.
   * Similar to `regularPoly` but with the ability to round the corners of the polygon.
   * @param x - The x-coordinate of the center of the polygon.
   * @param y - The y-coordinate of the center of the polygon.
   * @param radius - The radius of the circumscribed circle of the polygon.
   * @param sides - The number of sides of the polygon. Must be 3 or more.
   * @param corner - The radius of the rounding of the corners.
   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
   * @param smoothness - Optional parameter to adjust the smoothness of the rounding.
   * @returns The instance of the current object for chaining.
   */
  roundPoly(t, e, i, s, o, l = 0, c) {
    if (s = Math.max(s | 0, 3), o <= 0)
      return this.regularPoly(t, e, i, s, l);
    const d = i * Math.sin(Math.PI / s) - 1e-3;
    o = Math.min(o, d);
    const f = -1 * Math.PI / 2 + l, m = Math.PI * 2 / s, y = (s - 2) * Math.PI / s / 2;
    for (let b = 0; b < s; b++) {
      const v = b * m + f, x = t + i * Math.cos(v), S = e + i * Math.sin(v), _ = v + Math.PI + y, C = v - Math.PI - y, R = x + o * Math.cos(_), w = S + o * Math.sin(_), E = x + o * Math.cos(C), P = S + o * Math.sin(C);
      b === 0 ? this.moveTo(R, w) : this.lineTo(R, w), this.quadraticCurveTo(x, S, E, P, c);
    }
    return this.closePath();
  }
  /**
   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.
   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.
   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.
   * A minimum of 3 points is required.
   * @param radius - The default radius for the corners.
   * This radius is applied to all corners unless overridden in `points`.
   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve
   *  method instead of an arc method. Defaults to false.
   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.
   * Higher values make the curve smoother.
   * @returns The instance of the current object for chaining.
   */
  roundShape(t, e, i = !1, s) {
    return t.length < 3 ? this : (i ? XP(this, t, e, s) : YP(this, t, e), this.closePath());
  }
  /**
   * Draw Rectangle with fillet corners. This is much like rounded rectangle
   * however it support negative numbers as well for the corner radius.
   * @param x - Upper left corner of rect
   * @param y - Upper right corner of rect
   * @param width - Width of rect
   * @param height - Height of rect
   * @param fillet - accept negative or positive values
   */
  filletRect(t, e, i, s, o) {
    if (o === 0)
      return this.rect(t, e, i, s);
    const l = Math.min(i, s) / 2, c = Math.min(l, Math.max(-l, o)), d = t + i, f = e + s, m = c < 0 ? -c : 0, y = Math.abs(c);
    return this.moveTo(t, e + y).arcTo(t + m, e + m, t + y, e, y).lineTo(d - y, e).arcTo(d - m, e + m, d, e + y, y).lineTo(d, f - y).arcTo(d - m, f - m, t + i - y, f, y).lineTo(t + y, f).arcTo(t + m, f - m, t, f - y, y).closePath();
  }
  /**
   * Draw Rectangle with chamfer corners. These are angled corners.
   * @param x - Upper left corner of rect
   * @param y - Upper right corner of rect
   * @param width - Width of rect
   * @param height - Height of rect
   * @param chamfer - non-zero real number, size of corner cutout
   * @param transform
   */
  chamferRect(t, e, i, s, o, l) {
    if (o <= 0)
      return this.rect(t, e, i, s);
    const c = Math.min(o, Math.min(i, s) / 2), d = t + i, f = e + s, m = [
      t + c,
      e,
      d - c,
      e,
      d,
      e + c,
      d,
      f - c,
      d - c,
      f,
      t + c,
      f,
      t,
      f - c,
      t,
      e + c
    ];
    for (let y = m.length - 1; y >= 2; y -= 2)
      m[y] === m[y - 2] && m[y - 1] === m[y - 3] && m.splice(y - 1, 2);
    return this.poly(m, !0, l);
  }
  /**
   * Draws an ellipse at the specified location and with the given x and y radii.
   * An optional transformation can be applied, allowing for rotation, scaling, and translation.
   * @param x - The x-coordinate of the center of the ellipse.
   * @param y - The y-coordinate of the center of the ellipse.
   * @param radiusX - The horizontal radius of the ellipse.
   * @param radiusY - The vertical radius of the ellipse.
   * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.
   * @returns The instance of the current object for chaining.
   */
  ellipse(t, e, i, s, o) {
    return this.drawShape(new sg(t, e, i, s), o), this;
  }
  /**
   * Draws a rectangle with rounded corners.
   * The corner radius can be specified to determine how rounded the corners should be.
   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.
   * @param x - The x-coordinate of the top-left corner of the rectangle.
   * @param y - The y-coordinate of the top-left corner of the rectangle.
   * @param w - The width of the rectangle.
   * @param h - The height of the rectangle.
   * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.
   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.
   * @returns The instance of the current object for chaining.
   */
  roundRect(t, e, i, s, o, l) {
    return this.drawShape(new ag(t, e, i, s, o), l), this;
  }
  /**
   * Draws a given shape on the canvas.
   * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.
   * An optional transformation matrix can be applied to the shape, allowing for complex transformations.
   * @param shape - The shape to draw, defined as a `ShapePrimitive` object.
   * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,
   * scaling, and translations.
   * @returns The instance of the current object for chaining.
   */
  drawShape(t, e) {
    return this.endPoly(), this.shapePrimitives.push({ shape: t, transform: e }), this;
  }
  /**
   * Starts a new polygon path from the specified starting point.
   * This method initializes a new polygon or ends the current one if it exists.
   * @param x - The x-coordinate of the starting point of the new polygon.
   * @param y - The y-coordinate of the starting point of the new polygon.
   * @returns The instance of the current object for chaining.
   */
  startPoly(t, e) {
    let i = this._currentPoly;
    return i && this.endPoly(), i = new El(), i.points.push(t, e), this._currentPoly = i, this;
  }
  /**
   * Ends the current polygon path. If `closePath` is set to true,
   * the path is closed by connecting the last point to the first one.
   * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.
   * @param closePath - A boolean indicating whether to close the polygon by connecting the last point
   *  back to the starting point. False by default.
   * @returns The instance of the current object for chaining.
   */
  endPoly(t = !1) {
    const e = this._currentPoly;
    return e && e.points.length > 2 && (e.closePath = t, this.shapePrimitives.push({ shape: e })), this._currentPoly = null, this;
  }
  _ensurePoly(t = !0) {
    if (!this._currentPoly && (this._currentPoly = new El(), t)) {
      const e = this.shapePrimitives[this.shapePrimitives.length - 1];
      if (e) {
        let i = e.shape.x, s = e.shape.y;
        if (e.transform && !e.transform.isIdentity()) {
          const o = e.transform, l = i;
          i = o.a * i + o.c * s + o.tx, s = o.b * l + o.d * s + o.ty;
        }
        this._currentPoly.points.push(i, s);
      } else
        this._currentPoly.points.push(0, 0);
    }
  }
  /** Builds the path. */
  buildPath() {
    const t = this._graphicsPath2D;
    this.shapePrimitives.length = 0, this._currentPoly = null;
    for (let e = 0; e < t.instructions.length; e++) {
      const i = t.instructions[e];
      this[i.action](...i.data);
    }
    this.finish();
  }
  /** Gets the bounds of the path. */
  get bounds() {
    const t = this._bounds;
    t.clear();
    const e = this.shapePrimitives;
    for (let i = 0; i < e.length; i++) {
      const s = e[i], o = s.shape.getBounds(qP);
      s.transform ? t.addRect(o, s.transform) : t.addRect(o);
    }
    return t;
  }
}
class br {
  /**
   * Creates a `GraphicsPath` instance optionally from an SVG path string or an array of `PathInstruction`.
   * @param instructions - An SVG path string or an array of `PathInstruction` objects.
   * @param signed
   */
  constructor(t, e = !1) {
    this.instructions = [], this.uid = Ee("graphicsPath"), this._dirty = !0, this.checkForHoles = e, typeof t == "string" ? kR(t, this) : this.instructions = t?.slice() ?? [];
  }
  /**
   * Provides access to the internal shape path, ensuring it is up-to-date with the current instructions.
   * @returns The `ShapePath` instance associated with this `GraphicsPath`.
   */
  get shapePath() {
    return this._shapePath || (this._shapePath = new KP(this)), this._dirty && (this._dirty = !1, this._shapePath.buildPath()), this._shapePath;
  }
  /**
   * Adds another `GraphicsPath` to this path, optionally applying a transformation.
   * @param path - The `GraphicsPath` to add.
   * @param transform - An optional transformation to apply to the added path.
   * @returns The instance of the current object for chaining.
   */
  addPath(t, e) {
    return t = t.clone(), this.instructions.push({ action: "addPath", data: [t, e] }), this._dirty = !0, this;
  }
  arc(...t) {
    return this.instructions.push({ action: "arc", data: t }), this._dirty = !0, this;
  }
  arcTo(...t) {
    return this.instructions.push({ action: "arcTo", data: t }), this._dirty = !0, this;
  }
  arcToSvg(...t) {
    return this.instructions.push({ action: "arcToSvg", data: t }), this._dirty = !0, this;
  }
  bezierCurveTo(...t) {
    return this.instructions.push({ action: "bezierCurveTo", data: t }), this._dirty = !0, this;
  }
  /**
   * Adds a cubic Bezier curve to the path.
   * It requires two points: the second control point and the end point. The first control point is assumed to be
   * The starting point is the last point in the current path.
   * @param cp2x - The x-coordinate of the second control point.
   * @param cp2y - The y-coordinate of the second control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothness - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */
  bezierCurveToShort(t, e, i, s, o) {
    const l = this.instructions[this.instructions.length - 1], c = this.getLastPoint(Ut.shared);
    let d = 0, f = 0;
    if (!l || l.action !== "bezierCurveTo")
      d = c.x, f = c.y;
    else {
      d = l.data[2], f = l.data[3];
      const m = c.x, y = c.y;
      d = m + (m - d), f = y + (y - f);
    }
    return this.instructions.push({ action: "bezierCurveTo", data: [d, f, t, e, i, s, o] }), this._dirty = !0, this;
  }
  /**
   * Closes the current path by drawing a straight line back to the start.
   * If the shape is already closed or there are no points in the path, this method does nothing.
   * @returns The instance of the current object for chaining.
   */
  closePath() {
    return this.instructions.push({ action: "closePath", data: [] }), this._dirty = !0, this;
  }
  ellipse(...t) {
    return this.instructions.push({ action: "ellipse", data: t }), this._dirty = !0, this;
  }
  lineTo(...t) {
    return this.instructions.push({ action: "lineTo", data: t }), this._dirty = !0, this;
  }
  moveTo(...t) {
    return this.instructions.push({ action: "moveTo", data: t }), this;
  }
  quadraticCurveTo(...t) {
    return this.instructions.push({ action: "quadraticCurveTo", data: t }), this._dirty = !0, this;
  }
  /**
   * Adds a quadratic curve to the path. It uses the previous point as the control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothness - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */
  quadraticCurveToShort(t, e, i) {
    const s = this.instructions[this.instructions.length - 1], o = this.getLastPoint(Ut.shared);
    let l = 0, c = 0;
    if (!s || s.action !== "quadraticCurveTo")
      l = o.x, c = o.y;
    else {
      l = s.data[0], c = s.data[1];
      const d = o.x, f = o.y;
      l = d + (d - l), c = f + (f - c);
    }
    return this.instructions.push({ action: "quadraticCurveTo", data: [l, c, t, e, i] }), this._dirty = !0, this;
  }
  /**
   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.
   * @param x - The x-coordinate of the top-left corner of the rectangle.
   * @param y - The y-coordinate of the top-left corner of the rectangle.
   * @param w - The width of the rectangle.
   * @param h - The height of the rectangle.
   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.
   * @returns The instance of the current object for chaining.
   */
  rect(t, e, i, s, o) {
    return this.instructions.push({ action: "rect", data: [t, e, i, s, o] }), this._dirty = !0, this;
  }
  /**
   * Draws a circle shape. This method adds a new circle path to the current drawing.
   * @param x - The x-coordinate of the center of the circle.
   * @param y - The y-coordinate of the center of the circle.
   * @param radius - The radius of the circle.
   * @param transform - An optional `Matrix` object to apply a transformation to the circle.
   * @returns The instance of the current object for chaining.
   */
  circle(t, e, i, s) {
    return this.instructions.push({ action: "circle", data: [t, e, i, s] }), this._dirty = !0, this;
  }
  roundRect(...t) {
    return this.instructions.push({ action: "roundRect", data: t }), this._dirty = !0, this;
  }
  poly(...t) {
    return this.instructions.push({ action: "poly", data: t }), this._dirty = !0, this;
  }
  regularPoly(...t) {
    return this.instructions.push({ action: "regularPoly", data: t }), this._dirty = !0, this;
  }
  roundPoly(...t) {
    return this.instructions.push({ action: "roundPoly", data: t }), this._dirty = !0, this;
  }
  roundShape(...t) {
    return this.instructions.push({ action: "roundShape", data: t }), this._dirty = !0, this;
  }
  filletRect(...t) {
    return this.instructions.push({ action: "filletRect", data: t }), this._dirty = !0, this;
  }
  chamferRect(...t) {
    return this.instructions.push({ action: "chamferRect", data: t }), this._dirty = !0, this;
  }
  /**
   * Draws a star shape centered at a specified location. This method allows for the creation
   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.
   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.
   * An optional transformation can be applied to scale, rotate, or translate the star as needed.
   * @param x - The x-coordinate of the center of the star.
   * @param y - The y-coordinate of the center of the star.
   * @param points - The number of points of the star.
   * @param radius - The outer radius of the star (distance from the center to the outer points).
   * @param innerRadius - Optional. The inner radius of the star
   * (distance from the center to the inner points between the outer points).
   * If not provided, defaults to half of the `radius`.
   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.
   * Defaults to 0, meaning one point is directly upward.
   * @param transform - An optional `Matrix` object to apply a transformation to the star.
   * This can include rotations, scaling, and translations.
   * @returns The instance of the current object for chaining further drawing commands.
   */
  // eslint-disable-next-line max-len
  star(t, e, i, s, o, l, c) {
    o || (o = s / 2);
    const d = -1 * Math.PI / 2 + l, f = i * 2, m = Math.PI * 2 / f, y = [];
    for (let b = 0; b < f; b++) {
      const v = b % 2 ? o : s, x = b * m + d;
      y.push(
        t + v * Math.cos(x),
        e + v * Math.sin(x)
      );
    }
    return this.poly(y, !0, c), this;
  }
  /**
   * Creates a copy of the current `GraphicsPath` instance. This method supports both shallow and deep cloning.
   * A shallow clone copies the reference of the instructions array, while a deep clone creates a new array and
   * copies each instruction individually, ensuring that modifications to the instructions of the cloned `GraphicsPath`
   * do not affect the original `GraphicsPath` and vice versa.
   * @param deep - A boolean flag indicating whether the clone should be deep.
   * @returns A new `GraphicsPath` instance that is a clone of the current instance.
   */
  clone(t = !1) {
    const e = new br();
    if (e.checkForHoles = this.checkForHoles, !t)
      e.instructions = this.instructions.slice();
    else
      for (let i = 0; i < this.instructions.length; i++) {
        const s = this.instructions[i];
        e.instructions.push({ action: s.action, data: s.data.slice() });
      }
    return e;
  }
  clear() {
    return this.instructions.length = 0, this._dirty = !0, this;
  }
  /**
   * Applies a transformation matrix to all drawing instructions within the `GraphicsPath`.
   * This method enables the modification of the path's geometry according to the provided
   * transformation matrix, which can include translations, rotations, scaling, and skewing.
   *
   * Each drawing instruction in the path is updated to reflect the transformation,
   * ensuring the visual representation of the path is consistent with the applied matrix.
   *
   * Note: The transformation is applied directly to the coordinates and control points of the drawing instructions,
   * not to the path as a whole. This means the transformation's effects are baked into the individual instructions,
   * allowing for fine-grained control over the path's appearance.
   * @param matrix - A `Matrix` object representing the transformation to apply.
   * @returns The instance of the current object for chaining further operations.
   */
  transform(t) {
    if (t.isIdentity())
      return this;
    const e = t.a, i = t.b, s = t.c, o = t.d, l = t.tx, c = t.ty;
    let d = 0, f = 0, m = 0, y = 0, b = 0, v = 0, x = 0, S = 0;
    for (let _ = 0; _ < this.instructions.length; _++) {
      const C = this.instructions[_], R = C.data;
      switch (C.action) {
        case "moveTo":
        case "lineTo":
          d = R[0], f = R[1], R[0] = e * d + s * f + l, R[1] = i * d + o * f + c;
          break;
        case "bezierCurveTo":
          m = R[0], y = R[1], b = R[2], v = R[3], d = R[4], f = R[5], R[0] = e * m + s * y + l, R[1] = i * m + o * y + c, R[2] = e * b + s * v + l, R[3] = i * b + o * v + c, R[4] = e * d + s * f + l, R[5] = i * d + o * f + c;
          break;
        case "quadraticCurveTo":
          m = R[0], y = R[1], d = R[2], f = R[3], R[0] = e * m + s * y + l, R[1] = i * m + o * y + c, R[2] = e * d + s * f + l, R[3] = i * d + o * f + c;
          break;
        case "arcToSvg":
          d = R[5], f = R[6], x = R[0], S = R[1], R[0] = e * x + s * S, R[1] = i * x + o * S, R[5] = e * d + s * f + l, R[6] = i * d + o * f + c;
          break;
        case "circle":
          R[4] = ll(R[3], t);
          break;
        case "rect":
          R[4] = ll(R[4], t);
          break;
        case "ellipse":
          R[8] = ll(R[8], t);
          break;
        case "roundRect":
          R[5] = ll(R[5], t);
          break;
        case "addPath":
          R[0].transform(t);
          break;
        case "poly":
          R[2] = ll(R[2], t);
          break;
        default:
          $t("unknown transform action", C.action);
          break;
      }
    }
    return this._dirty = !0, this;
  }
  get bounds() {
    return this.shapePath.bounds;
  }
  /**
   * Retrieves the last point from the current drawing instructions in the `GraphicsPath`.
   * This method is useful for operations that depend on the path's current endpoint,
   * such as connecting subsequent shapes or paths. It supports various drawing instructions,
   * ensuring the last point's position is accurately determined regardless of the path's complexity.
   *
   * If the last instruction is a `closePath`, the method iterates backward through the instructions
   *  until it finds an actionable instruction that defines a point (e.g., `moveTo`, `lineTo`,
   * `quadraticCurveTo`, etc.). For compound paths added via `addPath`, it recursively retrieves
   * the last point from the nested path.
   * @param out - A `Point` object where the last point's coordinates will be stored.
   * This object is modified directly to contain the result.
   * @returns The `Point` object containing the last point's coordinates.
   */
  getLastPoint(t) {
    let e = this.instructions.length - 1, i = this.instructions[e];
    if (!i)
      return t.x = 0, t.y = 0, t;
    for (; i.action === "closePath"; ) {
      if (e--, e < 0)
        return t.x = 0, t.y = 0, t;
      i = this.instructions[e];
    }
    switch (i.action) {
      case "moveTo":
      case "lineTo":
        t.x = i.data[0], t.y = i.data[1];
        break;
      case "quadraticCurveTo":
        t.x = i.data[2], t.y = i.data[3];
        break;
      case "bezierCurveTo":
        t.x = i.data[4], t.y = i.data[5];
        break;
      case "arc":
      case "arcToSvg":
        t.x = i.data[5], t.y = i.data[6];
        break;
      case "addPath":
        i.data[0].getLastPoint(t);
        break;
    }
    return t;
  }
}
function ll(n, t) {
  return n ? n.prepend(t) : t.clone();
}
function $e(n, t, e) {
  const i = n.getAttribute(t);
  return i ? Number(i) : e;
}
function ZP(n, t) {
  const e = n.querySelectorAll("defs");
  for (let i = 0; i < e.length; i++) {
    const s = e[i];
    for (let o = 0; o < s.children.length; o++) {
      const l = s.children[o];
      switch (l.nodeName.toLowerCase()) {
        case "lineargradient":
          t.defs[l.id] = QP(l);
          break;
        case "radialgradient":
          t.defs[l.id] = JP();
          break;
      }
    }
  }
}
function QP(n) {
  const t = $e(n, "x1", 0), e = $e(n, "y1", 0), i = $e(n, "x2", 1), s = $e(n, "y2", 0), o = n.getAttribute("gradientUnits") || "objectBoundingBox", l = new vr(
    t,
    e,
    i,
    s,
    o === "objectBoundingBox" ? "local" : "global"
  );
  for (let c = 0; c < n.children.length; c++) {
    const d = n.children[c], f = $e(d, "offset", 0), m = Pe.shared.setValue(d.getAttribute("stop-color")).toNumber();
    l.addColorStop(f, m);
  }
  return l;
}
function JP(n) {
  return $t("[SVG Parser] Radial gradients are not yet supported"), new vr(0, 0, 1, 0);
}
function l0(n) {
  const t = n.match(/url\s*\(\s*['"]?\s*#([^'"\s)]+)\s*['"]?\s*\)/i);
  return t ? t[1] : "";
}
const u0 = {
  // Fill properties
  fill: { type: "paint", default: 0 },
  // Fill color/gradient
  "fill-opacity": { type: "number", default: 1 },
  // Fill transparency
  // Stroke properties
  stroke: { type: "paint", default: 0 },
  // Stroke color/gradient
  "stroke-width": { type: "number", default: 1 },
  // Width of stroke
  "stroke-opacity": { type: "number", default: 1 },
  // Stroke transparency
  "stroke-linecap": { type: "string", default: "butt" },
  // End cap style: butt, round, square
  "stroke-linejoin": { type: "string", default: "miter" },
  // Join style: miter, round, bevel
  "stroke-miterlimit": { type: "number", default: 10 },
  // Limit on miter join sharpness
  "stroke-dasharray": { type: "string", default: "none" },
  // Dash pattern
  "stroke-dashoffset": { type: "number", default: 0 },
  // Offset for dash pattern
  // Global properties
  opacity: { type: "number", default: 1 }
  // Overall opacity
};
function hT(n, t) {
  const e = n.getAttribute("style"), i = {}, s = {}, o = {
    strokeStyle: i,
    fillStyle: s,
    useFill: !1,
    useStroke: !1
  };
  for (const l in u0) {
    const c = n.getAttribute(l);
    c && c0(t, o, l, c.trim());
  }
  if (e) {
    const l = e.split(";");
    for (let c = 0; c < l.length; c++) {
      const d = l[c].trim(), [f, m] = d.split(":");
      u0[f] && c0(t, o, f, m.trim());
    }
  }
  return {
    strokeStyle: o.useStroke ? i : null,
    fillStyle: o.useFill ? s : null,
    useFill: o.useFill,
    useStroke: o.useStroke
  };
}
function c0(n, t, e, i) {
  switch (e) {
    case "stroke":
      if (i !== "none") {
        if (i.startsWith("url(")) {
          const s = l0(i);
          t.strokeStyle.fill = n.defs[s];
        } else
          t.strokeStyle.color = Pe.shared.setValue(i).toNumber();
        t.useStroke = !0;
      }
      break;
    case "stroke-width":
      t.strokeStyle.width = Number(i);
      break;
    case "fill":
      if (i !== "none") {
        if (i.startsWith("url(")) {
          const s = l0(i);
          t.fillStyle.fill = n.defs[s];
        } else
          t.fillStyle.color = Pe.shared.setValue(i).toNumber();
        t.useFill = !0;
      }
      break;
    case "fill-opacity":
      t.fillStyle.alpha = Number(i);
      break;
    case "stroke-opacity":
      t.strokeStyle.alpha = Number(i);
      break;
    case "opacity":
      t.fillStyle.alpha = Number(i), t.strokeStyle.alpha = Number(i);
      break;
  }
}
function tB(n) {
  if (n.length <= 2)
    return !0;
  const t = n.map((c) => c.area).sort((c, d) => d - c), [e, i] = t, s = t[t.length - 1], o = e / i, l = i / s;
  return !(o > 3 && l < 2);
}
function eB(n) {
  return n.split(/(?=[Mm])/).filter((i) => i.trim().length > 0);
}
function nB(n) {
  const t = n.match(/[-+]?[0-9]*\.?[0-9]+/g);
  if (!t || t.length < 4)
    return 0;
  const e = t.map(Number), i = [], s = [];
  for (let m = 0; m < e.length; m += 2)
    m + 1 < e.length && (i.push(e[m]), s.push(e[m + 1]));
  if (i.length === 0 || s.length === 0)
    return 0;
  const o = Math.min(...i), l = Math.max(...i), c = Math.min(...s), d = Math.max(...s);
  return (l - o) * (d - c);
}
function h0(n, t) {
  const e = new br(n, !1);
  for (const i of e.instructions)
    t.instructions.push(i);
}
function iB(n, t) {
  if (typeof n == "string") {
    const l = document.createElement("div");
    l.innerHTML = n.trim(), n = l.querySelector("svg");
  }
  const e = {
    context: t,
    defs: {},
    path: new br()
  };
  ZP(n, e);
  const i = n.children, { fillStyle: s, strokeStyle: o } = hT(n, e);
  for (let l = 0; l < i.length; l++) {
    const c = i[l];
    c.nodeName.toLowerCase() !== "defs" && dT(c, e, s, o);
  }
  return t;
}
function dT(n, t, e, i) {
  const s = n.children, { fillStyle: o, strokeStyle: l } = hT(n, t);
  o && e ? e = { ...e, ...o } : o && (e = o), l && i ? i = { ...i, ...l } : l && (i = l);
  const c = !e && !i;
  c && (e = { color: 0 });
  let d, f, m, y, b, v, x, S, _, C, R, w, E, P, k, G, $;
  switch (n.nodeName.toLowerCase()) {
    case "path": {
      P = n.getAttribute("d");
      const F = n.getAttribute("fill-rule"), j = eB(P), H = F === "evenodd", M = j.length > 1;
      if (H && M) {
        const L = j.map((B) => ({
          path: B,
          area: nB(B)
        }));
        if (L.sort((B, I) => I.area - B.area), j.length > 3 || !tB(L))
          for (let B = 0; B < L.length; B++) {
            const I = L[B], rt = B === 0;
            t.context.beginPath();
            const J = new br(void 0, !0);
            h0(I.path, J), t.context.path(J), rt ? (e && t.context.fill(e), i && t.context.stroke(i)) : t.context.cut();
          }
        else
          for (let B = 0; B < L.length; B++) {
            const I = L[B], rt = B % 2 === 1;
            t.context.beginPath();
            const J = new br(void 0, !0);
            h0(I.path, J), t.context.path(J), rt ? t.context.cut() : (e && t.context.fill(e), i && t.context.stroke(i));
          }
      } else {
        const L = F ? F === "evenodd" : !0;
        k = new br(P, L), t.context.path(k), e && t.context.fill(e), i && t.context.stroke(i);
      }
      break;
    }
    case "circle":
      x = $e(n, "cx", 0), S = $e(n, "cy", 0), _ = $e(n, "r", 0), t.context.ellipse(x, S, _, _), e && t.context.fill(e), i && t.context.stroke(i);
      break;
    case "rect":
      d = $e(n, "x", 0), f = $e(n, "y", 0), G = $e(n, "width", 0), $ = $e(n, "height", 0), C = $e(n, "rx", 0), R = $e(n, "ry", 0), C || R ? t.context.roundRect(d, f, G, $, C || R) : t.context.rect(d, f, G, $), e && t.context.fill(e), i && t.context.stroke(i);
      break;
    case "ellipse":
      x = $e(n, "cx", 0), S = $e(n, "cy", 0), C = $e(n, "rx", 0), R = $e(n, "ry", 0), t.context.beginPath(), t.context.ellipse(x, S, C, R), e && t.context.fill(e), i && t.context.stroke(i);
      break;
    case "line":
      m = $e(n, "x1", 0), y = $e(n, "y1", 0), b = $e(n, "x2", 0), v = $e(n, "y2", 0), t.context.beginPath(), t.context.moveTo(m, y), t.context.lineTo(b, v), i && t.context.stroke(i);
      break;
    case "polygon":
      E = n.getAttribute("points"), w = E.match(/\d+/g).map((F) => parseInt(F, 10)), t.context.poly(w, !0), e && t.context.fill(e), i && t.context.stroke(i);
      break;
    case "polyline":
      E = n.getAttribute("points"), w = E.match(/\d+/g).map((F) => parseInt(F, 10)), t.context.poly(w, !1), i && t.context.stroke(i);
      break;
    case "g":
    case "svg":
      break;
    default: {
      $t(`[SVG parser] <${n.nodeName}> elements unsupported`);
      break;
    }
  }
  c && (e = null);
  for (let F = 0; F < s.length; F++)
    dT(s[F], t, e, i);
}
function rB(n) {
  return Pe.isColorLike(n);
}
function d0(n) {
  return n instanceof Th;
}
function f0(n) {
  return n instanceof vr;
}
function sB(n) {
  return n instanceof Tt;
}
function aB(n, t, e) {
  const i = Pe.shared.setValue(t ?? 0);
  return n.color = i.toNumber(), n.alpha = i.alpha === 1 ? e.alpha : i.alpha, n.texture = Tt.WHITE, { ...e, ...n };
}
function oB(n, t, e) {
  return n.texture = t, { ...e, ...n };
}
function p0(n, t, e) {
  return n.fill = t, n.color = 16777215, n.texture = t.texture, n.matrix = t.transform, { ...e, ...n };
}
function m0(n, t, e) {
  return t.buildGradient(), n.fill = t, n.color = 16777215, n.texture = t.texture, n.matrix = t.transform, n.textureSpace = t.textureSpace, { ...e, ...n };
}
function lB(n, t) {
  const e = { ...t, ...n }, i = Pe.shared.setValue(e.color);
  return e.alpha *= i.alpha, e.color = i.toNumber(), e;
}
function ks(n, t) {
  if (n == null)
    return null;
  const e = {}, i = n;
  return rB(n) ? aB(e, n, t) : sB(n) ? oB(e, n, t) : d0(n) ? p0(e, n, t) : f0(n) ? m0(e, n, t) : i.fill && d0(i.fill) ? p0(i, i.fill, t) : i.fill && f0(i.fill) ? m0(i, i.fill, t) : lB(i, t);
}
function ah(n, t) {
  const { width: e, alignment: i, miterLimit: s, cap: o, join: l, pixelLine: c, ...d } = t, f = ks(n, d);
  return f ? {
    width: e,
    alignment: i,
    miterLimit: s,
    cap: o,
    join: l,
    pixelLine: c,
    ...f
  } : null;
}
const uB = new Ut(), g0 = new bt(), yg = class Ni extends Jn {
  constructor() {
    super(...arguments), this.uid = Ee("graphicsContext"), this.dirty = !0, this.batchMode = "auto", this.instructions = [], this._activePath = new br(), this._transform = new bt(), this._fillStyle = { ...Ni.defaultFillStyle }, this._strokeStyle = { ...Ni.defaultStrokeStyle }, this._stateStack = [], this._tick = 0, this._bounds = new Cn(), this._boundsDirty = !0;
  }
  /**
   * Creates a new GraphicsContext object that is a clone of this instance, copying all properties,
   * including the current drawing state, transformations, styles, and instructions.
   * @returns A new GraphicsContext instance with the same properties and state as this one.
   */
  clone() {
    const t = new Ni();
    return t.batchMode = this.batchMode, t.instructions = this.instructions.slice(), t._activePath = this._activePath.clone(), t._transform = this._transform.clone(), t._fillStyle = { ...this._fillStyle }, t._strokeStyle = { ...this._strokeStyle }, t._stateStack = this._stateStack.slice(), t._bounds = this._bounds.clone(), t._boundsDirty = !0, t;
  }
  /**
   * The current fill style of the graphics context. This can be a color, gradient, pattern, or a more complex style defined by a FillStyle object.
   */
  get fillStyle() {
    return this._fillStyle;
  }
  set fillStyle(t) {
    this._fillStyle = ks(t, Ni.defaultFillStyle);
  }
  /**
   * The current stroke style of the graphics context. Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.
   */
  get strokeStyle() {
    return this._strokeStyle;
  }
  set strokeStyle(t) {
    this._strokeStyle = ah(t, Ni.defaultStrokeStyle);
  }
  /**
   * Sets the current fill style of the graphics context. The fill style can be a color, gradient,
   * pattern, or a more complex style defined by a FillStyle object.
   * @param style - The fill style to apply. This can be a simple color, a gradient or pattern object,
   *                or a FillStyle or ConvertedFillStyle object.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  setFillStyle(t) {
    return this._fillStyle = ks(t, Ni.defaultFillStyle), this;
  }
  /**
   * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can
   * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.
   * @param style - The stroke style to apply. Can be defined as a color, a gradient or pattern,
   *                or a StrokeStyle or ConvertedStrokeStyle object.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  setStrokeStyle(t) {
    return this._strokeStyle = ks(t, Ni.defaultStrokeStyle), this;
  }
  texture(t, e, i, s, o, l) {
    return this.instructions.push({
      action: "texture",
      data: {
        image: t,
        dx: i || 0,
        dy: s || 0,
        dw: o || t.frame.width,
        dh: l || t.frame.height,
        transform: this._transform.clone(),
        alpha: this._fillStyle.alpha,
        style: e ? Pe.shared.setValue(e).toNumber() : 16777215
      }
    }), this.onUpdate(), this;
  }
  /**
   * Resets the current path. Any previous path and its commands are discarded and a new path is
   * started. This is typically called before beginning a new shape or series of drawing commands.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  beginPath() {
    return this._activePath = new br(), this;
  }
  fill(t, e) {
    let i;
    const s = this.instructions[this.instructions.length - 1];
    return this._tick === 0 && s && s.action === "stroke" ? i = s.data.path : i = this._activePath.clone(), i ? (t != null && (e !== void 0 && typeof t == "number" && (zt(ae, "GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead"), t = { color: t, alpha: e }), this._fillStyle = ks(t, Ni.defaultFillStyle)), this.instructions.push({
      action: "fill",
      // TODO copy fill style!
      data: { style: this.fillStyle, path: i }
    }), this.onUpdate(), this._initNextPathLocation(), this._tick = 0, this) : this;
  }
  _initNextPathLocation() {
    const { x: t, y: e } = this._activePath.getLastPoint(Ut.shared);
    this._activePath.clear(), this._activePath.moveTo(t, e);
  }
  /**
   * Strokes the current path with the current stroke style. This method can take an optional
   * FillInput parameter to define the stroke's appearance, including its color, width, and other properties.
   * @param style - (Optional) The stroke style to apply. Can be defined as a simple color or a more complex style object. If omitted, uses the current stroke style.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  stroke(t) {
    let e;
    const i = this.instructions[this.instructions.length - 1];
    return this._tick === 0 && i && i.action === "fill" ? e = i.data.path : e = this._activePath.clone(), e ? (t != null && (this._strokeStyle = ah(t, Ni.defaultStrokeStyle)), this.instructions.push({
      action: "stroke",
      // TODO copy fill style!
      data: { style: this.strokeStyle, path: e }
    }), this.onUpdate(), this._initNextPathLocation(), this._tick = 0, this) : this;
  }
  /**
   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by
   * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will
   * fail to cut correctly!
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  cut() {
    for (let t = 0; t < 2; t++) {
      const e = this.instructions[this.instructions.length - 1 - t], i = this._activePath.clone();
      if (e && (e.action === "stroke" || e.action === "fill"))
        if (e.data.hole)
          e.data.hole.addPath(i);
        else {
          e.data.hole = i;
          break;
        }
    }
    return this._initNextPathLocation(), this;
  }
  /**
   * Adds an arc to the current path, which is centered at (x, y) with the specified radius,
   * starting and ending angles, and direction.
   * @param x - The x-coordinate of the arc's center.
   * @param y - The y-coordinate of the arc's center.
   * @param radius - The arc's radius.
   * @param startAngle - The starting angle, in radians.
   * @param endAngle - The ending angle, in radians.
   * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise (false). Defaults to false.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  arc(t, e, i, s, o, l) {
    this._tick++;
    const c = this._transform;
    return this._activePath.arc(
      c.a * t + c.c * e + c.tx,
      c.b * t + c.d * e + c.ty,
      i,
      s,
      o,
      l
    ), this;
  }
  /**
   * Adds an arc to the current path with the given control points and radius, connected to the previous point
   * by a straight line if necessary.
   * @param x1 - The x-coordinate of the first control point.
   * @param y1 - The y-coordinate of the first control point.
   * @param x2 - The x-coordinate of the second control point.
   * @param y2 - The y-coordinate of the second control point.
   * @param radius - The arc's radius.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  arcTo(t, e, i, s, o) {
    this._tick++;
    const l = this._transform;
    return this._activePath.arcTo(
      l.a * t + l.c * e + l.tx,
      l.b * t + l.d * e + l.ty,
      l.a * i + l.c * s + l.tx,
      l.b * i + l.d * s + l.ty,
      o
    ), this;
  }
  /**
   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.
   * @param rx - The x-radius of the ellipse.
   * @param ry - The y-radius of the ellipse.
   * @param xAxisRotation - The rotation of the ellipse's x-axis relative
   * to the x-axis of the coordinate system, in degrees.
   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.
   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.
   * @param x - The x-coordinate of the arc's end point.
   * @param y - The y-coordinate of the arc's end point.
   * @returns The instance of the current object for chaining.
   */
  arcToSvg(t, e, i, s, o, l, c) {
    this._tick++;
    const d = this._transform;
    return this._activePath.arcToSvg(
      t,
      e,
      i,
      // should we rotate this with transform??
      s,
      o,
      d.a * l + d.c * c + d.tx,
      d.b * l + d.d * c + d.ty
    ), this;
  }
  /**
   * Adds a cubic Bezier curve to the path.
   * It requires three points: the first two are control points and the third one is the end point.
   * The starting point is the last point in the current path.
   * @param cp1x - The x-coordinate of the first control point.
   * @param cp1y - The y-coordinate of the first control point.
   * @param cp2x - The x-coordinate of the second control point.
   * @param cp2y - The y-coordinate of the second control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothness - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */
  bezierCurveTo(t, e, i, s, o, l, c) {
    this._tick++;
    const d = this._transform;
    return this._activePath.bezierCurveTo(
      d.a * t + d.c * e + d.tx,
      d.b * t + d.d * e + d.ty,
      d.a * i + d.c * s + d.tx,
      d.b * i + d.d * s + d.ty,
      d.a * o + d.c * l + d.tx,
      d.b * o + d.d * l + d.ty,
      c
    ), this;
  }
  /**
   * Closes the current path by drawing a straight line back to the start.
   * If the shape is already closed or there are no points in the path, this method does nothing.
   * @returns The instance of the current object for chaining.
   */
  closePath() {
    return this._tick++, this._activePath?.closePath(), this;
  }
  /**
   * Draws an ellipse at the specified location and with the given x and y radii.
   * An optional transformation can be applied, allowing for rotation, scaling, and translation.
   * @param x - The x-coordinate of the center of the ellipse.
   * @param y - The y-coordinate of the center of the ellipse.
   * @param radiusX - The horizontal radius of the ellipse.
   * @param radiusY - The vertical radius of the ellipse.
   * @returns The instance of the current object for chaining.
   */
  ellipse(t, e, i, s) {
    return this._tick++, this._activePath.ellipse(t, e, i, s, this._transform.clone()), this;
  }
  /**
   * Draws a circle shape. This method adds a new circle path to the current drawing.
   * @param x - The x-coordinate of the center of the circle.
   * @param y - The y-coordinate of the center of the circle.
   * @param radius - The radius of the circle.
   * @returns The instance of the current object for chaining.
   */
  circle(t, e, i) {
    return this._tick++, this._activePath.circle(t, e, i, this._transform.clone()), this;
  }
  /**
   * Adds another `GraphicsPath` to this path, optionally applying a transformation.
   * @param path - The `GraphicsPath` to add.
   * @returns The instance of the current object for chaining.
   */
  path(t) {
    return this._tick++, this._activePath.addPath(t, this._transform.clone()), this;
  }
  /**
   * Connects the current point to a new point with a straight line. This method updates the current path.
   * @param x - The x-coordinate of the new point to connect to.
   * @param y - The y-coordinate of the new point to connect to.
   * @returns The instance of the current object for chaining.
   */
  lineTo(t, e) {
    this._tick++;
    const i = this._transform;
    return this._activePath.lineTo(
      i.a * t + i.c * e + i.tx,
      i.b * t + i.d * e + i.ty
    ), this;
  }
  /**
   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.
   * @param x - The x-coordinate for the starting point.
   * @param y - The y-coordinate for the starting point.
   * @returns The instance of the current object for chaining.
   */
  moveTo(t, e) {
    this._tick++;
    const i = this._transform, s = this._activePath.instructions, o = i.a * t + i.c * e + i.tx, l = i.b * t + i.d * e + i.ty;
    return s.length === 1 && s[0].action === "moveTo" ? (s[0].data[0] = o, s[0].data[1] = l, this) : (this._activePath.moveTo(
      o,
      l
    ), this);
  }
  /**
   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.
   * The starting point is the last point in the current path.
   * @param cpx - The x-coordinate of the control point.
   * @param cpy - The y-coordinate of the control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothness - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */
  quadraticCurveTo(t, e, i, s, o) {
    this._tick++;
    const l = this._transform;
    return this._activePath.quadraticCurveTo(
      l.a * t + l.c * e + l.tx,
      l.b * t + l.d * e + l.ty,
      l.a * i + l.c * s + l.tx,
      l.b * i + l.d * s + l.ty,
      o
    ), this;
  }
  /**
   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.
   * @param x - The x-coordinate of the top-left corner of the rectangle.
   * @param y - The y-coordinate of the top-left corner of the rectangle.
   * @param w - The width of the rectangle.
   * @param h - The height of the rectangle.
   * @returns The instance of the current object for chaining.
   */
  rect(t, e, i, s) {
    return this._tick++, this._activePath.rect(t, e, i, s, this._transform.clone()), this;
  }
  /**
   * Draws a rectangle with rounded corners.
   * The corner radius can be specified to determine how rounded the corners should be.
   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.
   * @param x - The x-coordinate of the top-left corner of the rectangle.
   * @param y - The y-coordinate of the top-left corner of the rectangle.
   * @param w - The width of the rectangle.
   * @param h - The height of the rectangle.
   * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.
   * @returns The instance of the current object for chaining.
   */
  roundRect(t, e, i, s, o) {
    return this._tick++, this._activePath.roundRect(t, e, i, s, o, this._transform.clone()), this;
  }
  /**
   * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,
   * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,
   * rotated, or translated as needed.
   * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]
   * representing the x and y coordinates, of the polygon's vertices, in sequence.
   * @param close - A boolean indicating whether to close the polygon path. True by default.
   */
  poly(t, e) {
    return this._tick++, this._activePath.poly(t, e, this._transform.clone()), this;
  }
  /**
   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.
   * @param x - The x-coordinate of the center of the polygon.
   * @param y - The y-coordinate of the center of the polygon.
   * @param radius - The radius of the circumscribed circle of the polygon.
   * @param sides - The number of sides of the polygon. Must be 3 or more.
   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.
   * @returns The instance of the current object for chaining.
   */
  regularPoly(t, e, i, s, o = 0, l) {
    return this._tick++, this._activePath.regularPoly(t, e, i, s, o, l), this;
  }
  /**
   * Draws a polygon with rounded corners.
   * Similar to `regularPoly` but with the ability to round the corners of the polygon.
   * @param x - The x-coordinate of the center of the polygon.
   * @param y - The y-coordinate of the center of the polygon.
   * @param radius - The radius of the circumscribed circle of the polygon.
   * @param sides - The number of sides of the polygon. Must be 3 or more.
   * @param corner - The radius of the rounding of the corners.
   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
   * @returns The instance of the current object for chaining.
   */
  roundPoly(t, e, i, s, o, l) {
    return this._tick++, this._activePath.roundPoly(t, e, i, s, o, l), this;
  }
  /**
   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.
   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.
   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.
   * A minimum of 3 points is required.
   * @param radius - The default radius for the corners.
   * This radius is applied to all corners unless overridden in `points`.
   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve
   *  method instead of an arc method. Defaults to false.
   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.
   * Higher values make the curve smoother.
   * @returns The instance of the current object for chaining.
   */
  roundShape(t, e, i, s) {
    return this._tick++, this._activePath.roundShape(t, e, i, s), this;
  }
  /**
   * Draw Rectangle with fillet corners. This is much like rounded rectangle
   * however it support negative numbers as well for the corner radius.
   * @param x - Upper left corner of rect
   * @param y - Upper right corner of rect
   * @param width - Width of rect
   * @param height - Height of rect
   * @param fillet - accept negative or positive values
   */
  filletRect(t, e, i, s, o) {
    return this._tick++, this._activePath.filletRect(t, e, i, s, o), this;
  }
  /**
   * Draw Rectangle with chamfer corners. These are angled corners.
   * @param x - Upper left corner of rect
   * @param y - Upper right corner of rect
   * @param width - Width of rect
   * @param height - Height of rect
   * @param chamfer - non-zero real number, size of corner cutout
   * @param transform
   */
  chamferRect(t, e, i, s, o, l) {
    return this._tick++, this._activePath.chamferRect(t, e, i, s, o, l), this;
  }
  /**
   * Draws a star shape centered at a specified location. This method allows for the creation
   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.
   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.
   * An optional transformation can be applied to scale, rotate, or translate the star as needed.
   * @param x - The x-coordinate of the center of the star.
   * @param y - The y-coordinate of the center of the star.
   * @param points - The number of points of the star.
   * @param radius - The outer radius of the star (distance from the center to the outer points).
   * @param innerRadius - Optional. The inner radius of the star
   * (distance from the center to the inner points between the outer points).
   * If not provided, defaults to half of the `radius`.
   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.
   * Defaults to 0, meaning one point is directly upward.
   * @returns The instance of the current object for chaining further drawing commands.
   */
  star(t, e, i, s, o = 0, l = 0) {
    return this._tick++, this._activePath.star(t, e, i, s, o, l, this._transform.clone()), this;
  }
  /**
   * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths
   * defined in SVG format to be drawn within the graphics context.
   * @param svg - The SVG string to be parsed and rendered.
   */
  svg(t) {
    return this._tick++, iB(t, this), this;
  }
  /**
   * Restores the most recently saved graphics state by popping the top of the graphics state stack.
   * This includes transformations, fill styles, and stroke styles.
   */
  restore() {
    const t = this._stateStack.pop();
    return t && (this._transform = t.transform, this._fillStyle = t.fillStyle, this._strokeStyle = t.strokeStyle), this;
  }
  /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */
  save() {
    return this._stateStack.push({
      transform: this._transform.clone(),
      fillStyle: { ...this._fillStyle },
      strokeStyle: { ...this._strokeStyle }
    }), this;
  }
  /**
   * Returns the current transformation matrix of the graphics context.
   * @returns The current transformation matrix.
   */
  getTransform() {
    return this._transform;
  }
  /**
   * Resets the current transformation matrix to the identity matrix, effectively removing any transformations (rotation, scaling, translation) previously applied.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  resetTransform() {
    return this._transform.identity(), this;
  }
  /**
   * Applies a rotation transformation to the graphics context around the current origin.
   * @param angle - The angle of rotation in radians.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  rotate(t) {
    return this._transform.rotate(t), this;
  }
  /**
   * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.
   * @param x - The scale factor in the horizontal direction.
   * @param y - (Optional) The scale factor in the vertical direction. If not specified, the x value is used for both directions.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  scale(t, e = t) {
    return this._transform.scale(t, e), this;
  }
  setTransform(t, e, i, s, o, l) {
    return t instanceof bt ? (this._transform.set(t.a, t.b, t.c, t.d, t.tx, t.ty), this) : (this._transform.set(t, e, i, s, o, l), this);
  }
  transform(t, e, i, s, o, l) {
    return t instanceof bt ? (this._transform.append(t), this) : (g0.set(t, e, i, s, o, l), this._transform.append(g0), this);
  }
  /**
   * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.
   * @param x - The amount to translate in the horizontal direction.
   * @param y - (Optional) The amount to translate in the vertical direction. If not specified, the x value is used for both directions.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  translate(t, e = t) {
    return this._transform.translate(t, e), this;
  }
  /**
   * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,
   * and optionally resetting transformations to the identity matrix.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  clear() {
    return this._activePath.clear(), this.instructions.length = 0, this.resetTransform(), this.onUpdate(), this;
  }
  onUpdate() {
    this._boundsDirty = !0, !this.dirty && (this.emit("update", this, 16), this.dirty = !0);
  }
  /** The bounds of the graphic shape. */
  get bounds() {
    if (!this._boundsDirty)
      return this._bounds;
    this._boundsDirty = !1;
    const t = this._bounds;
    t.clear();
    for (let e = 0; e < this.instructions.length; e++) {
      const i = this.instructions[e], s = i.action;
      if (s === "fill") {
        const o = i.data;
        t.addBounds(o.path.bounds);
      } else if (s === "texture") {
        const o = i.data;
        t.addFrame(o.dx, o.dy, o.dx + o.dw, o.dy + o.dh, o.transform);
      }
      if (s === "stroke") {
        const o = i.data, l = o.style.alignment, c = o.style.width * (1 - l), d = o.path.bounds;
        t.addFrame(
          d.minX - c,
          d.minY - c,
          d.maxX + c,
          d.maxY + c
        );
      }
    }
    return t;
  }
  /**
   * Check to see if a point is contained within this geometry.
   * @param point - Point to check if it's contained.
   * @returns {boolean} `true` if the point is contained within geometry.
   */
  containsPoint(t) {
    if (!this.bounds.containsPoint(t.x, t.y))
      return !1;
    const e = this.instructions;
    let i = !1;
    for (let s = 0; s < e.length; s++) {
      const o = e[s], l = o.data, c = l.path;
      if (!o.action || !c)
        continue;
      const d = l.style, f = c.shapePath.shapePrimitives;
      for (let m = 0; m < f.length; m++) {
        const y = f[m].shape;
        if (!d || !y)
          continue;
        const b = f[m].transform, v = b ? b.applyInverse(t, uB) : t;
        if (o.action === "fill")
          i = y.contains(v.x, v.y);
        else {
          const S = d;
          i = y.strokeContains(v.x, v.y, S.width, S.alignment);
        }
        const x = l.hole;
        if (x) {
          const S = x.shapePath?.shapePrimitives;
          if (S)
            for (let _ = 0; _ < S.length; _++)
              S[_].shape.contains(v.x, v.y) && (i = !1);
        }
        if (i)
          return !0;
      }
    }
    return i;
  }
  /**
   * Destroys the GraphicsData object.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @example
   * context.destroy();
   * context.destroy(true);
   * context.destroy({ texture: true, textureSource: true });
   */
  destroy(t = !1) {
    if (this._stateStack.length = 0, this._transform = null, this.emit("destroy", this), this.removeAllListeners(), typeof t == "boolean" ? t : t?.texture) {
      const i = typeof t == "boolean" ? t : t?.textureSource;
      this._fillStyle.texture && (this._fillStyle.fill && "uid" in this._fillStyle.fill ? this._fillStyle.fill.destroy() : this._fillStyle.texture.destroy(i)), this._strokeStyle.texture && (this._strokeStyle.fill && "uid" in this._strokeStyle.fill ? this._strokeStyle.fill.destroy() : this._strokeStyle.texture.destroy(i));
    }
    this._fillStyle = null, this._strokeStyle = null, this.instructions = null, this._activePath = null, this._bounds = null, this._stateStack = null, this.customShader = null, this._transform = null;
  }
};
yg.defaultFillStyle = {
  /** The color to use for the fill. */
  color: 16777215,
  /** The alpha value to use for the fill. */
  alpha: 1,
  /** The texture to use for the fill. */
  texture: Tt.WHITE,
  /** The matrix to apply. */
  matrix: null,
  /** The fill pattern to use. */
  fill: null,
  /** Whether coordinates are 'global' or 'local' */
  textureSpace: "local"
};
yg.defaultStrokeStyle = {
  /** The width of the stroke. */
  width: 1,
  /** The color to use for the stroke. */
  color: 16777215,
  /** The alpha value to use for the stroke. */
  alpha: 1,
  /** The alignment of the stroke. */
  alignment: 0.5,
  /** The miter limit to use. */
  miterLimit: 10,
  /** The line cap style to use. */
  cap: "butt",
  /** The line join style to use. */
  join: "miter",
  /** The texture to use for the fill. */
  texture: Tt.WHITE,
  /** The matrix to apply. */
  matrix: null,
  /** The fill pattern to use. */
  fill: null,
  /** Whether coordinates are 'global' or 'local' */
  textureSpace: "local",
  /** If the stroke is a pixel line. */
  pixelLine: !1
};
let Si = yg;
const bg = class Ua extends Jn {
  constructor(t = {}) {
    super(), this.uid = Ee("textStyle"), this._tick = 0, cB(t);
    const e = { ...Ua.defaultTextStyle, ...t };
    for (const i in e) {
      const s = i;
      this[s] = e[i];
    }
    this.update(), this._tick = 0;
  }
  /**
   * Alignment for multiline text, does not affect single line text.
   * @type {'left'|'center'|'right'|'justify'}
   */
  get align() {
    return this._align;
  }
  set align(t) {
    this._align = t, this.update();
  }
  /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */
  get breakWords() {
    return this._breakWords;
  }
  set breakWords(t) {
    this._breakWords = t, this.update();
  }
  /** Set a drop shadow for the text. */
  get dropShadow() {
    return this._dropShadow;
  }
  set dropShadow(t) {
    t !== null && typeof t == "object" ? this._dropShadow = this._createProxy({ ...Ua.defaultDropShadow, ...t }) : this._dropShadow = t ? this._createProxy({ ...Ua.defaultDropShadow }) : null, this.update();
  }
  /** The font family, can be a single font name, or a list of names where the first is the preferred font. */
  get fontFamily() {
    return this._fontFamily;
  }
  set fontFamily(t) {
    this._fontFamily = t, this.update();
  }
  /** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */
  get fontSize() {
    return this._fontSize;
  }
  set fontSize(t) {
    typeof t == "string" ? this._fontSize = parseInt(t, 10) : this._fontSize = t, this.update();
  }
  /**
   * The font style.
   * @type {'normal'|'italic'|'oblique'}
   */
  get fontStyle() {
    return this._fontStyle;
  }
  set fontStyle(t) {
    this._fontStyle = t.toLowerCase(), this.update();
  }
  /**
   * The font variant.
   * @type {'normal'|'small-caps'}
   */
  get fontVariant() {
    return this._fontVariant;
  }
  set fontVariant(t) {
    this._fontVariant = t, this.update();
  }
  /**
   * The font weight.
   * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}
   */
  get fontWeight() {
    return this._fontWeight;
  }
  set fontWeight(t) {
    this._fontWeight = t, this.update();
  }
  /** The space between lines. */
  get leading() {
    return this._leading;
  }
  set leading(t) {
    this._leading = t, this.update();
  }
  /** The amount of spacing between letters, default is 0. */
  get letterSpacing() {
    return this._letterSpacing;
  }
  set letterSpacing(t) {
    this._letterSpacing = t, this.update();
  }
  /** The line height, a number that represents the vertical space that a letter uses. */
  get lineHeight() {
    return this._lineHeight;
  }
  set lineHeight(t) {
    this._lineHeight = t, this.update();
  }
  /**
   * Occasionally some fonts are cropped. Adding some padding will prevent this from happening
   * by adding padding to all sides of the text.
   * > [!NOTE] This will NOT affect the positioning or bounds of the text.
   */
  get padding() {
    return this._padding;
  }
  set padding(t) {
    this._padding = t, this.update();
  }
  /**
   * An optional filter or array of filters to apply to the text, allowing for advanced visual effects.
   * These filters will be applied to the text as it is created, resulting in faster rendering for static text
   * compared to applying the filter directly to the text object (which would be applied at run time).
   * @default null
   */
  get filters() {
    return this._filters;
  }
  set filters(t) {
    this._filters = Object.freeze(t), this.update();
  }
  /**
   * Trim transparent borders from the text texture.
   * > [!IMPORTANT] PERFORMANCE WARNING:
   * > This is a costly operation as it requires scanning pixel alpha values.
   * > Avoid using `trim: true` for dynamic text, as it could significantly impact performance.
   */
  get trim() {
    return this._trim;
  }
  set trim(t) {
    this._trim = t, this.update();
  }
  /**
   * The baseline of the text that is rendered.
   * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}
   */
  get textBaseline() {
    return this._textBaseline;
  }
  set textBaseline(t) {
    this._textBaseline = t, this.update();
  }
  /**
   * How newlines and spaces should be handled.
   * Default is 'pre' (preserve, preserve).
   *
   *  value       | New lines     |   Spaces
   *  ---         | ---           |   ---
   * 'normal'     | Collapse      |   Collapse
   * 'pre'        | Preserve      |   Preserve
   * 'pre-line'   | Preserve      |   Collapse
   * @type {'normal'|'pre'|'pre-line'}
   */
  get whiteSpace() {
    return this._whiteSpace;
  }
  set whiteSpace(t) {
    this._whiteSpace = t, this.update();
  }
  /** Indicates if word wrap should be used. */
  get wordWrap() {
    return this._wordWrap;
  }
  set wordWrap(t) {
    this._wordWrap = t, this.update();
  }
  /** The width at which text will wrap, it needs wordWrap to be set to true. */
  get wordWrapWidth() {
    return this._wordWrapWidth;
  }
  set wordWrapWidth(t) {
    this._wordWrapWidth = t, this.update();
  }
  /**
   * The fill style that will be used to color the text.
   * This can be:
   * - A color string like 'red', '#00FF00', or 'rgba(255,0,0,0.5)'
   * - A hex number like 0xff0000 for red
   * - A FillStyle object with properties like { color: 0xff0000, alpha: 0.5 }
   * - A FillGradient for gradient fills
   * - A FillPattern for pattern/texture fills
   *
   * When using a FillGradient, vertical gradients (angle of 90 degrees) are applied per line of text,
   * while gradients at any other angle are spread across the entire text body as a whole.
   * @example
   * // Vertical gradient applied per line
   * const verticalGradient = new FillGradient(0, 0, 0, 1)
   *     .addColorStop(0, 0xff0000)
   *     .addColorStop(1, 0x0000ff);
   *
   * const text = new Text({
   *     text: 'Line 1\nLine 2',
   *     style: { fill: verticalGradient }
   * });
   *
   * To manage the gradient in a global scope, set the textureSpace property of the FillGradient to 'global'.
   * @type {string|number|FillStyle|FillGradient|FillPattern}
   */
  get fill() {
    return this._originalFill;
  }
  set fill(t) {
    t !== this._originalFill && (this._originalFill = t, this._isFillStyle(t) && (this._originalFill = this._createProxy({ ...Si.defaultFillStyle, ...t }, () => {
      this._fill = ks(
        { ...this._originalFill },
        Si.defaultFillStyle
      );
    })), this._fill = ks(
      t === 0 ? "black" : t,
      Si.defaultFillStyle
    ), this.update());
  }
  /** A fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00'. */
  get stroke() {
    return this._originalStroke;
  }
  set stroke(t) {
    t !== this._originalStroke && (this._originalStroke = t, this._isFillStyle(t) && (this._originalStroke = this._createProxy({ ...Si.defaultStrokeStyle, ...t }, () => {
      this._stroke = ah(
        { ...this._originalStroke },
        Si.defaultStrokeStyle
      );
    })), this._stroke = ah(t, Si.defaultStrokeStyle), this.update());
  }
  update() {
    this._tick++, this.emit("update", this);
  }
  /** Resets all properties to the default values */
  reset() {
    const t = Ua.defaultTextStyle;
    for (const e in t)
      this[e] = t[e];
  }
  /**
   * Returns a unique key for this instance.
   * This key is used for caching.
   * @returns {string} Unique key for the instance
   */
  get styleKey() {
    return `${this.uid}-${this._tick}`;
  }
  /**
   * Creates a new TextStyle object with the same values as this one.
   * @returns New cloned TextStyle object
   */
  clone() {
    return new Ua({
      align: this.align,
      breakWords: this.breakWords,
      dropShadow: this._dropShadow ? { ...this._dropShadow } : null,
      fill: this._fill,
      fontFamily: this.fontFamily,
      fontSize: this.fontSize,
      fontStyle: this.fontStyle,
      fontVariant: this.fontVariant,
      fontWeight: this.fontWeight,
      leading: this.leading,
      letterSpacing: this.letterSpacing,
      lineHeight: this.lineHeight,
      padding: this.padding,
      stroke: this._stroke,
      textBaseline: this.textBaseline,
      whiteSpace: this.whiteSpace,
      wordWrap: this.wordWrap,
      wordWrapWidth: this.wordWrapWidth,
      filters: this._filters ? [...this._filters] : void 0
    });
  }
  /**
   * Returns the final padding for the text style, taking into account any filters applied.
   * Used internally for correct measurements
   * @internal
   * @returns {number} The final padding for the text style.
   */
  _getFinalPadding() {
    let t = 0;
    if (this._filters)
      for (let e = 0; e < this._filters.length; e++)
        t += this._filters[e].padding;
    return Math.max(this._padding, t);
  }
  /**
   * Destroys this text style.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @example
   * // Destroy the text style and its textures
   * textStyle.destroy({ texture: true, textureSource: true });
   * textStyle.destroy(true);
   */
  destroy(t = !1) {
    if (this.removeAllListeners(), typeof t == "boolean" ? t : t?.texture) {
      const i = typeof t == "boolean" ? t : t?.textureSource;
      this._fill?.texture && this._fill.texture.destroy(i), this._originalFill?.texture && this._originalFill.texture.destroy(i), this._stroke?.texture && this._stroke.texture.destroy(i), this._originalStroke?.texture && this._originalStroke.texture.destroy(i);
    }
    this._fill = null, this._stroke = null, this.dropShadow = null, this._originalStroke = null, this._originalFill = null;
  }
  _createProxy(t, e) {
    return new Proxy(t, {
      set: (i, s, o) => (i[s] = o, e?.(s, o), this.update(), !0)
    });
  }
  _isFillStyle(t) {
    return (t ?? null) !== null && !(Pe.isColorLike(t) || t instanceof vr || t instanceof Th);
  }
};
bg.defaultDropShadow = {
  alpha: 1,
  angle: Math.PI / 6,
  blur: 0,
  color: "black",
  distance: 5
};
bg.defaultTextStyle = {
  align: "left",
  breakWords: !1,
  dropShadow: null,
  fill: "black",
  fontFamily: "Arial",
  fontSize: 26,
  fontStyle: "normal",
  fontVariant: "normal",
  fontWeight: "normal",
  leading: 0,
  letterSpacing: 0,
  lineHeight: 0,
  padding: 0,
  stroke: null,
  textBaseline: "alphabetic",
  trim: !1,
  whiteSpace: "pre",
  wordWrap: !1,
  wordWrapWidth: 100
};
let qa = bg;
function cB(n) {
  const t = n;
  if (typeof t.dropShadow == "boolean" && t.dropShadow) {
    const e = qa.defaultDropShadow;
    n.dropShadow = {
      alpha: t.dropShadowAlpha ?? e.alpha,
      angle: t.dropShadowAngle ?? e.angle,
      blur: t.dropShadowBlur ?? e.blur,
      color: t.dropShadowColor ?? e.color,
      distance: t.dropShadowDistance ?? e.distance
    };
  }
  if (t.strokeThickness !== void 0) {
    zt(ae, "strokeThickness is now a part of stroke");
    const e = t.stroke;
    let i = {};
    if (Pe.isColorLike(e))
      i.color = e;
    else if (e instanceof vr || e instanceof Th)
      i.fill = e;
    else if (Object.hasOwnProperty.call(e, "color") || Object.hasOwnProperty.call(e, "fill"))
      i = e;
    else
      throw new Error("Invalid stroke value.");
    n.stroke = {
      ...i,
      width: t.strokeThickness
    };
  }
  if (Array.isArray(t.fillGradientStops)) {
    if (zt(ae, "gradient fill is now a fill pattern: `new FillGradient(...)`"), !Array.isArray(t.fill) || t.fill.length === 0)
      throw new Error("Invalid fill value. Expected an array of colors for gradient fill.");
    t.fill.length !== t.fillGradientStops.length && $t("The number of fill colors must match the number of fill gradient stops.");
    const e = new vr({
      start: { x: 0, y: 0 },
      end: { x: 0, y: 1 },
      textureSpace: "local"
    }), i = t.fillGradientStops.slice(), s = t.fill.map((o) => Pe.shared.setValue(o).toNumber());
    i.forEach((o, l) => {
      e.addColorStop(o, s[l]);
    }), n.fill = {
      fill: e
    };
  }
}
class hB {
  constructor(t) {
    this._canvasPool = /* @__PURE__ */ Object.create(null), this.canvasOptions = t || {}, this.enableFullScreen = !1;
  }
  /**
   * Creates texture with params that were specified in pool constructor.
   * @param pixelWidth - Width of texture in pixels.
   * @param pixelHeight - Height of texture in pixels.
   */
  _createCanvasAndContext(t, e) {
    const i = ve.get().createCanvas();
    i.width = t, i.height = e;
    const s = i.getContext("2d");
    return { canvas: i, context: s };
  }
  /**
   * Gets a Power-of-Two render texture or fullScreen texture
   * @param minWidth - The minimum width of the render texture.
   * @param minHeight - The minimum height of the render texture.
   * @param resolution - The resolution of the render texture.
   * @returns The new render texture.
   */
  getOptimalCanvasAndContext(t, e, i = 1) {
    t = Math.ceil(t * i - 1e-6), e = Math.ceil(e * i - 1e-6), t = Wa(t), e = Wa(e);
    const s = (t << 17) + (e << 1);
    this._canvasPool[s] || (this._canvasPool[s] = []);
    let o = this._canvasPool[s].pop();
    return o || (o = this._createCanvasAndContext(t, e)), o;
  }
  /**
   * Place a render texture back into the pool.
   * @param canvasAndContext
   */
  returnCanvasAndContext(t) {
    const e = t.canvas, { width: i, height: s } = e, o = (i << 17) + (s << 1);
    t.context.resetTransform(), t.context.clearRect(0, 0, i, s), this._canvasPool[o].push(t);
  }
  clear() {
    this._canvasPool = {};
  }
}
const xr = new hB();
to.register(xr);
const y0 = 1e5;
function oh(n, t, e, i = 0) {
  if (n.texture === Tt.WHITE && !n.fill)
    return Pe.shared.setValue(n.color).setAlpha(n.alpha ?? 1).toHexa();
  if (n.fill) {
    if (n.fill instanceof Th) {
      const s = n.fill, o = t.createPattern(s.texture.source.resource, "repeat"), l = s.transform.copyTo(bt.shared);
      return l.scale(
        s.texture.frame.width,
        s.texture.frame.height
      ), o.setTransform(l), o;
    } else if (n.fill instanceof vr) {
      const s = n.fill, o = s.type === "linear", l = s.textureSpace === "local";
      let c = 1, d = 1;
      l && e && (c = e.width + i, d = e.height + i);
      let f, m = !1;
      if (o) {
        const { start: y, end: b } = s;
        f = t.createLinearGradient(
          y.x * c,
          y.y * d,
          b.x * c,
          b.y * d
        ), m = Math.abs(b.x - y.x) < Math.abs((b.y - y.y) * 0.1);
      } else {
        const { center: y, innerRadius: b, outerCenter: v, outerRadius: x } = s;
        f = t.createRadialGradient(
          y.x * c,
          y.y * d,
          b * c,
          v.x * c,
          v.y * d,
          x * c
        );
      }
      if (m && l && e) {
        const y = e.lineHeight / d;
        for (let b = 0; b < e.lines.length; b++) {
          const v = (b * e.lineHeight + i / 2) / d;
          s.colorStops.forEach((x) => {
            const S = v + x.offset * y;
            f.addColorStop(
              // fix to 5 decimal places to avoid floating point precision issues
              Math.floor(S * y0) / y0,
              Pe.shared.setValue(x.color).toHex()
            );
          });
        }
      } else
        s.colorStops.forEach((y) => {
          f.addColorStop(y.offset, Pe.shared.setValue(y.color).toHex());
        });
      return f;
    }
  } else {
    const s = t.createPattern(n.texture.source.resource, "repeat"), o = n.matrix.copyTo(bt.shared);
    return o.scale(n.texture.frame.width, n.texture.frame.height), s.setTransform(o), s;
  }
  return $t("FillStyle not recognised", n), "red";
}
const fT = class pT extends CR {
  /**
   * @param options - The options for the dynamic bitmap font.
   */
  constructor(t) {
    super(), this.resolution = 1, this.pages = [], this._padding = 0, this._measureCache = /* @__PURE__ */ Object.create(null), this._currentChars = [], this._currentX = 0, this._currentY = 0, this._currentMaxCharHeight = 0, this._currentPageIndex = -1, this._skipKerning = !1;
    const e = { ...pT.defaultOptions, ...t };
    this._textureSize = e.textureSize, this._mipmap = e.mipmap;
    const i = e.style.clone();
    e.overrideFill && (i._fill.color = 16777215, i._fill.alpha = 1, i._fill.texture = Tt.WHITE, i._fill.fill = null), this.applyFillAsTint = e.overrideFill;
    const s = i.fontSize;
    i.fontSize = this.baseMeasurementFontSize;
    const o = rh(i);
    e.overrideSize ? i._stroke && (i._stroke.width *= this.baseRenderedFontSize / s) : i.fontSize = this.baseRenderedFontSize = s, this._style = i, this._skipKerning = e.skipKerning ?? !1, this.resolution = e.resolution ?? 1, this._padding = e.padding ?? 4, e.textureStyle && (this._textureStyle = e.textureStyle instanceof Qr ? e.textureStyle : new Qr(e.textureStyle)), this.fontMetrics = Li.measureFont(o), this.lineHeight = i.lineHeight || this.fontMetrics.fontSize || i.fontSize;
  }
  ensureCharacters(t) {
    const e = Li.graphemeSegmenter(t).filter((_) => !this._currentChars.includes(_)).filter((_, C, R) => R.indexOf(_) === C);
    if (!e.length)
      return;
    this._currentChars = [...this._currentChars, ...e];
    let i;
    this._currentPageIndex === -1 ? i = this._nextPage() : i = this.pages[this._currentPageIndex];
    let { canvas: s, context: o } = i.canvasAndContext, l = i.texture.source;
    const c = this._style;
    let d = this._currentX, f = this._currentY, m = this._currentMaxCharHeight;
    const y = this.baseRenderedFontSize / this.baseMeasurementFontSize, b = this._padding * y;
    let v = !1;
    const x = s.width / this.resolution, S = s.height / this.resolution;
    for (let _ = 0; _ < e.length; _++) {
      const C = e[_], R = Li.measureText(C, c, s, !1);
      R.lineHeight = R.height;
      const w = R.width * y, E = Math.ceil((c.fontStyle === "italic" ? 2 : 1) * w), P = R.height * y, k = E + b * 2, G = P + b * 2;
      if (v = !1, C !== `
` && C !== "\r" && C !== "	" && C !== " " && (v = !0, m = Math.ceil(Math.max(G, m))), d + k > x && (f += m, m = G, d = 0, f + m > S)) {
        l.update();
        const F = this._nextPage();
        s = F.canvasAndContext.canvas, o = F.canvasAndContext.context, l = F.texture.source, d = 0, f = 0, m = 0;
      }
      const $ = w / y - (c.dropShadow?.distance ?? 0) - (c._stroke?.width ?? 0);
      if (this.chars[C] = {
        id: C.codePointAt(0),
        xOffset: -this._padding,
        yOffset: -this._padding,
        xAdvance: $,
        kerning: {}
      }, v) {
        this._drawGlyph(
          o,
          R,
          d + b,
          f + b,
          y,
          c
        );
        const F = l.width * y, j = l.height * y, H = new ne(
          d / F * l.width,
          f / j * l.height,
          k / F * l.width,
          G / j * l.height
        );
        this.chars[C].texture = new Tt({
          source: l,
          frame: H
        }), d += Math.ceil(k);
      }
    }
    l.update(), this._currentX = d, this._currentY = f, this._currentMaxCharHeight = m, this._skipKerning && this._applyKerning(e, o);
  }
  /**
   * @deprecated since 8.0.0
   * The map of base page textures (i.e., sheets of glyphs).
   */
  get pageTextures() {
    return zt(ae, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."), this.pages;
  }
  _applyKerning(t, e) {
    const i = this._measureCache;
    for (let s = 0; s < t.length; s++) {
      const o = t[s];
      for (let l = 0; l < this._currentChars.length; l++) {
        const c = this._currentChars[l];
        let d = i[o];
        d || (d = i[o] = e.measureText(o).width);
        let f = i[c];
        f || (f = i[c] = e.measureText(c).width);
        let m = e.measureText(o + c).width, y = m - (d + f);
        y && (this.chars[o].kerning[c] = y), m = e.measureText(o + c).width, y = m - (d + f), y && (this.chars[c].kerning[o] = y);
      }
    }
  }
  _nextPage() {
    this._currentPageIndex++;
    const t = this.resolution, e = xr.getOptimalCanvasAndContext(
      this._textureSize,
      this._textureSize,
      t
    );
    this._setupContext(e.context, this._style, t);
    const i = t * (this.baseRenderedFontSize / this.baseMeasurementFontSize), s = new Tt({
      source: new Gl({
        resource: e.canvas,
        resolution: i,
        alphaMode: "premultiply-alpha-on-upload",
        autoGenerateMipmaps: this._mipmap
      })
    });
    this._textureStyle && (s.source.style = this._textureStyle);
    const o = {
      canvasAndContext: e,
      texture: s
    };
    return this.pages[this._currentPageIndex] = o, o;
  }
  // canvas style!
  _setupContext(t, e, i) {
    e.fontSize = this.baseRenderedFontSize, t.scale(i, i), t.font = rh(e), e.fontSize = this.baseMeasurementFontSize, t.textBaseline = e.textBaseline;
    const s = e._stroke, o = s?.width ?? 0;
    if (s && (t.lineWidth = o, t.lineJoin = s.join, t.miterLimit = s.miterLimit, t.strokeStyle = oh(s, t)), e._fill && (t.fillStyle = oh(e._fill, t)), e.dropShadow) {
      const l = e.dropShadow, c = Pe.shared.setValue(l.color).toArray(), d = l.blur * i, f = l.distance * i;
      t.shadowColor = `rgba(${c[0] * 255},${c[1] * 255},${c[2] * 255},${l.alpha})`, t.shadowBlur = d, t.shadowOffsetX = Math.cos(l.angle) * f, t.shadowOffsetY = Math.sin(l.angle) * f;
    } else
      t.shadowColor = "black", t.shadowBlur = 0, t.shadowOffsetX = 0, t.shadowOffsetY = 0;
  }
  _drawGlyph(t, e, i, s, o, l) {
    const c = e.text, d = e.fontProperties, m = (l._stroke?.width ?? 0) * o, y = i + m / 2, b = s - m / 2, v = d.descent * o, x = e.lineHeight * o;
    let S = !1;
    l.stroke && m && (S = !0, t.strokeText(c, y, b + x - v));
    const { shadowBlur: _, shadowOffsetX: C, shadowOffsetY: R } = t;
    l._fill && (S && (t.shadowBlur = 0, t.shadowOffsetX = 0, t.shadowOffsetY = 0), t.fillText(c, y, b + x - v)), S && (t.shadowBlur = _, t.shadowOffsetX = C, t.shadowOffsetY = R);
  }
  destroy() {
    super.destroy();
    for (let t = 0; t < this.pages.length; t++) {
      const { canvasAndContext: e, texture: i } = this.pages[t];
      xr.returnCanvasAndContext(e), i.destroy(!0);
    }
    this.pages = null;
  }
};
fT.defaultOptions = {
  textureSize: 512,
  style: new qa(),
  mipmap: !0
};
let b0 = fT;
function mT(n, t, e, i) {
  const s = {
    width: 0,
    height: 0,
    offsetY: 0,
    scale: t.fontSize / e.baseMeasurementFontSize,
    lines: [{
      width: 0,
      charPositions: [],
      spaceWidth: 0,
      spacesIndex: [],
      chars: []
    }]
  };
  s.offsetY = e.baseLineOffset;
  let o = s.lines[0], l = null, c = !0;
  const d = {
    width: 0,
    start: 0,
    index: 0,
    // use index to not modify the array as we use it a lot!
    positions: [],
    chars: []
  }, f = e.baseMeasurementFontSize / t.fontSize, m = t.letterSpacing * f, y = t.wordWrapWidth * f, b = t.lineHeight ? t.lineHeight * f : e.lineHeight, v = t.wordWrap && t.breakWords, x = (C) => {
    const R = o.width;
    for (let w = 0; w < d.index; w++) {
      const E = C.positions[w];
      o.chars.push(C.chars[w]), o.charPositions.push(E + R);
    }
    o.width += C.width, c = !1, d.width = 0, d.index = 0, d.chars.length = 0;
  }, S = () => {
    let C = o.chars.length - 1;
    if (i) {
      let R = o.chars[C];
      for (; R === " "; )
        o.width -= e.chars[R].xAdvance, R = o.chars[--C];
    }
    s.width = Math.max(s.width, o.width), o = {
      width: 0,
      charPositions: [],
      chars: [],
      spaceWidth: 0,
      spacesIndex: []
    }, c = !0, s.lines.push(o), s.height += b;
  }, _ = (C) => C - m > y;
  for (let C = 0; C < n.length + 1; C++) {
    let R;
    const w = C === n.length;
    w || (R = n[C]);
    const E = e.chars[R] || e.chars[" "];
    if (/(?:\s)/.test(R) || R === "\r" || R === `
` || w) {
      if (!c && t.wordWrap && _(o.width + d.width) ? (S(), x(d), w || o.charPositions.push(0)) : (d.start = o.width, x(d), w || o.charPositions.push(0)), R === "\r" || R === `
`)
        S();
      else if (!w) {
        const $ = E.xAdvance + (E.kerning[l] || 0) + m;
        o.width += $, o.spaceWidth = $, o.spacesIndex.push(o.charPositions.length), o.chars.push(R);
      }
    } else {
      const G = E.kerning[l] || 0, $ = E.xAdvance + G + m;
      v && _(o.width + d.width + $) && (x(d), S()), d.positions[d.index++] = d.width + G, d.chars.push(R), d.width += $;
    }
    l = R;
  }
  return S(), t.align === "center" ? dB(s) : t.align === "right" ? fB(s) : t.align === "justify" && pB(s), s;
}
function dB(n) {
  for (let t = 0; t < n.lines.length; t++) {
    const e = n.lines[t], i = n.width / 2 - e.width / 2;
    for (let s = 0; s < e.charPositions.length; s++)
      e.charPositions[s] += i;
  }
}
function fB(n) {
  for (let t = 0; t < n.lines.length; t++) {
    const e = n.lines[t], i = n.width - e.width;
    for (let s = 0; s < e.charPositions.length; s++)
      e.charPositions[s] += i;
  }
}
function pB(n) {
  const t = n.width;
  for (let e = 0; e < n.lines.length; e++) {
    const i = n.lines[e];
    let s = 0, o = i.spacesIndex[s++], l = 0;
    const c = i.spacesIndex.length, f = (t - i.width) / c;
    for (let m = 0; m < i.charPositions.length; m++)
      m === o && (o = i.spacesIndex[s++], l += f), i.charPositions[m] += l;
  }
}
function mB(n) {
  if (n === "")
    return [];
  typeof n == "string" && (n = [n]);
  const t = [];
  for (let e = 0, i = n.length; e < i; e++) {
    const s = n[e];
    if (Array.isArray(s)) {
      if (s.length !== 2)
        throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${s.length}.`);
      if (s[0].length === 0 || s[1].length === 0)
        throw new Error("[BitmapFont]: Invalid character delimiter.");
      const o = s[0].charCodeAt(0), l = s[1].charCodeAt(0);
      if (l < o)
        throw new Error("[BitmapFont]: Invalid character range.");
      for (let c = o, d = l; c <= d; c++)
        t.push(String.fromCharCode(c));
    } else
      t.push(...Array.from(s));
  }
  if (t.length === 0)
    throw new Error("[BitmapFont]: Empty set when resolving characters.");
  return t;
}
let kc = 0;
class gB {
  constructor() {
    this.ALPHA = [["a", "z"], ["A", "Z"], " "], this.NUMERIC = [["0", "9"]], this.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "], this.ASCII = [[" ", "~"]], this.defaultOptions = {
      chars: this.ALPHANUMERIC,
      resolution: 1,
      padding: 4,
      skipKerning: !1,
      textureStyle: null
    }, this.measureCache = K1(1e3);
  }
  /**
   * Get a font for the specified text and style.
   * @param text - The text to get the font for
   * @param style - The style to use
   */
  getFont(t, e) {
    let i = `${e.fontFamily}-bitmap`, s = !0;
    if (e._fill.fill && !e._stroke ? (i += e._fill.fill.styleKey, s = !1) : (e._stroke || e.dropShadow) && (i = `${e.styleKey}-bitmap`, s = !1), !Sn.has(i)) {
      const l = Object.create(e);
      l.lineHeight = 0;
      const c = new b0({
        style: l,
        overrideFill: s,
        overrideSize: !0,
        ...this.defaultOptions
      });
      kc++, kc > 50 && $t("BitmapText", `You have dynamically created ${kc} bitmap fonts, this can be inefficient. Try pre installing your font styles using \`BitmapFont.install({name:"style1", style})\``), c.once("destroy", () => {
        kc--, Sn.remove(i);
      }), Sn.set(
        i,
        c
      );
    }
    const o = Sn.get(i);
    return o.ensureCharacters?.(t), o;
  }
  /**
   * Get the layout of a text for the specified style.
   * @param text - The text to get the layout for
   * @param style - The style to use
   * @param trimEnd - Whether to ignore whitespaces at the end of each line
   */
  getLayout(t, e, i = !0) {
    const s = this.getFont(t, e), o = `${t}-${e.styleKey}-${i}`;
    if (this.measureCache.has(o))
      return this.measureCache.get(o);
    const l = Li.graphemeSegmenter(t), c = mT(l, e, s, i);
    return this.measureCache.set(o, c), c;
  }
  /**
   * Measure the text using the specified style.
   * @param text - The text to measure
   * @param style - The style to use
   * @param trimEnd - Whether to ignore whitespaces at the end of each line
   */
  measureText(t, e, i = !0) {
    return this.getLayout(t, e, i);
  }
  // eslint-disable-next-line max-len
  install(...t) {
    let e = t[0];
    typeof e == "string" && (e = {
      name: e,
      style: t[1],
      chars: t[2]?.chars,
      resolution: t[2]?.resolution,
      padding: t[2]?.padding,
      skipKerning: t[2]?.skipKerning
    }, zt(ae, "BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})"));
    const i = e?.name;
    if (!i)
      throw new Error("[BitmapFontManager] Property `name` is required.");
    e = { ...this.defaultOptions, ...e };
    const s = e.style, o = s instanceof qa ? s : new qa(s), l = e.dynamicFill ?? this._canUseTintForStyle(o), c = new b0({
      style: o,
      overrideFill: l,
      skipKerning: e.skipKerning,
      padding: e.padding,
      resolution: e.resolution,
      overrideSize: !1,
      textureStyle: e.textureStyle
    }), d = mB(e.chars);
    return c.ensureCharacters(d.join("")), Sn.set(`${i}-bitmap`, c), c.once("destroy", () => Sn.remove(`${i}-bitmap`)), c;
  }
  /**
   * Uninstalls a bitmap font from the cache.
   * @param {string} name - The name of the bitmap font to uninstall.
   */
  uninstall(t) {
    const e = `${t}-bitmap`, i = Sn.get(e);
    i && i.destroy();
  }
  /**
   * Determines if a style can use tinting instead of baking colors into the bitmap.
   * Tinting is more efficient as it allows reusing the same bitmap with different colors.
   * @param style - The text style to evaluate
   * @returns true if the style can use tinting, false if colors must be baked in
   * @private
   */
  _canUseTintForStyle(t) {
    return !t._stroke && (!t.dropShadow || t.dropShadow.color === 0) && !t._fill.fill && t._fill.color === 16777215;
  }
}
const yB = new gB();
class gT {
  /**
   * Constructor for the DOMPipe class.
   * @param renderer - The renderer instance that this DOMPipe will be associated with.
   */
  constructor(t) {
    this._attachedDomElements = [], this._renderer = t, this._renderer.runners.postrender.add(this), this._renderer.runners.init.add(this), this._domElement = document.createElement("div"), this._domElement.style.position = "absolute", this._domElement.style.top = "0", this._domElement.style.left = "0", this._domElement.style.pointerEvents = "none", this._domElement.style.zIndex = "1000";
  }
  /** Initializes the DOMPipe, setting up the main DOM element and adding it to the document body. */
  init() {
    this._canvasObserver = new M1({
      domElement: this._domElement,
      renderer: this._renderer
    });
  }
  /**
   * Adds a renderable DOM container to the list of attached elements.
   * @param domContainer - The DOM container to be added.
   * @param _instructionSet - The instruction set (unused).
   */
  addRenderable(t, e) {
    this._attachedDomElements.includes(t) || this._attachedDomElements.push(t);
  }
  /**
   * Updates a renderable DOM container.
   * @param _domContainer - The DOM container to be updated (unused).
   */
  updateRenderable(t) {
  }
  /**
   * Validates a renderable DOM container.
   * @param _domContainer - The DOM container to be validated (unused).
   * @returns Always returns true as validation is not required.
   */
  validateRenderable(t) {
    return !0;
  }
  /** Handles the post-rendering process, ensuring DOM elements are correctly positioned and visible. */
  postrender() {
    const t = this._attachedDomElements;
    if (t.length === 0) {
      this._domElement.remove();
      return;
    }
    this._canvasObserver.ensureAttached();
    for (let e = 0; e < t.length; e++) {
      const i = t[e], s = i.element;
      if (!i.parent || i.globalDisplayStatus < 7)
        s?.remove(), t.splice(e, 1), e--;
      else {
        this._domElement.contains(s) || (s.style.position = "absolute", s.style.pointerEvents = "auto", this._domElement.appendChild(s));
        const o = i.worldTransform, l = i._anchor, c = i.width * l.x, d = i.height * l.y;
        s.style.transformOrigin = `${c}px ${d}px`, s.style.transform = `matrix(${o.a}, ${o.b}, ${o.c}, ${o.d}, ${o.tx - c}, ${o.ty - d})`, s.style.opacity = i.groupAlpha.toString();
      }
    }
  }
  /** Destroys the DOMPipe, removing all attached DOM elements and cleaning up resources. */
  destroy() {
    this._renderer.runners.postrender.remove(this);
    for (let t = 0; t < this._attachedDomElements.length; t++)
      this._attachedDomElements[t].element?.remove();
    this._attachedDomElements.length = 0, this._domElement.remove(), this._canvasObserver.destroy(), this._renderer = null;
  }
}
gT.extension = {
  type: [
    W.WebGLPipes,
    W.WebGPUPipes,
    W.CanvasPipes
  ],
  name: "dom"
};
class bB {
  constructor() {
    this.interactionFrequency = 10, this._deltaTime = 0, this._didMove = !1, this._tickerAdded = !1, this._pauseUpdate = !0;
  }
  /**
   * Initializes the event ticker.
   * @param events - The event system.
   */
  init(t) {
    this.removeTickerListener(), this.events = t, this.interactionFrequency = 10, this._deltaTime = 0, this._didMove = !1, this._tickerAdded = !1, this._pauseUpdate = !0;
  }
  /** Whether to pause the update checks or not. */
  get pauseUpdate() {
    return this._pauseUpdate;
  }
  set pauseUpdate(t) {
    this._pauseUpdate = t;
  }
  /** Adds the ticker listener. */
  addTickerListener() {
    this._tickerAdded || !this.domElement || (Kn.system.add(this._tickerUpdate, this, Ya.INTERACTION), this._tickerAdded = !0);
  }
  /** Removes the ticker listener. */
  removeTickerListener() {
    this._tickerAdded && (Kn.system.remove(this._tickerUpdate, this), this._tickerAdded = !1);
  }
  /** Sets flag to not fire extra events when the user has already moved there mouse */
  pointerMoved() {
    this._didMove = !0;
  }
  /** Updates the state of interactive objects. */
  _update() {
    if (!this.domElement || this._pauseUpdate)
      return;
    if (this._didMove) {
      this._didMove = !1;
      return;
    }
    const t = this.events._rootPointerEvent;
    this.events.supportsTouchEvents && t.pointerType === "touch" || globalThis.document.dispatchEvent(this.events.supportsPointerEvents ? new PointerEvent("pointermove", {
      clientX: t.clientX,
      clientY: t.clientY,
      pointerType: t.pointerType,
      pointerId: t.pointerId
    }) : new MouseEvent("mousemove", {
      clientX: t.clientX,
      clientY: t.clientY
    }));
  }
  /**
   * Updates the state of interactive objects if at least {@link interactionFrequency}
   * milliseconds have passed since the last invocation.
   *
   * Invoked by a throttled ticker update from {@link Ticker.system}.
   * @param ticker - The throttled ticker.
   */
  _tickerUpdate(t) {
    this._deltaTime += t.deltaTime, !(this._deltaTime < this.interactionFrequency) && (this._deltaTime = 0, this._update());
  }
  /** Destroys the event ticker. */
  destroy() {
    this.removeTickerListener(), this.events = null, this.domElement = null, this._deltaTime = 0, this._didMove = !1, this._tickerAdded = !1, this._pauseUpdate = !0;
  }
}
const dr = new bB();
class lh extends Xl {
  constructor() {
    super(...arguments), this.client = new Ut(), this.movement = new Ut(), this.offset = new Ut(), this.global = new Ut(), this.screen = new Ut();
  }
  /** @readonly */
  get clientX() {
    return this.client.x;
  }
  /** @readonly */
  get clientY() {
    return this.client.y;
  }
  /**
   * Alias for {@link FederatedMouseEvent.clientX this.clientX}.
   * @readonly
   */
  get x() {
    return this.clientX;
  }
  /**
   * Alias for {@link FederatedMouseEvent.clientY this.clientY}.
   * @readonly
   */
  get y() {
    return this.clientY;
  }
  /** @readonly */
  get movementX() {
    return this.movement.x;
  }
  /** @readonly */
  get movementY() {
    return this.movement.y;
  }
  /** @readonly */
  get offsetX() {
    return this.offset.x;
  }
  /** @readonly */
  get offsetY() {
    return this.offset.y;
  }
  /** @readonly */
  get globalX() {
    return this.global.x;
  }
  /** @readonly */
  get globalY() {
    return this.global.y;
  }
  /**
   * The pointer coordinates in the renderer's screen. Alias for `screen.x`.
   * @readonly
   */
  get screenX() {
    return this.screen.x;
  }
  /**
   * The pointer coordinates in the renderer's screen. Alias for `screen.y`.
   * @readonly
   */
  get screenY() {
    return this.screen.y;
  }
  /**
   * Converts global coordinates into container-local coordinates.
   *
   * This method transforms coordinates from world space to a container's local space,
   * useful for precise positioning and hit testing.
   * @param container - The Container to get local coordinates for
   * @param point - Optional Point object to store the result. If not provided, a new Point will be created
   * @param globalPos - Optional custom global coordinates. If not provided, the event's global position is used
   * @returns The local coordinates as a Point object
   * @example
   * ```ts
   * // Basic usage - get local coordinates relative to a container
   * sprite.on('pointermove', (event: FederatedMouseEvent) => {
   *     // Get position relative to the sprite
   *     const localPos = event.getLocalPosition(sprite);
   *     console.log('Local position:', localPos.x, localPos.y);
   * });
   * // Using custom global coordinates
   * const customGlobal = new Point(100, 100);
   * sprite.on('pointermove', (event: FederatedMouseEvent) => {
   *     // Transform custom coordinates
   *     const localPos = event.getLocalPosition(sprite, undefined, customGlobal);
   *     console.log('Custom local position:', localPos.x, localPos.y);
   * });
   * ```
   * @see {@link Container.worldTransform} For the transformation matrix
   * @see {@link Point} For the point class used to store coordinates
   */
  getLocalPosition(t, e, i) {
    return t.worldTransform.applyInverse(i || this.global, e);
  }
  /**
   * Whether the modifier key was pressed when this event natively occurred.
   * @param key - The modifier key.
   */
  getModifierState(t) {
    return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(t);
  }
  /**
   * Not supported.
   * @param _typeArg
   * @param _canBubbleArg
   * @param _cancelableArg
   * @param _viewArg
   * @param _detailArg
   * @param _screenXArg
   * @param _screenYArg
   * @param _clientXArg
   * @param _clientYArg
   * @param _ctrlKeyArg
   * @param _altKeyArg
   * @param _shiftKeyArg
   * @param _metaKeyArg
   * @param _buttonArg
   * @param _relatedTargetArg
   * @deprecated since 7.0.0
   * @ignore
   */
  // eslint-disable-next-line max-params
  initMouseEvent(t, e, i, s, o, l, c, d, f, m, y, b, v, x, S) {
    throw new Error("Method not implemented.");
  }
}
class _i extends lh {
  constructor() {
    super(...arguments), this.width = 0, this.height = 0, this.isPrimary = !1;
  }
  /**
   * Only included for completeness for now
   * @ignore
   */
  getCoalescedEvents() {
    return this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove" ? [this] : [];
  }
  /**
   * Only included for completeness for now
   * @ignore
   */
  getPredictedEvents() {
    throw new Error("getPredictedEvents is not supported!");
  }
}
class Ka extends lh {
  constructor() {
    super(...arguments), this.DOM_DELTA_PIXEL = 0, this.DOM_DELTA_LINE = 1, this.DOM_DELTA_PAGE = 2;
  }
}
Ka.DOM_DELTA_PIXEL = 0;
Ka.DOM_DELTA_LINE = 1;
Ka.DOM_DELTA_PAGE = 2;
const vB = 2048, xB = new Ut(), ul = new Ut();
class _B {
  /**
   * @param rootTarget - The holder of the event boundary.
   */
  constructor(t) {
    this.dispatch = new Jn(), this.moveOnAll = !1, this.enableGlobalMoveEvents = !0, this.mappingState = {
      trackingData: {}
    }, this.eventPool = /* @__PURE__ */ new Map(), this._allInteractiveElements = [], this._hitElements = [], this._isPointerMoveEvent = !1, this.rootTarget = t, this.hitPruneFn = this.hitPruneFn.bind(this), this.hitTestFn = this.hitTestFn.bind(this), this.mapPointerDown = this.mapPointerDown.bind(this), this.mapPointerMove = this.mapPointerMove.bind(this), this.mapPointerOut = this.mapPointerOut.bind(this), this.mapPointerOver = this.mapPointerOver.bind(this), this.mapPointerUp = this.mapPointerUp.bind(this), this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this), this.mapWheel = this.mapWheel.bind(this), this.mappingTable = {}, this.addEventMapping("pointerdown", this.mapPointerDown), this.addEventMapping("pointermove", this.mapPointerMove), this.addEventMapping("pointerout", this.mapPointerOut), this.addEventMapping("pointerleave", this.mapPointerOut), this.addEventMapping("pointerover", this.mapPointerOver), this.addEventMapping("pointerup", this.mapPointerUp), this.addEventMapping("pointerupoutside", this.mapPointerUpOutside), this.addEventMapping("wheel", this.mapWheel);
  }
  /**
   * Adds an event mapping for the event `type` handled by `fn`.
   *
   * Event mappings can be used to implement additional or custom events. They take an event
   * coming from the upstream scene (or directly from the {@link EventSystem}) and dispatch new downstream events
   * generally trickling down and bubbling up to {@link EventBoundary.rootTarget this.rootTarget}.
   *
   * To modify the semantics of existing events, the built-in mapping methods of EventBoundary should be overridden
   * instead.
   * @param type - The type of upstream event to map.
   * @param fn - The mapping method. The context of this function must be bound manually, if desired.
   */
  addEventMapping(t, e) {
    this.mappingTable[t] || (this.mappingTable[t] = []), this.mappingTable[t].push({
      fn: e,
      priority: 0
    }), this.mappingTable[t].sort((i, s) => i.priority - s.priority);
  }
  /**
   * Dispatches the given event
   * @param e - The event to dispatch.
   * @param type - The type of event to dispatch. Defaults to `e.type`.
   */
  dispatchEvent(t, e) {
    t.propagationStopped = !1, t.propagationImmediatelyStopped = !1, this.propagate(t, e), this.dispatch.emit(e || t.type, t);
  }
  /**
   * Maps the given upstream event through the event boundary and propagates it downstream.
   * @param e - The event to map.
   */
  mapEvent(t) {
    if (!this.rootTarget)
      return;
    const e = this.mappingTable[t.type];
    if (e)
      for (let i = 0, s = e.length; i < s; i++)
        e[i].fn(t);
    else
      $t(`[EventBoundary]: Event mapping not defined for ${t.type}`);
  }
  /**
   * Finds the Container that is the target of a event at the given coordinates.
   *
   * The passed (x,y) coordinates are in the world space above this event boundary.
   * @param x - The x coordinate of the event.
   * @param y - The y coordinate of the event.
   */
  hitTest(t, e) {
    dr.pauseUpdate = !0;
    const s = this._isPointerMoveEvent && this.enableGlobalMoveEvents ? "hitTestMoveRecursive" : "hitTestRecursive", o = this[s](
      this.rootTarget,
      this.rootTarget.eventMode,
      xB.set(t, e),
      this.hitTestFn,
      this.hitPruneFn
    );
    return o && o[0];
  }
  /**
   * Propagate the passed event from from {@link EventBoundary.rootTarget this.rootTarget} to its
   * target `e.target`.
   * @param e - The event to propagate.
   * @param type - The type of event to propagate. Defaults to `e.type`.
   */
  propagate(t, e) {
    if (!t.target)
      return;
    const i = t.composedPath();
    t.eventPhase = t.CAPTURING_PHASE;
    for (let s = 0, o = i.length - 1; s < o; s++)
      if (t.currentTarget = i[s], this.notifyTarget(t, e), t.propagationStopped || t.propagationImmediatelyStopped)
        return;
    if (t.eventPhase = t.AT_TARGET, t.currentTarget = t.target, this.notifyTarget(t, e), !(t.propagationStopped || t.propagationImmediatelyStopped)) {
      t.eventPhase = t.BUBBLING_PHASE;
      for (let s = i.length - 2; s >= 0; s--)
        if (t.currentTarget = i[s], this.notifyTarget(t, e), t.propagationStopped || t.propagationImmediatelyStopped)
          return;
    }
  }
  /**
   * Emits the event `e` to all interactive containers. The event is propagated in the bubbling phase always.
   *
   * This is used in the `globalpointermove` event.
   * @param e - The emitted event.
   * @param type - The listeners to notify.
   * @param targets - The targets to notify.
   */
  all(t, e, i = this._allInteractiveElements) {
    if (i.length === 0)
      return;
    t.eventPhase = t.BUBBLING_PHASE;
    const s = Array.isArray(e) ? e : [e];
    for (let o = i.length - 1; o >= 0; o--)
      s.forEach((l) => {
        t.currentTarget = i[o], this.notifyTarget(t, l);
      });
  }
  /**
   * Finds the propagation path from {@link EventBoundary.rootTarget rootTarget} to the passed
   * `target`. The last element in the path is `target`.
   * @param target - The target to find the propagation path to.
   */
  propagationPath(t) {
    const e = [t];
    for (let i = 0; i < vB && t !== this.rootTarget && t.parent; i++) {
      if (!t.parent)
        throw new Error("Cannot find propagation path to disconnected target");
      e.push(t.parent), t = t.parent;
    }
    return e.reverse(), e;
  }
  hitTestMoveRecursive(t, e, i, s, o, l = !1) {
    let c = !1;
    if (this._interactivePrune(t))
      return null;
    if ((t.eventMode === "dynamic" || e === "dynamic") && (dr.pauseUpdate = !1), t.interactiveChildren && t.children) {
      const m = t.children;
      for (let y = m.length - 1; y >= 0; y--) {
        const b = m[y], v = this.hitTestMoveRecursive(
          b,
          this._isInteractive(e) ? e : b.eventMode,
          i,
          s,
          o,
          l || o(t, i)
        );
        if (v) {
          if (v.length > 0 && !v[v.length - 1].parent)
            continue;
          const x = t.isInteractive();
          (v.length > 0 || x) && (x && this._allInteractiveElements.push(t), v.push(t)), this._hitElements.length === 0 && (this._hitElements = v), c = !0;
        }
      }
    }
    const d = this._isInteractive(e), f = t.isInteractive();
    return f && f && this._allInteractiveElements.push(t), l || this._hitElements.length > 0 ? null : c ? this._hitElements : d && !o(t, i) && s(t, i) ? f ? [t] : [] : null;
  }
  /**
   * Recursive implementation for {@link EventBoundary.hitTest hitTest}.
   * @param currentTarget - The Container that is to be hit tested.
   * @param eventMode - The event mode for the `currentTarget` or one of its parents.
   * @param location - The location that is being tested for overlap.
   * @param testFn - Callback that determines whether the target passes hit testing. This callback
   *  can assume that `pruneFn` failed to prune the container.
   * @param pruneFn - Callback that determiness whether the target and all of its children
   *  cannot pass the hit test. It is used as a preliminary optimization to prune entire subtrees
   *  of the scene graph.
   * @returns An array holding the hit testing target and all its ancestors in order. The first element
   *  is the target itself and the last is {@link EventBoundary.rootTarget rootTarget}. This is the opposite
   *  order w.r.t. the propagation path. If no hit testing target is found, null is returned.
   */
  hitTestRecursive(t, e, i, s, o) {
    if (this._interactivePrune(t) || o(t, i))
      return null;
    if ((t.eventMode === "dynamic" || e === "dynamic") && (dr.pauseUpdate = !1), t.interactiveChildren && t.children) {
      const d = t.children, f = i;
      for (let m = d.length - 1; m >= 0; m--) {
        const y = d[m], b = this.hitTestRecursive(
          y,
          this._isInteractive(e) ? e : y.eventMode,
          f,
          s,
          o
        );
        if (b) {
          if (b.length > 0 && !b[b.length - 1].parent)
            continue;
          const v = t.isInteractive();
          return (b.length > 0 || v) && b.push(t), b;
        }
      }
    }
    const l = this._isInteractive(e), c = t.isInteractive();
    return l && s(t, i) ? c ? [t] : [] : null;
  }
  _isInteractive(t) {
    return t === "static" || t === "dynamic";
  }
  _interactivePrune(t) {
    return !t || !t.visible || !t.renderable || !t.measurable || t.eventMode === "none" || t.eventMode === "passive" && !t.interactiveChildren;
  }
  /**
   * Checks whether the container or any of its children cannot pass the hit test at all.
   *
   * {@link EventBoundary}'s implementation uses the {@link Container.hitArea hitArea}
   * and {@link Container._maskEffect} for pruning.
   * @param container - The container to prune.
   * @param location - The location to test for overlap.
   */
  hitPruneFn(t, e) {
    if (t.hitArea && (t.worldTransform.applyInverse(e, ul), !t.hitArea.contains(ul.x, ul.y)))
      return !0;
    if (t.effects && t.effects.length)
      for (let i = 0; i < t.effects.length; i++) {
        const s = t.effects[i];
        if (s.containsPoint && !s.containsPoint(e, this.hitTestFn))
          return !0;
      }
    return !1;
  }
  /**
   * Checks whether the container passes hit testing for the given location.
   * @param container - The container to test.
   * @param location - The location to test for overlap.
   * @returns - Whether `container` passes hit testing for `location`.
   */
  hitTestFn(t, e) {
    return t.hitArea ? !0 : t?.containsPoint ? (t.worldTransform.applyInverse(e, ul), t.containsPoint(ul)) : !1;
  }
  /**
   * Notify all the listeners to the event's `currentTarget`.
   *
   * If the `currentTarget` contains the property `on<type>`, then it is called here,
   * simulating the behavior from version 6.x and prior.
   * @param e - The event passed to the target.
   * @param type - The type of event to notify. Defaults to `e.type`.
   */
  notifyTarget(t, e) {
    if (!t.currentTarget.isInteractive())
      return;
    e ?? (e = t.type);
    const i = `on${e}`;
    t.currentTarget[i]?.(t);
    const s = t.eventPhase === t.CAPTURING_PHASE || t.eventPhase === t.AT_TARGET ? `${e}capture` : e;
    this._notifyListeners(t, s), t.eventPhase === t.AT_TARGET && this._notifyListeners(t, e);
  }
  /**
   * Maps the upstream `pointerdown` events to a downstream `pointerdown` event.
   *
   * `touchstart`, `rightdown`, `mousedown` events are also dispatched for specific pointer types.
   * @param from - The upstream `pointerdown` event.
   */
  mapPointerDown(t) {
    if (!(t instanceof _i)) {
      $t("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const e = this.createPointerEvent(t);
    if (this.dispatchEvent(e, "pointerdown"), e.pointerType === "touch")
      this.dispatchEvent(e, "touchstart");
    else if (e.pointerType === "mouse" || e.pointerType === "pen") {
      const s = e.button === 2;
      this.dispatchEvent(e, s ? "rightdown" : "mousedown");
    }
    const i = this.trackingData(t.pointerId);
    i.pressTargetsByButton[t.button] = e.composedPath(), this.freeEvent(e);
  }
  /**
   * Maps the upstream `pointermove` to downstream `pointerout`, `pointerover`, and `pointermove` events, in that order.
   *
   * The tracking data for the specific pointer has an updated `overTarget`. `mouseout`, `mouseover`,
   * `mousemove`, and `touchmove` events are fired as well for specific pointer types.
   * @param from - The upstream `pointermove` event.
   */
  mapPointerMove(t) {
    if (!(t instanceof _i)) {
      $t("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    this._allInteractiveElements.length = 0, this._hitElements.length = 0, this._isPointerMoveEvent = !0;
    const e = this.createPointerEvent(t);
    this._isPointerMoveEvent = !1;
    const i = e.pointerType === "mouse" || e.pointerType === "pen", s = this.trackingData(t.pointerId), o = this.findMountedTarget(s.overTargets);
    if (s.overTargets?.length > 0 && o !== e.target) {
      const d = t.type === "mousemove" ? "mouseout" : "pointerout", f = this.createPointerEvent(t, d, o);
      if (this.dispatchEvent(f, "pointerout"), i && this.dispatchEvent(f, "mouseout"), !e.composedPath().includes(o)) {
        const m = this.createPointerEvent(t, "pointerleave", o);
        for (m.eventPhase = m.AT_TARGET; m.target && !e.composedPath().includes(m.target); )
          m.currentTarget = m.target, this.notifyTarget(m), i && this.notifyTarget(m, "mouseleave"), m.target = m.target.parent;
        this.freeEvent(m);
      }
      this.freeEvent(f);
    }
    if (o !== e.target) {
      const d = t.type === "mousemove" ? "mouseover" : "pointerover", f = this.clonePointerEvent(e, d);
      this.dispatchEvent(f, "pointerover"), i && this.dispatchEvent(f, "mouseover");
      let m = o?.parent;
      for (; m && m !== this.rootTarget.parent && m !== e.target; )
        m = m.parent;
      if (!m || m === this.rootTarget.parent) {
        const b = this.clonePointerEvent(e, "pointerenter");
        for (b.eventPhase = b.AT_TARGET; b.target && b.target !== o && b.target !== this.rootTarget.parent; )
          b.currentTarget = b.target, this.notifyTarget(b), i && this.notifyTarget(b, "mouseenter"), b.target = b.target.parent;
        this.freeEvent(b);
      }
      this.freeEvent(f);
    }
    const l = [], c = this.enableGlobalMoveEvents ?? !0;
    this.moveOnAll ? l.push("pointermove") : this.dispatchEvent(e, "pointermove"), c && l.push("globalpointermove"), e.pointerType === "touch" && (this.moveOnAll ? l.splice(1, 0, "touchmove") : this.dispatchEvent(e, "touchmove"), c && l.push("globaltouchmove")), i && (this.moveOnAll ? l.splice(1, 0, "mousemove") : this.dispatchEvent(e, "mousemove"), c && l.push("globalmousemove"), this.cursor = e.target?.cursor), l.length > 0 && this.all(e, l), this._allInteractiveElements.length = 0, this._hitElements.length = 0, s.overTargets = e.composedPath(), this.freeEvent(e);
  }
  /**
   * Maps the upstream `pointerover` to downstream `pointerover` and `pointerenter` events, in that order.
   *
   * The tracking data for the specific pointer gets a new `overTarget`.
   * @param from - The upstream `pointerover` event.
   */
  mapPointerOver(t) {
    if (!(t instanceof _i)) {
      $t("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const e = this.trackingData(t.pointerId), i = this.createPointerEvent(t), s = i.pointerType === "mouse" || i.pointerType === "pen";
    this.dispatchEvent(i, "pointerover"), s && this.dispatchEvent(i, "mouseover"), i.pointerType === "mouse" && (this.cursor = i.target?.cursor);
    const o = this.clonePointerEvent(i, "pointerenter");
    for (o.eventPhase = o.AT_TARGET; o.target && o.target !== this.rootTarget.parent; )
      o.currentTarget = o.target, this.notifyTarget(o), s && this.notifyTarget(o, "mouseenter"), o.target = o.target.parent;
    e.overTargets = i.composedPath(), this.freeEvent(i), this.freeEvent(o);
  }
  /**
   * Maps the upstream `pointerout` to downstream `pointerout`, `pointerleave` events, in that order.
   *
   * The tracking data for the specific pointer is cleared of a `overTarget`.
   * @param from - The upstream `pointerout` event.
   */
  mapPointerOut(t) {
    if (!(t instanceof _i)) {
      $t("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const e = this.trackingData(t.pointerId);
    if (e.overTargets) {
      const i = t.pointerType === "mouse" || t.pointerType === "pen", s = this.findMountedTarget(e.overTargets), o = this.createPointerEvent(t, "pointerout", s);
      this.dispatchEvent(o), i && this.dispatchEvent(o, "mouseout");
      const l = this.createPointerEvent(t, "pointerleave", s);
      for (l.eventPhase = l.AT_TARGET; l.target && l.target !== this.rootTarget.parent; )
        l.currentTarget = l.target, this.notifyTarget(l), i && this.notifyTarget(l, "mouseleave"), l.target = l.target.parent;
      e.overTargets = null, this.freeEvent(o), this.freeEvent(l);
    }
    this.cursor = null;
  }
  /**
   * Maps the upstream `pointerup` event to downstream `pointerup`, `pointerupoutside`,
   * and `click`/`rightclick`/`pointertap` events, in that order.
   *
   * The `pointerupoutside` event bubbles from the original `pointerdown` target to the most specific
   * ancestor of the `pointerdown` and `pointerup` targets, which is also the `click` event's target. `touchend`,
   * `rightup`, `mouseup`, `touchendoutside`, `rightupoutside`, `mouseupoutside`, and `tap` are fired as well for
   * specific pointer types.
   * @param from - The upstream `pointerup` event.
   */
  mapPointerUp(t) {
    if (!(t instanceof _i)) {
      $t("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const e = performance.now(), i = this.createPointerEvent(t);
    if (this.dispatchEvent(i, "pointerup"), i.pointerType === "touch")
      this.dispatchEvent(i, "touchend");
    else if (i.pointerType === "mouse" || i.pointerType === "pen") {
      const c = i.button === 2;
      this.dispatchEvent(i, c ? "rightup" : "mouseup");
    }
    const s = this.trackingData(t.pointerId), o = this.findMountedTarget(s.pressTargetsByButton[t.button]);
    let l = o;
    if (o && !i.composedPath().includes(o)) {
      let c = o;
      for (; c && !i.composedPath().includes(c); ) {
        if (i.currentTarget = c, this.notifyTarget(i, "pointerupoutside"), i.pointerType === "touch")
          this.notifyTarget(i, "touchendoutside");
        else if (i.pointerType === "mouse" || i.pointerType === "pen") {
          const d = i.button === 2;
          this.notifyTarget(i, d ? "rightupoutside" : "mouseupoutside");
        }
        c = c.parent;
      }
      delete s.pressTargetsByButton[t.button], l = c;
    }
    if (l) {
      const c = this.clonePointerEvent(i, "click");
      c.target = l, c.path = null, s.clicksByButton[t.button] || (s.clicksByButton[t.button] = {
        clickCount: 0,
        target: c.target,
        timeStamp: e
      });
      const d = s.clicksByButton[t.button];
      if (d.target === c.target && e - d.timeStamp < 200 ? ++d.clickCount : d.clickCount = 1, d.target = c.target, d.timeStamp = e, c.detail = d.clickCount, c.pointerType === "mouse") {
        const f = c.button === 2;
        this.dispatchEvent(c, f ? "rightclick" : "click");
      } else c.pointerType === "touch" && this.dispatchEvent(c, "tap");
      this.dispatchEvent(c, "pointertap"), this.freeEvent(c);
    }
    this.freeEvent(i);
  }
  /**
   * Maps the upstream `pointerupoutside` event to a downstream `pointerupoutside` event, bubbling from the original
   * `pointerdown` target to `rootTarget`.
   *
   * (The most specific ancestor of the `pointerdown` event and the `pointerup` event must the
   * `{@link EventBoundary}'s root because the `pointerup` event occurred outside of the boundary.)
   *
   * `touchendoutside`, `mouseupoutside`, and `rightupoutside` events are fired as well for specific pointer
   * types. The tracking data for the specific pointer is cleared of a `pressTarget`.
   * @param from - The upstream `pointerupoutside` event.
   */
  mapPointerUpOutside(t) {
    if (!(t instanceof _i)) {
      $t("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const e = this.trackingData(t.pointerId), i = this.findMountedTarget(e.pressTargetsByButton[t.button]), s = this.createPointerEvent(t);
    if (i) {
      let o = i;
      for (; o; )
        s.currentTarget = o, this.notifyTarget(s, "pointerupoutside"), s.pointerType === "touch" ? this.notifyTarget(s, "touchendoutside") : (s.pointerType === "mouse" || s.pointerType === "pen") && this.notifyTarget(s, s.button === 2 ? "rightupoutside" : "mouseupoutside"), o = o.parent;
      delete e.pressTargetsByButton[t.button];
    }
    this.freeEvent(s);
  }
  /**
   * Maps the upstream `wheel` event to a downstream `wheel` event.
   * @param from - The upstream `wheel` event.
   */
  mapWheel(t) {
    if (!(t instanceof Ka)) {
      $t("EventBoundary cannot map a non-wheel event as a wheel event");
      return;
    }
    const e = this.createWheelEvent(t);
    this.dispatchEvent(e), this.freeEvent(e);
  }
  /**
   * Finds the most specific event-target in the given propagation path that is still mounted in the scene graph.
   *
   * This is used to find the correct `pointerup` and `pointerout` target in the case that the original `pointerdown`
   * or `pointerover` target was unmounted from the scene graph.
   * @param propagationPath - The propagation path was valid in the past.
   * @returns - The most specific event-target still mounted at the same location in the scene graph.
   */
  findMountedTarget(t) {
    if (!t)
      return null;
    let e = t[0];
    for (let i = 1; i < t.length && t[i].parent === e; i++)
      e = t[i];
    return e;
  }
  /**
   * Creates an event whose `originalEvent` is `from`, with an optional `type` and `target` override.
   *
   * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.
   * @param from - The `originalEvent` for the returned event.
   * @param [type=from.type] - The type of the returned event.
   * @param target - The target of the returned event.
   */
  createPointerEvent(t, e, i) {
    const s = this.allocateEvent(_i);
    return this.copyPointerData(t, s), this.copyMouseData(t, s), this.copyData(t, s), s.nativeEvent = t.nativeEvent, s.originalEvent = t, s.target = i ?? this.hitTest(s.global.x, s.global.y) ?? this._hitElements[0], typeof e == "string" && (s.type = e), s;
  }
  /**
   * Creates a wheel event whose `originalEvent` is `from`.
   *
   * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.
   * @param from - The upstream wheel event.
   */
  createWheelEvent(t) {
    const e = this.allocateEvent(Ka);
    return this.copyWheelData(t, e), this.copyMouseData(t, e), this.copyData(t, e), e.nativeEvent = t.nativeEvent, e.originalEvent = t, e.target = this.hitTest(e.global.x, e.global.y), e;
  }
  /**
   * Clones the event `from`, with an optional `type` override.
   *
   * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.
   * @param from - The event to clone.
   * @param [type=from.type] - The type of the returned event.
   */
  clonePointerEvent(t, e) {
    const i = this.allocateEvent(_i);
    return i.nativeEvent = t.nativeEvent, i.originalEvent = t.originalEvent, this.copyPointerData(t, i), this.copyMouseData(t, i), this.copyData(t, i), i.target = t.target, i.path = t.composedPath().slice(), i.type = e ?? i.type, i;
  }
  /**
   * Copies wheel {@link FederatedWheelEvent} data from `from` into `to`.
   *
   * The following properties are copied:
   * + deltaMode
   * + deltaX
   * + deltaY
   * + deltaZ
   * @param from - The event to copy data from.
   * @param to - The event to copy data into.
   */
  copyWheelData(t, e) {
    e.deltaMode = t.deltaMode, e.deltaX = t.deltaX, e.deltaY = t.deltaY, e.deltaZ = t.deltaZ;
  }
  /**
   * Copies pointer {@link FederatedPointerEvent} data from `from` into `to`.
   *
   * The following properties are copied:
   * + pointerId
   * + width
   * + height
   * + isPrimary
   * + pointerType
   * + pressure
   * + tangentialPressure
   * + tiltX
   * + tiltY
   * @param from - The event to copy data from.
   * @param to - The event to copy data into.
   */
  copyPointerData(t, e) {
    t instanceof _i && e instanceof _i && (e.pointerId = t.pointerId, e.width = t.width, e.height = t.height, e.isPrimary = t.isPrimary, e.pointerType = t.pointerType, e.pressure = t.pressure, e.tangentialPressure = t.tangentialPressure, e.tiltX = t.tiltX, e.tiltY = t.tiltY, e.twist = t.twist);
  }
  /**
   * Copies mouse {@link FederatedMouseEvent} data from `from` to `to`.
   *
   * The following properties are copied:
   * + altKey
   * + button
   * + buttons
   * + clientX
   * + clientY
   * + metaKey
   * + movementX
   * + movementY
   * + pageX
   * + pageY
   * + x
   * + y
   * + screen
   * + shiftKey
   * + global
   * @param from - The event to copy data from.
   * @param to - The event to copy data into.
   */
  copyMouseData(t, e) {
    t instanceof lh && e instanceof lh && (e.altKey = t.altKey, e.button = t.button, e.buttons = t.buttons, e.client.copyFrom(t.client), e.ctrlKey = t.ctrlKey, e.metaKey = t.metaKey, e.movement.copyFrom(t.movement), e.screen.copyFrom(t.screen), e.shiftKey = t.shiftKey, e.global.copyFrom(t.global));
  }
  /**
   * Copies base {@link FederatedEvent} data from `from` into `to`.
   *
   * The following properties are copied:
   * + isTrusted
   * + srcElement
   * + timeStamp
   * + type
   * @param from - The event to copy data from.
   * @param to - The event to copy data into.
   */
  copyData(t, e) {
    e.isTrusted = t.isTrusted, e.srcElement = t.srcElement, e.timeStamp = performance.now(), e.type = t.type, e.detail = t.detail, e.view = t.view, e.which = t.which, e.layer.copyFrom(t.layer), e.page.copyFrom(t.page);
  }
  /**
   * @param id - The pointer ID.
   * @returns The tracking data stored for the given pointer. If no data exists, a blank
   *  state will be created.
   */
  trackingData(t) {
    return this.mappingState.trackingData[t] || (this.mappingState.trackingData[t] = {
      pressTargetsByButton: {},
      clicksByButton: {},
      overTarget: null
    }), this.mappingState.trackingData[t];
  }
  /**
   * Allocate a specific type of event from {@link EventBoundary#eventPool this.eventPool}.
   *
   * This allocation is constructor-agnostic, as long as it only takes one argument - this event
   * boundary.
   * @param constructor - The event's constructor.
   * @returns An event of the given type.
   */
  allocateEvent(t) {
    this.eventPool.has(t) || this.eventPool.set(t, []);
    const e = this.eventPool.get(t).pop() || new t(this);
    return e.eventPhase = e.NONE, e.currentTarget = null, e.defaultPrevented = !1, e.path = null, e.target = null, e;
  }
  /**
   * Frees the event and puts it back into the event pool.
   *
   * It is illegal to reuse the event until it is allocated again, using `this.allocateEvent`.
   *
   * It is also advised that events not allocated from {@link EventBoundary#allocateEvent this.allocateEvent}
   * not be freed. This is because of the possibility that the same event is freed twice, which can cause
   * it to be allocated twice & result in overwriting.
   * @param event - The event to be freed.
   * @throws Error if the event is managed by another event boundary.
   */
  freeEvent(t) {
    if (t.manager !== this)
      throw new Error("It is illegal to free an event not managed by this EventBoundary!");
    const e = t.constructor;
    this.eventPool.has(e) || this.eventPool.set(e, []), this.eventPool.get(e).push(t);
  }
  /**
   * Similar to {@link EventEmitter.emit}, except it stops if the `propagationImmediatelyStopped` flag
   * is set on the event.
   * @param e - The event to call each listener with.
   * @param type - The event key.
   */
  _notifyListeners(t, e) {
    const i = t.currentTarget._events[e];
    if (i)
      if ("fn" in i)
        i.once && t.currentTarget.removeListener(e, i.fn, void 0, !0), i.fn.call(i.context, t);
      else
        for (let s = 0, o = i.length; s < o && !t.propagationImmediatelyStopped; s++)
          i[s].once && t.currentTarget.removeListener(e, i[s].fn, void 0, !0), i[s].fn.call(i[s].context, t);
  }
}
const SB = 1, TB = {
  touchstart: "pointerdown",
  touchend: "pointerup",
  touchendoutside: "pointerupoutside",
  touchmove: "pointermove",
  touchcancel: "pointercancel"
}, vg = class Em {
  /**
   * @param {Renderer} renderer
   */
  constructor(t) {
    this.supportsTouchEvents = "ontouchstart" in globalThis, this.supportsPointerEvents = !!globalThis.PointerEvent, this.domElement = null, this.resolution = 1, this.renderer = t, this.rootBoundary = new _B(null), dr.init(this), this.autoPreventDefault = !0, this._eventsAdded = !1, this._rootPointerEvent = new _i(null), this._rootWheelEvent = new Ka(null), this.cursorStyles = {
      default: "inherit",
      pointer: "pointer"
    }, this.features = new Proxy({ ...Em.defaultEventFeatures }, {
      set: (e, i, s) => (i === "globalMove" && (this.rootBoundary.enableGlobalMoveEvents = s), e[i] = s, !0)
    }), this._onPointerDown = this._onPointerDown.bind(this), this._onPointerMove = this._onPointerMove.bind(this), this._onPointerUp = this._onPointerUp.bind(this), this._onPointerOverOut = this._onPointerOverOut.bind(this), this.onWheel = this.onWheel.bind(this);
  }
  /**
   * The default interaction mode for all display objects.
   * @see Container.eventMode
   * @type {EventMode}
   * @readonly
   * @since 7.2.0
   */
  static get defaultEventMode() {
    return this._defaultEventMode;
  }
  /**
   * Runner init called, view is available at this point.
   * @ignore
   */
  init(t) {
    const { canvas: e, resolution: i } = this.renderer;
    this.setTargetElement(e), this.resolution = i, Em._defaultEventMode = t.eventMode ?? "passive", Object.assign(this.features, t.eventFeatures ?? {}), this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove;
  }
  /**
   * Handle changing resolution.
   * @ignore
   */
  resolutionChange(t) {
    this.resolution = t;
  }
  /** Destroys all event listeners and detaches the renderer. */
  destroy() {
    dr.destroy(), this.setTargetElement(null), this.renderer = null, this._currentCursor = null;
  }
  /**
   * Sets the current cursor mode, handling any callbacks or CSS style changes.
   * The cursor can be a CSS cursor string, a custom callback function, or a key from the cursorStyles dictionary.
   * @param mode - Cursor mode to set. Can be:
   * - A CSS cursor string (e.g., 'pointer', 'grab')
   * - A key from the cursorStyles dictionary
   * - null/undefined to reset to default
   * @example
   * ```ts
   * // Using predefined cursor styles
   * app.renderer.events.setCursor('pointer');    // Set standard pointer cursor
   * app.renderer.events.setCursor('grab');       // Set grab cursor
   * app.renderer.events.setCursor(null);         // Reset to default
   *
   * // Using custom cursor styles
   * app.renderer.events.cursorStyles.custom = 'url("cursor.png"), auto';
   * app.renderer.events.setCursor('custom');     // Apply custom cursor
   *
   * // Using callback-based cursor
   * app.renderer.events.cursorStyles.dynamic = (mode) => {
   *     document.body.style.cursor = mode === 'hover' ? 'pointer' : 'default';
   * };
   * app.renderer.events.setCursor('dynamic');    // Trigger cursor callback
   * ```
   * @remarks
   * - Has no effect on OffscreenCanvas except for callback-based cursors
   * - Caches current cursor to avoid unnecessary DOM updates
   * - Supports CSS cursor values, style objects, and callback functions
   * @see {@link EventSystem.cursorStyles} For defining custom cursor styles
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/cursor} MDN Cursor Reference
   */
  setCursor(t) {
    t || (t = "default");
    let e = !0;
    if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas && (e = !1), this._currentCursor === t)
      return;
    this._currentCursor = t;
    const i = this.cursorStyles[t];
    if (i)
      switch (typeof i) {
        case "string":
          e && (this.domElement.style.cursor = i);
          break;
        case "function":
          i(t);
          break;
        case "object":
          e && Object.assign(this.domElement.style, i);
          break;
      }
    else e && typeof t == "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, t) && (this.domElement.style.cursor = t);
  }
  /**
   * The global pointer event instance containing the most recent pointer state.
   * This is useful for accessing pointer information without listening to events.
   * @example
   * ```ts
   * // Access current pointer position at any time
   * const eventSystem = app.renderer.events;
   * const pointer = eventSystem.pointer;
   *
   * // Get global coordinates
   * console.log('Position:', pointer.global.x, pointer.global.y);
   *
   * // Check button state
   * console.log('Buttons pressed:', pointer.buttons);
   *
   * // Get pointer type and pressure
   * console.log('Type:', pointer.pointerType);
   * console.log('Pressure:', pointer.pressure);
   * ```
   * @readonly
   * @since 7.2.0
   * @see {@link FederatedPointerEvent} For all available pointer properties
   */
  get pointer() {
    return this._rootPointerEvent;
  }
  /**
   * Event handler for pointer down events on {@link EventSystem#domElement this.domElement}.
   * @param nativeEvent - The native mouse/pointer/touch event.
   */
  _onPointerDown(t) {
    if (!this.features.click)
      return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    const e = this._normalizeToPointerData(t);
    this.autoPreventDefault && e[0].isNormalized && (t.cancelable || !("cancelable" in t)) && t.preventDefault();
    for (let i = 0, s = e.length; i < s; i++) {
      const o = e[i], l = this._bootstrapEvent(this._rootPointerEvent, o);
      this.rootBoundary.mapEvent(l);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  /**
   * Event handler for pointer move events on on {@link EventSystem#domElement this.domElement}.
   * @param nativeEvent - The native mouse/pointer/touch events.
   */
  _onPointerMove(t) {
    if (!this.features.move)
      return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, dr.pointerMoved();
    const e = this._normalizeToPointerData(t);
    for (let i = 0, s = e.length; i < s; i++) {
      const o = this._bootstrapEvent(this._rootPointerEvent, e[i]);
      this.rootBoundary.mapEvent(o);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  /**
   * Event handler for pointer up events on {@link EventSystem#domElement this.domElement}.
   * @param nativeEvent - The native mouse/pointer/touch event.
   */
  _onPointerUp(t) {
    if (!this.features.click)
      return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    let e = t.target;
    t.composedPath && t.composedPath().length > 0 && (e = t.composedPath()[0]);
    const i = e !== this.domElement ? "outside" : "", s = this._normalizeToPointerData(t);
    for (let o = 0, l = s.length; o < l; o++) {
      const c = this._bootstrapEvent(this._rootPointerEvent, s[o]);
      c.type += i, this.rootBoundary.mapEvent(c);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  /**
   * Event handler for pointer over & out events on {@link EventSystem#domElement this.domElement}.
   * @param nativeEvent - The native mouse/pointer/touch event.
   */
  _onPointerOverOut(t) {
    if (!this.features.click)
      return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    const e = this._normalizeToPointerData(t);
    for (let i = 0, s = e.length; i < s; i++) {
      const o = this._bootstrapEvent(this._rootPointerEvent, e[i]);
      this.rootBoundary.mapEvent(o);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  /**
   * Passive handler for `wheel` events on {@link EventSystem.domElement this.domElement}.
   * @param nativeEvent - The native wheel event.
   */
  onWheel(t) {
    if (!this.features.wheel)
      return;
    const e = this.normalizeWheelEvent(t);
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, this.rootBoundary.mapEvent(e);
  }
  /**
   * Sets the {@link EventSystem#domElement domElement} and binds event listeners.
   * This method manages the DOM event bindings for the event system, allowing you to
   * change or remove the target element that receives input events.
   * > [!IMPORTANT] This will default to the canvas element of the renderer, so you
   * > should not need to call this unless you are using a custom element.
   * @param element - The new DOM element to bind events to, or null to remove all event bindings
   * @example
   * ```ts
   * // Set a new canvas element as the target
   * const canvas = document.createElement('canvas');
   * app.renderer.events.setTargetElement(canvas);
   *
   * // Remove all event bindings
   * app.renderer.events.setTargetElement(null);
   *
   * // Switch to a different canvas
   * const newCanvas = document.querySelector('#game-canvas');
   * app.renderer.events.setTargetElement(newCanvas);
   * ```
   * @remarks
   * - Automatically removes event listeners from previous element
   * - Required for the event system to function
   * - Safe to call multiple times
   * @see {@link EventSystem#domElement} The current DOM element
   * @see {@link EventsTicker} For the ticker system that tracks pointer movement
   */
  setTargetElement(t) {
    this._removeEvents(), this.domElement = t, dr.domElement = t, this._addEvents();
  }
  /** Register event listeners on {@link Renderer#domElement this.domElement}. */
  _addEvents() {
    if (this._eventsAdded || !this.domElement)
      return;
    dr.addTickerListener();
    const t = this.domElement.style;
    t && (globalThis.navigator.msPointerEnabled ? (t.msContentZooming = "none", t.msTouchAction = "none") : this.supportsPointerEvents && (t.touchAction = "none")), this.supportsPointerEvents ? (globalThis.document.addEventListener("pointermove", this._onPointerMove, !0), this.domElement.addEventListener("pointerdown", this._onPointerDown, !0), this.domElement.addEventListener("pointerleave", this._onPointerOverOut, !0), this.domElement.addEventListener("pointerover", this._onPointerOverOut, !0), globalThis.addEventListener("pointerup", this._onPointerUp, !0)) : (globalThis.document.addEventListener("mousemove", this._onPointerMove, !0), this.domElement.addEventListener("mousedown", this._onPointerDown, !0), this.domElement.addEventListener("mouseout", this._onPointerOverOut, !0), this.domElement.addEventListener("mouseover", this._onPointerOverOut, !0), globalThis.addEventListener("mouseup", this._onPointerUp, !0), this.supportsTouchEvents && (this.domElement.addEventListener("touchstart", this._onPointerDown, !0), this.domElement.addEventListener("touchend", this._onPointerUp, !0), this.domElement.addEventListener("touchmove", this._onPointerMove, !0))), this.domElement.addEventListener("wheel", this.onWheel, {
      passive: !0,
      capture: !0
    }), this._eventsAdded = !0;
  }
  /** Unregister event listeners on {@link EventSystem#domElement this.domElement}. */
  _removeEvents() {
    if (!this._eventsAdded || !this.domElement)
      return;
    dr.removeTickerListener();
    const t = this.domElement.style;
    t && (globalThis.navigator.msPointerEnabled ? (t.msContentZooming = "", t.msTouchAction = "") : this.supportsPointerEvents && (t.touchAction = "")), this.supportsPointerEvents ? (globalThis.document.removeEventListener("pointermove", this._onPointerMove, !0), this.domElement.removeEventListener("pointerdown", this._onPointerDown, !0), this.domElement.removeEventListener("pointerleave", this._onPointerOverOut, !0), this.domElement.removeEventListener("pointerover", this._onPointerOverOut, !0), globalThis.removeEventListener("pointerup", this._onPointerUp, !0)) : (globalThis.document.removeEventListener("mousemove", this._onPointerMove, !0), this.domElement.removeEventListener("mousedown", this._onPointerDown, !0), this.domElement.removeEventListener("mouseout", this._onPointerOverOut, !0), this.domElement.removeEventListener("mouseover", this._onPointerOverOut, !0), globalThis.removeEventListener("mouseup", this._onPointerUp, !0), this.supportsTouchEvents && (this.domElement.removeEventListener("touchstart", this._onPointerDown, !0), this.domElement.removeEventListener("touchend", this._onPointerUp, !0), this.domElement.removeEventListener("touchmove", this._onPointerMove, !0))), this.domElement.removeEventListener("wheel", this.onWheel, !0), this.domElement = null, this._eventsAdded = !1;
  }
  /**
   * Maps coordinates from DOM/screen space into PixiJS normalized coordinates.
   * This takes into account the current scale, position, and resolution of the DOM element.
   * @param point - The point to store the mapped coordinates in
   * @param x - The x coordinate in DOM/client space
   * @param y - The y coordinate in DOM/client space
   * @example
   * ```ts
   * // Map mouse coordinates to PixiJS space
   * const point = new Point();
   * app.renderer.events.mapPositionToPoint(
   *     point,
   *     event.clientX,
   *     event.clientY
   * );
   * console.log('Mapped position:', point.x, point.y);
   *
   * // Using with pointer events
   * sprite.on('pointermove', (event) => {
   *     // event.global already contains mapped coordinates
   *     console.log('Global:', event.global.x, event.global.y);
   *
   *     // Map to local coordinates
   *     const local = event.getLocalPosition(sprite);
   *     console.log('Local:', local.x, local.y);
   * });
   * ```
   * @remarks
   * - Accounts for element scaling and positioning
   * - Adjusts for device pixel ratio/resolution
   */
  mapPositionToPoint(t, e, i) {
    const s = this.domElement.isConnected ? this.domElement.getBoundingClientRect() : {
      width: this.domElement.width,
      height: this.domElement.height,
      left: 0,
      top: 0
    }, o = 1 / this.resolution;
    t.x = (e - s.left) * (this.domElement.width / s.width) * o, t.y = (i - s.top) * (this.domElement.height / s.height) * o;
  }
  /**
   * Ensures that the original event object contains all data that a regular pointer event would have
   * @param event - The original event data from a touch or mouse event
   * @returns An array containing a single normalized pointer event, in the case of a pointer
   *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches
   */
  _normalizeToPointerData(t) {
    const e = [];
    if (this.supportsTouchEvents && t instanceof TouchEvent)
      for (let i = 0, s = t.changedTouches.length; i < s; i++) {
        const o = t.changedTouches[i];
        typeof o.button > "u" && (o.button = 0), typeof o.buttons > "u" && (o.buttons = 1), typeof o.isPrimary > "u" && (o.isPrimary = t.touches.length === 1 && t.type === "touchstart"), typeof o.width > "u" && (o.width = o.radiusX || 1), typeof o.height > "u" && (o.height = o.radiusY || 1), typeof o.tiltX > "u" && (o.tiltX = 0), typeof o.tiltY > "u" && (o.tiltY = 0), typeof o.pointerType > "u" && (o.pointerType = "touch"), typeof o.pointerId > "u" && (o.pointerId = o.identifier || 0), typeof o.pressure > "u" && (o.pressure = o.force || 0.5), typeof o.twist > "u" && (o.twist = 0), typeof o.tangentialPressure > "u" && (o.tangentialPressure = 0), typeof o.layerX > "u" && (o.layerX = o.offsetX = o.clientX), typeof o.layerY > "u" && (o.layerY = o.offsetY = o.clientY), o.isNormalized = !0, o.type = t.type, e.push(o);
      }
    else if (!globalThis.MouseEvent || t instanceof MouseEvent && (!this.supportsPointerEvents || !(t instanceof globalThis.PointerEvent))) {
      const i = t;
      typeof i.isPrimary > "u" && (i.isPrimary = !0), typeof i.width > "u" && (i.width = 1), typeof i.height > "u" && (i.height = 1), typeof i.tiltX > "u" && (i.tiltX = 0), typeof i.tiltY > "u" && (i.tiltY = 0), typeof i.pointerType > "u" && (i.pointerType = "mouse"), typeof i.pointerId > "u" && (i.pointerId = SB), typeof i.pressure > "u" && (i.pressure = 0.5), typeof i.twist > "u" && (i.twist = 0), typeof i.tangentialPressure > "u" && (i.tangentialPressure = 0), i.isNormalized = !0, e.push(i);
    } else
      e.push(t);
    return e;
  }
  /**
   * Normalizes the native {@link https://w3c.github.io/uievents/#interface-wheelevent WheelEvent}.
   *
   * The returned {@link FederatedWheelEvent} is a shared instance. It will not persist across
   * multiple native wheel events.
   * @param nativeEvent - The native wheel event that occurred on the canvas.
   * @returns A federated wheel event.
   */
  normalizeWheelEvent(t) {
    const e = this._rootWheelEvent;
    return this._transferMouseData(e, t), e.deltaX = t.deltaX, e.deltaY = t.deltaY, e.deltaZ = t.deltaZ, e.deltaMode = t.deltaMode, this.mapPositionToPoint(e.screen, t.clientX, t.clientY), e.global.copyFrom(e.screen), e.offset.copyFrom(e.screen), e.nativeEvent = t, e.type = t.type, e;
  }
  /**
   * Normalizes the `nativeEvent` into a federateed {@link FederatedPointerEvent}.
   * @param event
   * @param nativeEvent
   */
  _bootstrapEvent(t, e) {
    return t.originalEvent = null, t.nativeEvent = e, t.pointerId = e.pointerId, t.width = e.width, t.height = e.height, t.isPrimary = e.isPrimary, t.pointerType = e.pointerType, t.pressure = e.pressure, t.tangentialPressure = e.tangentialPressure, t.tiltX = e.tiltX, t.tiltY = e.tiltY, t.twist = e.twist, this._transferMouseData(t, e), this.mapPositionToPoint(t.screen, e.clientX, e.clientY), t.global.copyFrom(t.screen), t.offset.copyFrom(t.screen), t.isTrusted = e.isTrusted, t.type === "pointerleave" && (t.type = "pointerout"), t.type.startsWith("mouse") && (t.type = t.type.replace("mouse", "pointer")), t.type.startsWith("touch") && (t.type = TB[t.type] || t.type), t;
  }
  /**
   * Transfers base & mouse event data from the `nativeEvent` to the federated event.
   * @param event
   * @param nativeEvent
   */
  _transferMouseData(t, e) {
    t.isTrusted = e.isTrusted, t.srcElement = e.srcElement, t.timeStamp = performance.now(), t.type = e.type, t.altKey = e.altKey, t.button = e.button, t.buttons = e.buttons, t.client.x = e.clientX, t.client.y = e.clientY, t.ctrlKey = e.ctrlKey, t.metaKey = e.metaKey, t.movement.x = e.movementX, t.movement.y = e.movementY, t.page.x = e.pageX, t.page.y = e.pageY, t.relatedTarget = null, t.shiftKey = e.shiftKey;
  }
};
vg.extension = {
  name: "events",
  type: [
    W.WebGLSystem,
    W.CanvasSystem,
    W.WebGPUSystem
  ],
  priority: -1
};
vg.defaultEventFeatures = {
  /** Enables pointer events associated with pointer movement. */
  move: !0,
  /** Enables global pointer move events. */
  globalMove: !0,
  /** Enables pointer events associated with clicking. */
  click: !0,
  /** Enables wheel events. */
  wheel: !0
};
let yT = vg;
const wB = {
  onclick: null,
  onmousedown: null,
  onmouseenter: null,
  onmouseleave: null,
  onmousemove: null,
  onglobalmousemove: null,
  onmouseout: null,
  onmouseover: null,
  onmouseup: null,
  onmouseupoutside: null,
  onpointercancel: null,
  onpointerdown: null,
  onpointerenter: null,
  onpointerleave: null,
  onpointermove: null,
  onglobalpointermove: null,
  onpointerout: null,
  onpointerover: null,
  onpointertap: null,
  onpointerup: null,
  onpointerupoutside: null,
  onrightclick: null,
  onrightdown: null,
  onrightup: null,
  onrightupoutside: null,
  ontap: null,
  ontouchcancel: null,
  ontouchend: null,
  ontouchendoutside: null,
  ontouchmove: null,
  onglobaltouchmove: null,
  ontouchstart: null,
  onwheel: null,
  get interactive() {
    return this.eventMode === "dynamic" || this.eventMode === "static";
  },
  set interactive(n) {
    this.eventMode = n ? "static" : "passive";
  },
  _internalEventMode: void 0,
  get eventMode() {
    return this._internalEventMode ?? yT.defaultEventMode;
  },
  set eventMode(n) {
    this._internalEventMode = n;
  },
  isInteractive() {
    return this.eventMode === "static" || this.eventMode === "dynamic";
  },
  interactiveChildren: !0,
  hitArea: null,
  addEventListener(n, t, e) {
    const i = typeof e == "boolean" && e || typeof e == "object" && e.capture, s = typeof e == "object" ? e.signal : void 0, o = typeof e == "object" ? e.once === !0 : !1, l = typeof t == "function" ? void 0 : t;
    n = i ? `${n}capture` : n;
    const c = typeof t == "function" ? t : t.handleEvent, d = this;
    s && s.addEventListener("abort", () => {
      d.off(n, c, l);
    }), o ? d.once(n, c, l) : d.on(n, c, l);
  },
  removeEventListener(n, t, e) {
    const i = typeof e == "boolean" && e || typeof e == "object" && e.capture, s = typeof t == "function" ? void 0 : t;
    n = i ? `${n}capture` : n, t = typeof t == "function" ? t : t.handleEvent, this.off(n, t, s);
  },
  dispatchEvent(n) {
    if (!(n instanceof Xl))
      throw new Error("Container cannot propagate events outside of the Federated Events API");
    return n.defaultPrevented = !1, n.path = null, n.target = this, n.manager.dispatchEvent(n), !n.defaultPrevented;
  }
};
class bT {
  constructor(t) {
    this._renderer = t;
  }
  push(t, e, i) {
    this._renderer.renderPipes.batch.break(i), i.add({
      renderPipeId: "filter",
      canBundle: !1,
      action: "pushFilter",
      container: e,
      filterEffect: t
    });
  }
  pop(t, e, i) {
    this._renderer.renderPipes.batch.break(i), i.add({
      renderPipeId: "filter",
      action: "popFilter",
      canBundle: !1
    });
  }
  execute(t) {
    t.action === "pushFilter" ? this._renderer.filter.push(t) : t.action === "popFilter" && this._renderer.filter.pop();
  }
  destroy() {
    this._renderer = null;
  }
}
bT.extension = {
  type: [
    W.WebGLPipes,
    W.WebGPUPipes,
    W.CanvasPipes
  ],
  name: "filter"
};
const v0 = new bt();
function CB(n, t) {
  t.clear();
  const e = t.matrix;
  for (let i = 0; i < n.length; i++) {
    const s = n[i];
    if (s.globalDisplayStatus < 7)
      continue;
    const o = s.renderGroup ?? s.parentRenderGroup;
    o?.isCachedAsTexture ? t.matrix = v0.copyFrom(o.textureOffsetInverseTransform).append(s.worldTransform) : o?._parentCacheAsTextureRenderGroup ? t.matrix = v0.copyFrom(o._parentCacheAsTextureRenderGroup.inverseWorldTransform).append(s.groupTransform) : t.matrix = s.worldTransform, t.addBounds(s.bounds);
  }
  return t.matrix = e, t;
}
const EB = new ql({
  attributes: {
    aPosition: {
      buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
      format: "float32x2",
      stride: 8,
      offset: 0
    }
  },
  indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3])
});
class MB {
  constructor() {
    this.skip = !1, this.inputTexture = null, this.backTexture = null, this.filters = null, this.bounds = new Cn(), this.container = null, this.blendRequired = !1, this.outputRenderSurface = null, this.globalFrame = { x: 0, y: 0, width: 0, height: 0 };
  }
}
class vT {
  constructor(t) {
    this._filterStackIndex = 0, this._filterStack = [], this._filterGlobalUniforms = new Pn({
      uInputSize: { value: new Float32Array(4), type: "vec4<f32>" },
      uInputPixel: { value: new Float32Array(4), type: "vec4<f32>" },
      uInputClamp: { value: new Float32Array(4), type: "vec4<f32>" },
      uOutputFrame: { value: new Float32Array(4), type: "vec4<f32>" },
      uGlobalFrame: { value: new Float32Array(4), type: "vec4<f32>" },
      uOutputTexture: { value: new Float32Array(4), type: "vec4<f32>" }
    }), this._globalFilterBindGroup = new yr({}), this.renderer = t;
  }
  /**
   * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.
   * @readonly
   */
  get activeBackTexture() {
    return this._activeFilterData?.backTexture;
  }
  /**
   * Pushes a filter instruction onto the filter stack.
   * @param instruction - The instruction containing the filter effect and container.
   * @internal
   */
  push(t) {
    const e = this.renderer, i = t.filterEffect.filters, s = this._pushFilterData();
    s.skip = !1, s.filters = i, s.container = t.container, s.outputRenderSurface = e.renderTarget.renderSurface;
    const o = e.renderTarget.renderTarget.colorTexture.source, l = o.resolution, c = o.antialias;
    if (i.length === 0) {
      s.skip = !0;
      return;
    }
    const d = s.bounds;
    if (this._calculateFilterArea(t, d), this._calculateFilterBounds(s, e.renderTarget.rootViewPort, c, l, 1), s.skip)
      return;
    const f = this._getPreviousFilterData(), m = this._findFilterResolution(l);
    let y = 0, b = 0;
    f && (y = f.bounds.minX, b = f.bounds.minY), this._calculateGlobalFrame(
      s,
      y,
      b,
      m,
      o.width,
      o.height
    ), this._setupFilterTextures(s, d, e, f);
  }
  /**
   * Applies filters to a texture.
   *
   * This method takes a texture and a list of filters, applies the filters to the texture,
   * and returns the resulting texture.
   * @param {object} params - The parameters for applying filters.
   * @param {Texture} params.texture - The texture to apply filters to.
   * @param {Filter[]} params.filters - The filters to apply.
   * @returns {Texture} The resulting texture after all filters have been applied.
   * @example
   *
   * ```ts
   * // Create a texture and a list of filters
   * const texture = new Texture(...);
   * const filters = [new BlurFilter(), new ColorMatrixFilter()];
   *
   * // Apply the filters to the texture
   * const resultTexture = filterSystem.applyToTexture({ texture, filters });
   *
   * // Use the resulting texture
   * sprite.texture = resultTexture;
   * ```
   *
   * Key Points:
   * 1. padding is not currently supported here - so clipping may occur with filters that use padding.
   * 2. If all filters are disabled or skipped, the original texture is returned.
   */
  generateFilteredTexture({ texture: t, filters: e }) {
    const i = this._pushFilterData();
    this._activeFilterData = i, i.skip = !1, i.filters = e;
    const s = t.source, o = s.resolution, l = s.antialias;
    if (e.length === 0)
      return i.skip = !0, t;
    const c = i.bounds;
    if (c.addRect(t.frame), this._calculateFilterBounds(i, c.rectangle, l, o, 0), i.skip)
      return t;
    const d = o;
    this._calculateGlobalFrame(
      i,
      0,
      0,
      d,
      s.width,
      s.height
    ), i.outputRenderSurface = mn.getOptimalTexture(
      c.width,
      c.height,
      i.resolution,
      i.antialias
    ), i.backTexture = Tt.EMPTY, i.inputTexture = t, this.renderer.renderTarget.finishRenderPass(), this._applyFiltersToTexture(i, !0);
    const b = i.outputRenderSurface;
    return b.source.alphaMode = "premultiplied-alpha", b;
  }
  /** @internal */
  pop() {
    const t = this.renderer, e = this._popFilterData();
    e.skip || (t.globalUniforms.pop(), t.renderTarget.finishRenderPass(), this._activeFilterData = e, this._applyFiltersToTexture(e, !1), e.blendRequired && mn.returnTexture(e.backTexture), mn.returnTexture(e.inputTexture));
  }
  /**
   * Copies the last render surface to a texture.
   * @param lastRenderSurface - The last render surface to copy from.
   * @param bounds - The bounds of the area to copy.
   * @param previousBounds - The previous bounds to use for offsetting the copy.
   */
  getBackTexture(t, e, i) {
    const s = t.colorTexture.source._resolution, o = mn.getOptimalTexture(
      e.width,
      e.height,
      s,
      !1
    );
    let l = e.minX, c = e.minY;
    i && (l -= i.minX, c -= i.minY), l = Math.floor(l * s), c = Math.floor(c * s);
    const d = Math.ceil(e.width * s), f = Math.ceil(e.height * s);
    return this.renderer.renderTarget.copyToTexture(
      t,
      o,
      { x: l, y: c },
      { width: d, height: f },
      { x: 0, y: 0 }
    ), o;
  }
  /**
   * Applies a filter to a texture.
   * @param filter - The filter to apply.
   * @param input - The input texture.
   * @param output - The output render surface.
   * @param clear - Whether to clear the output surface before applying the filter.
   */
  applyFilter(t, e, i, s) {
    const o = this.renderer, l = this._activeFilterData, d = l.outputRenderSurface === i, f = o.renderTarget.rootRenderTarget.colorTexture.source._resolution, m = this._findFilterResolution(f);
    let y = 0, b = 0;
    if (d) {
      const v = this._findPreviousFilterOffset();
      y = v.x, b = v.y;
    }
    this._updateFilterUniforms(e, i, l, y, b, m, d, s), this._setupBindGroupsAndRender(t, e, o);
  }
  /**
   * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.
   *
   * Use `outputMatrix * vTextureCoord` in the shader.
   * @param outputMatrix - The matrix to output to.
   * @param {Sprite} sprite - The sprite to map to.
   * @returns The mapped matrix.
   */
  calculateSpriteMatrix(t, e) {
    const i = this._activeFilterData, s = t.set(
      i.inputTexture._source.width,
      0,
      0,
      i.inputTexture._source.height,
      i.bounds.minX,
      i.bounds.minY
    ), o = e.worldTransform.copyTo(bt.shared), l = e.renderGroup || e.parentRenderGroup;
    return l && l.cacheToLocalTransform && o.prepend(l.cacheToLocalTransform), o.invert(), s.prepend(o), s.scale(
      1 / e.texture.orig.width,
      1 / e.texture.orig.height
    ), s.translate(e.anchor.x, e.anchor.y), s;
  }
  destroy() {
  }
  /**
   * Sets up the bind groups and renders the filter.
   * @param filter - The filter to apply
   * @param input - The input texture
   * @param renderer - The renderer instance
   */
  _setupBindGroupsAndRender(t, e, i) {
    if (i.renderPipes.uniformBatch) {
      const s = i.renderPipes.uniformBatch.getUboResource(this._filterGlobalUniforms);
      this._globalFilterBindGroup.setResource(s, 0);
    } else
      this._globalFilterBindGroup.setResource(this._filterGlobalUniforms, 0);
    this._globalFilterBindGroup.setResource(e.source, 1), this._globalFilterBindGroup.setResource(e.source.style, 2), t.groups[0] = this._globalFilterBindGroup, i.encoder.draw({
      geometry: EB,
      shader: t,
      state: t._state,
      topology: "triangle-list"
    }), i.type === Ti.WEBGL && i.renderTarget.finishRenderPass();
  }
  /**
   * Sets up the filter textures including input texture and back texture if needed.
   * @param filterData - The filter data to update
   * @param bounds - The bounds for the texture
   * @param renderer - The renderer instance
   * @param previousFilterData - The previous filter data for back texture calculation
   */
  _setupFilterTextures(t, e, i, s) {
    if (t.backTexture = Tt.EMPTY, t.inputTexture = mn.getOptimalTexture(
      e.width,
      e.height,
      t.resolution,
      t.antialias
    ), t.blendRequired) {
      i.renderTarget.finishRenderPass();
      const o = i.renderTarget.getRenderTarget(t.outputRenderSurface);
      t.backTexture = this.getBackTexture(o, e, s?.bounds);
    }
    i.renderTarget.bind(t.inputTexture, !0), i.globalUniforms.push({
      offset: e
    });
  }
  /**
   * Calculates and sets the global frame for the filter.
   * @param filterData - The filter data to update
   * @param offsetX - The X offset
   * @param offsetY - The Y offset
   * @param globalResolution - The global resolution
   * @param sourceWidth - The source texture width
   * @param sourceHeight - The source texture height
   */
  _calculateGlobalFrame(t, e, i, s, o, l) {
    const c = t.globalFrame;
    c.x = e * s, c.y = i * s, c.width = o * s, c.height = l * s;
  }
  /**
   * Updates the filter uniforms with the current filter state.
   * @param input - The input texture
   * @param output - The output render surface
   * @param filterData - The current filter data
   * @param offsetX - The X offset for positioning
   * @param offsetY - The Y offset for positioning
   * @param resolution - The current resolution
   * @param isFinalTarget - Whether this is the final render target
   * @param clear - Whether to clear the output surface
   */
  _updateFilterUniforms(t, e, i, s, o, l, c, d) {
    const f = this._filterGlobalUniforms.uniforms, m = f.uOutputFrame, y = f.uInputSize, b = f.uInputPixel, v = f.uInputClamp, x = f.uGlobalFrame, S = f.uOutputTexture;
    c ? (m[0] = i.bounds.minX - s, m[1] = i.bounds.minY - o) : (m[0] = 0, m[1] = 0), m[2] = t.frame.width, m[3] = t.frame.height, y[0] = t.source.width, y[1] = t.source.height, y[2] = 1 / y[0], y[3] = 1 / y[1], b[0] = t.source.pixelWidth, b[1] = t.source.pixelHeight, b[2] = 1 / b[0], b[3] = 1 / b[1], v[0] = 0.5 * b[2], v[1] = 0.5 * b[3], v[2] = t.frame.width * y[2] - 0.5 * b[2], v[3] = t.frame.height * y[3] - 0.5 * b[3];
    const _ = this.renderer.renderTarget.rootRenderTarget.colorTexture;
    x[0] = s * l, x[1] = o * l, x[2] = _.source.width * l, x[3] = _.source.height * l, e instanceof Tt && (e.source.resource = null);
    const C = this.renderer.renderTarget.getRenderTarget(e);
    this.renderer.renderTarget.bind(e, !!d), e instanceof Tt ? (S[0] = e.frame.width, S[1] = e.frame.height) : (S[0] = C.width, S[1] = C.height), S[2] = C.isRoot ? -1 : 1, this._filterGlobalUniforms.update();
  }
  /**
   * Finds the correct resolution by looking back through the filter stack.
   * @param rootResolution - The fallback root resolution to use
   * @returns The resolution from the previous filter or root resolution
   */
  _findFilterResolution(t) {
    let e = this._filterStackIndex - 1;
    for (; e > 0 && this._filterStack[e].skip; )
      --e;
    return e > 0 && this._filterStack[e].inputTexture ? this._filterStack[e].inputTexture.source._resolution : t;
  }
  /**
   * Finds the offset from the previous non-skipped filter in the stack.
   * @returns The offset coordinates from the previous filter
   */
  _findPreviousFilterOffset() {
    let t = 0, e = 0, i = this._filterStackIndex;
    for (; i > 0; ) {
      i--;
      const s = this._filterStack[i];
      if (!s.skip) {
        t = s.bounds.minX, e = s.bounds.minY;
        break;
      }
    }
    return { x: t, y: e };
  }
  /**
   * Calculates the filter area bounds based on the instruction type.
   * @param instruction - The filter instruction
   * @param bounds - The bounds object to populate
   */
  _calculateFilterArea(t, e) {
    if (t.renderables ? CB(t.renderables, e) : t.filterEffect.filterArea ? (e.clear(), e.addRect(t.filterEffect.filterArea), e.applyMatrix(t.container.worldTransform)) : t.container.getFastGlobalBounds(!0, e), t.container) {
      const s = (t.container.renderGroup || t.container.parentRenderGroup).cacheToLocalTransform;
      s && e.applyMatrix(s);
    }
  }
  _applyFiltersToTexture(t, e) {
    const i = t.inputTexture, s = t.bounds, o = t.filters;
    if (this._globalFilterBindGroup.setResource(i.source.style, 2), this._globalFilterBindGroup.setResource(t.backTexture.source, 3), o.length === 1)
      o[0].apply(this, i, t.outputRenderSurface, e);
    else {
      let l = t.inputTexture;
      const c = mn.getOptimalTexture(
        s.width,
        s.height,
        l.source._resolution,
        !1
      );
      let d = c, f = 0;
      for (f = 0; f < o.length - 1; ++f) {
        o[f].apply(this, l, d, !0);
        const y = l;
        l = d, d = y;
      }
      o[f].apply(this, l, t.outputRenderSurface, e), mn.returnTexture(c);
    }
  }
  _calculateFilterBounds(t, e, i, s, o) {
    const l = this.renderer, c = t.bounds, d = t.filters;
    let f = 1 / 0, m = 0, y = !0, b = !1, v = !1, x = !0;
    for (let S = 0; S < d.length; S++) {
      const _ = d[S];
      if (f = Math.min(f, _.resolution === "inherit" ? s : _.resolution), m += _.padding, _.antialias === "off" ? y = !1 : _.antialias === "inherit" && y && (y = i), _.clipToViewport || (x = !1), !!!(_.compatibleRenderers & l.type)) {
        v = !1;
        break;
      }
      if (_.blendRequired && !(l.backBuffer?.useBackBuffer ?? !0)) {
        $t("Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options."), v = !1;
        break;
      }
      v = _.enabled || v, b || (b = _.blendRequired);
    }
    if (!v) {
      t.skip = !0;
      return;
    }
    if (x && c.fitBounds(0, e.width / s, 0, e.height / s), c.scale(f).ceil().scale(1 / f).pad((m | 0) * o), !c.isPositive) {
      t.skip = !0;
      return;
    }
    t.antialias = y, t.resolution = f, t.blendRequired = b;
  }
  _popFilterData() {
    return this._filterStackIndex--, this._filterStack[this._filterStackIndex];
  }
  _getPreviousFilterData() {
    let t, e = this._filterStackIndex - 1;
    for (; e > 0 && (e--, t = this._filterStack[e], !!t.skip); )
      ;
    return t;
  }
  _pushFilterData() {
    let t = this._filterStack[this._filterStackIndex];
    return t || (t = this._filterStack[this._filterStackIndex] = new MB()), this._filterStackIndex++, t;
  }
}
vT.extension = {
  type: [
    W.WebGLSystem,
    W.WebGPUSystem
  ],
  name: "filter"
};
var AB = `in vec2 vMaskCoord;
in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform sampler2D uMaskTexture;

uniform float uAlpha;
uniform vec4 uMaskClamp;
uniform float uInverse;

out vec4 finalColor;

void main(void)
{
    float clip = step(3.5,
        step(uMaskClamp.x, vMaskCoord.x) +
        step(uMaskClamp.y, vMaskCoord.y) +
        step(vMaskCoord.x, uMaskClamp.z) +
        step(vMaskCoord.y, uMaskClamp.w));

    // TODO look into why this is needed
    float npmAlpha = uAlpha;
    vec4 original = texture(uTexture, vTextureCoord);
    vec4 masky = texture(uMaskTexture, vMaskCoord);
    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);

    float a = alphaMul * masky.r * npmAlpha * clip;

    if (uInverse == 1.0) {
        a = 1.0 - a;
    }

    finalColor = original * a;
}
`, RB = `in vec2 aPosition;

out vec2 vTextureCoord;
out vec2 vMaskCoord;


uniform vec4 uInputSize;
uniform vec4 uOutputFrame;
uniform vec4 uOutputTexture;
uniform mat3 uFilterMatrix;

vec4 filterVertexPosition(  vec2 aPosition )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
       
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord(  vec2 aPosition )
{
    return aPosition * (uOutputFrame.zw * uInputSize.zw);
}

vec2 getFilterCoord( vec2 aPosition )
{
    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}   

void main(void)
{
    gl_Position = filterVertexPosition(aPosition);
    vTextureCoord = filterTextureCoord(aPosition);
    vMaskCoord = getFilterCoord(aPosition);
}
`, x0 = `struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct MaskUniforms {
  uFilterMatrix:mat3x3<f32>,
  uMaskClamp:vec4<f32>,
  uAlpha:f32,
  uInverse:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;

@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;
@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
    @location(1) filterUv : vec2<f32>,
};

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);
}

fn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>
{
  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}

fn getSize() -> vec2<f32>
{
  return gfu.uGlobalFrame.zw;
}

@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>,
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition),
   getFilterCoord(aPosition)
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @location(1) filterUv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {

    var maskClamp = filterUniforms.uMaskClamp;
    var uAlpha = filterUniforms.uAlpha;

    var clip = step(3.5,
      step(maskClamp.x, filterUv.x) +
      step(maskClamp.y, filterUv.y) +
      step(filterUv.x, maskClamp.z) +
      step(filterUv.y, maskClamp.w));

    var mask = textureSample(uMaskTexture, uSampler, filterUv);
    var source = textureSample(uTexture, uSampler, uv);
    var alphaMul = 1.0 - uAlpha * (1.0 - mask.a);

    var a: f32 = alphaMul * mask.r * uAlpha * clip;

    if (filterUniforms.uInverse == 1.0) {
        a = 1.0 - a;
    }

    return source * a;
}
`;
class PB extends nR {
  constructor(t) {
    const { sprite: e, ...i } = t, s = new e1(e.texture), o = new Pn({
      uFilterMatrix: { value: new bt(), type: "mat3x3<f32>" },
      uMaskClamp: { value: s.uClampFrame, type: "vec4<f32>" },
      uAlpha: { value: 1, type: "f32" },
      uInverse: { value: t.inverse ? 1 : 0, type: "f32" }
    }), l = Ns.from({
      vertex: {
        source: x0,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: x0,
        entryPoint: "mainFragment"
      }
    }), c = eo.from({
      vertex: RB,
      fragment: AB,
      name: "mask-filter"
    });
    super({
      ...i,
      gpuProgram: l,
      glProgram: c,
      clipToViewport: !1,
      resources: {
        filterUniforms: o,
        uMaskTexture: e.texture.source
      }
    }), this.sprite = e, this._textureMatrix = s;
  }
  set inverse(t) {
    this.resources.filterUniforms.uniforms.uInverse = t ? 1 : 0;
  }
  get inverse() {
    return this.resources.filterUniforms.uniforms.uInverse === 1;
  }
  apply(t, e, i, s) {
    this._textureMatrix.texture = this.sprite.texture, t.calculateSpriteMatrix(
      this.resources.filterUniforms.uniforms.uFilterMatrix,
      this.sprite
    ).prepend(this._textureMatrix.mapCoord), this.resources.uMaskTexture = this.sprite.texture.source, t.applyFilter(this, e, i, s);
  }
}
class $l extends d1 {
  /**
   * Creates a new Graphics object.
   * @param options - Options for the Graphics.
   */
  constructor(t) {
    t instanceof Si && (t = { context: t });
    const { context: e, roundPixels: i, ...s } = t || {};
    super({
      label: "Graphics",
      ...s
    }), this.renderPipeId = "graphics", e ? this._context = e : this._context = this._ownedContext = new Si(), this._context.on("update", this.onViewUpdate, this), this.didViewUpdate = !0, this.allowChildren = !1, this.roundPixels = i ?? !1;
  }
  set context(t) {
    t !== this._context && (this._context.off("update", this.onViewUpdate, this), this._context = t, this._context.on("update", this.onViewUpdate, this), this.onViewUpdate());
  }
  /**
   * The underlying graphics context used for drawing operations.
   * Controls how shapes and paths are rendered.
   * @example
   * ```ts
   * // Create a shared context
   * const sharedContext = new GraphicsContext();
   *
   * // Create graphics objects sharing the same context
   * const graphics1 = new Graphics();
   * const graphics2 = new Graphics();
   *
   * // Assign shared context
   * graphics1.context = sharedContext;
   * graphics2.context = sharedContext;
   *
   * // Both graphics will show the same shapes
   * sharedContext
   *     .rect(0, 0, 100, 100)
   *     .fill({ color: 0xff0000 });
   * ```
   * @see {@link GraphicsContext} For drawing operations
   * @see {@link GraphicsOptions} For context configuration
   */
  get context() {
    return this._context;
  }
  /**
   * The local bounds of the graphics object.
   * Returns the boundaries after all graphical operations but before any transforms.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Draw a shape
   * graphics
   *     .rect(0, 0, 100, 100)
   *     .fill({ color: 0xff0000 });
   *
   * // Get bounds information
   * const bounds = graphics.bounds;
   * console.log(bounds.width);  // 100
   * console.log(bounds.height); // 100
   * ```
   * @readonly
   * @see {@link Bounds} For bounds operations
   * @see {@link Container#getBounds} For transformed bounds
   */
  get bounds() {
    return this._context.bounds;
  }
  /**
   * Graphics objects do not need to update their bounds as the context handles this.
   * @private
   */
  updateBounds() {
  }
  /**
   * Checks if the object contains the given point.
   * Returns true if the point lies within the Graphics object's rendered area.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Draw a shape
   * graphics
   *     .rect(0, 0, 100, 100)
   *     .fill({ color: 0xff0000 });
   *
   * // Check point intersection
   * if (graphics.containsPoint({ x: 50, y: 50 })) {
   *     console.log('Point is inside rectangle!');
   * }
   * ```
   * @param point - The point to check in local coordinates
   * @returns True if the point is inside the Graphics object
   * @see {@link Graphics#bounds} For bounding box checks
   * @see {@link PointData} For point data structure
   */
  containsPoint(t) {
    return this._context.containsPoint(t);
  }
  /**
   * Destroys this graphics renderable and optionally its context.
   * @param options - Options parameter. A boolean will act as if all options
   *
   * If the context was created by this graphics and `destroy(false)` or `destroy()` is called
   * then the context will still be destroyed.
   *
   * If you want to explicitly not destroy this context that this graphics created,
   * then you should pass destroy({ context: false })
   *
   * If the context was passed in as an argument to the constructor then it will not be destroyed
   * @example
   * ```ts
   * // Destroy the graphics and its context
   * graphics.destroy();
   * graphics.destroy(true);
   * graphics.destroy({ context: true, texture: true, textureSource: true });
   * ```
   */
  destroy(t) {
    this._ownedContext && !t ? this._ownedContext.destroy(t) : (t === !0 || t?.context === !0) && this._context.destroy(t), this._ownedContext = null, this._context = null, super.destroy(t);
  }
  _callContextMethod(t, e) {
    return this.context[t](...e), this;
  }
  // --------------------------------------- GraphicsContext methods ---------------------------------------
  /**
   * Sets the current fill style of the graphics context.
   * The fill style can be a color, gradient, pattern, or a complex style object.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Basic color fill
   * graphics
   *     .setFillStyle({ color: 0xff0000 }) // Red fill
   *     .rect(0, 0, 100, 100)
   *     .fill();
   *
   * // Gradient fill
   * const gradient = new FillGradient({
   *    end: { x: 1, y: 0 },
   *    colorStops: [
   *         { offset: 0, color: 0xff0000 }, // Red at start
   *         { offset: 0.5, color: 0x00ff00 }, // Green at middle
   *         { offset: 1, color: 0x0000ff }, // Blue at end
   *    ],
   * });
   *
   * graphics
   *     .setFillStyle(gradient)
   *     .circle(100, 100, 50)
   *     .fill();
   *
   * // Pattern fill
   * const pattern = new FillPattern(texture);
   * graphics
   *     .setFillStyle({
   *         fill: pattern,
   *         alpha: 0.5
   *     })
   *     .rect(0, 0, 200, 200)
   *     .fill();
   * ```
   * @param {FillInput} args - The fill style to apply
   * @returns The Graphics instance for chaining
   * @see {@link FillStyle} For fill style options
   * @see {@link FillGradient} For gradient fills
   * @see {@link FillPattern} For pattern fills
   */
  setFillStyle(...t) {
    return this._callContextMethod("setFillStyle", t);
  }
  /**
   * Sets the current stroke style of the graphics context.
   * Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Basic color stroke
   * graphics
   *     .setStrokeStyle({
   *         width: 2,
   *         color: 0x000000
   *     })
   *     .rect(0, 0, 100, 100)
   *     .stroke();
   *
   * // Complex stroke style
   * graphics
   *     .setStrokeStyle({
   *         width: 4,
   *         color: 0xff0000,
   *         alpha: 0.5,
   *         join: 'round',
   *         cap: 'round',
   *         alignment: 0.5
   *     })
   *     .circle(100, 100, 50)
   *     .stroke();
   *
   * // Gradient stroke
   * const gradient = new FillGradient({
   *    end: { x: 1, y: 0 },
   *    colorStops: [
   *         { offset: 0, color: 0xff0000 }, // Red at start
   *         { offset: 0.5, color: 0x00ff00 }, // Green at middle
   *         { offset: 1, color: 0x0000ff }, // Blue at end
   *    ],
   * });
   *
   * graphics
   *     .setStrokeStyle({
   *         width: 10,
   *         fill: gradient
   *     })
   *     .poly([0,0, 100,50, 0,100])
   *     .stroke();
   * ```
   * @param {StrokeInput} args - The stroke style to apply
   * @returns The Graphics instance for chaining
   * @see {@link StrokeStyle} For stroke style options
   * @see {@link FillGradient} For gradient strokes
   * @see {@link FillPattern} For pattern strokes
   */
  setStrokeStyle(...t) {
    return this._callContextMethod("setStrokeStyle", t);
  }
  fill(...t) {
    return this._callContextMethod("fill", t);
  }
  /**
   * Strokes the current path with the current stroke style or specified style.
   * Outlines the shape using the stroke settings.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Stroke with direct color
   * graphics
   *     .circle(50, 50, 25)
   *     .stroke({
   *         width: 2,
   *         color: 0xff0000
   *     }); // 2px red stroke
   *
   * // Fill with texture
   * graphics
   *    .rect(0, 0, 100, 100)
   *    .stroke(myTexture); // Fill with texture
   *
   * // Stroke with gradient
   * const gradient = new FillGradient({
   *     end: { x: 1, y: 0 },
   *     colorStops: [
   *         { offset: 0, color: 0xff0000 },
   *         { offset: 0.5, color: 0x00ff00 },
   *         { offset: 1, color: 0x0000ff },
   *     ],
   * });
   *
   * graphics
   *     .rect(0, 0, 100, 100)
   *     .stroke({
   *         width: 4,
   *         fill: gradient,
   *         alignment: 0.5,
   *         join: 'round'
   *     });
   * ```
   * @param {StrokeStyle} args - Optional stroke style to apply. Can be:
   * - A stroke style object with width, color, etc.
   * - A gradient
   * - A pattern
   * If omitted, uses current stroke style.
   * @returns The Graphics instance for chaining
   * @see {@link StrokeStyle} For stroke style options
   * @see {@link FillGradient} For gradient strokes
   * @see {@link setStrokeStyle} For setting default stroke style
   */
  stroke(...t) {
    return this._callContextMethod("stroke", t);
  }
  texture(...t) {
    return this._callContextMethod("texture", t);
  }
  /**
   * Resets the current path. Any previous path and its commands are discarded and a new path is
   * started. This is typically called before beginning a new shape or series of drawing commands.
   * @example
   * ```ts
   * const graphics = new Graphics();
   * graphics
   *     .circle(150, 150, 50)
   *     .fill({ color: 0x00ff00 })
   *     .beginPath() // Starts a new path
   *     .circle(250, 150, 50)
   *     .fill({ color: 0x0000ff });
   * ```
   * @returns The Graphics instance for chaining
   * @see {@link Graphics#moveTo} For starting a new subpath
   * @see {@link Graphics#closePath} For closing the current path
   */
  beginPath() {
    return this._callContextMethod("beginPath", []);
  }
  /**
   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by
   * subtracting a path from the previously drawn path.
   *
   * If a hole is not completely in a shape, it will fail to cut correctly.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Draw outer circle
   * graphics
   *     .circle(100, 100, 50)
   *     .fill({ color: 0xff0000 });
   *     .circle(100, 100, 25) // Inner circle
   *     .cut() // Cuts out the inner circle from the outer circle
   * ```
   */
  cut() {
    return this._callContextMethod("cut", []);
  }
  arc(...t) {
    return this._callContextMethod("arc", t);
  }
  arcTo(...t) {
    return this._callContextMethod("arcTo", t);
  }
  arcToSvg(...t) {
    return this._callContextMethod("arcToSvg", t);
  }
  bezierCurveTo(...t) {
    return this._callContextMethod("bezierCurveTo", t);
  }
  /**
   * Closes the current path by drawing a straight line back to the start point.
   *
   * This is useful for completing shapes and ensuring they are properly closed for fills.
   * @example
   * ```ts
   * // Create a triangle with closed path
   * const graphics = new Graphics();
   * graphics
   *     .moveTo(50, 50)
   *     .lineTo(100, 100)
   *     .lineTo(0, 100)
   *     .closePath()
   * ```
   * @returns The Graphics instance for method chaining
   * @see {@link Graphics#beginPath} For starting a new path
   * @see {@link Graphics#fill} For filling closed paths
   * @see {@link Graphics#stroke} For stroking paths
   */
  closePath() {
    return this._callContextMethod("closePath", []);
  }
  ellipse(...t) {
    return this._callContextMethod("ellipse", t);
  }
  circle(...t) {
    return this._callContextMethod("circle", t);
  }
  path(...t) {
    return this._callContextMethod("path", t);
  }
  lineTo(...t) {
    return this._callContextMethod("lineTo", t);
  }
  moveTo(...t) {
    return this._callContextMethod("moveTo", t);
  }
  quadraticCurveTo(...t) {
    return this._callContextMethod("quadraticCurveTo", t);
  }
  rect(...t) {
    return this._callContextMethod("rect", t);
  }
  roundRect(...t) {
    return this._callContextMethod("roundRect", t);
  }
  poly(...t) {
    return this._callContextMethod("poly", t);
  }
  regularPoly(...t) {
    return this._callContextMethod("regularPoly", t);
  }
  roundPoly(...t) {
    return this._callContextMethod("roundPoly", t);
  }
  roundShape(...t) {
    return this._callContextMethod("roundShape", t);
  }
  filletRect(...t) {
    return this._callContextMethod("filletRect", t);
  }
  chamferRect(...t) {
    return this._callContextMethod("chamferRect", t);
  }
  star(...t) {
    return this._callContextMethod("star", t);
  }
  svg(...t) {
    return this._callContextMethod("svg", t);
  }
  restore(...t) {
    return this._callContextMethod("restore", t);
  }
  /**
   * Saves the current graphics state onto a stack. The state includes:
   * - Current transformation matrix
   * - Current fill style
   * - Current stroke style
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Save state before complex operations
   * graphics.save();
   *
   * // Create transformed and styled shape
   * graphics
   *     .translateTransform(100, 100)
   *     .rotateTransform(Math.PI / 4)
   *     .setFillStyle({
   *         color: 0xff0000,
   *         alpha: 0.5
   *     })
   *     .rect(-25, -25, 50, 50)
   *     .fill();
   *
   * // Restore to original state
   * graphics.restore();
   *
   * // Continue drawing with previous state
   * graphics
   *     .circle(50, 50, 25)
   *     .fill();
   * ```
   * @returns The Graphics instance for method chaining
   * @see {@link Graphics#restore} For restoring the saved state
   * @see {@link Graphics#setTransform} For setting transformations
   */
  save() {
    return this._callContextMethod("save", []);
  }
  /**
   * Returns the current transformation matrix of the graphics context.
   * This matrix represents all accumulated transformations including translate, scale, and rotate.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Apply some transformations
   * graphics
   *     .translateTransform(100, 100)
   *     .rotateTransform(Math.PI / 4);
   *
   * // Get the current transform matrix
   * const matrix = graphics.getTransform();
   * console.log(matrix.tx, matrix.ty); // 100, 100
   *
   * // Use the matrix for other operations
   * graphics
   *     .setTransform(matrix)
   *     .circle(0, 0, 50)
   *     .fill({ color: 0xff0000 });
   * ```
   * @returns The current transformation matrix.
   * @see {@link Graphics#setTransform} For setting the transform matrix
   * @see {@link Matrix} For matrix operations
   */
  getTransform() {
    return this.context.getTransform();
  }
  /**
   * Resets the current transformation matrix to the identity matrix, effectively removing
   * any transformations (rotation, scaling, translation) previously applied.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Apply transformations
   * graphics
   *     .translateTransform(100, 100)
   *     .scaleTransform(2, 2)
   *     .circle(0, 0, 25)
   *     .fill({ color: 0xff0000 });
   * // Reset transform to default state
   * graphics
   *     .resetTransform()
   *     .circle(50, 50, 25) // Will draw at actual coordinates
   *     .fill({ color: 0x00ff00 });
   * ```
   * @returns The Graphics instance for method chaining
   * @see {@link Graphics#getTransform} For getting the current transform
   * @see {@link Graphics#setTransform} For setting a specific transform
   * @see {@link Graphics#save} For saving the current transform state
   * @see {@link Graphics#restore} For restoring a previous transform state
   */
  resetTransform() {
    return this._callContextMethod("resetTransform", []);
  }
  rotateTransform(...t) {
    return this._callContextMethod("rotate", t);
  }
  scaleTransform(...t) {
    return this._callContextMethod("scale", t);
  }
  setTransform(...t) {
    return this._callContextMethod("setTransform", t);
  }
  transform(...t) {
    return this._callContextMethod("transform", t);
  }
  translateTransform(...t) {
    return this._callContextMethod("translate", t);
  }
  /**
   * Clears all drawing commands from the graphics context, effectively resetting it.
   * This includes clearing the current path, fill style, stroke style, and transformations.
   *
   * > [!NOTE] Graphics objects are not designed to be continuously cleared and redrawn.
   * > Instead, they are intended to be used for static or semi-static graphics that
   * > can be redrawn as needed. Frequent clearing and redrawing may lead to performance issues.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Draw some shapes
   * graphics
   *     .circle(100, 100, 50)
   *     .fill({ color: 0xff0000 })
   *     .rect(200, 100, 100, 50)
   *     .fill({ color: 0x00ff00 });
   *
   * // Clear all graphics
   * graphics.clear();
   *
   * // Start fresh with new shapes
   * graphics
   *     .circle(150, 150, 30)
   *     .fill({ color: 0x0000ff });
   * ```
   * @returns The Graphics instance for method chaining
   * @see {@link Graphics#beginPath} For starting a new path without clearing styles
   * @see {@link Graphics#save} For saving the current state
   * @see {@link Graphics#restore} For restoring a previous state
   */
  clear() {
    return this._callContextMethod("clear", []);
  }
  /**
   * Gets or sets the current fill style for the graphics context. The fill style determines
   * how shapes are filled when using the fill() method.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Basic color fill
   * graphics.fillStyle = {
   *     color: 0xff0000,  // Red
   *     alpha: 1
   * };
   *
   * // Using gradients
   * const gradient = new FillGradient({
   *     end: { x: 0, y: 1 }, // Vertical gradient
   *     stops: [
   *         { offset: 0, color: 0xff0000, alpha: 1 }, // Start color
   *         { offset: 1, color: 0x0000ff, alpha: 1 }  // End color
   *     ]
   * });
   *
   * graphics.fillStyle = {
   *     fill: gradient,
   *     alpha: 0.8
   * };
   *
   * // Using patterns
   * graphics.fillStyle = {
   *     texture: myTexture,
   *     alpha: 1,
   *     matrix: new Matrix()
   *         .scale(0.5, 0.5)
   *         .rotate(Math.PI / 4)
   * };
   * ```
   * @type {ConvertedFillStyle}
   * @see {@link FillStyle} For all available fill style options
   * @see {@link FillGradient} For creating gradient fills
   * @see {@link Graphics#fill} For applying the fill to paths
   */
  get fillStyle() {
    return this._context.fillStyle;
  }
  set fillStyle(t) {
    this._context.fillStyle = t;
  }
  /**
   * Gets or sets the current stroke style for the graphics context. The stroke style determines
   * how paths are outlined when using the stroke() method.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Basic stroke style
   * graphics.strokeStyle = {
   *     width: 2,
   *     color: 0xff0000,
   *     alpha: 1
   * };
   *
   * // Using with gradients
   * const gradient = new FillGradient({
   *   end: { x: 0, y: 1 },
   *   stops: [
   *       { offset: 0, color: 0xff0000, alpha: 1 },
   *       { offset: 1, color: 0x0000ff, alpha: 1 }
   *   ]
   * });
   *
   * graphics.strokeStyle = {
   *     width: 4,
   *     fill: gradient,
   *     alignment: 0.5,
   *     join: 'round',
   *     cap: 'round'
   * };
   *
   * // Complex stroke settings
   * graphics.strokeStyle = {
   *     width: 6,
   *     color: 0x00ff00,
   *     alpha: 0.5,
   *     join: 'miter',
   *     miterLimit: 10,
   * };
   * ```
   * @see {@link StrokeStyle} For all available stroke style options
   * @see {@link Graphics#stroke} For applying the stroke to paths
   */
  get strokeStyle() {
    return this._context.strokeStyle;
  }
  set strokeStyle(t) {
    this._context.strokeStyle = t;
  }
  /**
   * Creates a new Graphics object that copies the current graphics content.
   * The clone can either share the same context (shallow clone) or have its own independent
   * context (deep clone).
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Create original graphics content
   * graphics
   *     .circle(100, 100, 50)
   *     .fill({ color: 0xff0000 });
   *
   * // Create a shallow clone (shared context)
   * const shallowClone = graphics.clone();
   *
   * // Changes to original affect the clone
   * graphics
   *     .circle(200, 100, 30)
   *     .fill({ color: 0x00ff00 });
   *
   * // Create a deep clone (independent context)
   * const deepClone = graphics.clone(true);
   *
   * // Modify deep clone independently
   * deepClone
   *     .translateTransform(100, 100)
   *     .circle(0, 0, 40)
   *     .fill({ color: 0x0000ff });
   * ```
   * @param deep - Whether to create a deep clone of the graphics object.
   *              If false (default), the context will be shared between objects.
   *              If true, creates an independent copy of the context.
   * @returns A new Graphics instance with either shared or copied context
   * @see {@link Graphics#context} For accessing the underlying graphics context
   * @see {@link GraphicsContext} For understanding the shared context behavior
   */
  clone(t = !1) {
    return t ? new $l(this._context.clone()) : (this._ownedContext = null, new $l(this._context));
  }
  // -------- v7 deprecations ---------
  /**
   * @param width
   * @param color
   * @param alpha
   * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead
   */
  lineStyle(t, e, i) {
    zt(ae, "Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.");
    const s = {};
    return t && (s.width = t), e && (s.color = e), i && (s.alpha = i), this.context.strokeStyle = s, this;
  }
  /**
   * @param color
   * @param alpha
   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead
   */
  beginFill(t, e) {
    zt(ae, "Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");
    const i = {};
    return t !== void 0 && (i.color = t), e !== void 0 && (i.alpha = e), this.context.fillStyle = i, this;
  }
  /**
   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead
   */
  endFill() {
    zt(ae, "Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style."), this.context.fill();
    const t = this.context.strokeStyle;
    return (t.width !== Si.defaultStrokeStyle.width || t.color !== Si.defaultStrokeStyle.color || t.alpha !== Si.defaultStrokeStyle.alpha) && this.context.stroke(), this;
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0 Use {@link Graphics#circle} instead
   */
  drawCircle(...t) {
    return zt(ae, "Graphics#drawCircle has been renamed to Graphics#circle"), this._callContextMethod("circle", t);
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead
   */
  drawEllipse(...t) {
    return zt(ae, "Graphics#drawEllipse has been renamed to Graphics#ellipse"), this._callContextMethod("ellipse", t);
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0 Use {@link Graphics#poly} instead
   */
  drawPolygon(...t) {
    return zt(ae, "Graphics#drawPolygon has been renamed to Graphics#poly"), this._callContextMethod("poly", t);
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0 Use {@link Graphics#rect} instead
   */
  drawRect(...t) {
    return zt(ae, "Graphics#drawRect has been renamed to Graphics#rect"), this._callContextMethod("rect", t);
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead
   */
  drawRoundedRect(...t) {
    return zt(ae, "Graphics#drawRoundedRect has been renamed to Graphics#roundRect"), this._callContextMethod("roundRect", t);
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0 Use {@link Graphics#star} instead
   */
  drawStar(...t) {
    return zt(ae, "Graphics#drawStar has been renamed to Graphics#star"), this._callContextMethod("star", t);
  }
}
const xT = class _T extends ql {
  constructor(...t) {
    let e = t[0] ?? {};
    e instanceof Float32Array && (zt(ae, "use new MeshGeometry({ positions, uvs, indices }) instead"), e = {
      positions: e,
      uvs: t[1],
      indices: t[2]
    }), e = { ..._T.defaultOptions, ...e };
    const i = e.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
    let s = e.uvs;
    s || (e.positions ? s = new Float32Array(i.length) : s = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]));
    const o = e.indices || new Uint32Array([0, 1, 2, 0, 2, 3]), l = e.shrinkBuffersToFit, c = new Zn({
      data: i,
      label: "attribute-mesh-positions",
      shrinkToFit: l,
      usage: Qt.VERTEX | Qt.COPY_DST
    }), d = new Zn({
      data: s,
      label: "attribute-mesh-uvs",
      shrinkToFit: l,
      usage: Qt.VERTEX | Qt.COPY_DST
    }), f = new Zn({
      data: o,
      label: "index-mesh-buffer",
      shrinkToFit: l,
      usage: Qt.INDEX | Qt.COPY_DST
    });
    super({
      attributes: {
        aPosition: {
          buffer: c,
          format: "float32x2",
          stride: 8,
          offset: 0
        },
        aUV: {
          buffer: d,
          format: "float32x2",
          stride: 8,
          offset: 0
        }
      },
      indexBuffer: f,
      topology: e.topology
    }), this.batchMode = "auto";
  }
  /** The positions of the mesh. */
  get positions() {
    return this.attributes.aPosition.buffer.data;
  }
  /**
   * Set the positions of the mesh.
   * When setting the positions, its important that the uvs array is at least as long as the positions array.
   * otherwise the geometry will not be valid.
   * @param {Float32Array} value - The positions of the mesh.
   */
  set positions(t) {
    this.attributes.aPosition.buffer.data = t;
  }
  /** The UVs of the mesh. */
  get uvs() {
    return this.attributes.aUV.buffer.data;
  }
  /**
   * Set the UVs of the mesh.
   * Its important that the uvs array you set is at least as long as the positions array.
   * otherwise the geometry will not be valid.
   * @param {Float32Array} value - The UVs of the mesh.
   */
  set uvs(t) {
    this.attributes.aUV.buffer.data = t;
  }
  /** The indices of the mesh. */
  get indices() {
    return this.indexBuffer.data;
  }
  set indices(t) {
    this.indexBuffer.data = t;
  }
};
xT.defaultOptions = {
  topology: "triangle-list",
  shrinkBuffersToFit: !1
};
let xg = xT, Ss = null, fr = null;
function BB(n, t) {
  Ss || (Ss = ve.get().createCanvas(256, 128), fr = Ss.getContext("2d", { willReadFrequently: !0 }), fr.globalCompositeOperation = "copy", fr.globalAlpha = 1), (Ss.width < n || Ss.height < t) && (Ss.width = Wa(n), Ss.height = Wa(t));
}
function _0(n, t, e) {
  for (let i = 0, s = 4 * e * t; i < t; ++i, s += 4)
    if (n[s + 3] !== 0)
      return !1;
  return !0;
}
function S0(n, t, e, i, s) {
  const o = 4 * t;
  for (let l = i, c = i * o + 4 * e; l <= s; ++l, c += o)
    if (n[c + 3] !== 0)
      return !1;
  return !0;
}
function kB(...n) {
  let t = n[0];
  t.canvas || (t = { canvas: n[0], resolution: n[1] });
  const { canvas: e } = t, i = Math.min(t.resolution ?? 1, 1), s = t.width ?? e.width, o = t.height ?? e.height;
  let l = t.output;
  if (BB(s, o), !fr)
    throw new TypeError("Failed to get canvas 2D context");
  fr.drawImage(
    e,
    0,
    0,
    s,
    o,
    0,
    0,
    s * i,
    o * i
  );
  const d = fr.getImageData(0, 0, s, o).data;
  let f = 0, m = 0, y = s - 1, b = o - 1;
  for (; m < o && _0(d, s, m); )
    ++m;
  if (m === o)
    return ne.EMPTY;
  for (; _0(d, s, b); )
    --b;
  for (; S0(d, s, f, m, b); )
    ++f;
  for (; S0(d, s, y, m, b); )
    --y;
  return ++y, ++b, fr.globalCompositeOperation = "source-over", fr.strokeRect(f, m, y - f, b - m), fr.globalCompositeOperation = "copy", l ?? (l = new ne()), l.set(f / i, m / i, (y - f) / i, (b - m) / i), l;
}
const T0 = new ne();
class OB {
  /**
   * Creates a canvas with the specified text rendered to it.
   *
   * Generates a canvas of appropriate size, renders the text with the provided style,
   * and returns both the canvas/context and a Rectangle representing the text bounds.
   *
   * When trim is enabled in the style, the frame will represent the bounds of the
   * non-transparent pixels, which can be smaller than the full canvas.
   * @param options - The options for generating the text canvas
   * @param options.text - The text to render
   * @param options.style - The style to apply to the text
   * @param options.resolution - The resolution of the canvas (defaults to 1)
   * @param options.padding
   * @returns An object containing the canvas/context and the frame (bounds) of the text
   */
  getCanvasAndContext(t) {
    const { text: e, style: i, resolution: s = 1 } = t, o = i._getFinalPadding(), l = Li.measureText(e || " ", i), c = Math.ceil(Math.ceil(Math.max(1, l.width) + o * 2) * s), d = Math.ceil(Math.ceil(Math.max(1, l.height) + o * 2) * s), f = xr.getOptimalCanvasAndContext(c, d);
    this._renderTextToCanvas(e, i, o, s, f);
    const m = i.trim ? kB({ canvas: f.canvas, width: c, height: d, resolution: 1, output: T0 }) : T0.set(0, 0, c, d);
    return {
      canvasAndContext: f,
      frame: m
    };
  }
  /**
   * Returns a canvas and context to the pool.
   *
   * This should be called when you're done with the canvas to allow reuse
   * and prevent memory leaks.
   * @param canvasAndContext - The canvas and context to return to the pool
   */
  returnCanvasAndContext(t) {
    xr.returnCanvasAndContext(t);
  }
  /**
   * Renders text to its canvas, and updates its texture.
   * @param text - The text to render
   * @param style - The style of the text
   * @param padding - The padding of the text
   * @param resolution - The resolution of the text
   * @param canvasAndContext - The canvas and context to render the text to
   */
  _renderTextToCanvas(t, e, i, s, o) {
    const { canvas: l, context: c } = o, d = rh(e), f = Li.measureText(t || " ", e), m = f.lines, y = f.lineHeight, b = f.lineWidths, v = f.maxLineWidth, x = f.fontProperties, S = l.height;
    if (c.resetTransform(), c.scale(s, s), c.textBaseline = e.textBaseline, e._stroke?.width) {
      const w = e._stroke;
      c.lineWidth = w.width, c.miterLimit = w.miterLimit, c.lineJoin = w.join, c.lineCap = w.cap;
    }
    c.font = d;
    let _, C;
    const R = e.dropShadow ? 2 : 1;
    for (let w = 0; w < R; ++w) {
      const E = e.dropShadow && w === 0, P = E ? Math.ceil(Math.max(1, S) + i * 2) : 0, k = P * s;
      if (E) {
        c.fillStyle = "black", c.strokeStyle = "black";
        const F = e.dropShadow, j = F.color, H = F.alpha;
        c.shadowColor = Pe.shared.setValue(j).setAlpha(H).toRgbaString();
        const M = F.blur * s, Y = F.distance * s;
        c.shadowBlur = M, c.shadowOffsetX = Math.cos(F.angle) * Y, c.shadowOffsetY = Math.sin(F.angle) * Y + k;
      } else {
        if (c.fillStyle = e._fill ? oh(e._fill, c, f, i * 2) : null, e._stroke?.width) {
          const F = e._stroke.width * 0.5 + i * 2;
          c.strokeStyle = oh(e._stroke, c, f, F);
        }
        c.shadowColor = "black";
      }
      let G = (y - x.fontSize) / 2;
      y - x.fontSize < 0 && (G = 0);
      const $ = e._stroke?.width ?? 0;
      for (let F = 0; F < m.length; F++)
        _ = $ / 2, C = $ / 2 + F * y + x.ascent + G, e.align === "right" ? _ += v - b[F] : e.align === "center" && (_ += (v - b[F]) / 2), e._stroke?.width && this._drawLetterSpacing(
          m[F],
          e,
          o,
          _ + i,
          C + i - P,
          !0
        ), e._fill !== void 0 && this._drawLetterSpacing(
          m[F],
          e,
          o,
          _ + i,
          C + i - P
        );
    }
  }
  /**
   * Render the text with letter-spacing.
   *
   * This method handles rendering text with the correct letter spacing, using either:
   * 1. Native letter spacing if supported by the browser
   * 2. Manual letter spacing calculation if not natively supported
   *
   * For manual letter spacing, it calculates the position of each character
   * based on its width and the desired spacing.
   * @param text - The text to draw
   * @param style - The text style to apply
   * @param canvasAndContext - The canvas and context to draw to
   * @param x - Horizontal position to draw the text
   * @param y - Vertical position to draw the text
   * @param isStroke - Whether to render the stroke (true) or fill (false)
   * @private
   */
  _drawLetterSpacing(t, e, i, s, o, l = !1) {
    const { context: c } = i, d = e.letterSpacing;
    let f = !1;
    if (Li.experimentalLetterSpacingSupported && (Li.experimentalLetterSpacing ? (c.letterSpacing = `${d}px`, c.textLetterSpacing = `${d}px`, f = !0) : (c.letterSpacing = "0px", c.textLetterSpacing = "0px")), d === 0 || f) {
      l ? c.strokeText(t, s, o) : c.fillText(t, s, o);
      return;
    }
    let m = s;
    const y = Li.graphemeSegmenter(t);
    let b = c.measureText(t).width, v = 0;
    for (let x = 0; x < y.length; ++x) {
      const S = y[x];
      l ? c.strokeText(S, m, o) : c.fillText(S, m, o);
      let _ = "";
      for (let C = x + 1; C < y.length; ++C)
        _ += y[C];
      v = c.measureText(_).width, m += b - v + d, b = v;
    }
  }
}
const zp = new OB(), w0 = "http://www.w3.org/2000/svg", C0 = "http://www.w3.org/1999/xhtml";
class ST {
  constructor() {
    this.svgRoot = document.createElementNS(w0, "svg"), this.foreignObject = document.createElementNS(w0, "foreignObject"), this.domElement = document.createElementNS(C0, "div"), this.styleElement = document.createElementNS(C0, "style");
    const { foreignObject: t, svgRoot: e, styleElement: i, domElement: s } = this;
    t.setAttribute("width", "10000"), t.setAttribute("height", "10000"), t.style.overflow = "hidden", e.appendChild(t), t.appendChild(i), t.appendChild(s), this.image = ve.get().createImage();
  }
  destroy() {
    this.svgRoot.remove(), this.foreignObject.remove(), this.styleElement.remove(), this.domElement.remove(), this.image.src = "", this.image.remove(), this.svgRoot = null, this.foreignObject = null, this.styleElement = null, this.domElement = null, this.image = null, this.canvasAndContext = null;
  }
}
let E0;
function DB(n, t, e, i) {
  i || (i = E0 || (E0 = new ST()));
  const { domElement: s, styleElement: o, svgRoot: l } = i;
  s.innerHTML = `<style>${t.cssStyle};</style><div style='padding:0'>${n}</div>`, s.setAttribute("style", "transform-origin: top left; display: inline-block"), e && (o.textContent = e), document.body.appendChild(l);
  const c = s.getBoundingClientRect();
  l.remove();
  const d = t.padding * 2;
  return {
    width: c.width - d,
    height: c.height - d
  };
}
class TT {
  constructor() {
    this._tempState = wi.for2d(), this._didUploadHash = {};
  }
  init(t) {
    t.renderer.runners.contextChange.add(this);
  }
  contextChange() {
    this._didUploadHash = {};
  }
  start(t, e, i) {
    const s = t.renderer, o = this._didUploadHash[i.uid];
    s.shader.bind(i, o), o || (this._didUploadHash[i.uid] = !0), s.shader.updateUniformGroup(s.globalUniforms.uniformGroup), s.geometry.bind(e, i.glProgram);
  }
  execute(t, e) {
    const i = t.renderer;
    this._tempState.blendMode = e.blendMode, i.state.set(this._tempState);
    const s = e.textures.textures;
    for (let o = 0; o < e.textures.count; o++)
      i.texture.bind(s[o], o);
    i.geometry.draw(e.topology, e.size, e.start);
  }
}
TT.extension = {
  type: [
    W.WebGLPipesAdaptor
  ],
  name: "batch"
};
const Oc = wi.for2d();
class wT {
  start(t, e, i) {
    const s = t.renderer, o = s.encoder, l = i.gpuProgram;
    this._shader = i, this._geometry = e, o.setGeometry(e, l), Oc.blendMode = "normal", s.pipeline.getPipeline(
      e,
      l,
      Oc
    );
    const c = s.globalUniforms.bindGroup;
    o.resetBindGroup(1), o.setBindGroup(0, c, l);
  }
  execute(t, e) {
    const i = this._shader.gpuProgram, s = t.renderer, o = s.encoder;
    if (!e.bindGroup) {
      const d = e.textures;
      e.bindGroup = og(
        d.textures,
        d.count,
        s.limits.maxBatchableTextures
      );
    }
    Oc.blendMode = e.blendMode;
    const l = s.bindGroup.getBindGroup(
      e.bindGroup,
      i,
      1
    ), c = s.pipeline.getPipeline(
      this._geometry,
      i,
      Oc,
      e.topology
    );
    e.bindGroup._touch(s.textureGC.count), o.setPipeline(c), o.renderPassEncoder.setBindGroup(1, l), o.renderPassEncoder.drawIndexed(e.size, 1, e.start);
  }
}
wT.extension = {
  type: [
    W.WebGPUPipesAdaptor
  ],
  name: "batch"
};
const _g = class CT {
  constructor(t, e) {
    this.state = wi.for2d(), this._batchersByInstructionSet = /* @__PURE__ */ Object.create(null), this._activeBatches = /* @__PURE__ */ Object.create(null), this.renderer = t, this._adaptor = e, this._adaptor.init?.(this);
  }
  static getBatcher(t) {
    return new this._availableBatchers[t]();
  }
  buildStart(t) {
    let e = this._batchersByInstructionSet[t.uid];
    e || (e = this._batchersByInstructionSet[t.uid] = /* @__PURE__ */ Object.create(null), e.default || (e.default = new fg({
      maxTextures: this.renderer.limits.maxBatchableTextures
    }))), this._activeBatches = e, this._activeBatch = this._activeBatches.default;
    for (const i in this._activeBatches)
      this._activeBatches[i].begin();
  }
  addToBatch(t, e) {
    if (this._activeBatch.name !== t.batcherName) {
      this._activeBatch.break(e);
      let i = this._activeBatches[t.batcherName];
      i || (i = this._activeBatches[t.batcherName] = CT.getBatcher(t.batcherName), i.begin()), this._activeBatch = i;
    }
    this._activeBatch.add(t);
  }
  break(t) {
    this._activeBatch.break(t);
  }
  buildEnd(t) {
    this._activeBatch.break(t);
    const e = this._activeBatches;
    for (const i in e) {
      const s = e[i], o = s.geometry;
      o.indexBuffer.setDataWithSize(s.indexBuffer, s.indexSize, !0), o.buffers[0].setDataWithSize(s.attributeBuffer.float32View, s.attributeSize, !1);
    }
  }
  upload(t) {
    const e = this._batchersByInstructionSet[t.uid];
    for (const i in e) {
      const s = e[i], o = s.geometry;
      s.dirty && (s.dirty = !1, o.buffers[0].update(s.attributeSize * 4));
    }
  }
  execute(t) {
    if (t.action === "startBatch") {
      const e = t.batcher, i = e.geometry, s = e.shader;
      this._adaptor.start(this, i, s);
    }
    this._adaptor.execute(this, t);
  }
  destroy() {
    this.state = null, this.renderer = null, this._adaptor = null;
    for (const t in this._activeBatches)
      this._activeBatches[t].destroy();
    this._activeBatches = null;
  }
};
_g.extension = {
  type: [
    W.WebGLPipes,
    W.WebGPUPipes,
    W.CanvasPipes
  ],
  name: "batch"
};
_g._availableBatchers = /* @__PURE__ */ Object.create(null);
let ET = _g;
Nt.handleByMap(W.Batcher, ET._availableBatchers);
Nt.add(fg);
const Rl = {
  name: "local-uniform-bit",
  vertex: {
    header: (
      /* wgsl */
      `

            struct LocalUniforms {
                uTransformMatrix:mat3x3<f32>,
                uColor:vec4<f32>,
                uRound:f32,
            }

            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `
    ),
    main: (
      /* wgsl */
      `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `
    ),
    end: (
      /* wgsl */
      `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `
    )
  }
}, GB = {
  ...Rl,
  vertex: {
    ...Rl.vertex,
    // replace the group!
    header: Rl.vertex.header.replace("group(1)", "group(2)")
  }
}, Sg = {
  name: "local-uniform-bit",
  vertex: {
    header: (
      /* glsl */
      `

            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `
    ),
    main: (
      /* glsl */
      `
            vColor *= uColor;
            modelMatrix = uTransformMatrix;
        `
    ),
    end: (
      /* glsl */
      `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `
    )
  }
}, UB = {
  name: "texture-bit",
  vertex: {
    header: (
      /* wgsl */
      `

        struct TextureUniforms {
            uTextureMatrix:mat3x3<f32>,
        }

        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;
        `
    ),
    main: (
      /* wgsl */
      `
            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;
        `
    )
  },
  fragment: {
    header: (
      /* wgsl */
      `
            @group(2) @binding(0) var uTexture: texture_2d<f32>;
            @group(2) @binding(1) var uSampler: sampler;


        `
    ),
    main: (
      /* wgsl */
      `
            outColor = textureSample(uTexture, uSampler, vUV);
        `
    )
  }
}, NB = {
  name: "texture-bit",
  vertex: {
    header: (
      /* glsl */
      `
            uniform mat3 uTextureMatrix;
        `
    ),
    main: (
      /* glsl */
      `
            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;
        `
    )
  },
  fragment: {
    header: (
      /* glsl */
      `
        uniform sampler2D uTexture;


        `
    ),
    main: (
      /* glsl */
      `
            outColor = texture(uTexture, vUV);
        `
    )
  }
}, IB = new Cn();
class zB extends th {
  constructor() {
    super(), this.filters = [new PB({
      sprite: new ja(Tt.EMPTY),
      inverse: !1,
      resolution: "inherit",
      antialias: "inherit"
    })];
  }
  get sprite() {
    return this.filters[0].sprite;
  }
  set sprite(t) {
    this.filters[0].sprite = t;
  }
  get inverse() {
    return this.filters[0].inverse;
  }
  set inverse(t) {
    this.filters[0].inverse = t;
  }
}
class MT {
  constructor(t) {
    this._activeMaskStage = [], this._renderer = t;
  }
  push(t, e, i) {
    const s = this._renderer;
    if (s.renderPipes.batch.break(i), i.add({
      renderPipeId: "alphaMask",
      action: "pushMaskBegin",
      mask: t,
      inverse: e._maskOptions.inverse,
      canBundle: !1,
      maskedContainer: e
    }), t.inverse = e._maskOptions.inverse, t.renderMaskToTexture) {
      const o = t.mask;
      o.includeInBuild = !0, o.collectRenderables(
        i,
        s,
        null
      ), o.includeInBuild = !1;
    }
    s.renderPipes.batch.break(i), i.add({
      renderPipeId: "alphaMask",
      action: "pushMaskEnd",
      mask: t,
      maskedContainer: e,
      inverse: e._maskOptions.inverse,
      canBundle: !1
    });
  }
  pop(t, e, i) {
    this._renderer.renderPipes.batch.break(i), i.add({
      renderPipeId: "alphaMask",
      action: "popMaskEnd",
      mask: t,
      inverse: e._maskOptions.inverse,
      canBundle: !1
    });
  }
  execute(t) {
    const e = this._renderer, i = t.mask.renderMaskToTexture;
    if (t.action === "pushMaskBegin") {
      const s = Qe.get(zB);
      if (s.inverse = t.inverse, i) {
        t.mask.mask.measurable = !0;
        const o = Qm(t.mask.mask, !0, IB);
        t.mask.mask.measurable = !1, o.ceil();
        const l = e.renderTarget.renderTarget.colorTexture.source, c = mn.getOptimalTexture(
          o.width,
          o.height,
          l._resolution,
          l.antialias
        );
        e.renderTarget.push(c, !0), e.globalUniforms.push({
          offset: o,
          worldColor: 4294967295
        });
        const d = s.sprite;
        d.texture = c, d.worldTransform.tx = o.minX, d.worldTransform.ty = o.minY, this._activeMaskStage.push({
          filterEffect: s,
          maskedContainer: t.maskedContainer,
          filterTexture: c
        });
      } else
        s.sprite = t.mask.mask, this._activeMaskStage.push({
          filterEffect: s,
          maskedContainer: t.maskedContainer
        });
    } else if (t.action === "pushMaskEnd") {
      const s = this._activeMaskStage[this._activeMaskStage.length - 1];
      i && (e.type === Ti.WEBGL && e.renderTarget.finishRenderPass(), e.renderTarget.pop(), e.globalUniforms.pop()), e.filter.push({
        renderPipeId: "filter",
        action: "pushFilter",
        container: s.maskedContainer,
        filterEffect: s.filterEffect,
        canBundle: !1
      });
    } else if (t.action === "popMaskEnd") {
      e.filter.pop();
      const s = this._activeMaskStage.pop();
      i && mn.returnTexture(s.filterTexture), Qe.return(s.filterEffect);
    }
  }
  destroy() {
    this._renderer = null, this._activeMaskStage = null;
  }
}
MT.extension = {
  type: [
    W.WebGLPipes,
    W.WebGPUPipes,
    W.CanvasPipes
  ],
  name: "alphaMask"
};
class AT {
  constructor(t) {
    this._colorStack = [], this._colorStackIndex = 0, this._currentColor = 0, this._renderer = t;
  }
  buildStart() {
    this._colorStack[0] = 15, this._colorStackIndex = 1, this._currentColor = 15;
  }
  push(t, e, i) {
    this._renderer.renderPipes.batch.break(i);
    const o = this._colorStack;
    o[this._colorStackIndex] = o[this._colorStackIndex - 1] & t.mask;
    const l = this._colorStack[this._colorStackIndex];
    l !== this._currentColor && (this._currentColor = l, i.add({
      renderPipeId: "colorMask",
      colorMask: l,
      canBundle: !1
    })), this._colorStackIndex++;
  }
  pop(t, e, i) {
    this._renderer.renderPipes.batch.break(i);
    const o = this._colorStack;
    this._colorStackIndex--;
    const l = o[this._colorStackIndex - 1];
    l !== this._currentColor && (this._currentColor = l, i.add({
      renderPipeId: "colorMask",
      colorMask: l,
      canBundle: !1
    }));
  }
  execute(t) {
    this._renderer.colorMask.setMask(t.colorMask);
  }
  destroy() {
    this._renderer = null, this._colorStack = null;
  }
}
AT.extension = {
  type: [
    W.WebGLPipes,
    W.WebGPUPipes,
    W.CanvasPipes
  ],
  name: "colorMask"
};
class RT {
  constructor(t) {
    this._maskStackHash = {}, this._maskHash = /* @__PURE__ */ new WeakMap(), this._renderer = t;
  }
  push(t, e, i) {
    var s;
    const o = t, l = this._renderer;
    l.renderPipes.batch.break(i), l.renderPipes.blendMode.setBlendMode(o.mask, "none", i), i.add({
      renderPipeId: "stencilMask",
      action: "pushMaskBegin",
      mask: t,
      inverse: e._maskOptions.inverse,
      canBundle: !1
    });
    const c = o.mask;
    c.includeInBuild = !0, this._maskHash.has(o) || this._maskHash.set(o, {
      instructionsStart: 0,
      instructionsLength: 0
    });
    const d = this._maskHash.get(o);
    d.instructionsStart = i.instructionSize, c.collectRenderables(
      i,
      l,
      null
    ), c.includeInBuild = !1, l.renderPipes.batch.break(i), i.add({
      renderPipeId: "stencilMask",
      action: "pushMaskEnd",
      mask: t,
      inverse: e._maskOptions.inverse,
      canBundle: !1
    });
    const f = i.instructionSize - d.instructionsStart - 1;
    d.instructionsLength = f;
    const m = l.renderTarget.renderTarget.uid;
    (s = this._maskStackHash)[m] ?? (s[m] = 0);
  }
  pop(t, e, i) {
    const s = t, o = this._renderer;
    o.renderPipes.batch.break(i), o.renderPipes.blendMode.setBlendMode(s.mask, "none", i), i.add({
      renderPipeId: "stencilMask",
      action: "popMaskBegin",
      inverse: e._maskOptions.inverse,
      canBundle: !1
    });
    const l = this._maskHash.get(t);
    for (let c = 0; c < l.instructionsLength; c++)
      i.instructions[i.instructionSize++] = i.instructions[l.instructionsStart++];
    i.add({
      renderPipeId: "stencilMask",
      action: "popMaskEnd",
      canBundle: !1
    });
  }
  execute(t) {
    var e;
    const i = this._renderer, s = i.renderTarget.renderTarget.uid;
    let o = (e = this._maskStackHash)[s] ?? (e[s] = 0);
    t.action === "pushMaskBegin" ? (i.renderTarget.ensureDepthStencil(), i.stencil.setStencilMode(Ye.RENDERING_MASK_ADD, o), o++, i.colorMask.setMask(0)) : t.action === "pushMaskEnd" ? (t.inverse ? i.stencil.setStencilMode(Ye.INVERSE_MASK_ACTIVE, o) : i.stencil.setStencilMode(Ye.MASK_ACTIVE, o), i.colorMask.setMask(15)) : t.action === "popMaskBegin" ? (i.colorMask.setMask(0), o !== 0 ? i.stencil.setStencilMode(Ye.RENDERING_MASK_REMOVE, o) : (i.renderTarget.clear(null, Xn.STENCIL), i.stencil.setStencilMode(Ye.DISABLED, o)), o--) : t.action === "popMaskEnd" && (t.inverse ? i.stencil.setStencilMode(Ye.INVERSE_MASK_ACTIVE, o) : i.stencil.setStencilMode(Ye.MASK_ACTIVE, o), i.colorMask.setMask(15)), this._maskStackHash[s] = o;
  }
  destroy() {
    this._renderer = null, this._maskStackHash = null, this._maskHash = null;
  }
}
RT.extension = {
  type: [
    W.WebGLPipes,
    W.WebGPUPipes,
    W.CanvasPipes
  ],
  name: "stencilMask"
};
var Yc = /* @__PURE__ */ ((n) => (n[n.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", n[n.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", n[n.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER", n))(Yc || {});
class LB {
  constructor(t, e) {
    this._lastBindBaseLocation = -1, this._lastBindCallId = -1, this.buffer = t || null, this.updateID = -1, this.byteLength = -1, this.type = e;
  }
}
class PT {
  /**
   * @param {Renderer} renderer - The renderer this System works for.
   */
  constructor(t) {
    this._gpuBuffers = /* @__PURE__ */ Object.create(null), this._boundBufferBases = /* @__PURE__ */ Object.create(null), this._minBaseLocation = 0, this._nextBindBaseIndex = this._minBaseLocation, this._bindCallId = 0, this._renderer = t, this._renderer.renderableGC.addManagedHash(this, "_gpuBuffers");
  }
  /** @ignore */
  destroy() {
    this._renderer = null, this._gl = null, this._gpuBuffers = null, this._boundBufferBases = null;
  }
  /** Sets up the renderer context and necessary buffers. */
  contextChange() {
    this._gl = this._renderer.gl, this._gpuBuffers = /* @__PURE__ */ Object.create(null), this._maxBindings = this._renderer.limits.maxUniformBindings;
  }
  getGlBuffer(t) {
    return this._gpuBuffers[t.uid] || this.createGLBuffer(t);
  }
  /**
   * This binds specified buffer. On first run, it will create the webGL buffers for the context too
   * @param buffer - the buffer to bind to the renderer
   */
  bind(t) {
    const { _gl: e } = this, i = this.getGlBuffer(t);
    e.bindBuffer(i.type, i.buffer);
  }
  /**
   * Binds an uniform buffer to at the given index.
   *
   * A cache is used so a buffer will not be bound again if already bound.
   * @param glBuffer - the buffer to bind
   * @param index - the base index to bind it to.
   */
  bindBufferBase(t, e) {
    const { _gl: i } = this;
    this._boundBufferBases[e] !== t && (this._boundBufferBases[e] = t, t._lastBindBaseLocation = e, i.bindBufferBase(i.UNIFORM_BUFFER, e, t.buffer));
  }
  nextBindBase(t) {
    this._bindCallId++, this._minBaseLocation = 0, t && (this._boundBufferBases[0] = null, this._minBaseLocation = 1, this._nextBindBaseIndex < 1 && (this._nextBindBaseIndex = 1));
  }
  freeLocationForBufferBase(t) {
    let e = this.getLastBindBaseLocation(t);
    if (e >= this._minBaseLocation)
      return t._lastBindCallId = this._bindCallId, e;
    let i = 0, s = this._nextBindBaseIndex;
    for (; i < 2; ) {
      s >= this._maxBindings && (s = this._minBaseLocation, i++);
      const o = this._boundBufferBases[s];
      if (o && o._lastBindCallId === this._bindCallId) {
        s++;
        continue;
      }
      break;
    }
    return e = s, this._nextBindBaseIndex = s + 1, i >= 2 ? -1 : (t._lastBindCallId = this._bindCallId, this._boundBufferBases[e] = null, e);
  }
  getLastBindBaseLocation(t) {
    const e = t._lastBindBaseLocation;
    return this._boundBufferBases[e] === t ? e : -1;
  }
  /**
   * Binds a buffer whilst also binding its range.
   * This will make the buffer start from the offset supplied rather than 0 when it is read.
   * @param glBuffer - the buffer to bind
   * @param index - the base index to bind at, defaults to 0
   * @param offset - the offset to bind at (this is blocks of 256). 0 = 0, 1 = 256, 2 = 512 etc
   * @param size - the size to bind at (this is blocks of 256).
   */
  bindBufferRange(t, e, i, s) {
    const { _gl: o } = this;
    i || (i = 0), e || (e = 0), this._boundBufferBases[e] = null, o.bindBufferRange(o.UNIFORM_BUFFER, e || 0, t.buffer, i * 256, s || 256);
  }
  /**
   * Will ensure the data in the buffer is uploaded to the GPU.
   * @param {Buffer} buffer - the buffer to update
   */
  updateBuffer(t) {
    const { _gl: e } = this, i = this.getGlBuffer(t);
    if (t._updateID === i.updateID)
      return i;
    i.updateID = t._updateID, e.bindBuffer(i.type, i.buffer);
    const s = t.data, o = t.descriptor.usage & Qt.STATIC ? e.STATIC_DRAW : e.DYNAMIC_DRAW;
    return s ? i.byteLength >= s.byteLength ? e.bufferSubData(i.type, 0, s, 0, t._updateSize / s.BYTES_PER_ELEMENT) : (i.byteLength = s.byteLength, e.bufferData(i.type, s, o)) : (i.byteLength = t.descriptor.size, e.bufferData(i.type, i.byteLength, o)), i;
  }
  /** dispose all WebGL resources of all managed buffers */
  destroyAll() {
    const t = this._gl;
    for (const e in this._gpuBuffers)
      t.deleteBuffer(this._gpuBuffers[e].buffer);
    this._gpuBuffers = /* @__PURE__ */ Object.create(null);
  }
  /**
   * Disposes buffer
   * @param {Buffer} buffer - buffer with data
   * @param {boolean} [contextLost=false] - If context was lost, we suppress deleteVertexArray
   */
  onBufferDestroy(t, e) {
    const i = this._gpuBuffers[t.uid], s = this._gl;
    e || s.deleteBuffer(i.buffer), this._gpuBuffers[t.uid] = null;
  }
  /**
   * creates and attaches a GLBuffer object tied to the current context.
   * @param buffer
   * @protected
   */
  createGLBuffer(t) {
    const { _gl: e } = this;
    let i = Yc.ARRAY_BUFFER;
    t.descriptor.usage & Qt.INDEX ? i = Yc.ELEMENT_ARRAY_BUFFER : t.descriptor.usage & Qt.UNIFORM && (i = Yc.UNIFORM_BUFFER);
    const s = new LB(e.createBuffer(), i);
    return this._gpuBuffers[t.uid] = s, t.on("destroy", this.onBufferDestroy, this), s;
  }
  resetState() {
    this._boundBufferBases = /* @__PURE__ */ Object.create(null);
  }
}
PT.extension = {
  type: [
    W.WebGLSystem
  ],
  name: "buffer"
};
const Tg = class BT {
  /** @param renderer - The renderer this System works for. */
  constructor(t) {
    this.supports = {
      /** Support for 32-bit indices buffer. */
      uint32Indices: !0,
      /** Support for UniformBufferObjects */
      uniformBufferObject: !0,
      /** Support for VertexArrayObjects */
      vertexArrayObject: !0,
      /** Support for SRGB texture format */
      srgbTextures: !0,
      /** Support for wrapping modes if a texture is non-power of two */
      nonPowOf2wrapping: !0,
      /** Support for MSAA (antialiasing of dynamic textures) */
      msaa: !0,
      /** Support for mipmaps if a texture is non-power of two */
      nonPowOf2mipmaps: !0
    }, this._renderer = t, this.extensions = /* @__PURE__ */ Object.create(null), this.handleContextLost = this.handleContextLost.bind(this), this.handleContextRestored = this.handleContextRestored.bind(this);
  }
  /**
   * `true` if the context is lost
   * @readonly
   */
  get isLost() {
    return !this.gl || this.gl.isContextLost();
  }
  /**
   * Handles the context change event.
   * @param {WebGLRenderingContext} gl - New WebGL context.
   */
  contextChange(t) {
    this.gl = t, this._renderer.gl = t;
  }
  init(t) {
    t = { ...BT.defaultOptions, ...t };
    let e = this.multiView = t.multiView;
    if (t.context && e && ($t("Renderer created with both a context and multiview enabled. Disabling multiView as both cannot work together."), e = !1), e ? this.canvas = ve.get().createCanvas(this._renderer.canvas.width, this._renderer.canvas.height) : this.canvas = this._renderer.view.canvas, t.context)
      this.initFromContext(t.context);
    else {
      const i = this._renderer.background.alpha < 1, s = t.premultipliedAlpha ?? !0, o = t.antialias && !this._renderer.backBuffer.useBackBuffer;
      this.createContext(t.preferWebGLVersion, {
        alpha: i,
        premultipliedAlpha: s,
        antialias: o,
        stencil: !0,
        preserveDrawingBuffer: t.preserveDrawingBuffer,
        powerPreference: t.powerPreference ?? "default"
      });
    }
  }
  ensureCanvasSize(t) {
    if (!this.multiView) {
      t !== this.canvas && $t("multiView is disabled, but targetCanvas is not the main canvas");
      return;
    }
    const { canvas: e } = this;
    (e.width < t.width || e.height < t.height) && (e.width = Math.max(t.width, t.width), e.height = Math.max(t.height, t.height));
  }
  /**
   * Initializes the context.
   * @protected
   * @param {WebGLRenderingContext} gl - WebGL context
   */
  initFromContext(t) {
    this.gl = t, this.webGLVersion = t instanceof ve.get().getWebGLRenderingContext() ? 1 : 2, this.getExtensions(), this.validateContext(t), this._renderer.runners.contextChange.emit(t);
    const e = this._renderer.view.canvas;
    e.addEventListener("webglcontextlost", this.handleContextLost, !1), e.addEventListener("webglcontextrestored", this.handleContextRestored, !1);
  }
  /**
   * Initialize from context options
   * @protected
   * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext
   * @param preferWebGLVersion
   * @param {object} options - context attributes
   */
  createContext(t, e) {
    let i;
    const s = this.canvas;
    if (t === 2 && (i = s.getContext("webgl2", e)), !i && (i = s.getContext("webgl", e), !i))
      throw new Error("This browser does not support WebGL. Try using the canvas renderer");
    this.gl = i, this.initFromContext(this.gl);
  }
  /** Auto-populate the {@link GlContextSystem.extensions extensions}. */
  getExtensions() {
    const { gl: t } = this, e = {
      anisotropicFiltering: t.getExtension("EXT_texture_filter_anisotropic"),
      floatTextureLinear: t.getExtension("OES_texture_float_linear"),
      s3tc: t.getExtension("WEBGL_compressed_texture_s3tc"),
      s3tc_sRGB: t.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
      // eslint-disable-line camelcase
      etc: t.getExtension("WEBGL_compressed_texture_etc"),
      etc1: t.getExtension("WEBGL_compressed_texture_etc1"),
      pvrtc: t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
      atc: t.getExtension("WEBGL_compressed_texture_atc"),
      astc: t.getExtension("WEBGL_compressed_texture_astc"),
      bptc: t.getExtension("EXT_texture_compression_bptc"),
      rgtc: t.getExtension("EXT_texture_compression_rgtc"),
      loseContext: t.getExtension("WEBGL_lose_context")
    };
    if (this.webGLVersion === 1)
      this.extensions = {
        ...e,
        drawBuffers: t.getExtension("WEBGL_draw_buffers"),
        depthTexture: t.getExtension("WEBGL_depth_texture"),
        vertexArrayObject: t.getExtension("OES_vertex_array_object") || t.getExtension("MOZ_OES_vertex_array_object") || t.getExtension("WEBKIT_OES_vertex_array_object"),
        uint32ElementIndex: t.getExtension("OES_element_index_uint"),
        // Floats and half-floats
        floatTexture: t.getExtension("OES_texture_float"),
        floatTextureLinear: t.getExtension("OES_texture_float_linear"),
        textureHalfFloat: t.getExtension("OES_texture_half_float"),
        textureHalfFloatLinear: t.getExtension("OES_texture_half_float_linear"),
        vertexAttribDivisorANGLE: t.getExtension("ANGLE_instanced_arrays"),
        srgb: t.getExtension("EXT_sRGB")
      };
    else {
      this.extensions = {
        ...e,
        colorBufferFloat: t.getExtension("EXT_color_buffer_float")
      };
      const i = t.getExtension("WEBGL_provoking_vertex");
      i && i.provokingVertexWEBGL(i.FIRST_VERTEX_CONVENTION_WEBGL);
    }
  }
  /**
   * Handles a lost webgl context
   * @param {WebGLContextEvent} event - The context lost event.
   */
  handleContextLost(t) {
    t.preventDefault(), this._contextLossForced && (this._contextLossForced = !1, setTimeout(() => {
      this.gl.isContextLost() && this.extensions.loseContext?.restoreContext();
    }, 0));
  }
  /** Handles a restored webgl context. */
  handleContextRestored() {
    this.getExtensions(), this._renderer.runners.contextChange.emit(this.gl);
  }
  destroy() {
    const t = this._renderer.view.canvas;
    this._renderer = null, t.removeEventListener("webglcontextlost", this.handleContextLost), t.removeEventListener("webglcontextrestored", this.handleContextRestored), this.gl.useProgram(null), this.extensions.loseContext?.loseContext();
  }
  /**
   * this function can be called to force a webGL context loss
   * this will release all resources on the GPU.
   * Useful if you need to put Pixi to sleep, and save some GPU memory
   *
   * As soon as render is called - all resources will be created again.
   */
  forceContextLoss() {
    this.extensions.loseContext?.loseContext(), this._contextLossForced = !0;
  }
  /**
   * Validate context.
   * @param {WebGLRenderingContext} gl - Render context.
   */
  validateContext(t) {
    const e = t.getContextAttributes();
    e && !e.stencil && $t("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
    const i = this.supports, s = this.webGLVersion === 2, o = this.extensions;
    i.uint32Indices = s || !!o.uint32ElementIndex, i.uniformBufferObject = s, i.vertexArrayObject = s || !!o.vertexArrayObject, i.srgbTextures = s || !!o.srgb, i.nonPowOf2wrapping = s, i.nonPowOf2mipmaps = s, i.msaa = s, i.uint32Indices || $t("Provided WebGL context does not support 32 index buffer, large scenes may not render correctly");
  }
};
Tg.extension = {
  type: [
    W.WebGLSystem
  ],
  name: "context"
};
Tg.defaultOptions = {
  /**
   * {@link WebGLOptions.context}
   * @default null
   */
  context: null,
  /**
   * {@link WebGLOptions.premultipliedAlpha}
   * @default true
   */
  premultipliedAlpha: !0,
  /**
   * {@link WebGLOptions.preserveDrawingBuffer}
   * @default false
   */
  preserveDrawingBuffer: !1,
  /**
   * {@link WebGLOptions.powerPreference}
   * @default default
   */
  powerPreference: void 0,
  /**
   * {@link WebGLOptions.webGLVersion}
   * @default 2
   */
  preferWebGLVersion: 2,
  /**
   * {@link WebGLOptions.multiView}
   * @default false
   */
  multiView: !1
};
let FB = Tg;
function kT(n, t) {
  for (const e in n.attributes) {
    const i = n.attributes[e], s = t[e];
    s ? (i.format ?? (i.format = s.format), i.offset ?? (i.offset = s.offset), i.instance ?? (i.instance = s.instance)) : $t(`Attribute ${e} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`);
  }
  HB(n);
}
function HB(n) {
  const { buffers: t, attributes: e } = n, i = {}, s = {};
  for (const o in t) {
    const l = t[o];
    i[l.uid] = 0, s[l.uid] = 0;
  }
  for (const o in e) {
    const l = e[o];
    i[l.buffer.uid] += Jr(l.format).stride;
  }
  for (const o in e) {
    const l = e[o];
    l.stride ?? (l.stride = i[l.buffer.uid]), l.start ?? (l.start = s[l.buffer.uid]), s[l.buffer.uid] += Jr(l.format).stride;
  }
}
var Mm = /* @__PURE__ */ ((n) => (n[n.RGBA = 6408] = "RGBA", n[n.RGB = 6407] = "RGB", n[n.RG = 33319] = "RG", n[n.RED = 6403] = "RED", n[n.RGBA_INTEGER = 36249] = "RGBA_INTEGER", n[n.RGB_INTEGER = 36248] = "RGB_INTEGER", n[n.RG_INTEGER = 33320] = "RG_INTEGER", n[n.RED_INTEGER = 36244] = "RED_INTEGER", n[n.ALPHA = 6406] = "ALPHA", n[n.LUMINANCE = 6409] = "LUMINANCE", n[n.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", n[n.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", n[n.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL", n))(Mm || {}), OT = /* @__PURE__ */ ((n) => (n[n.TEXTURE_2D = 3553] = "TEXTURE_2D", n[n.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", n[n.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", n[n.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", n[n.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", n[n.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", n[n.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", n[n.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", n[n.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z", n))(OT || {}), ee = /* @__PURE__ */ ((n) => (n[n.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", n[n.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", n[n.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", n[n.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", n[n.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", n[n.UNSIGNED_INT = 5125] = "UNSIGNED_INT", n[n.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", n[n.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", n[n.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", n[n.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", n[n.BYTE = 5120] = "BYTE", n[n.SHORT = 5122] = "SHORT", n[n.INT = 5124] = "INT", n[n.FLOAT = 5126] = "FLOAT", n[n.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", n[n.HALF_FLOAT = 36193] = "HALF_FLOAT", n))(ee || {});
const M0 = {
  uint8x2: ee.UNSIGNED_BYTE,
  uint8x4: ee.UNSIGNED_BYTE,
  sint8x2: ee.BYTE,
  sint8x4: ee.BYTE,
  unorm8x2: ee.UNSIGNED_BYTE,
  unorm8x4: ee.UNSIGNED_BYTE,
  snorm8x2: ee.BYTE,
  snorm8x4: ee.BYTE,
  uint16x2: ee.UNSIGNED_SHORT,
  uint16x4: ee.UNSIGNED_SHORT,
  sint16x2: ee.SHORT,
  sint16x4: ee.SHORT,
  unorm16x2: ee.UNSIGNED_SHORT,
  unorm16x4: ee.UNSIGNED_SHORT,
  snorm16x2: ee.SHORT,
  snorm16x4: ee.SHORT,
  float16x2: ee.HALF_FLOAT,
  float16x4: ee.HALF_FLOAT,
  float32: ee.FLOAT,
  float32x2: ee.FLOAT,
  float32x3: ee.FLOAT,
  float32x4: ee.FLOAT,
  uint32: ee.UNSIGNED_INT,
  uint32x2: ee.UNSIGNED_INT,
  uint32x3: ee.UNSIGNED_INT,
  uint32x4: ee.UNSIGNED_INT,
  sint32: ee.INT,
  sint32x2: ee.INT,
  sint32x3: ee.INT,
  sint32x4: ee.INT
};
function $B(n) {
  return M0[n] ?? M0.float32;
}
const WB = {
  "point-list": 0,
  "line-list": 1,
  "line-strip": 3,
  "triangle-list": 4,
  "triangle-strip": 5
};
class DT {
  /** @param renderer - The renderer this System works for. */
  constructor(t) {
    this._geometryVaoHash = /* @__PURE__ */ Object.create(null), this._renderer = t, this._activeGeometry = null, this._activeVao = null, this.hasVao = !0, this.hasInstance = !0, this._renderer.renderableGC.addManagedHash(this, "_geometryVaoHash");
  }
  /** Sets up the renderer context and necessary buffers. */
  contextChange() {
    const t = this.gl = this._renderer.gl;
    if (!this._renderer.context.supports.vertexArrayObject)
      throw new Error("[PixiJS] Vertex Array Objects are not supported on this device");
    const e = this._renderer.context.extensions.vertexArrayObject;
    e && (t.createVertexArray = () => e.createVertexArrayOES(), t.bindVertexArray = (s) => e.bindVertexArrayOES(s), t.deleteVertexArray = (s) => e.deleteVertexArrayOES(s));
    const i = this._renderer.context.extensions.vertexAttribDivisorANGLE;
    i && (t.drawArraysInstanced = (s, o, l, c) => {
      i.drawArraysInstancedANGLE(s, o, l, c);
    }, t.drawElementsInstanced = (s, o, l, c, d) => {
      i.drawElementsInstancedANGLE(s, o, l, c, d);
    }, t.vertexAttribDivisor = (s, o) => i.vertexAttribDivisorANGLE(s, o)), this._activeGeometry = null, this._activeVao = null, this._geometryVaoHash = /* @__PURE__ */ Object.create(null);
  }
  /**
   * Binds geometry so that is can be drawn. Creating a Vao if required
   * @param geometry - Instance of geometry to bind.
   * @param program - Instance of program to use vao for.
   */
  bind(t, e) {
    const i = this.gl;
    this._activeGeometry = t;
    const s = this.getVao(t, e);
    this._activeVao !== s && (this._activeVao = s, i.bindVertexArray(s)), this.updateBuffers();
  }
  /** Reset and unbind any active VAO and geometry. */
  resetState() {
    this.unbind();
  }
  /** Update buffers of the currently bound geometry. */
  updateBuffers() {
    const t = this._activeGeometry, e = this._renderer.buffer;
    for (let i = 0; i < t.buffers.length; i++) {
      const s = t.buffers[i];
      e.updateBuffer(s);
    }
  }
  /**
   * Check compatibility between a geometry and a program
   * @param geometry - Geometry instance.
   * @param program - Program instance.
   */
  checkCompatibility(t, e) {
    const i = t.attributes, s = e._attributeData;
    for (const o in s)
      if (!i[o])
        throw new Error(`shader and geometry incompatible, geometry missing the "${o}" attribute`);
  }
  /**
   * Takes a geometry and program and generates a unique signature for them.
   * @param geometry - To get signature from.
   * @param program - To test geometry against.
   * @returns - Unique signature of the geometry and program
   */
  getSignature(t, e) {
    const i = t.attributes, s = e._attributeData, o = ["g", t.uid];
    for (const l in i)
      s[l] && o.push(l, s[l].location);
    return o.join("-");
  }
  getVao(t, e) {
    return this._geometryVaoHash[t.uid]?.[e._key] || this.initGeometryVao(t, e);
  }
  /**
   * Creates or gets Vao with the same structure as the geometry and stores it on the geometry.
   * If vao is created, it is bound automatically. We use a shader to infer what and how to set up the
   * attribute locations.
   * @param geometry - Instance of geometry to to generate Vao for.
   * @param program
   * @param _incRefCount - Increment refCount of all geometry buffers.
   */
  initGeometryVao(t, e, i = !0) {
    const s = this._renderer.gl, o = this._renderer.buffer;
    this._renderer.shader._getProgramData(e), this.checkCompatibility(t, e);
    const l = this.getSignature(t, e);
    this._geometryVaoHash[t.uid] || (this._geometryVaoHash[t.uid] = /* @__PURE__ */ Object.create(null), t.on("destroy", this.onGeometryDestroy, this));
    const c = this._geometryVaoHash[t.uid];
    let d = c[l];
    if (d)
      return c[e._key] = d, d;
    kT(t, e._attributeData);
    const f = t.buffers;
    d = s.createVertexArray(), s.bindVertexArray(d);
    for (let m = 0; m < f.length; m++) {
      const y = f[m];
      o.bind(y);
    }
    return this.activateVao(t, e), c[e._key] = d, c[l] = d, s.bindVertexArray(null), d;
  }
  /**
   * Disposes geometry.
   * @param geometry - Geometry with buffers. Only VAO will be disposed
   * @param [contextLost=false] - If context was lost, we suppress deleteVertexArray
   */
  onGeometryDestroy(t, e) {
    const i = this._geometryVaoHash[t.uid], s = this.gl;
    if (i) {
      if (e)
        for (const o in i)
          this._activeVao !== i[o] && this.unbind(), s.deleteVertexArray(i[o]);
      this._geometryVaoHash[t.uid] = null;
    }
  }
  /**
   * Dispose all WebGL resources of all managed geometries.
   * @param [contextLost=false] - If context was lost, we suppress `gl.delete` calls
   */
  destroyAll(t = !1) {
    const e = this.gl;
    for (const i in this._geometryVaoHash) {
      if (t)
        for (const s in this._geometryVaoHash[i]) {
          const o = this._geometryVaoHash[i];
          this._activeVao !== o && this.unbind(), e.deleteVertexArray(o[s]);
        }
      this._geometryVaoHash[i] = null;
    }
  }
  /**
   * Activate vertex array object.
   * @param geometry - Geometry instance.
   * @param program - Shader program instance.
   */
  activateVao(t, e) {
    const i = this._renderer.gl, s = this._renderer.buffer, o = t.attributes;
    t.indexBuffer && s.bind(t.indexBuffer);
    let l = null;
    for (const c in o) {
      const d = o[c], f = d.buffer, m = s.getGlBuffer(f), y = e._attributeData[c];
      if (y) {
        l !== m && (s.bind(f), l = m);
        const b = y.location;
        i.enableVertexAttribArray(b);
        const v = Jr(d.format), x = $B(d.format);
        if (y.format?.substring(1, 4) === "int" ? i.vertexAttribIPointer(
          b,
          v.size,
          x,
          d.stride,
          d.offset
        ) : i.vertexAttribPointer(
          b,
          v.size,
          x,
          v.normalised,
          d.stride,
          d.offset
        ), d.instance)
          if (this.hasInstance) {
            const S = d.divisor ?? 1;
            i.vertexAttribDivisor(b, S);
          } else
            throw new Error("geometry error, GPU Instancing is not supported on this device");
      }
    }
  }
  /**
   * Draws the currently bound geometry.
   * @param topology - The type primitive to render.
   * @param size - The number of elements to be rendered. If not specified, all vertices after the
   *  starting vertex will be drawn.
   * @param start - The starting vertex in the geometry to start drawing from. If not specified,
   *  drawing will start from the first vertex.
   * @param instanceCount - The number of instances of the set of elements to execute. If not specified,
   *  all instances will be drawn.
   * @returns This instance of the geometry system.
   */
  draw(t, e, i, s) {
    const { gl: o } = this._renderer, l = this._activeGeometry, c = WB[t || l.topology];
    if (s ?? (s = l.instanceCount), l.indexBuffer) {
      const d = l.indexBuffer.data.BYTES_PER_ELEMENT, f = d === 2 ? o.UNSIGNED_SHORT : o.UNSIGNED_INT;
      s > 1 ? o.drawElementsInstanced(c, e || l.indexBuffer.data.length, f, (i || 0) * d, s) : o.drawElements(c, e || l.indexBuffer.data.length, f, (i || 0) * d);
    } else s > 1 ? o.drawArraysInstanced(c, i || 0, e || l.getSize(), s) : o.drawArrays(c, i || 0, e || l.getSize());
    return this;
  }
  /** Unbind/reset everything. */
  unbind() {
    this.gl.bindVertexArray(null), this._activeVao = null, this._activeGeometry = null;
  }
  destroy() {
    this._renderer = null, this.gl = null, this._activeVao = null, this._activeGeometry = null, this._geometryVaoHash = null;
  }
}
DT.extension = {
  type: [
    W.WebGLSystem
  ],
  name: "geometry"
};
const VB = new ql({
  attributes: {
    aPosition: [
      -1,
      -1,
      // Bottom left corner
      3,
      -1,
      // Bottom right corner, extending beyond right edge
      -1,
      3
      // Top left corner, extending beyond top edge
    ]
  }
}), wg = class GT {
  constructor(t) {
    this.useBackBuffer = !1, this._useBackBufferThisRender = !1, this._renderer = t;
  }
  init(t = {}) {
    const { useBackBuffer: e, antialias: i } = { ...GT.defaultOptions, ...t };
    this.useBackBuffer = e, this._antialias = i, this._renderer.context.supports.msaa || ($t("antialiasing, is not supported on when using the back buffer"), this._antialias = !1), this._state = wi.for2d();
    const s = new eo({
      vertex: `
                attribute vec2 aPosition;
                out vec2 vUv;

                void main() {
                    gl_Position = vec4(aPosition, 0.0, 1.0);

                    vUv = (aPosition + 1.0) / 2.0;

                    // flip dem UVs
                    vUv.y = 1.0 - vUv.y;
                }`,
      fragment: `
                in vec2 vUv;
                out vec4 finalColor;

                uniform sampler2D uTexture;

                void main() {
                    finalColor = texture(uTexture, vUv);
                }`,
      name: "big-triangle"
    });
    this._bigTriangleShader = new fi({
      glProgram: s,
      resources: {
        uTexture: Tt.WHITE.source
      }
    });
  }
  /**
   * This is called before the RenderTargetSystem is started. This is where
   * we replace the target with the back buffer if required.
   * @param options - The options for this render.
   */
  renderStart(t) {
    const e = this._renderer.renderTarget.getRenderTarget(t.target);
    if (this._useBackBufferThisRender = this.useBackBuffer && !!e.isRoot, this._useBackBufferThisRender) {
      const i = this._renderer.renderTarget.getRenderTarget(t.target);
      this._targetTexture = i.colorTexture, t.target = this._getBackBufferTexture(i.colorTexture);
    }
  }
  renderEnd() {
    this._presentBackBuffer();
  }
  _presentBackBuffer() {
    const t = this._renderer;
    t.renderTarget.finishRenderPass(), this._useBackBufferThisRender && (t.renderTarget.bind(this._targetTexture, !1), this._bigTriangleShader.resources.uTexture = this._backBufferTexture.source, t.encoder.draw({
      geometry: VB,
      shader: this._bigTriangleShader,
      state: this._state
    }));
  }
  _getBackBufferTexture(t) {
    return this._backBufferTexture = this._backBufferTexture || new Tt({
      source: new rn({
        width: t.width,
        height: t.height,
        resolution: t._resolution,
        antialias: this._antialias
      })
    }), this._backBufferTexture.source.resize(
      t.width,
      t.height,
      t._resolution
    ), this._backBufferTexture;
  }
  /** destroys the back buffer */
  destroy() {
    this._backBufferTexture && (this._backBufferTexture.destroy(), this._backBufferTexture = null);
  }
};
wg.extension = {
  type: [
    W.WebGLSystem
  ],
  name: "backBuffer",
  priority: 1
};
wg.defaultOptions = {
  /** if true will use the back buffer where required */
  useBackBuffer: !1
};
let jB = wg;
class UT {
  constructor(t) {
    this._colorMaskCache = 15, this._renderer = t;
  }
  setMask(t) {
    this._colorMaskCache !== t && (this._colorMaskCache = t, this._renderer.gl.colorMask(
      !!(t & 8),
      !!(t & 4),
      !!(t & 2),
      !!(t & 1)
    ));
  }
}
UT.extension = {
  type: [
    W.WebGLSystem
  ],
  name: "colorMask"
};
class NT {
  constructor(t) {
    this.commandFinished = Promise.resolve(), this._renderer = t;
  }
  setGeometry(t, e) {
    this._renderer.geometry.bind(t, e.glProgram);
  }
  finishRenderPass() {
  }
  draw(t) {
    const e = this._renderer, { geometry: i, shader: s, state: o, skipSync: l, topology: c, size: d, start: f, instanceCount: m } = t;
    e.shader.bind(s, l), e.geometry.bind(i, e.shader._activeProgram), o && e.state.set(o), e.geometry.draw(c, d, f, m ?? i.instanceCount);
  }
  destroy() {
    this._renderer = null;
  }
}
NT.extension = {
  type: [
    W.WebGLSystem
  ],
  name: "encoder"
};
class IT {
  constructor(t) {
    this._renderer = t;
  }
  contextChange() {
    const t = this._renderer.gl;
    this.maxTextures = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS), this.maxBatchableTextures = Q1(this.maxTextures, t);
    const e = this._renderer.context.webGLVersion === 2;
    this.maxUniformBindings = e ? t.getParameter(t.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
  }
  destroy() {
  }
}
IT.extension = {
  type: [
    W.WebGLSystem
  ],
  name: "limits"
};
class YB {
  constructor() {
    this.width = -1, this.height = -1, this.msaa = !1, this.msaaRenderBuffer = [];
  }
}
const ns = [];
ns[Ye.NONE] = void 0;
ns[Ye.DISABLED] = {
  stencilWriteMask: 0,
  stencilReadMask: 0
};
ns[Ye.RENDERING_MASK_ADD] = {
  stencilFront: {
    compare: "equal",
    passOp: "increment-clamp"
  },
  stencilBack: {
    compare: "equal",
    passOp: "increment-clamp"
  }
};
ns[Ye.RENDERING_MASK_REMOVE] = {
  stencilFront: {
    compare: "equal",
    passOp: "decrement-clamp"
  },
  stencilBack: {
    compare: "equal",
    passOp: "decrement-clamp"
  }
};
ns[Ye.MASK_ACTIVE] = {
  stencilWriteMask: 0,
  stencilFront: {
    compare: "equal",
    passOp: "keep"
  },
  stencilBack: {
    compare: "equal",
    passOp: "keep"
  }
};
ns[Ye.INVERSE_MASK_ACTIVE] = {
  stencilWriteMask: 0,
  stencilFront: {
    compare: "not-equal",
    passOp: "keep"
  },
  stencilBack: {
    compare: "not-equal",
    passOp: "keep"
  }
};
class zT {
  constructor(t) {
    this._stencilCache = {
      enabled: !1,
      stencilReference: 0,
      stencilMode: Ye.NONE
    }, this._renderTargetStencilState = /* @__PURE__ */ Object.create(null), t.renderTarget.onRenderTargetChange.add(this);
  }
  contextChange(t) {
    this._gl = t, this._comparisonFuncMapping = {
      always: t.ALWAYS,
      never: t.NEVER,
      equal: t.EQUAL,
      "not-equal": t.NOTEQUAL,
      less: t.LESS,
      "less-equal": t.LEQUAL,
      greater: t.GREATER,
      "greater-equal": t.GEQUAL
    }, this._stencilOpsMapping = {
      keep: t.KEEP,
      zero: t.ZERO,
      replace: t.REPLACE,
      invert: t.INVERT,
      "increment-clamp": t.INCR,
      "decrement-clamp": t.DECR,
      "increment-wrap": t.INCR_WRAP,
      "decrement-wrap": t.DECR_WRAP
    }, this.resetState();
  }
  onRenderTargetChange(t) {
    if (this._activeRenderTarget === t)
      return;
    this._activeRenderTarget = t;
    let e = this._renderTargetStencilState[t.uid];
    e || (e = this._renderTargetStencilState[t.uid] = {
      stencilMode: Ye.DISABLED,
      stencilReference: 0
    }), this.setStencilMode(e.stencilMode, e.stencilReference);
  }
  resetState() {
    this._stencilCache.enabled = !1, this._stencilCache.stencilMode = Ye.NONE, this._stencilCache.stencilReference = 0;
  }
  setStencilMode(t, e) {
    const i = this._renderTargetStencilState[this._activeRenderTarget.uid], s = this._gl, o = ns[t], l = this._stencilCache;
    if (i.stencilMode = t, i.stencilReference = e, t === Ye.DISABLED) {
      this._stencilCache.enabled && (this._stencilCache.enabled = !1, s.disable(s.STENCIL_TEST));
      return;
    }
    this._stencilCache.enabled || (this._stencilCache.enabled = !0, s.enable(s.STENCIL_TEST)), (t !== l.stencilMode || l.stencilReference !== e) && (l.stencilMode = t, l.stencilReference = e, s.stencilFunc(this._comparisonFuncMapping[o.stencilBack.compare], e, 255), s.stencilOp(s.KEEP, s.KEEP, this._stencilOpsMapping[o.stencilBack.passOp]));
  }
}
zT.extension = {
  type: [
    W.WebGLSystem
  ],
  name: "stencil"
};
class LT {
  constructor(t) {
    this._syncFunctionHash = /* @__PURE__ */ Object.create(null), this._adaptor = t, this._systemCheck();
  }
  /**
   * Overridable function by `pixi.js/unsafe-eval` to silence
   * throwing an error if platform doesn't support unsafe-evals.
   * @private
   */
  _systemCheck() {
    if (!U1())
      throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");
  }
  ensureUniformGroup(t) {
    const e = this.getUniformGroupData(t);
    t.buffer || (t.buffer = new Zn({
      data: new Float32Array(e.layout.size / 4),
      usage: Qt.UNIFORM | Qt.COPY_DST
    }));
  }
  getUniformGroupData(t) {
    return this._syncFunctionHash[t._signature] || this._initUniformGroup(t);
  }
  _initUniformGroup(t) {
    const e = t._signature;
    let i = this._syncFunctionHash[e];
    if (!i) {
      const s = Object.keys(t.uniformStructures).map((c) => t.uniformStructures[c]), o = this._adaptor.createUboElements(s), l = this._generateUboSync(o.uboElements);
      i = this._syncFunctionHash[e] = {
        layout: o,
        syncFunction: l
      };
    }
    return this._syncFunctionHash[e];
  }
  _generateUboSync(t) {
    return this._adaptor.generateUboSync(t);
  }
  syncUniformGroup(t, e, i) {
    const s = this.getUniformGroupData(t);
    t.buffer || (t.buffer = new Zn({
      data: new Float32Array(s.layout.size / 4),
      usage: Qt.UNIFORM | Qt.COPY_DST
    }));
    let o = null;
    return e || (e = t.buffer.data, o = t.buffer.dataInt32), i || (i = 0), s.syncFunction(t.uniforms, e, o, i), !0;
  }
  updateUniformGroup(t) {
    if (t.isStatic && !t._dirtyId)
      return !1;
    t._dirtyId = 0;
    const e = this.syncUniformGroup(t);
    return t.buffer.update(), e;
  }
  destroy() {
    this._syncFunctionHash = null;
  }
}
const FT = {
  f32: 4,
  i32: 4,
  "vec2<f32>": 8,
  "vec3<f32>": 12,
  "vec4<f32>": 16,
  "vec2<i32>": 8,
  "vec3<i32>": 12,
  "vec4<i32>": 16,
  "mat2x2<f32>": 32,
  "mat3x3<f32>": 48,
  "mat4x4<f32>": 64
  // TODO - not essential for now but support these in the future
  // int:      4,
  // ivec2:    8,
  // ivec3:    12,
  // ivec4:    16,
  // uint:     4,
  // uvec2:    8,
  // uvec3:    12,
  // uvec4:    16,
  // bool:     4,
  // bvec2:    8,
  // bvec3:    12,
  // bvec4:    16,
  // mat2:     16 * 2,
  // mat3:     16 * 3,
  // mat4:     16 * 4,
};
function XB(n) {
  const t = n.map((o) => ({
    data: o,
    offset: 0,
    size: 0
  })), e = 16;
  let i = 0, s = 0;
  for (let o = 0; o < t.length; o++) {
    const l = t[o];
    if (i = FT[l.data.type], !i)
      throw new Error(`Unknown type ${l.data.type}`);
    l.data.size > 1 && (i = Math.max(i, e) * l.data.size);
    const c = i === 12 ? 16 : i;
    l.size = i;
    const d = s % e;
    d > 0 && e - d < c ? s += (e - d) % 16 : s += (i - d % i) % i, l.offset = s, s += i;
  }
  return s = Math.ceil(s / 16) * 16, { uboElements: t, size: s };
}
const Os = [
  // uploading pixi matrix object to mat3
  {
    type: "mat3x3<f32>",
    test: (n) => n.value.a !== void 0,
    ubo: `
            var matrix = uv[name].toArray(true);
            data[offset] = matrix[0];
            data[offset + 1] = matrix[1];
            data[offset + 2] = matrix[2];
            data[offset + 4] = matrix[3];
            data[offset + 5] = matrix[4];
            data[offset + 6] = matrix[5];
            data[offset + 8] = matrix[6];
            data[offset + 9] = matrix[7];
            data[offset + 10] = matrix[8];
        `,
    uniform: `
            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));
        `
  },
  // uploading a pixi rectangle as a vec4
  {
    type: "vec4<f32>",
    test: (n) => n.type === "vec4<f32>" && n.size === 1 && n.value.width !== void 0,
    ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
            data[offset + 2] = v.width;
            data[offset + 3] = v.height;
        `,
    uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {
                cv[0] = v.x;
                cv[1] = v.y;
                cv[2] = v.width;
                cv[3] = v.height;
                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);
            }
        `
  },
  // uploading a pixi point as a vec2
  {
    type: "vec2<f32>",
    test: (n) => n.type === "vec2<f32>" && n.size === 1 && n.value.x !== void 0,
    ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
        `,
    uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y) {
                cv[0] = v.x;
                cv[1] = v.y;
                gl.uniform2f(ud[name].location, v.x, v.y);
            }
        `
  },
  // uploading a pixi color as a vec4
  {
    type: "vec4<f32>",
    test: (n) => n.type === "vec4<f32>" && n.size === 1 && n.value.red !== void 0,
    ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
            data[offset + 3] = v.alpha;
        `,
    uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                cv[3] = v.alpha;
                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);
            }
        `
  },
  // uploading a pixi color as a vec3
  {
    type: "vec3<f32>",
    test: (n) => n.type === "vec3<f32>" && n.size === 1 && n.value.red !== void 0,
    ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
        `,
    uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);
            }
        `
  }
];
function HT(n, t, e, i) {
  const s = [`
        var v = null;
        var v2 = null;
        var t = 0;
        var index = 0;
        var name = null;
        var arrayOffset = null;
    `];
  let o = 0;
  for (let c = 0; c < n.length; c++) {
    const d = n[c], f = d.data.name;
    let m = !1, y = 0;
    for (let b = 0; b < Os.length; b++)
      if (Os[b].test(d.data)) {
        y = d.offset / 4, s.push(
          `name = "${f}";`,
          `offset += ${y - o};`,
          Os[b][t] || Os[b].ubo
        ), m = !0;
        break;
      }
    if (!m)
      if (d.data.size > 1)
        y = d.offset / 4, s.push(e(d, y - o));
      else {
        const b = i[d.data.type];
        y = d.offset / 4, s.push(
          /* wgsl */
          `
                    v = uv.${f};
                    offset += ${y - o};
                    ${b};
                `
        );
      }
    o = y;
  }
  const l = s.join(`
`);
  return new Function(
    "uv",
    "data",
    "dataInt32",
    "offset",
    l
  );
}
function Ma(n, t) {
  return `
        for (let i = 0; i < ${n * t}; i++) {
            data[offset + (((i / ${n})|0) * 4) + (i % ${n})] = v[i];
        }
    `;
}
const $T = {
  f32: `
        data[offset] = v;`,
  i32: `
        dataInt32[offset] = v;`,
  "vec2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];`,
  "vec3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];`,
  "vec4<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];`,
  "vec2<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];`,
  "vec3<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];`,
  "vec4<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];
        dataInt32[offset + 3] = v[3];`,
  "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 4] = v[2];
        data[offset + 5] = v[3];`,
  "mat3x3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];
        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];`,
  "mat4x4<f32>": `
        for (let i = 0; i < 16; i++) {
            data[offset + i] = v[i];
        }`,
  "mat3x2<f32>": Ma(3, 2),
  "mat4x2<f32>": Ma(4, 2),
  "mat2x3<f32>": Ma(2, 3),
  "mat4x3<f32>": Ma(4, 3),
  "mat2x4<f32>": Ma(2, 4),
  "mat3x4<f32>": Ma(3, 4)
}, qB = {
  ...$T,
  "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];
    `
};
function KB(n, t) {
  const e = Math.max(FT[n.data.type] / 16, 1), i = n.data.value.length / n.data.size, s = (4 - i % 4) % 4, o = n.data.type.indexOf("i32") >= 0 ? "dataInt32" : "data";
  return `
        v = uv.${n.data.name};
        offset += ${t};

        arrayOffset = offset;

        t = 0;

        for(var i=0; i < ${n.data.size * e}; i++)
        {
            for(var j = 0; j < ${i}; j++)
            {
                ${o}[arrayOffset++] = v[t++];
            }
            ${s !== 0 ? `arrayOffset += ${s};` : ""}
        }
    `;
}
function ZB(n) {
  return HT(
    n,
    "uboStd40",
    KB,
    $T
  );
}
class WT extends LT {
  constructor() {
    super({
      createUboElements: XB,
      generateUboSync: ZB
    });
  }
}
WT.extension = {
  type: [W.WebGLSystem],
  name: "ubo"
};
class QB {
  constructor() {
    this._clearColorCache = [0, 0, 0, 0], this._viewPortCache = new ne();
  }
  init(t, e) {
    this._renderer = t, this._renderTargetSystem = e, t.runners.contextChange.add(this);
  }
  contextChange() {
    this._clearColorCache = [0, 0, 0, 0], this._viewPortCache = new ne();
  }
  copyToTexture(t, e, i, s, o) {
    const l = this._renderTargetSystem, c = this._renderer, d = l.getGpuRenderTarget(t), f = c.gl;
    return this.finishRenderPass(t), f.bindFramebuffer(f.FRAMEBUFFER, d.resolveTargetFramebuffer), c.texture.bind(e, 0), f.copyTexSubImage2D(
      f.TEXTURE_2D,
      0,
      o.x,
      o.y,
      i.x,
      i.y,
      s.width,
      s.height
    ), e;
  }
  startRenderPass(t, e = !0, i, s) {
    const o = this._renderTargetSystem, l = t.colorTexture, c = o.getGpuRenderTarget(t);
    let d = s.y;
    t.isRoot && (d = l.pixelHeight - s.height), t.colorTextures.forEach((y) => {
      this._renderer.texture.unbind(y);
    });
    const f = this._renderer.gl;
    f.bindFramebuffer(f.FRAMEBUFFER, c.framebuffer);
    const m = this._viewPortCache;
    (m.x !== s.x || m.y !== d || m.width !== s.width || m.height !== s.height) && (m.x = s.x, m.y = d, m.width = s.width, m.height = s.height, f.viewport(
      s.x,
      d,
      s.width,
      s.height
    )), !c.depthStencilRenderBuffer && (t.stencil || t.depth) && this._initStencil(c), this.clear(t, e, i);
  }
  finishRenderPass(t) {
    const i = this._renderTargetSystem.getGpuRenderTarget(t);
    if (!i.msaa)
      return;
    const s = this._renderer.gl;
    s.bindFramebuffer(s.FRAMEBUFFER, i.resolveTargetFramebuffer), s.bindFramebuffer(s.READ_FRAMEBUFFER, i.framebuffer), s.blitFramebuffer(
      0,
      0,
      i.width,
      i.height,
      0,
      0,
      i.width,
      i.height,
      s.COLOR_BUFFER_BIT,
      s.NEAREST
    ), s.bindFramebuffer(s.FRAMEBUFFER, i.framebuffer);
  }
  initGpuRenderTarget(t) {
    const i = this._renderer.gl, s = new YB();
    return t.colorTexture instanceof gr ? (this._renderer.context.ensureCanvasSize(t.colorTexture.resource), s.framebuffer = null, s) : (this._initColor(t, s), i.bindFramebuffer(i.FRAMEBUFFER, null), s);
  }
  destroyGpuRenderTarget(t) {
    const e = this._renderer.gl;
    t.framebuffer && (e.deleteFramebuffer(t.framebuffer), t.framebuffer = null), t.resolveTargetFramebuffer && (e.deleteFramebuffer(t.resolveTargetFramebuffer), t.resolveTargetFramebuffer = null), t.depthStencilRenderBuffer && (e.deleteRenderbuffer(t.depthStencilRenderBuffer), t.depthStencilRenderBuffer = null), t.msaaRenderBuffer.forEach((i) => {
      e.deleteRenderbuffer(i);
    }), t.msaaRenderBuffer = null;
  }
  clear(t, e, i) {
    if (!e)
      return;
    const s = this._renderTargetSystem;
    typeof e == "boolean" && (e = e ? Xn.ALL : Xn.NONE);
    const o = this._renderer.gl;
    if (e & Xn.COLOR) {
      i ?? (i = s.defaultClearColor);
      const l = this._clearColorCache, c = i;
      (l[0] !== c[0] || l[1] !== c[1] || l[2] !== c[2] || l[3] !== c[3]) && (l[0] = c[0], l[1] = c[1], l[2] = c[2], l[3] = c[3], o.clearColor(c[0], c[1], c[2], c[3]));
    }
    o.clear(e);
  }
  resizeGpuRenderTarget(t) {
    if (t.isRoot)
      return;
    const i = this._renderTargetSystem.getGpuRenderTarget(t);
    this._resizeColor(t, i), (t.stencil || t.depth) && this._resizeStencil(i);
  }
  _initColor(t, e) {
    const i = this._renderer, s = i.gl, o = s.createFramebuffer();
    if (e.resolveTargetFramebuffer = o, s.bindFramebuffer(s.FRAMEBUFFER, o), e.width = t.colorTexture.source.pixelWidth, e.height = t.colorTexture.source.pixelHeight, t.colorTextures.forEach((l, c) => {
      const d = l.source;
      d.antialias && (i.context.supports.msaa ? e.msaa = !0 : $t("[RenderTexture] Antialiasing on textures is not supported in WebGL1")), i.texture.bindSource(d, 0);
      const m = i.texture.getGlSource(d).texture;
      s.framebufferTexture2D(
        s.FRAMEBUFFER,
        s.COLOR_ATTACHMENT0 + c,
        3553,
        // texture.target,
        m,
        0
      );
    }), e.msaa) {
      const l = s.createFramebuffer();
      e.framebuffer = l, s.bindFramebuffer(s.FRAMEBUFFER, l), t.colorTextures.forEach((c, d) => {
        const f = s.createRenderbuffer();
        e.msaaRenderBuffer[d] = f;
      });
    } else
      e.framebuffer = o;
    this._resizeColor(t, e);
  }
  _resizeColor(t, e) {
    const i = t.colorTexture.source;
    if (e.width = i.pixelWidth, e.height = i.pixelHeight, t.colorTextures.forEach((s, o) => {
      o !== 0 && s.source.resize(i.width, i.height, i._resolution);
    }), e.msaa) {
      const s = this._renderer, o = s.gl, l = e.framebuffer;
      o.bindFramebuffer(o.FRAMEBUFFER, l), t.colorTextures.forEach((c, d) => {
        const f = c.source;
        s.texture.bindSource(f, 0);
        const y = s.texture.getGlSource(f).internalFormat, b = e.msaaRenderBuffer[d];
        o.bindRenderbuffer(
          o.RENDERBUFFER,
          b
        ), o.renderbufferStorageMultisample(
          o.RENDERBUFFER,
          4,
          y,
          f.pixelWidth,
          f.pixelHeight
        ), o.framebufferRenderbuffer(
          o.FRAMEBUFFER,
          o.COLOR_ATTACHMENT0 + d,
          o.RENDERBUFFER,
          b
        );
      });
    }
  }
  _initStencil(t) {
    if (t.framebuffer === null)
      return;
    const e = this._renderer.gl, i = e.createRenderbuffer();
    t.depthStencilRenderBuffer = i, e.bindRenderbuffer(
      e.RENDERBUFFER,
      i
    ), e.framebufferRenderbuffer(
      e.FRAMEBUFFER,
      e.DEPTH_STENCIL_ATTACHMENT,
      e.RENDERBUFFER,
      i
    ), this._resizeStencil(t);
  }
  _resizeStencil(t) {
    const e = this._renderer.gl;
    e.bindRenderbuffer(
      e.RENDERBUFFER,
      t.depthStencilRenderBuffer
    ), t.msaa ? e.renderbufferStorageMultisample(
      e.RENDERBUFFER,
      4,
      e.DEPTH24_STENCIL8,
      t.width,
      t.height
    ) : e.renderbufferStorage(
      e.RENDERBUFFER,
      this._renderer.context.webGLVersion === 2 ? e.DEPTH24_STENCIL8 : e.DEPTH_STENCIL,
      t.width,
      t.height
    );
  }
  prerender(t) {
    const e = t.colorTexture.resource;
    this._renderer.context.multiView && gr.test(e) && this._renderer.context.ensureCanvasSize(e);
  }
  postrender(t) {
    if (this._renderer.context.multiView && gr.test(t.colorTexture.resource)) {
      const e = this._renderer.context.canvas, i = t.colorTexture;
      i.context2D.drawImage(
        e,
        0,
        i.pixelHeight - e.height
      );
    }
  }
}
function JB(n, t, e, i, s, o) {
  const l = o ? 1 : -1;
  return n.identity(), n.a = 1 / i * 2, n.d = l * (1 / s * 2), n.tx = -1 - t * n.a, n.ty = -l - e * n.d, n;
}
const Na = /* @__PURE__ */ new Map();
to.register(Na);
function VT(n, t) {
  if (!Na.has(n)) {
    const e = new Tt({
      source: new gr({
        resource: n,
        ...t
      })
    }), i = () => {
      Na.get(n) === e && Na.delete(n);
    };
    e.once("destroy", i), e.source.once("destroy", i), Na.set(n, e);
  }
  return Na.get(n);
}
function t3(n) {
  const t = n.colorTexture.source.resource;
  return globalThis.HTMLCanvasElement && t instanceof HTMLCanvasElement && document.body.contains(t);
}
const jT = class YT {
  /**
   * @param [descriptor] - Options for creating a render target.
   */
  constructor(t = {}) {
    if (this.uid = Ee("renderTarget"), this.colorTextures = [], this.dirtyId = 0, this.isRoot = !1, this._size = new Float32Array(2), this._managedColorTextures = !1, t = { ...YT.defaultOptions, ...t }, this.stencil = t.stencil, this.depth = t.depth, this.isRoot = t.isRoot, typeof t.colorTextures == "number") {
      this._managedColorTextures = !0;
      for (let e = 0; e < t.colorTextures; e++)
        this.colorTextures.push(
          new rn({
            width: t.width,
            height: t.height,
            resolution: t.resolution,
            antialias: t.antialias
          })
        );
    } else {
      this.colorTextures = [...t.colorTextures.map((i) => i.source)];
      const e = this.colorTexture.source;
      this.resize(e.width, e.height, e._resolution);
    }
    this.colorTexture.source.on("resize", this.onSourceResize, this), (t.depthStencilTexture || this.stencil) && (t.depthStencilTexture instanceof Tt || t.depthStencilTexture instanceof rn ? this.depthStencilTexture = t.depthStencilTexture.source : this.ensureDepthStencilTexture());
  }
  get size() {
    const t = this._size;
    return t[0] = this.pixelWidth, t[1] = this.pixelHeight, t;
  }
  get width() {
    return this.colorTexture.source.width;
  }
  get height() {
    return this.colorTexture.source.height;
  }
  get pixelWidth() {
    return this.colorTexture.source.pixelWidth;
  }
  get pixelHeight() {
    return this.colorTexture.source.pixelHeight;
  }
  get resolution() {
    return this.colorTexture.source._resolution;
  }
  get colorTexture() {
    return this.colorTextures[0];
  }
  onSourceResize(t) {
    this.resize(t.width, t.height, t._resolution, !0);
  }
  /**
   * This will ensure a depthStencil texture is created for this render target.
   * Most likely called by the mask system to make sure we have stencil buffer added.
   * @internal
   */
  ensureDepthStencilTexture() {
    this.depthStencilTexture || (this.depthStencilTexture = new rn({
      width: this.width,
      height: this.height,
      resolution: this.resolution,
      format: "depth24plus-stencil8",
      autoGenerateMipmaps: !1,
      antialias: !1,
      mipLevelCount: 1
      // sampleCount: handled by the render target system..
    }));
  }
  resize(t, e, i = this.resolution, s = !1) {
    this.dirtyId++, this.colorTextures.forEach((o, l) => {
      s && l === 0 || o.source.resize(t, e, i);
    }), this.depthStencilTexture && this.depthStencilTexture.source.resize(t, e, i);
  }
  destroy() {
    this.colorTexture.source.off("resize", this.onSourceResize, this), this._managedColorTextures && this.colorTextures.forEach((t) => {
      t.destroy();
    }), this.depthStencilTexture && (this.depthStencilTexture.destroy(), delete this.depthStencilTexture);
  }
};
jT.defaultOptions = {
  /** the width of the RenderTarget */
  width: 0,
  /** the height of the RenderTarget */
  height: 0,
  /** the resolution of the RenderTarget */
  resolution: 1,
  /** an array of textures, or a number indicating how many color textures there should be */
  colorTextures: 1,
  /** should this render target have a stencil buffer? */
  stencil: !1,
  /** should this render target have a depth buffer? */
  depth: !1,
  /** should this render target be antialiased? */
  antialias: !1,
  // save on perf by default!
  /** is this a root element, true if this is gl context owners render target */
  isRoot: !1
};
let Am = jT;
class XT {
  constructor(t) {
    this.rootViewPort = new ne(), this.viewport = new ne(), this.onRenderTargetChange = new F1("onRenderTargetChange"), this.projectionMatrix = new bt(), this.defaultClearColor = [0, 0, 0, 0], this._renderSurfaceToRenderTargetHash = /* @__PURE__ */ new Map(), this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null), this._renderTargetStack = [], this._renderer = t, t.renderableGC.addManagedHash(this, "_gpuRenderTargetHash");
  }
  /** called when dev wants to finish a render pass */
  finishRenderPass() {
    this.adaptor.finishRenderPass(this.renderTarget);
  }
  /**
   * called when the renderer starts to render a scene.
   * @param options
   * @param options.target - the render target to render to
   * @param options.clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111
   * @param options.clearColor - the color to clear to
   * @param options.frame - the frame to render to
   */
  renderStart({
    target: t,
    clear: e,
    clearColor: i,
    frame: s
  }) {
    this._renderTargetStack.length = 0, this.push(
      t,
      e,
      i,
      s
    ), this.rootViewPort.copyFrom(this.viewport), this.rootRenderTarget = this.renderTarget, this.renderingToScreen = t3(this.rootRenderTarget), this.adaptor.prerender?.(this.rootRenderTarget);
  }
  postrender() {
    this.adaptor.postrender?.(this.rootRenderTarget);
  }
  /**
   * Binding a render surface! This is the main function of the render target system.
   * It will take the RenderSurface (which can be a texture, canvas, or render target) and bind it to the renderer.
   * Once bound all draw calls will be rendered to the render surface.
   *
   * If a frame is not provide and the render surface is a texture, the frame of the texture will be used.
   * @param renderSurface - the render surface to bind
   * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111
   * @param clearColor - the color to clear to
   * @param frame - the frame to render to
   * @returns the render target that was bound
   */
  bind(t, e = !0, i, s) {
    const o = this.getRenderTarget(t), l = this.renderTarget !== o;
    this.renderTarget = o, this.renderSurface = t;
    const c = this.getGpuRenderTarget(o);
    (o.pixelWidth !== c.width || o.pixelHeight !== c.height) && (this.adaptor.resizeGpuRenderTarget(o), c.width = o.pixelWidth, c.height = o.pixelHeight);
    const d = o.colorTexture, f = this.viewport, m = d.pixelWidth, y = d.pixelHeight;
    if (!s && t instanceof Tt && (s = t.frame), s) {
      const b = d._resolution;
      f.x = s.x * b + 0.5 | 0, f.y = s.y * b + 0.5 | 0, f.width = s.width * b + 0.5 | 0, f.height = s.height * b + 0.5 | 0;
    } else
      f.x = 0, f.y = 0, f.width = m, f.height = y;
    return JB(
      this.projectionMatrix,
      0,
      0,
      f.width / d.resolution,
      f.height / d.resolution,
      !o.isRoot
    ), this.adaptor.startRenderPass(o, e, i, f), l && this.onRenderTargetChange.emit(o), o;
  }
  clear(t, e = Xn.ALL, i) {
    e && (t && (t = this.getRenderTarget(t)), this.adaptor.clear(
      t || this.renderTarget,
      e,
      i,
      this.viewport
    ));
  }
  contextChange() {
    this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
  }
  /**
   * Push a render surface to the renderer. This will bind the render surface to the renderer,
   * @param renderSurface - the render surface to push
   * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111
   * @param clearColor - the color to clear to
   * @param frame - the frame to use when rendering to the render surface
   */
  push(t, e = Xn.ALL, i, s) {
    const o = this.bind(t, e, i, s);
    return this._renderTargetStack.push({
      renderTarget: o,
      frame: s
    }), o;
  }
  /** Pops the current render target from the renderer and restores the previous render target. */
  pop() {
    this._renderTargetStack.pop();
    const t = this._renderTargetStack[this._renderTargetStack.length - 1];
    this.bind(t.renderTarget, !1, null, t.frame);
  }
  /**
   * Gets the render target from the provide render surface. Eg if its a texture,
   * it will return the render target for the texture.
   * If its a render target, it will return the same render target.
   * @param renderSurface - the render surface to get the render target for
   * @returns the render target for the render surface
   */
  getRenderTarget(t) {
    return t.isTexture && (t = t.source), this._renderSurfaceToRenderTargetHash.get(t) ?? this._initRenderTarget(t);
  }
  /**
   * Copies a render surface to another texture.
   *
   * NOTE:
   * for sourceRenderSurfaceTexture, The render target must be something that is written too by the renderer
   *
   * The following is not valid:
   * @example
   * const canvas = document.createElement('canvas')
   * canvas.width = 200;
   * canvas.height = 200;
   *
   * const ctx = canvas2.getContext('2d')!
   * ctx.fillStyle = 'red'
   * ctx.fillRect(0, 0, 200, 200);
   *
   * const texture = RenderTexture.create({
   *   width: 200,
   *   height: 200,
   * })
   * const renderTarget = renderer.renderTarget.getRenderTarget(canvas2);
   *
   * renderer.renderTarget.copyToTexture(renderTarget,texture, {x:0,y:0},{width:200,height:200},{x:0,y:0});
   *
   * The best way to copy a canvas is to create a texture from it. Then render with that.
   *
   * Parsing in a RenderTarget canvas context (with a 2d context)
   * @param sourceRenderSurfaceTexture - the render surface to copy from
   * @param destinationTexture - the texture to copy to
   * @param originSrc - the origin of the copy
   * @param originSrc.x - the x origin of the copy
   * @param originSrc.y - the y origin of the copy
   * @param size - the size of the copy
   * @param size.width - the width of the copy
   * @param size.height - the height of the copy
   * @param originDest - the destination origin (top left to paste from!)
   * @param originDest.x - the x origin of the paste
   * @param originDest.y - the y origin of the paste
   */
  copyToTexture(t, e, i, s, o) {
    i.x < 0 && (s.width += i.x, o.x -= i.x, i.x = 0), i.y < 0 && (s.height += i.y, o.y -= i.y, i.y = 0);
    const { pixelWidth: l, pixelHeight: c } = t;
    return s.width = Math.min(s.width, l - i.x), s.height = Math.min(s.height, c - i.y), this.adaptor.copyToTexture(
      t,
      e,
      i,
      s,
      o
    );
  }
  /**
   * ensures that we have a depth stencil buffer available to render to
   * This is used by the mask system to make sure we have a stencil buffer.
   */
  ensureDepthStencil() {
    this.renderTarget.stencil || (this.renderTarget.stencil = !0, this.adaptor.startRenderPass(this.renderTarget, !1, null, this.viewport));
  }
  /** nukes the render target system */
  destroy() {
    this._renderer = null, this._renderSurfaceToRenderTargetHash.forEach((t, e) => {
      t !== e && t.destroy();
    }), this._renderSurfaceToRenderTargetHash.clear(), this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
  }
  _initRenderTarget(t) {
    let e = null;
    return gr.test(t) && (t = VT(t).source), t instanceof Am ? e = t : t instanceof rn && (e = new Am({
      colorTextures: [t]
    }), t.source instanceof gr && (e.isRoot = !0), t.once("destroy", () => {
      e.destroy(), this._renderSurfaceToRenderTargetHash.delete(t);
      const i = this._gpuRenderTargetHash[e.uid];
      i && (this._gpuRenderTargetHash[e.uid] = null, this.adaptor.destroyGpuRenderTarget(i));
    })), this._renderSurfaceToRenderTargetHash.set(t, e), e;
  }
  getGpuRenderTarget(t) {
    return this._gpuRenderTargetHash[t.uid] || (this._gpuRenderTargetHash[t.uid] = this.adaptor.initGpuRenderTarget(t));
  }
  resetState() {
    this.renderTarget = null, this.renderSurface = null;
  }
}
class qT extends XT {
  constructor(t) {
    super(t), this.adaptor = new QB(), this.adaptor.init(t, this);
  }
}
qT.extension = {
  type: [W.WebGLSystem],
  name: "renderTarget"
};
class Cg extends Jn {
  /**
   * Create a new Buffer Resource.
   * @param options - The options for the buffer resource
   * @param options.buffer - The underlying buffer that this resource is using
   * @param options.offset - The offset of the buffer this resource is using.
   * If not provided, then it will use the offset of the buffer.
   * @param options.size - The size of the buffer this resource is using.
   * If not provided, then it will use the size of the buffer.
   */
  constructor({ buffer: t, offset: e, size: i }) {
    super(), this.uid = Ee("buffer"), this._resourceType = "bufferResource", this._touched = 0, this._resourceId = Ee("resource"), this._bufferResource = !0, this.destroyed = !1, this.buffer = t, this.offset = e | 0, this.size = i, this.buffer.on("change", this.onBufferChange, this);
  }
  onBufferChange() {
    this._resourceId = Ee("resource"), this.emit("change", this);
  }
  /**
   * Destroys this resource. Make sure the underlying buffer is not used anywhere else
   * if you want to destroy it as well, or code will explode
   * @param destroyBuffer - Should the underlying buffer be destroyed as well?
   */
  destroy(t = !1) {
    this.destroyed = !0, t && this.buffer.destroy(), this.emit("change", this), this.buffer = null;
  }
}
function e3(n, t) {
  const e = [], i = [`
        var g = s.groups;
        var sS = r.shader;
        var p = s.glProgram;
        var ugS = r.uniformGroup;
        var resources;
    `];
  let s = !1, o = 0;
  const l = t._getProgramData(n.glProgram);
  for (const d in n.groups) {
    const f = n.groups[d];
    e.push(`
            resources = g[${d}].resources;
        `);
    for (const m in f.resources) {
      const y = f.resources[m];
      if (y instanceof Pn)
        if (y.ubo) {
          const b = n._uniformBindMap[d][Number(m)];
          e.push(`
                        sS.bindUniformBlock(
                            resources[${m}],
                            '${b}',
                            ${n.glProgram._uniformBlockData[b].index}
                        );
                    `);
        } else
          e.push(`
                        ugS.updateUniformGroup(resources[${m}], p, sD);
                    `);
      else if (y instanceof Cg) {
        const b = n._uniformBindMap[d][Number(m)];
        e.push(`
                    sS.bindUniformBlock(
                        resources[${m}],
                        '${b}',
                        ${n.glProgram._uniformBlockData[b].index}
                    );
                `);
      } else if (y instanceof rn) {
        const b = n._uniformBindMap[d][m], v = l.uniformData[b];
        v && (s || (s = !0, i.push(`
                        var tS = r.texture;
                        `)), t._gl.uniform1i(v.location, o), e.push(`
                        tS.bind(resources[${m}], ${o});
                    `), o++);
      }
    }
  }
  const c = [...i, ...e].join(`
`);
  return new Function("r", "s", "sD", c);
}
class n3 {
  /**
   * Makes a new Pixi program.
   * @param program - webgl program
   * @param uniformData - uniforms
   */
  constructor(t, e) {
    this.program = t, this.uniformData = e, this.uniformGroups = {}, this.uniformDirtyGroups = {}, this.uniformBlockBindings = {};
  }
  /** Destroys this program. */
  destroy() {
    this.uniformData = null, this.uniformGroups = null, this.uniformDirtyGroups = null, this.uniformBlockBindings = null, this.program = null;
  }
}
function A0(n, t, e) {
  const i = n.createShader(t);
  return n.shaderSource(i, e), n.compileShader(i), i;
}
function Lp(n) {
  const t = new Array(n);
  for (let e = 0; e < t.length; e++)
    t[e] = !1;
  return t;
}
function KT(n, t) {
  switch (n) {
    case "float":
      return 0;
    case "vec2":
      return new Float32Array(2 * t);
    case "vec3":
      return new Float32Array(3 * t);
    case "vec4":
      return new Float32Array(4 * t);
    case "int":
    case "uint":
    case "sampler2D":
    case "sampler2DArray":
      return 0;
    case "ivec2":
      return new Int32Array(2 * t);
    case "ivec3":
      return new Int32Array(3 * t);
    case "ivec4":
      return new Int32Array(4 * t);
    case "uvec2":
      return new Uint32Array(2 * t);
    case "uvec3":
      return new Uint32Array(3 * t);
    case "uvec4":
      return new Uint32Array(4 * t);
    case "bool":
      return !1;
    case "bvec2":
      return Lp(2 * t);
    case "bvec3":
      return Lp(3 * t);
    case "bvec4":
      return Lp(4 * t);
    case "mat2":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
}
let Dc = null;
const R0 = {
  FLOAT: "float",
  FLOAT_VEC2: "vec2",
  FLOAT_VEC3: "vec3",
  FLOAT_VEC4: "vec4",
  INT: "int",
  INT_VEC2: "ivec2",
  INT_VEC3: "ivec3",
  INT_VEC4: "ivec4",
  UNSIGNED_INT: "uint",
  UNSIGNED_INT_VEC2: "uvec2",
  UNSIGNED_INT_VEC3: "uvec3",
  UNSIGNED_INT_VEC4: "uvec4",
  BOOL: "bool",
  BOOL_VEC2: "bvec2",
  BOOL_VEC3: "bvec3",
  BOOL_VEC4: "bvec4",
  FLOAT_MAT2: "mat2",
  FLOAT_MAT3: "mat3",
  FLOAT_MAT4: "mat4",
  SAMPLER_2D: "sampler2D",
  INT_SAMPLER_2D: "sampler2D",
  UNSIGNED_INT_SAMPLER_2D: "sampler2D",
  SAMPLER_CUBE: "samplerCube",
  INT_SAMPLER_CUBE: "samplerCube",
  UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
  SAMPLER_2D_ARRAY: "sampler2DArray",
  INT_SAMPLER_2D_ARRAY: "sampler2DArray",
  UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
}, i3 = {
  float: "float32",
  vec2: "float32x2",
  vec3: "float32x3",
  vec4: "float32x4",
  int: "sint32",
  ivec2: "sint32x2",
  ivec3: "sint32x3",
  ivec4: "sint32x4",
  uint: "uint32",
  uvec2: "uint32x2",
  uvec3: "uint32x3",
  uvec4: "uint32x4",
  bool: "uint32",
  bvec2: "uint32x2",
  bvec3: "uint32x3",
  bvec4: "uint32x4"
};
function ZT(n, t) {
  if (!Dc) {
    const e = Object.keys(R0);
    Dc = {};
    for (let i = 0; i < e.length; ++i) {
      const s = e[i];
      Dc[n[s]] = R0[s];
    }
  }
  return Dc[t];
}
function r3(n, t) {
  const e = ZT(n, t);
  return i3[e] || "float32";
}
function s3(n, t, e = !1) {
  const i = {}, s = t.getProgramParameter(n, t.ACTIVE_ATTRIBUTES);
  for (let l = 0; l < s; l++) {
    const c = t.getActiveAttrib(n, l);
    if (c.name.startsWith("gl_"))
      continue;
    const d = r3(t, c.type);
    i[c.name] = {
      location: 0,
      // set further down..
      format: d,
      stride: Jr(d).stride,
      offset: 0,
      instance: !1,
      start: 0
    };
  }
  const o = Object.keys(i);
  if (e) {
    o.sort((l, c) => l > c ? 1 : -1);
    for (let l = 0; l < o.length; l++)
      i[o[l]].location = l, t.bindAttribLocation(n, l, o[l]);
    t.linkProgram(n);
  } else
    for (let l = 0; l < o.length; l++)
      i[o[l]].location = t.getAttribLocation(n, o[l]);
  return i;
}
function a3(n, t) {
  if (!t.ACTIVE_UNIFORM_BLOCKS)
    return {};
  const e = {}, i = t.getProgramParameter(n, t.ACTIVE_UNIFORM_BLOCKS);
  for (let s = 0; s < i; s++) {
    const o = t.getActiveUniformBlockName(n, s), l = t.getUniformBlockIndex(n, o), c = t.getActiveUniformBlockParameter(n, s, t.UNIFORM_BLOCK_DATA_SIZE);
    e[o] = {
      name: o,
      index: l,
      size: c
    };
  }
  return e;
}
function o3(n, t) {
  const e = {}, i = t.getProgramParameter(n, t.ACTIVE_UNIFORMS);
  for (let s = 0; s < i; s++) {
    const o = t.getActiveUniform(n, s), l = o.name.replace(/\[.*?\]$/, ""), c = !!o.name.match(/\[.*?\]$/), d = ZT(t, o.type);
    e[l] = {
      name: l,
      index: s,
      type: d,
      size: o.size,
      isArray: c,
      value: KT(d, o.size)
    };
  }
  return e;
}
function P0(n, t) {
  const e = n.getShaderSource(t).split(`
`).map((f, m) => `${m}: ${f}`), i = n.getShaderInfoLog(t), s = i.split(`
`), o = {}, l = s.map((f) => parseFloat(f.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter((f) => f && !o[f] ? (o[f] = !0, !0) : !1), c = [""];
  l.forEach((f) => {
    e[f - 1] = `%c${e[f - 1]}%c`, c.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
  });
  const d = e.join(`
`);
  c[0] = d, console.error(i), console.groupCollapsed("click to view full shader code"), console.warn(...c), console.groupEnd();
}
function l3(n, t, e, i) {
  n.getProgramParameter(t, n.LINK_STATUS) || (n.getShaderParameter(e, n.COMPILE_STATUS) || P0(n, e), n.getShaderParameter(i, n.COMPILE_STATUS) || P0(n, i), console.error("PixiJS Error: Could not initialize shader."), n.getProgramInfoLog(t) !== "" && console.warn("PixiJS Warning: gl.getProgramInfoLog()", n.getProgramInfoLog(t)));
}
function u3(n, t) {
  const e = A0(n, n.VERTEX_SHADER, t.vertex), i = A0(n, n.FRAGMENT_SHADER, t.fragment), s = n.createProgram();
  n.attachShader(s, e), n.attachShader(s, i);
  const o = t.transformFeedbackVaryings;
  o && (typeof n.transformFeedbackVaryings != "function" ? $t("TransformFeedback is not supported but TransformFeedbackVaryings are given.") : n.transformFeedbackVaryings(
    s,
    o.names,
    o.bufferMode === "separate" ? n.SEPARATE_ATTRIBS : n.INTERLEAVED_ATTRIBS
  )), n.linkProgram(s), n.getProgramParameter(s, n.LINK_STATUS) || l3(n, s, e, i), t._attributeData = s3(
    s,
    n,
    !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(t.vertex)
  ), t._uniformData = o3(s, n), t._uniformBlockData = a3(s, n), n.deleteShader(e), n.deleteShader(i);
  const l = {};
  for (const d in t._uniformData) {
    const f = t._uniformData[d];
    l[d] = {
      location: n.getUniformLocation(s, d),
      value: KT(f.type, f.size)
    };
  }
  return new n3(s, l);
}
const Gc = {
  textureCount: 0,
  blockIndex: 0
};
class QT {
  constructor(t) {
    this._activeProgram = null, this._programDataHash = /* @__PURE__ */ Object.create(null), this._shaderSyncFunctions = /* @__PURE__ */ Object.create(null), this._renderer = t, this._renderer.renderableGC.addManagedHash(this, "_programDataHash");
  }
  contextChange(t) {
    this._gl = t, this._programDataHash = /* @__PURE__ */ Object.create(null), this._shaderSyncFunctions = /* @__PURE__ */ Object.create(null), this._activeProgram = null;
  }
  /**
   * Changes the current shader to the one given in parameter.
   * @param shader - the new shader
   * @param skipSync - false if the shader should automatically sync its uniforms.
   * @returns the glProgram that belongs to the shader.
   */
  bind(t, e) {
    if (this._setProgram(t.glProgram), e)
      return;
    Gc.textureCount = 0, Gc.blockIndex = 0;
    let i = this._shaderSyncFunctions[t.glProgram._key];
    i || (i = this._shaderSyncFunctions[t.glProgram._key] = this._generateShaderSync(t, this)), this._renderer.buffer.nextBindBase(!!t.glProgram.transformFeedbackVaryings), i(this._renderer, t, Gc);
  }
  /**
   * Updates the uniform group.
   * @param uniformGroup - the uniform group to update
   */
  updateUniformGroup(t) {
    this._renderer.uniformGroup.updateUniformGroup(t, this._activeProgram, Gc);
  }
  /**
   * Binds a uniform block to the shader.
   * @param uniformGroup - the uniform group to bind
   * @param name - the name of the uniform block
   * @param index - the index of the uniform block
   */
  bindUniformBlock(t, e, i = 0) {
    const s = this._renderer.buffer, o = this._getProgramData(this._activeProgram), l = t._bufferResource;
    l || this._renderer.ubo.updateUniformGroup(t);
    const c = t.buffer, d = s.updateBuffer(c), f = s.freeLocationForBufferBase(d);
    if (l) {
      const { offset: y, size: b } = t;
      y === 0 && b === c.data.byteLength ? s.bindBufferBase(d, f) : s.bindBufferRange(d, f, y);
    } else s.getLastBindBaseLocation(d) !== f && s.bindBufferBase(d, f);
    const m = this._activeProgram._uniformBlockData[e].index;
    o.uniformBlockBindings[i] !== f && (o.uniformBlockBindings[i] = f, this._renderer.gl.uniformBlockBinding(o.program, m, f));
  }
  _setProgram(t) {
    if (this._activeProgram === t)
      return;
    this._activeProgram = t;
    const e = this._getProgramData(t);
    this._gl.useProgram(e.program);
  }
  /**
   * @param program - the program to get the data for
   * @internal
   */
  _getProgramData(t) {
    return this._programDataHash[t._key] || this._createProgramData(t);
  }
  _createProgramData(t) {
    const e = t._key;
    return this._programDataHash[e] = u3(this._gl, t), this._programDataHash[e];
  }
  destroy() {
    for (const t of Object.keys(this._programDataHash))
      this._programDataHash[t].destroy(), this._programDataHash[t] = null;
    this._programDataHash = null, this._shaderSyncFunctions = null, this._activeProgram = null, this._renderer = null, this._gl = null;
  }
  /**
   * Creates a function that can be executed that will sync the shader as efficiently as possible.
   * Overridden by the unsafe eval package if you don't want eval used in your project.
   * @param shader - the shader to generate the sync function for
   * @param shaderSystem - the shader system to use
   * @returns - the generated sync function
   * @ignore
   */
  _generateShaderSync(t, e) {
    return e3(t, e);
  }
  resetState() {
    this._activeProgram = null;
  }
}
QT.extension = {
  type: [
    W.WebGLSystem
  ],
  name: "shader"
};
const c3 = {
  f32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1f(location, v);
        }`,
  "vec2<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2f(location, v[0], v[1]);
        }`,
  "vec3<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3f(location, v[0], v[1], v[2]);
        }`,
  "vec4<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4f(location, v[0], v[1], v[2], v[3]);
        }`,
  i32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
  "vec2<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
  "vec3<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
  "vec4<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
  u32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1ui(location, v);
        }`,
  "vec2<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2ui(location, v[0], v[1]);
        }`,
  "vec3<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3ui(location, v[0], v[1], v[2]);
        }`,
  "vec4<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
        }`,
  bool: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
  "vec2<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
  "vec3<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
  "vec4<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
  "mat2x2<f32>": "gl.uniformMatrix2fv(location, false, v);",
  "mat3x3<f32>": "gl.uniformMatrix3fv(location, false, v);",
  "mat4x4<f32>": "gl.uniformMatrix4fv(location, false, v);"
}, h3 = {
  f32: "gl.uniform1fv(location, v);",
  "vec2<f32>": "gl.uniform2fv(location, v);",
  "vec3<f32>": "gl.uniform3fv(location, v);",
  "vec4<f32>": "gl.uniform4fv(location, v);",
  "mat2x2<f32>": "gl.uniformMatrix2fv(location, false, v);",
  "mat3x3<f32>": "gl.uniformMatrix3fv(location, false, v);",
  "mat4x4<f32>": "gl.uniformMatrix4fv(location, false, v);",
  i32: "gl.uniform1iv(location, v);",
  "vec2<i32>": "gl.uniform2iv(location, v);",
  "vec3<i32>": "gl.uniform3iv(location, v);",
  "vec4<i32>": "gl.uniform4iv(location, v);",
  u32: "gl.uniform1iv(location, v);",
  "vec2<u32>": "gl.uniform2iv(location, v);",
  "vec3<u32>": "gl.uniform3iv(location, v);",
  "vec4<u32>": "gl.uniform4iv(location, v);",
  bool: "gl.uniform1iv(location, v);",
  "vec2<bool>": "gl.uniform2iv(location, v);",
  "vec3<bool>": "gl.uniform3iv(location, v);",
  "vec4<bool>": "gl.uniform4iv(location, v);"
};
function d3(n, t) {
  const e = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
        var name = null;
    `];
  for (const i in n.uniforms) {
    if (!t[i]) {
      n.uniforms[i] instanceof Pn ? n.uniforms[i].ubo ? e.push(`
                        renderer.shader.bindUniformBlock(uv.${i}, "${i}");
                    `) : e.push(`
                        renderer.shader.updateUniformGroup(uv.${i});
                    `) : n.uniforms[i] instanceof Cg && e.push(`
                        renderer.shader.bindBufferResource(uv.${i}, "${i}");
                    `);
      continue;
    }
    const s = n.uniformStructures[i];
    let o = !1;
    for (let l = 0; l < Os.length; l++) {
      const c = Os[l];
      if (s.type === c.type && c.test(s)) {
        e.push(`name = "${i}";`, Os[l].uniform), o = !0;
        break;
      }
    }
    if (!o) {
      const c = (s.size === 1 ? c3 : h3)[s.type].replace("location", `ud["${i}"].location`);
      e.push(`
            cu = ud["${i}"];
            cv = cu.value;
            v = uv["${i}"];
            ${c};`);
    }
  }
  return new Function("ud", "uv", "renderer", "syncData", e.join(`
`));
}
class JT {
  /** @param renderer - The renderer this System works for. */
  constructor(t) {
    this._cache = {}, this._uniformGroupSyncHash = {}, this._renderer = t, this.gl = null, this._cache = {};
  }
  contextChange(t) {
    this.gl = t;
  }
  /**
   * Uploads the uniforms values to the currently bound shader.
   * @param group - the uniforms values that be applied to the current shader
   * @param program
   * @param syncData
   * @param syncData.textureCount
   */
  updateUniformGroup(t, e, i) {
    const s = this._renderer.shader._getProgramData(e);
    (!t.isStatic || t._dirtyId !== s.uniformDirtyGroups[t.uid]) && (s.uniformDirtyGroups[t.uid] = t._dirtyId, this._getUniformSyncFunction(t, e)(s.uniformData, t.uniforms, this._renderer, i));
  }
  /**
   * Overridable by the pixi.js/unsafe-eval package to use static syncUniforms instead.
   * @param group
   * @param program
   */
  _getUniformSyncFunction(t, e) {
    return this._uniformGroupSyncHash[t._signature]?.[e._key] || this._createUniformSyncFunction(t, e);
  }
  _createUniformSyncFunction(t, e) {
    const i = this._uniformGroupSyncHash[t._signature] || (this._uniformGroupSyncHash[t._signature] = {}), s = this._getSignature(t, e._uniformData, "u");
    return this._cache[s] || (this._cache[s] = this._generateUniformsSync(t, e._uniformData)), i[e._key] = this._cache[s], i[e._key];
  }
  _generateUniformsSync(t, e) {
    return d3(t, e);
  }
  /**
   * Takes a uniform group and data and generates a unique signature for them.
   * @param group - The uniform group to get signature of
   * @param group.uniforms
   * @param uniformData - Uniform information generated by the shader
   * @param preFix
   * @returns Unique signature of the uniform group
   */
  _getSignature(t, e, i) {
    const s = t.uniforms, o = [`${i}-`];
    for (const l in s)
      o.push(l), e[l] && o.push(e[l].type);
    return o.join("-");
  }
  /** Destroys this System and removes all its textures. */
  destroy() {
    this._renderer = null, this._cache = null;
  }
}
JT.extension = {
  type: [
    W.WebGLSystem
  ],
  name: "uniformGroup"
};
function f3(n) {
  const t = {};
  if (t.normal = [n.ONE, n.ONE_MINUS_SRC_ALPHA], t.add = [n.ONE, n.ONE], t.multiply = [n.DST_COLOR, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA], t.screen = [n.ONE, n.ONE_MINUS_SRC_COLOR, n.ONE, n.ONE_MINUS_SRC_ALPHA], t.none = [0, 0], t["normal-npm"] = [n.SRC_ALPHA, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA], t["add-npm"] = [n.SRC_ALPHA, n.ONE, n.ONE, n.ONE], t["screen-npm"] = [n.SRC_ALPHA, n.ONE_MINUS_SRC_COLOR, n.ONE, n.ONE_MINUS_SRC_ALPHA], t.erase = [n.ZERO, n.ONE_MINUS_SRC_ALPHA], !(n instanceof ve.get().getWebGLRenderingContext()))
    t.min = [n.ONE, n.ONE, n.ONE, n.ONE, n.MIN, n.MIN], t.max = [n.ONE, n.ONE, n.ONE, n.ONE, n.MAX, n.MAX];
  else {
    const i = n.getExtension("EXT_blend_minmax");
    i && (t.min = [n.ONE, n.ONE, n.ONE, n.ONE, i.MIN_EXT, i.MIN_EXT], t.max = [n.ONE, n.ONE, n.ONE, n.ONE, i.MAX_EXT, i.MAX_EXT]);
  }
  return t;
}
const p3 = 0, m3 = 1, g3 = 2, y3 = 3, b3 = 4, v3 = 5, tw = class Rm {
  constructor(t) {
    this._invertFrontFace = !1, this.gl = null, this.stateId = 0, this.polygonOffset = 0, this.blendMode = "none", this._blendEq = !1, this.map = [], this.map[p3] = this.setBlend, this.map[m3] = this.setOffset, this.map[g3] = this.setCullFace, this.map[y3] = this.setDepthTest, this.map[b3] = this.setFrontFace, this.map[v3] = this.setDepthMask, this.checks = [], this.defaultState = wi.for2d(), t.renderTarget.onRenderTargetChange.add(this);
  }
  onRenderTargetChange(t) {
    this._invertFrontFace = !t.isRoot, this._cullFace ? this.setFrontFace(this._frontFace) : this._frontFaceDirty = !0;
  }
  contextChange(t) {
    this.gl = t, this.blendModesMap = f3(t), this.resetState();
  }
  /**
   * Sets the current state
   * @param {*} state - The state to set.
   */
  set(t) {
    if (t || (t = this.defaultState), this.stateId !== t.data) {
      let e = this.stateId ^ t.data, i = 0;
      for (; e; )
        e & 1 && this.map[i].call(this, !!(t.data & 1 << i)), e >>= 1, i++;
      this.stateId = t.data;
    }
    for (let e = 0; e < this.checks.length; e++)
      this.checks[e](this, t);
  }
  /**
   * Sets the state, when previous state is unknown.
   * @param {*} state - The state to set
   */
  forceState(t) {
    t || (t = this.defaultState);
    for (let e = 0; e < this.map.length; e++)
      this.map[e].call(this, !!(t.data & 1 << e));
    for (let e = 0; e < this.checks.length; e++)
      this.checks[e](this, t);
    this.stateId = t.data;
  }
  /**
   * Sets whether to enable or disable blending.
   * @param value - Turn on or off WebGl blending.
   */
  setBlend(t) {
    this._updateCheck(Rm._checkBlendMode, t), this.gl[t ? "enable" : "disable"](this.gl.BLEND);
  }
  /**
   * Sets whether to enable or disable polygon offset fill.
   * @param value - Turn on or off webgl polygon offset testing.
   */
  setOffset(t) {
    this._updateCheck(Rm._checkPolygonOffset, t), this.gl[t ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
  }
  /**
   * Sets whether to enable or disable depth test.
   * @param value - Turn on or off webgl depth testing.
   */
  setDepthTest(t) {
    this.gl[t ? "enable" : "disable"](this.gl.DEPTH_TEST);
  }
  /**
   * Sets whether to enable or disable depth mask.
   * @param value - Turn on or off webgl depth mask.
   */
  setDepthMask(t) {
    this.gl.depthMask(t);
  }
  /**
   * Sets whether to enable or disable cull face.
   * @param {boolean} value - Turn on or off webgl cull face.
   */
  setCullFace(t) {
    this._cullFace = t, this.gl[t ? "enable" : "disable"](this.gl.CULL_FACE), this._cullFace && this._frontFaceDirty && this.setFrontFace(this._frontFace);
  }
  /**
   * Sets the gl front face.
   * @param {boolean} value - true is clockwise and false is counter-clockwise
   */
  setFrontFace(t) {
    this._frontFace = t, this._frontFaceDirty = !1;
    const e = this._invertFrontFace ? !t : t;
    this._glFrontFace !== e && (this._glFrontFace = e, this.gl.frontFace(this.gl[e ? "CW" : "CCW"]));
  }
  /**
   * Sets the blend mode.
   * @param {number} value - The blend mode to set to.
   */
  setBlendMode(t) {
    if (this.blendModesMap[t] || (t = "normal"), t === this.blendMode)
      return;
    this.blendMode = t;
    const e = this.blendModesMap[t], i = this.gl;
    e.length === 2 ? i.blendFunc(e[0], e[1]) : i.blendFuncSeparate(e[0], e[1], e[2], e[3]), e.length === 6 ? (this._blendEq = !0, i.blendEquationSeparate(e[4], e[5])) : this._blendEq && (this._blendEq = !1, i.blendEquationSeparate(i.FUNC_ADD, i.FUNC_ADD));
  }
  /**
   * Sets the polygon offset.
   * @param {number} value - the polygon offset
   * @param {number} scale - the polygon offset scale
   */
  setPolygonOffset(t, e) {
    this.gl.polygonOffset(t, e);
  }
  /** Resets all the logic and disables the VAOs. */
  resetState() {
    this._glFrontFace = !1, this._frontFace = !1, this._cullFace = !1, this._frontFaceDirty = !1, this._invertFrontFace = !1, this.gl.frontFace(this.gl.CCW), this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1), this.forceState(this.defaultState), this._blendEq = !0, this.blendMode = "", this.setBlendMode("normal");
  }
  /**
   * Checks to see which updates should be checked based on which settings have been activated.
   *
   * For example, if blend is enabled then we should check the blend modes each time the state is changed
   * or if polygon fill is activated then we need to check if the polygon offset changes.
   * The idea is that we only check what we have too.
   * @param func - the checking function to add or remove
   * @param value - should the check function be added or removed.
   */
  _updateCheck(t, e) {
    const i = this.checks.indexOf(t);
    e && i === -1 ? this.checks.push(t) : !e && i !== -1 && this.checks.splice(i, 1);
  }
  /**
   * A private little wrapper function that we call to check the blend mode.
   * @param system - the System to perform the state check on
   * @param state - the state that the blendMode will pulled from
   */
  static _checkBlendMode(t, e) {
    t.setBlendMode(e.blendMode);
  }
  /**
   * A private little wrapper function that we call to check the polygon offset.
   * @param system - the System to perform the state check on
   * @param state - the state that the blendMode will pulled from
   */
  static _checkPolygonOffset(t, e) {
    t.setPolygonOffset(1, e.polygonOffset);
  }
  /** @ignore */
  destroy() {
    this.gl = null, this.checks.length = 0;
  }
};
tw.extension = {
  type: [
    W.WebGLSystem
  ],
  name: "state"
};
let x3 = tw;
class _3 {
  constructor(t) {
    this.target = OT.TEXTURE_2D, this.texture = t, this.width = -1, this.height = -1, this.type = ee.UNSIGNED_BYTE, this.internalFormat = Mm.RGBA, this.format = Mm.RGBA, this.samplerType = 0;
  }
}
const S3 = {
  id: "buffer",
  upload(n, t, e) {
    t.width === n.width || t.height === n.height ? e.texSubImage2D(
      e.TEXTURE_2D,
      0,
      0,
      0,
      n.width,
      n.height,
      t.format,
      t.type,
      n.resource
    ) : e.texImage2D(
      t.target,
      0,
      t.internalFormat,
      n.width,
      n.height,
      0,
      t.format,
      t.type,
      n.resource
    ), t.width = n.width, t.height = n.height;
  }
}, T3 = {
  "bc1-rgba-unorm": !0,
  "bc1-rgba-unorm-srgb": !0,
  "bc2-rgba-unorm": !0,
  "bc2-rgba-unorm-srgb": !0,
  "bc3-rgba-unorm": !0,
  "bc3-rgba-unorm-srgb": !0,
  "bc4-r-unorm": !0,
  "bc4-r-snorm": !0,
  "bc5-rg-unorm": !0,
  "bc5-rg-snorm": !0,
  "bc6h-rgb-ufloat": !0,
  "bc6h-rgb-float": !0,
  "bc7-rgba-unorm": !0,
  "bc7-rgba-unorm-srgb": !0,
  // ETC2 compressed formats usable if "texture-compression-etc2" is both
  // supported by the device/user agent and enabled in requestDevice.
  "etc2-rgb8unorm": !0,
  "etc2-rgb8unorm-srgb": !0,
  "etc2-rgb8a1unorm": !0,
  "etc2-rgb8a1unorm-srgb": !0,
  "etc2-rgba8unorm": !0,
  "etc2-rgba8unorm-srgb": !0,
  "eac-r11unorm": !0,
  "eac-r11snorm": !0,
  "eac-rg11unorm": !0,
  "eac-rg11snorm": !0,
  // ASTC compressed formats usable if "texture-compression-astc" is both
  // supported by the device/user agent and enabled in requestDevice.
  "astc-4x4-unorm": !0,
  "astc-4x4-unorm-srgb": !0,
  "astc-5x4-unorm": !0,
  "astc-5x4-unorm-srgb": !0,
  "astc-5x5-unorm": !0,
  "astc-5x5-unorm-srgb": !0,
  "astc-6x5-unorm": !0,
  "astc-6x5-unorm-srgb": !0,
  "astc-6x6-unorm": !0,
  "astc-6x6-unorm-srgb": !0,
  "astc-8x5-unorm": !0,
  "astc-8x5-unorm-srgb": !0,
  "astc-8x6-unorm": !0,
  "astc-8x6-unorm-srgb": !0,
  "astc-8x8-unorm": !0,
  "astc-8x8-unorm-srgb": !0,
  "astc-10x5-unorm": !0,
  "astc-10x5-unorm-srgb": !0,
  "astc-10x6-unorm": !0,
  "astc-10x6-unorm-srgb": !0,
  "astc-10x8-unorm": !0,
  "astc-10x8-unorm-srgb": !0,
  "astc-10x10-unorm": !0,
  "astc-10x10-unorm-srgb": !0,
  "astc-12x10-unorm": !0,
  "astc-12x10-unorm-srgb": !0,
  "astc-12x12-unorm": !0,
  "astc-12x12-unorm-srgb": !0
}, w3 = {
  id: "compressed",
  upload(n, t, e) {
    e.pixelStorei(e.UNPACK_ALIGNMENT, 4);
    let i = n.pixelWidth, s = n.pixelHeight;
    const o = !!T3[n.format];
    for (let l = 0; l < n.resource.length; l++) {
      const c = n.resource[l];
      o ? e.compressedTexImage2D(
        e.TEXTURE_2D,
        l,
        t.internalFormat,
        i,
        s,
        0,
        c
      ) : e.texImage2D(
        e.TEXTURE_2D,
        l,
        t.internalFormat,
        i,
        s,
        0,
        t.format,
        t.type,
        c
      ), i = Math.max(i >> 1, 1), s = Math.max(s >> 1, 1);
    }
  }
}, ew = {
  id: "image",
  upload(n, t, e, i) {
    const s = t.width, o = t.height, l = n.pixelWidth, c = n.pixelHeight, d = n.resourceWidth, f = n.resourceHeight;
    d < l || f < c ? ((s !== l || o !== c) && e.texImage2D(
      t.target,
      0,
      t.internalFormat,
      l,
      c,
      0,
      t.format,
      t.type,
      null
    ), i === 2 ? e.texSubImage2D(
      e.TEXTURE_2D,
      0,
      0,
      0,
      d,
      f,
      t.format,
      t.type,
      n.resource
    ) : e.texSubImage2D(
      e.TEXTURE_2D,
      0,
      0,
      0,
      t.format,
      t.type,
      n.resource
    )) : s === l && o === c ? e.texSubImage2D(
      e.TEXTURE_2D,
      0,
      0,
      0,
      t.format,
      t.type,
      n.resource
    ) : i === 2 ? e.texImage2D(
      t.target,
      0,
      t.internalFormat,
      l,
      c,
      0,
      t.format,
      t.type,
      n.resource
    ) : e.texImage2D(
      t.target,
      0,
      t.internalFormat,
      t.format,
      t.type,
      n.resource
    ), t.width = l, t.height = c;
  }
}, C3 = {
  id: "video",
  upload(n, t, e, i) {
    if (!n.isValid) {
      e.texImage2D(
        t.target,
        0,
        t.internalFormat,
        1,
        1,
        0,
        t.format,
        t.type,
        null
      );
      return;
    }
    ew.upload(n, t, e, i);
  }
}, B0 = {
  linear: 9729,
  nearest: 9728
}, E3 = {
  linear: {
    linear: 9987,
    nearest: 9985
  },
  nearest: {
    linear: 9986,
    nearest: 9984
  }
}, Fp = {
  "clamp-to-edge": 33071,
  repeat: 10497,
  "mirror-repeat": 33648
}, M3 = {
  never: 512,
  less: 513,
  equal: 514,
  "less-equal": 515,
  greater: 516,
  "not-equal": 517,
  "greater-equal": 518,
  always: 519
};
function k0(n, t, e, i, s, o, l, c) {
  const d = o;
  if (!c || n.addressModeU !== "repeat" || n.addressModeV !== "repeat" || n.addressModeW !== "repeat") {
    const f = Fp[l ? "clamp-to-edge" : n.addressModeU], m = Fp[l ? "clamp-to-edge" : n.addressModeV], y = Fp[l ? "clamp-to-edge" : n.addressModeW];
    t[s](d, t.TEXTURE_WRAP_S, f), t[s](d, t.TEXTURE_WRAP_T, m), t.TEXTURE_WRAP_R && t[s](d, t.TEXTURE_WRAP_R, y);
  }
  if ((!c || n.magFilter !== "linear") && t[s](d, t.TEXTURE_MAG_FILTER, B0[n.magFilter]), e) {
    if (!c || n.mipmapFilter !== "linear") {
      const f = E3[n.minFilter][n.mipmapFilter];
      t[s](d, t.TEXTURE_MIN_FILTER, f);
    }
  } else
    t[s](d, t.TEXTURE_MIN_FILTER, B0[n.minFilter]);
  if (i && n.maxAnisotropy > 1) {
    const f = Math.min(n.maxAnisotropy, t.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
    t[s](d, i.TEXTURE_MAX_ANISOTROPY_EXT, f);
  }
  n.compare && t[s](d, t.TEXTURE_COMPARE_FUNC, M3[n.compare]);
}
function A3(n) {
  return {
    // 8-bit formats
    r8unorm: n.RED,
    r8snorm: n.RED,
    r8uint: n.RED,
    r8sint: n.RED,
    // 16-bit formats
    r16uint: n.RED,
    r16sint: n.RED,
    r16float: n.RED,
    rg8unorm: n.RG,
    rg8snorm: n.RG,
    rg8uint: n.RG,
    rg8sint: n.RG,
    // 32-bit formats
    r32uint: n.RED,
    r32sint: n.RED,
    r32float: n.RED,
    rg16uint: n.RG,
    rg16sint: n.RG,
    rg16float: n.RG,
    rgba8unorm: n.RGBA,
    "rgba8unorm-srgb": n.RGBA,
    // Packed 32-bit formats
    rgba8snorm: n.RGBA,
    rgba8uint: n.RGBA,
    rgba8sint: n.RGBA,
    bgra8unorm: n.RGBA,
    "bgra8unorm-srgb": n.RGBA,
    rgb9e5ufloat: n.RGB,
    rgb10a2unorm: n.RGBA,
    rg11b10ufloat: n.RGB,
    // 64-bit formats
    rg32uint: n.RG,
    rg32sint: n.RG,
    rg32float: n.RG,
    rgba16uint: n.RGBA,
    rgba16sint: n.RGBA,
    rgba16float: n.RGBA,
    // 128-bit formats
    rgba32uint: n.RGBA,
    rgba32sint: n.RGBA,
    rgba32float: n.RGBA,
    // Depth/stencil formats
    stencil8: n.STENCIL_INDEX8,
    depth16unorm: n.DEPTH_COMPONENT,
    depth24plus: n.DEPTH_COMPONENT,
    "depth24plus-stencil8": n.DEPTH_STENCIL,
    depth32float: n.DEPTH_COMPONENT,
    "depth32float-stencil8": n.DEPTH_STENCIL
  };
}
function R3(n, t) {
  let e = {}, i = n.RGBA;
  return n instanceof ve.get().getWebGLRenderingContext() ? t.srgb && (e = {
    "rgba8unorm-srgb": t.srgb.SRGB8_ALPHA8_EXT,
    "bgra8unorm-srgb": t.srgb.SRGB8_ALPHA8_EXT
  }) : (e = {
    "rgba8unorm-srgb": n.SRGB8_ALPHA8,
    "bgra8unorm-srgb": n.SRGB8_ALPHA8
  }, i = n.RGBA8), {
    // 8-bit formats
    r8unorm: n.R8,
    r8snorm: n.R8_SNORM,
    r8uint: n.R8UI,
    r8sint: n.R8I,
    // 16-bit formats
    r16uint: n.R16UI,
    r16sint: n.R16I,
    r16float: n.R16F,
    rg8unorm: n.RG8,
    rg8snorm: n.RG8_SNORM,
    rg8uint: n.RG8UI,
    rg8sint: n.RG8I,
    // 32-bit formats
    r32uint: n.R32UI,
    r32sint: n.R32I,
    r32float: n.R32F,
    rg16uint: n.RG16UI,
    rg16sint: n.RG16I,
    rg16float: n.RG16F,
    rgba8unorm: n.RGBA,
    ...e,
    // Packed 32-bit formats
    rgba8snorm: n.RGBA8_SNORM,
    rgba8uint: n.RGBA8UI,
    rgba8sint: n.RGBA8I,
    bgra8unorm: i,
    rgb9e5ufloat: n.RGB9_E5,
    rgb10a2unorm: n.RGB10_A2,
    rg11b10ufloat: n.R11F_G11F_B10F,
    // 64-bit formats
    rg32uint: n.RG32UI,
    rg32sint: n.RG32I,
    rg32float: n.RG32F,
    rgba16uint: n.RGBA16UI,
    rgba16sint: n.RGBA16I,
    rgba16float: n.RGBA16F,
    // 128-bit formats
    rgba32uint: n.RGBA32UI,
    rgba32sint: n.RGBA32I,
    rgba32float: n.RGBA32F,
    // Depth/stencil formats
    stencil8: n.STENCIL_INDEX8,
    depth16unorm: n.DEPTH_COMPONENT16,
    depth24plus: n.DEPTH_COMPONENT24,
    "depth24plus-stencil8": n.DEPTH24_STENCIL8,
    depth32float: n.DEPTH_COMPONENT32F,
    "depth32float-stencil8": n.DEPTH32F_STENCIL8,
    // Compressed formats
    ...t.s3tc ? {
      "bc1-rgba-unorm": t.s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT,
      "bc2-rgba-unorm": t.s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT,
      "bc3-rgba-unorm": t.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT
    } : {},
    ...t.s3tc_sRGB ? {
      "bc1-rgba-unorm-srgb": t.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
      "bc2-rgba-unorm-srgb": t.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
      "bc3-rgba-unorm-srgb": t.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
    } : {},
    ...t.rgtc ? {
      "bc4-r-unorm": t.rgtc.COMPRESSED_RED_RGTC1_EXT,
      "bc4-r-snorm": t.rgtc.COMPRESSED_SIGNED_RED_RGTC1_EXT,
      "bc5-rg-unorm": t.rgtc.COMPRESSED_RED_GREEN_RGTC2_EXT,
      "bc5-rg-snorm": t.rgtc.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
    } : {},
    ...t.bptc ? {
      "bc6h-rgb-float": t.bptc.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT,
      "bc6h-rgb-ufloat": t.bptc.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT,
      "bc7-rgba-unorm": t.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT,
      "bc7-rgba-unorm-srgb": t.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
    } : {},
    ...t.etc ? {
      "etc2-rgb8unorm": t.etc.COMPRESSED_RGB8_ETC2,
      "etc2-rgb8unorm-srgb": t.etc.COMPRESSED_SRGB8_ETC2,
      "etc2-rgb8a1unorm": t.etc.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,
      "etc2-rgb8a1unorm-srgb": t.etc.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,
      "etc2-rgba8unorm": t.etc.COMPRESSED_RGBA8_ETC2_EAC,
      "etc2-rgba8unorm-srgb": t.etc.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,
      "eac-r11unorm": t.etc.COMPRESSED_R11_EAC,
      // 'eac-r11snorm'
      "eac-rg11unorm": t.etc.COMPRESSED_SIGNED_RG11_EAC
      // 'eac-rg11snorm'
    } : {},
    ...t.astc ? {
      "astc-4x4-unorm": t.astc.COMPRESSED_RGBA_ASTC_4x4_KHR,
      "astc-4x4-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,
      "astc-5x4-unorm": t.astc.COMPRESSED_RGBA_ASTC_5x4_KHR,
      "astc-5x4-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR,
      "astc-5x5-unorm": t.astc.COMPRESSED_RGBA_ASTC_5x5_KHR,
      "astc-5x5-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,
      "astc-6x5-unorm": t.astc.COMPRESSED_RGBA_ASTC_6x5_KHR,
      "astc-6x5-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,
      "astc-6x6-unorm": t.astc.COMPRESSED_RGBA_ASTC_6x6_KHR,
      "astc-6x6-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,
      "astc-8x5-unorm": t.astc.COMPRESSED_RGBA_ASTC_8x5_KHR,
      "astc-8x5-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,
      "astc-8x6-unorm": t.astc.COMPRESSED_RGBA_ASTC_8x6_KHR,
      "astc-8x6-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,
      "astc-8x8-unorm": t.astc.COMPRESSED_RGBA_ASTC_8x8_KHR,
      "astc-8x8-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,
      "astc-10x5-unorm": t.astc.COMPRESSED_RGBA_ASTC_10x5_KHR,
      "astc-10x5-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,
      "astc-10x6-unorm": t.astc.COMPRESSED_RGBA_ASTC_10x6_KHR,
      "astc-10x6-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,
      "astc-10x8-unorm": t.astc.COMPRESSED_RGBA_ASTC_10x8_KHR,
      "astc-10x8-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,
      "astc-10x10-unorm": t.astc.COMPRESSED_RGBA_ASTC_10x10_KHR,
      "astc-10x10-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,
      "astc-12x10-unorm": t.astc.COMPRESSED_RGBA_ASTC_12x10_KHR,
      "astc-12x10-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,
      "astc-12x12-unorm": t.astc.COMPRESSED_RGBA_ASTC_12x12_KHR,
      "astc-12x12-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
    } : {}
  };
}
function P3(n) {
  return {
    // 8-bit formats
    r8unorm: n.UNSIGNED_BYTE,
    r8snorm: n.BYTE,
    r8uint: n.UNSIGNED_BYTE,
    r8sint: n.BYTE,
    // 16-bit formats
    r16uint: n.UNSIGNED_SHORT,
    r16sint: n.SHORT,
    r16float: n.HALF_FLOAT,
    rg8unorm: n.UNSIGNED_BYTE,
    rg8snorm: n.BYTE,
    rg8uint: n.UNSIGNED_BYTE,
    rg8sint: n.BYTE,
    // 32-bit formats
    r32uint: n.UNSIGNED_INT,
    r32sint: n.INT,
    r32float: n.FLOAT,
    rg16uint: n.UNSIGNED_SHORT,
    rg16sint: n.SHORT,
    rg16float: n.HALF_FLOAT,
    rgba8unorm: n.UNSIGNED_BYTE,
    "rgba8unorm-srgb": n.UNSIGNED_BYTE,
    // Packed 32-bit formats
    rgba8snorm: n.BYTE,
    rgba8uint: n.UNSIGNED_BYTE,
    rgba8sint: n.BYTE,
    bgra8unorm: n.UNSIGNED_BYTE,
    "bgra8unorm-srgb": n.UNSIGNED_BYTE,
    rgb9e5ufloat: n.UNSIGNED_INT_5_9_9_9_REV,
    rgb10a2unorm: n.UNSIGNED_INT_2_10_10_10_REV,
    rg11b10ufloat: n.UNSIGNED_INT_10F_11F_11F_REV,
    // 64-bit formats
    rg32uint: n.UNSIGNED_INT,
    rg32sint: n.INT,
    rg32float: n.FLOAT,
    rgba16uint: n.UNSIGNED_SHORT,
    rgba16sint: n.SHORT,
    rgba16float: n.HALF_FLOAT,
    // 128-bit formats
    rgba32uint: n.UNSIGNED_INT,
    rgba32sint: n.INT,
    rgba32float: n.FLOAT,
    // Depth/stencil formats
    stencil8: n.UNSIGNED_BYTE,
    depth16unorm: n.UNSIGNED_SHORT,
    depth24plus: n.UNSIGNED_INT,
    "depth24plus-stencil8": n.UNSIGNED_INT_24_8,
    depth32float: n.FLOAT,
    "depth32float-stencil8": n.FLOAT_32_UNSIGNED_INT_24_8_REV
  };
}
const B3 = 4;
class nw {
  constructor(t) {
    this.managedTextures = [], this._glTextures = /* @__PURE__ */ Object.create(null), this._glSamplers = /* @__PURE__ */ Object.create(null), this._boundTextures = [], this._activeTextureLocation = -1, this._boundSamplers = /* @__PURE__ */ Object.create(null), this._uploads = {
      image: ew,
      buffer: S3,
      video: C3,
      compressed: w3
    }, this._premultiplyAlpha = !1, this._useSeparateSamplers = !1, this._renderer = t, this._renderer.renderableGC.addManagedHash(this, "_glTextures"), this._renderer.renderableGC.addManagedHash(this, "_glSamplers");
  }
  contextChange(t) {
    this._gl = t, this._mapFormatToInternalFormat || (this._mapFormatToInternalFormat = R3(t, this._renderer.context.extensions), this._mapFormatToType = P3(t), this._mapFormatToFormat = A3(t)), this._glTextures = /* @__PURE__ */ Object.create(null), this._glSamplers = /* @__PURE__ */ Object.create(null), this._boundSamplers = /* @__PURE__ */ Object.create(null), this._premultiplyAlpha = !1;
    for (let e = 0; e < 16; e++)
      this.bind(Tt.EMPTY, e);
  }
  /**
   * Initializes a texture source, if it has already been initialized nothing will happen.
   * @param source - The texture source to initialize.
   * @returns The initialized texture source.
   */
  initSource(t) {
    this.bind(t);
  }
  bind(t, e = 0) {
    const i = t.source;
    t ? (this.bindSource(i, e), this._useSeparateSamplers && this._bindSampler(i.style, e)) : (this.bindSource(null, e), this._useSeparateSamplers && this._bindSampler(null, e));
  }
  bindSource(t, e = 0) {
    const i = this._gl;
    if (t._touched = this._renderer.textureGC.count, this._boundTextures[e] !== t) {
      this._boundTextures[e] = t, this._activateLocation(e), t || (t = Tt.EMPTY.source);
      const s = this.getGlSource(t);
      i.bindTexture(s.target, s.texture);
    }
  }
  _bindSampler(t, e = 0) {
    const i = this._gl;
    if (!t) {
      this._boundSamplers[e] = null, i.bindSampler(e, null);
      return;
    }
    const s = this._getGlSampler(t);
    this._boundSamplers[e] !== s && (this._boundSamplers[e] = s, i.bindSampler(e, s));
  }
  unbind(t) {
    const e = t.source, i = this._boundTextures, s = this._gl;
    for (let o = 0; o < i.length; o++)
      if (i[o] === e) {
        this._activateLocation(o);
        const l = this.getGlSource(e);
        s.bindTexture(l.target, null), i[o] = null;
      }
  }
  _activateLocation(t) {
    this._activeTextureLocation !== t && (this._activeTextureLocation = t, this._gl.activeTexture(this._gl.TEXTURE0 + t));
  }
  _initSource(t) {
    const e = this._gl, i = new _3(e.createTexture());
    if (i.type = this._mapFormatToType[t.format], i.internalFormat = this._mapFormatToInternalFormat[t.format], i.format = this._mapFormatToFormat[t.format], t.autoGenerateMipmaps && (this._renderer.context.supports.nonPowOf2mipmaps || t.isPowerOfTwo)) {
      const s = Math.max(t.width, t.height);
      t.mipLevelCount = Math.floor(Math.log2(s)) + 1;
    }
    return this._glTextures[t.uid] = i, this.managedTextures.includes(t) || (t.on("update", this.onSourceUpdate, this), t.on("resize", this.onSourceUpdate, this), t.on("styleChange", this.onStyleChange, this), t.on("destroy", this.onSourceDestroy, this), t.on("unload", this.onSourceUnload, this), t.on("updateMipmaps", this.onUpdateMipmaps, this), this.managedTextures.push(t)), this.onSourceUpdate(t), this.updateStyle(t, !1), i;
  }
  onStyleChange(t) {
    this.updateStyle(t, !1);
  }
  updateStyle(t, e) {
    const i = this._gl, s = this.getGlSource(t);
    i.bindTexture(i.TEXTURE_2D, s.texture), this._boundTextures[this._activeTextureLocation] = t, k0(
      t.style,
      i,
      t.mipLevelCount > 1,
      this._renderer.context.extensions.anisotropicFiltering,
      "texParameteri",
      i.TEXTURE_2D,
      // will force a clamp to edge if the texture is not a power of two
      !this._renderer.context.supports.nonPowOf2wrapping && !t.isPowerOfTwo,
      e
    );
  }
  onSourceUnload(t) {
    const e = this._glTextures[t.uid];
    e && (this.unbind(t), this._glTextures[t.uid] = null, this._gl.deleteTexture(e.texture));
  }
  onSourceUpdate(t) {
    const e = this._gl, i = this.getGlSource(t);
    e.bindTexture(e.TEXTURE_2D, i.texture), this._boundTextures[this._activeTextureLocation] = t;
    const s = t.alphaMode === "premultiply-alpha-on-upload";
    this._premultiplyAlpha !== s && (this._premultiplyAlpha = s, e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, s)), this._uploads[t.uploadMethodId] ? this._uploads[t.uploadMethodId].upload(t, i, e, this._renderer.context.webGLVersion) : e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, t.pixelWidth, t.pixelHeight, 0, e.RGBA, e.UNSIGNED_BYTE, null), t.autoGenerateMipmaps && t.mipLevelCount > 1 && this.onUpdateMipmaps(t, !1);
  }
  onUpdateMipmaps(t, e = !0) {
    e && this.bindSource(t, 0);
    const i = this.getGlSource(t);
    this._gl.generateMipmap(i.target);
  }
  onSourceDestroy(t) {
    t.off("destroy", this.onSourceDestroy, this), t.off("update", this.onSourceUpdate, this), t.off("resize", this.onSourceUpdate, this), t.off("unload", this.onSourceUnload, this), t.off("styleChange", this.onStyleChange, this), t.off("updateMipmaps", this.onUpdateMipmaps, this), this.managedTextures.splice(this.managedTextures.indexOf(t), 1), this.onSourceUnload(t);
  }
  _initSampler(t) {
    const e = this._gl, i = this._gl.createSampler();
    return this._glSamplers[t._resourceId] = i, k0(
      t,
      e,
      this._boundTextures[this._activeTextureLocation].mipLevelCount > 1,
      this._renderer.context.extensions.anisotropicFiltering,
      "samplerParameteri",
      i,
      !1,
      !0
    ), this._glSamplers[t._resourceId];
  }
  _getGlSampler(t) {
    return this._glSamplers[t._resourceId] || this._initSampler(t);
  }
  getGlSource(t) {
    return this._glTextures[t.uid] || this._initSource(t);
  }
  generateCanvas(t) {
    const { pixels: e, width: i, height: s } = this.getPixels(t), o = ve.get().createCanvas();
    o.width = i, o.height = s;
    const l = o.getContext("2d");
    if (l) {
      const c = l.createImageData(i, s);
      c.data.set(e), l.putImageData(c, 0, 0);
    }
    return o;
  }
  getPixels(t) {
    const e = t.source.resolution, i = t.frame, s = Math.max(Math.round(i.width * e), 1), o = Math.max(Math.round(i.height * e), 1), l = new Uint8Array(B3 * s * o), c = this._renderer, d = c.renderTarget.getRenderTarget(t), f = c.renderTarget.getGpuRenderTarget(d), m = c.gl;
    return m.bindFramebuffer(m.FRAMEBUFFER, f.resolveTargetFramebuffer), m.readPixels(
      Math.round(i.x * e),
      Math.round(i.y * e),
      s,
      o,
      m.RGBA,
      m.UNSIGNED_BYTE,
      l
    ), { pixels: new Uint8ClampedArray(l.buffer), width: s, height: o };
  }
  destroy() {
    this.managedTextures.slice().forEach((t) => this.onSourceDestroy(t)), this.managedTextures = null, this._glTextures = null, this._glSamplers = null, this._boundTextures = null, this._boundSamplers = null, this._mapFormatToInternalFormat = null, this._mapFormatToType = null, this._mapFormatToFormat = null, this._uploads = null, this._renderer = null;
  }
  resetState() {
    this._activeTextureLocation = -1, this._boundTextures.fill(Tt.EMPTY.source), this._boundSamplers = /* @__PURE__ */ Object.create(null);
    const t = this._gl;
    this._premultiplyAlpha = !1, t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._premultiplyAlpha);
  }
}
nw.extension = {
  type: [
    W.WebGLSystem
  ],
  name: "texture"
};
class iw {
  contextChange(t) {
    const e = new Pn({
      uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
      uTransformMatrix: { value: new bt(), type: "mat3x3<f32>" },
      uRound: { value: 0, type: "f32" }
    }), i = t.limits.maxBatchableTextures, s = Zl({
      name: "graphics",
      bits: [
        ug,
        hg(i),
        Sg,
        Jl
      ]
    });
    this.shader = new fi({
      glProgram: s,
      resources: {
        localUniforms: e,
        batchSamplers: dg(i)
      }
    });
  }
  execute(t, e) {
    const i = e.context, s = i.customShader || this.shader, o = t.renderer, l = o.graphicsContext, {
      batcher: c,
      instructions: d
    } = l.getContextRenderData(i);
    s.groups[0] = o.globalUniforms.bindGroup, o.state.set(t.state), o.shader.bind(s), o.geometry.bind(c.geometry, s.glProgram);
    const f = d.instructions;
    for (let m = 0; m < d.instructionSize; m++) {
      const y = f[m];
      if (y.size) {
        for (let b = 0; b < y.textures.count; b++)
          o.texture.bind(y.textures.textures[b], b);
        o.geometry.draw(y.topology, y.size, y.start);
      }
    }
  }
  destroy() {
    this.shader.destroy(!0), this.shader = null;
  }
}
iw.extension = {
  type: [
    W.WebGLPipesAdaptor
  ],
  name: "graphics"
};
class rw {
  init() {
    const t = Zl({
      name: "mesh",
      bits: [
        Sg,
        NB,
        Jl
      ]
    });
    this._shader = new fi({
      glProgram: t,
      resources: {
        uTexture: Tt.EMPTY.source,
        textureUniforms: {
          uTextureMatrix: { type: "mat3x3<f32>", value: new bt() }
        }
      }
    });
  }
  execute(t, e) {
    const i = t.renderer;
    let s = e._shader;
    if (s) {
      if (!s.glProgram) {
        $t("Mesh shader has no glProgram", e.shader);
        return;
      }
    } else {
      s = this._shader;
      const o = e.texture, l = o.source;
      s.resources.uTexture = l, s.resources.uSampler = l.style, s.resources.textureUniforms.uniforms.uTextureMatrix = o.textureMatrix.mapCoord;
    }
    s.groups[100] = i.globalUniforms.bindGroup, s.groups[101] = t.localUniformsBindGroup, i.encoder.draw({
      geometry: e._geometry,
      shader: s,
      state: e.state
    });
  }
  destroy() {
    this._shader.destroy(!0), this._shader = null;
  }
}
rw.extension = {
  type: [
    W.WebGLPipesAdaptor
  ],
  name: "mesh"
};
class sw {
  constructor(t) {
    this._renderer = t;
  }
  updateRenderable() {
  }
  destroyRenderable() {
  }
  validateRenderable() {
    return !1;
  }
  addRenderable(t, e) {
    this._renderer.renderPipes.batch.break(e), e.add(t);
  }
  execute(t) {
    t.isRenderable && t.render(this._renderer);
  }
  destroy() {
    this._renderer = null;
  }
}
sw.extension = {
  type: [
    W.WebGLPipes,
    W.WebGPUPipes,
    W.CanvasPipes
  ],
  name: "customRender"
};
class Ch {
  constructor() {
    this.batcherName = "default", this.topology = "triangle-list", this.attributeSize = 4, this.indexSize = 6, this.packAsQuad = !0, this.roundPixels = 0, this._attributeStart = 0, this._batcher = null, this._batch = null;
  }
  get blendMode() {
    return this.renderable.groupBlendMode;
  }
  get color() {
    return this.renderable.groupColorAlpha;
  }
  reset() {
    this.renderable = null, this.texture = null, this._batcher = null, this._batch = null, this.bounds = null;
  }
  destroy() {
  }
}
function Pm(n, t) {
  const e = n.instructionSet, i = e.instructions;
  for (let s = 0; s < e.instructionSize; s++) {
    const o = i[s];
    t[o.renderPipeId].execute(o);
  }
}
const k3 = new bt();
class aw {
  constructor(t) {
    this._renderer = t;
  }
  addRenderGroup(t, e) {
    t.isCachedAsTexture ? this._addRenderableCacheAsTexture(t, e) : this._addRenderableDirect(t, e);
  }
  execute(t) {
    t.isRenderable && (t.isCachedAsTexture ? this._executeCacheAsTexture(t) : this._executeDirect(t));
  }
  destroy() {
    this._renderer = null;
  }
  _addRenderableDirect(t, e) {
    this._renderer.renderPipes.batch.break(e), t._batchableRenderGroup && (Qe.return(t._batchableRenderGroup), t._batchableRenderGroup = null), e.add(t);
  }
  _addRenderableCacheAsTexture(t, e) {
    const i = t._batchableRenderGroup ?? (t._batchableRenderGroup = Qe.get(Ch));
    i.renderable = t.root, i.transform = t.root.relativeGroupTransform, i.texture = t.texture, i.bounds = t._textureBounds, e.add(t), this._renderer.renderPipes.blendMode.pushBlendMode(t, t.root.groupBlendMode, e), this._renderer.renderPipes.batch.addToBatch(i, e), this._renderer.renderPipes.blendMode.popBlendMode(e);
  }
  _executeCacheAsTexture(t) {
    if (t.textureNeedsUpdate) {
      t.textureNeedsUpdate = !1;
      const e = k3.identity().translate(
        -t._textureBounds.x,
        -t._textureBounds.y
      );
      this._renderer.renderTarget.push(t.texture, !0, null, t.texture.frame), this._renderer.globalUniforms.push({
        worldTransformMatrix: e,
        worldColor: 4294967295,
        offset: { x: 0, y: 0 }
      }), Pm(t, this._renderer.renderPipes), this._renderer.renderTarget.finishRenderPass(), this._renderer.renderTarget.pop(), this._renderer.globalUniforms.pop();
    }
    t._batchableRenderGroup._batcher.updateElement(t._batchableRenderGroup), t._batchableRenderGroup._batcher.geometry.buffers[0].update();
  }
  _executeDirect(t) {
    this._renderer.globalUniforms.push({
      worldTransformMatrix: t.inverseParentTextureTransform,
      worldColor: t.worldColorAlpha
    }), Pm(t, this._renderer.renderPipes), this._renderer.globalUniforms.pop();
  }
}
aw.extension = {
  type: [
    W.WebGLPipes,
    W.WebGPUPipes,
    W.CanvasPipes
  ],
  name: "renderGroup"
};
function Bm(n, t) {
  t || (t = 0);
  for (let e = t; e < n.length && n[e]; e++)
    n[e] = null;
}
const O3 = new Rn(), O0 = Cl | nh | eg;
function ow(n, t = !1) {
  D3(n);
  const e = n.childrenToUpdate, i = n.updateTick++;
  for (const s in e) {
    const o = Number(s), l = e[s], c = l.list, d = l.index;
    for (let f = 0; f < d; f++) {
      const m = c[f];
      m.parentRenderGroup === n && m.relativeRenderGroupDepth === o && lw(m, i, 0);
    }
    Bm(c, d), l.index = 0;
  }
  if (t)
    for (let s = 0; s < n.renderGroupChildren.length; s++)
      ow(n.renderGroupChildren[s], t);
}
function D3(n) {
  const t = n.root;
  let e;
  if (n.renderGroupParent) {
    const i = n.renderGroupParent;
    n.worldTransform.appendFrom(
      t.relativeGroupTransform,
      i.worldTransform
    ), n.worldColor = eh(
      t.groupColor,
      i.worldColor
    ), e = t.groupAlpha * i.worldAlpha;
  } else
    n.worldTransform.copyFrom(t.localTransform), n.worldColor = t.localColor, e = t.localAlpha;
  e = e < 0 ? 0 : e > 1 ? 1 : e, n.worldAlpha = e, n.worldColorAlpha = n.worldColor + ((e * 255 | 0) << 24);
}
function lw(n, t, e) {
  if (t === n.updateTick)
    return;
  n.updateTick = t, n.didChange = !1;
  const i = n.localTransform;
  n.updateLocalTransform();
  const s = n.parent;
  if (s && !s.renderGroup ? (e |= n._updateFlags, n.relativeGroupTransform.appendFrom(
    i,
    s.relativeGroupTransform
  ), e & O0 && D0(n, s, e)) : (e = n._updateFlags, n.relativeGroupTransform.copyFrom(i), e & O0 && D0(n, O3, e)), !n.renderGroup) {
    const o = n.children, l = o.length;
    for (let f = 0; f < l; f++)
      lw(o[f], t, e);
    const c = n.parentRenderGroup, d = n;
    d.renderPipeId && !c.structureDidChange && c.updateRenderable(d);
  }
}
function D0(n, t, e) {
  if (e & nh) {
    n.groupColor = eh(
      n.localColor,
      t.groupColor
    );
    let i = n.localAlpha * t.groupAlpha;
    i = i < 0 ? 0 : i > 1 ? 1 : i, n.groupAlpha = i, n.groupColorAlpha = n.groupColor + ((i * 255 | 0) << 24);
  }
  e & eg && (n.groupBlendMode = n.localBlendMode === "inherit" ? t.groupBlendMode : n.localBlendMode), e & Cl && (n.globalDisplayStatus = n.localDisplayStatus & t.globalDisplayStatus), n._updateFlags = 0;
}
function G3(n, t) {
  const { list: e, index: i } = n.childrenRenderablesToUpdate;
  let s = !1;
  for (let o = 0; o < i; o++) {
    const l = e[o];
    if (s = t[l.renderPipeId].validateRenderable(l), s)
      break;
  }
  return n.structureDidChange = s, s;
}
const U3 = new bt();
class uw {
  constructor(t) {
    this._renderer = t;
  }
  render({ container: t, transform: e }) {
    const i = t.parent, s = t.renderGroup.renderGroupParent;
    t.parent = null, t.renderGroup.renderGroupParent = null;
    const o = this._renderer, l = U3;
    e && (l.copyFrom(t.renderGroup.localTransform), t.renderGroup.localTransform.copyFrom(e));
    const c = o.renderPipes;
    this._updateCachedRenderGroups(t.renderGroup, null), this._updateRenderGroups(t.renderGroup), o.globalUniforms.start({
      worldTransformMatrix: e ? t.renderGroup.localTransform : t.renderGroup.worldTransform,
      worldColor: t.renderGroup.worldColorAlpha
    }), Pm(t.renderGroup, c), c.uniformBatch && c.uniformBatch.renderEnd(), e && t.renderGroup.localTransform.copyFrom(l), t.parent = i, t.renderGroup.renderGroupParent = s;
  }
  destroy() {
    this._renderer = null;
  }
  _updateCachedRenderGroups(t, e) {
    if (t._parentCacheAsTextureRenderGroup = e, t.isCachedAsTexture) {
      if (!t.textureNeedsUpdate)
        return;
      e = t;
    }
    for (let i = t.renderGroupChildren.length - 1; i >= 0; i--)
      this._updateCachedRenderGroups(t.renderGroupChildren[i], e);
    if (t.invalidateMatrices(), t.isCachedAsTexture) {
      if (t.textureNeedsUpdate) {
        const i = t.root.getLocalBounds();
        i.ceil();
        const s = t.texture;
        t.texture && mn.returnTexture(t.texture, !0);
        const o = this._renderer, l = t.textureOptions.resolution || o.view.resolution, c = t.textureOptions.antialias ?? o.view.antialias, d = t.textureOptions.scaleMode ?? "linear", f = mn.getOptimalTexture(
          i.width,
          i.height,
          l,
          c
        );
        f._source.style = new Qr({ scaleMode: d }), t.texture = f, t._textureBounds || (t._textureBounds = new Cn()), t._textureBounds.copyFrom(i), s !== t.texture && t.renderGroupParent && (t.renderGroupParent.structureDidChange = !0);
      }
    } else t.texture && (mn.returnTexture(t.texture, !0), t.texture = null);
  }
  _updateRenderGroups(t) {
    const e = this._renderer, i = e.renderPipes;
    if (t.runOnRender(e), t.instructionSet.renderPipes = i, t.structureDidChange ? Bm(t.childrenRenderablesToUpdate.list, 0) : G3(t, i), ow(t), t.structureDidChange ? (t.structureDidChange = !1, this._buildInstructions(t, e)) : this._updateRenderables(t), t.childrenRenderablesToUpdate.index = 0, e.renderPipes.batch.upload(t.instructionSet), !(t.isCachedAsTexture && !t.textureNeedsUpdate))
      for (let s = 0; s < t.renderGroupChildren.length; s++)
        this._updateRenderGroups(t.renderGroupChildren[s]);
  }
  _updateRenderables(t) {
    const { list: e, index: i } = t.childrenRenderablesToUpdate;
    for (let s = 0; s < i; s++) {
      const o = e[s];
      o.didViewUpdate && t.updateRenderable(o);
    }
    Bm(e, i);
  }
  _buildInstructions(t, e) {
    const i = t.root, s = t.instructionSet;
    s.reset();
    const o = e.renderPipes ? e : e.batch.renderer, l = o.renderPipes;
    l.batch.buildStart(s), l.blendMode.buildStart(), l.colorMask.buildStart(), i.sortableChildren && i.sortChildren(), i.collectRenderablesWithEffects(s, o, null), l.batch.buildEnd(s), l.blendMode.buildEnd(s);
  }
}
uw.extension = {
  type: [
    W.WebGLSystem,
    W.WebGPUSystem,
    W.CanvasSystem
  ],
  name: "renderGroup"
};
class cw {
  constructor(t) {
    this._renderer = t;
  }
  addRenderable(t, e) {
    const i = this._getGpuSprite(t);
    t.didViewUpdate && this._updateBatchableSprite(t, i), this._renderer.renderPipes.batch.addToBatch(i, e);
  }
  updateRenderable(t) {
    const e = this._getGpuSprite(t);
    t.didViewUpdate && this._updateBatchableSprite(t, e), e._batcher.updateElement(e);
  }
  validateRenderable(t) {
    const e = this._getGpuSprite(t);
    return !e._batcher.checkAndUpdateTexture(
      e,
      t._texture
    );
  }
  _updateBatchableSprite(t, e) {
    e.bounds = t.visualBounds, e.texture = t._texture;
  }
  _getGpuSprite(t) {
    return t._gpuData[this._renderer.uid] || this._initGPUSprite(t);
  }
  _initGPUSprite(t) {
    const e = new Ch();
    return e.renderable = t, e.transform = t.groupTransform, e.texture = t._texture, e.bounds = t.visualBounds, e.roundPixels = this._renderer._roundPixels | t._roundPixels, t._gpuData[this._renderer.uid] = e, e;
  }
  destroy() {
    this._renderer = null;
  }
}
cw.extension = {
  type: [
    W.WebGLPipes,
    W.WebGPUPipes,
    W.CanvasPipes
  ],
  name: "sprite"
};
const Eg = class hw {
  constructor() {
    this.clearBeforeRender = !0, this._backgroundColor = new Pe(0), this.color = this._backgroundColor, this.alpha = 1;
  }
  /**
   * initiates the background system
   * @param options - the options for the background colors
   */
  init(t) {
    t = { ...hw.defaultOptions, ...t }, this.clearBeforeRender = t.clearBeforeRender, this.color = t.background || t.backgroundColor || this._backgroundColor, this.alpha = t.backgroundAlpha, this._backgroundColor.setAlpha(t.backgroundAlpha);
  }
  /** The background color to fill if not transparent */
  get color() {
    return this._backgroundColor;
  }
  set color(t) {
    Pe.shared.setValue(t).alpha < 1 && this._backgroundColor.alpha === 1 && $t(
      "Cannot set a transparent background on an opaque canvas. To enable transparency, set backgroundAlpha < 1 when initializing your Application."
    ), this._backgroundColor.setValue(t);
  }
  /** The background color alpha. Setting this to 0 will make the canvas transparent. */
  get alpha() {
    return this._backgroundColor.alpha;
  }
  set alpha(t) {
    this._backgroundColor.setAlpha(t);
  }
  /** The background color as an [R, G, B, A] array. */
  get colorRgba() {
    return this._backgroundColor.toArray();
  }
  /**
   * destroys the background system
   * @internal
   */
  destroy() {
  }
};
Eg.extension = {
  type: [
    W.WebGLSystem,
    W.WebGPUSystem,
    W.CanvasSystem
  ],
  name: "background",
  priority: 0
};
Eg.defaultOptions = {
  /**
   * {@link WebGLOptions.backgroundAlpha}
   * @default 1
   */
  backgroundAlpha: 1,
  /**
   * {@link WebGLOptions.backgroundColor}
   * @default 0x000000
   */
  backgroundColor: 0,
  /**
   * {@link WebGLOptions.clearBeforeRender}
   * @default true
   */
  clearBeforeRender: !0
};
let N3 = Eg;
const Pl = {};
Nt.handle(W.BlendMode, (n) => {
  if (!n.name)
    throw new Error("BlendMode extension must have a name property");
  Pl[n.name] = n.ref;
}, (n) => {
  delete Pl[n.name];
});
class dw {
  constructor(t) {
    this._blendModeStack = [], this._isAdvanced = !1, this._filterHash = /* @__PURE__ */ Object.create(null), this._renderer = t, this._renderer.runners.prerender.add(this);
  }
  prerender() {
    this._activeBlendMode = "normal", this._isAdvanced = !1;
  }
  /**
   * Push a blend mode onto the internal stack and apply it to the instruction set if needed.
   * @param renderable - The renderable or {@link RenderGroup} associated with the change.
   * @param blendMode - The blend mode to activate.
   * @param instructionSet - The instruction set being built.
   */
  pushBlendMode(t, e, i) {
    this._blendModeStack.push(e), this.setBlendMode(t, e, i);
  }
  /**
   * Pop the last blend mode from the stack and apply the new top-of-stack mode.
   * @param instructionSet - The instruction set being built.
   */
  popBlendMode(t) {
    this._blendModeStack.pop();
    const e = this._blendModeStack[this._activeBlendMode.length - 1] ?? "normal";
    this.setBlendMode(null, e, t);
  }
  /**
   * Ensure a blend mode switch is added to the instruction set when the mode changes.
   * If an advanced blend mode is active, subsequent renderables will be collected so they can be
   * rendered within a single filter pass.
   * @param renderable - The renderable or {@link RenderGroup} to associate with the change, or null when unwinding.
   * @param blendMode - The target blend mode.
   * @param instructionSet - The instruction set being built.
   */
  setBlendMode(t, e, i) {
    const s = t instanceof dm;
    if (this._activeBlendMode === e) {
      this._isAdvanced && t && !s && this._renderableList?.push(t);
      return;
    }
    this._isAdvanced && this._endAdvancedBlendMode(i), this._activeBlendMode = e, t && (this._isAdvanced = !!Pl[e], this._isAdvanced && this._beginAdvancedBlendMode(t, i));
  }
  _beginAdvancedBlendMode(t, e) {
    this._renderer.renderPipes.batch.break(e);
    const i = this._activeBlendMode;
    if (!Pl[i]) {
      $t(`Unable to assign BlendMode: '${i}'. You may want to include: import 'pixi.js/advanced-blend-modes'`);
      return;
    }
    const s = this._ensureFilterEffect(i), o = t instanceof dm, l = {
      renderPipeId: "filter",
      action: "pushFilter",
      filterEffect: s,
      renderables: o ? null : [t],
      container: o ? t.root : null,
      canBundle: !1
    };
    this._renderableList = l.renderables, e.add(l);
  }
  _ensureFilterEffect(t) {
    let e = this._filterHash[t];
    return e || (e = this._filterHash[t] = new th(), e.filters = [new Pl[t]()]), e;
  }
  _endAdvancedBlendMode(t) {
    this._isAdvanced = !1, this._renderableList = null, this._renderer.renderPipes.batch.break(t), t.add({
      renderPipeId: "filter",
      action: "popFilter",
      canBundle: !1
    });
  }
  /**
   * called when the instruction build process is starting this will reset internally to the default blend mode
   * @internal
   */
  buildStart() {
    this._isAdvanced = !1;
  }
  /**
   * called when the instruction build process is finished, ensuring that if there is an advanced blend mode
   * active, we add the final render instructions added to the instruction set
   * @param instructionSet - The instruction set we are adding to
   * @internal
   */
  buildEnd(t) {
    this._isAdvanced && this._endAdvancedBlendMode(t);
  }
  /** @internal */
  destroy() {
    this._renderer = null, this._renderableList = null;
    for (const t in this._filterHash)
      this._filterHash[t].destroy();
    this._filterHash = null;
  }
}
dw.extension = {
  type: [
    W.WebGLPipes,
    W.WebGPUPipes,
    W.CanvasPipes
  ],
  name: "blendMode"
};
const Hp = {
  png: "image/png",
  jpg: "image/jpeg",
  webp: "image/webp"
}, Mg = class fw {
  /** @param renderer - The renderer this System works for. */
  constructor(t) {
    this._renderer = t;
  }
  _normalizeOptions(t, e = {}) {
    return t instanceof Rn || t instanceof Tt ? {
      target: t,
      ...e
    } : {
      ...e,
      ...t
    };
  }
  /**
   * Creates an IImage from a display object or texture.
   * @param options - Options for creating the image, or the target to extract
   * @returns Promise that resolves with the generated IImage
   * @example
   * ```ts
   * // Basic usage with a sprite
   * const sprite = new Sprite(texture);
   * const image = await renderer.extract.image(sprite);
   * document.body.appendChild(image);
   *
   * // Advanced usage with options
   * const image = await renderer.extract.image({
   *     target: container,
   *     format: 'webp',
   *     quality: 0.8,
   *     frame: new Rectangle(0, 0, 100, 100),
   *     resolution: 2,
   *     clearColor: '#ff0000',
   *     antialias: true
   * });
   *
   * // Extract directly from a texture
   * const texture = Texture.from('myTexture.png');
   * const image = await renderer.extract.image(texture);
   * ```
   * @see {@link ExtractImageOptions} For detailed options
   * @see {@link ExtractSystem.base64} For base64 string output
   * @see {@link ExtractSystem.canvas} For canvas output
   * @see {@link ImageLike} For the image interface
   * @category rendering
   */
  async image(t) {
    const e = ve.get().createImage();
    return e.src = await this.base64(t), e;
  }
  /**
   * Converts the target into a base64 encoded string.
   *
   * This method works by first creating
   * a canvas using `Extract.canvas` and then converting it to a base64 string.
   * @param options - The options for creating the base64 string, or the target to extract
   * @returns Promise that resolves with the base64 encoded string
   * @example
   * ```ts
   * // Basic usage with a sprite
   * const sprite = new Sprite(texture);
   * const base64 = await renderer.extract.base64(sprite);
   * console.log(base64); // data:image/png;base64,...
   *
   * // Advanced usage with options
   * const base64 = await renderer.extract.base64({
   *     target: container,
   *     format: 'webp',
   *     quality: 0.8,
   *     frame: new Rectangle(0, 0, 100, 100),
   *     resolution: 2
   * });
   * ```
   * @throws Will throw an error if the platform doesn't support any of:
   * - ICanvas.toDataURL
   * - ICanvas.toBlob
   * - ICanvas.convertToBlob
   * @see {@link ExtractImageOptions} For detailed options
   * @see {@link ExtractSystem.canvas} For canvas output
   * @see {@link ExtractSystem.image} For HTMLImage output
   * @category rendering
   */
  async base64(t) {
    t = this._normalizeOptions(
      t,
      fw.defaultImageOptions
    );
    const { format: e, quality: i } = t, s = this.canvas(t);
    if (s.toBlob !== void 0)
      return new Promise((o, l) => {
        s.toBlob((c) => {
          if (!c) {
            l(new Error("ICanvas.toBlob failed!"));
            return;
          }
          const d = new FileReader();
          d.onload = () => o(d.result), d.onerror = l, d.readAsDataURL(c);
        }, Hp[e], i);
      });
    if (s.toDataURL !== void 0)
      return s.toDataURL(Hp[e], i);
    if (s.convertToBlob !== void 0) {
      const o = await s.convertToBlob({ type: Hp[e], quality: i });
      return new Promise((l, c) => {
        const d = new FileReader();
        d.onload = () => l(d.result), d.onerror = c, d.readAsDataURL(o);
      });
    }
    throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented");
  }
  /**
   * Creates a Canvas element, renders the target to it and returns it.
   * This method is useful for creating static images or when you need direct canvas access.
   * @param options - The options for creating the canvas, or the target to extract
   * @returns A Canvas element with the texture rendered on
   * @example
   * ```ts
   * // Basic canvas extraction from a sprite
   * const sprite = new Sprite(texture);
   * const canvas = renderer.extract.canvas(sprite);
   * document.body.appendChild(canvas);
   *
   * // Extract with custom region
   * const canvas = renderer.extract.canvas({
   *     target: container,
   *     frame: new Rectangle(0, 0, 100, 100)
   * });
   *
   * // Extract with high resolution
   * const canvas = renderer.extract.canvas({
   *     target: sprite,
   *     resolution: 2,
   *     clearColor: '#ff0000'
   * });
   *
   * // Extract directly from a texture
   * const texture = Texture.from('myTexture.png');
   * const canvas = renderer.extract.canvas(texture);
   *
   * // Extract with anti-aliasing
   * const canvas = renderer.extract.canvas({
   *     target: graphics,
   *     antialias: true
   * });
   * ```
   * @see {@link ExtractOptions} For detailed options
   * @see {@link ExtractSystem.image} For HTMLImage output
   * @see {@link ExtractSystem.pixels} For raw pixel data
   * @category rendering
   */
  canvas(t) {
    t = this._normalizeOptions(t);
    const e = t.target, i = this._renderer;
    if (e instanceof Tt)
      return i.texture.generateCanvas(e);
    const s = i.textureGenerator.generateTexture(t), o = i.texture.generateCanvas(s);
    return s.destroy(!0), o;
  }
  /**
   * Returns a one-dimensional array containing the pixel data of the entire texture in RGBA order,
   * with integer values between 0 and 255 (inclusive).
   * > [!NOE] The returned array is a flat Uint8Array where every 4 values represent RGBA
   * @param options - The options for extracting the image, or the target to extract
   * @returns One-dimensional Uint8Array containing the pixel data in RGBA format
   * @example
   * ```ts
   * // Basic pixel extraction
   * const sprite = new Sprite(texture);
   * const pixels = renderer.extract.pixels(sprite);
   * console.log(pixels[0], pixels[1], pixels[2], pixels[3]); // R,G,B,A values
   *
   * // Extract with custom region
   * const pixels = renderer.extract.pixels({
   *     target: sprite,
   *     frame: new Rectangle(0, 0, 100, 100)
   * });
   *
   * // Extract with high resolution
   * const pixels = renderer.extract.pixels({
   *     target: sprite,
   *     resolution: 2
   * });
   * ```
   * @see {@link ExtractOptions} For detailed options
   * @see {@link ExtractSystem.canvas} For canvas output
   * @see {@link ExtractSystem.image} For image output
   * @category rendering
   */
  pixels(t) {
    t = this._normalizeOptions(t);
    const e = t.target, i = this._renderer, s = e instanceof Tt ? e : i.textureGenerator.generateTexture(t), o = i.texture.getPixels(s);
    return e instanceof Rn && s.destroy(!0), o;
  }
  /**
   * Creates a texture from a display object or existing texture.
   *
   * This is useful for creating
   * reusable textures from rendered content or making copies of existing textures.
   * > [!NOTE] The returned texture should be destroyed when no longer needed
   * @param options - The options for creating the texture, or the target to extract
   * @returns A new texture containing the extracted content
   * @example
   * ```ts
   * // Basic texture extraction from a sprite
   * const sprite = new Sprite(texture);
   * const extractedTexture = renderer.extract.texture(sprite);
   *
   * // Extract with custom region
   * const regionTexture = renderer.extract.texture({
   *     target: container,
   *     frame: new Rectangle(0, 0, 100, 100)
   * });
   *
   * // Extract with high resolution
   * const hiResTexture = renderer.extract.texture({
   *     target: sprite,
   *     resolution: 2,
   *     clearColor: '#ff0000'
   * });
   *
   * // Create a new sprite from extracted texture
   * const newSprite = new Sprite(
   *     renderer.extract.texture({
   *         target: graphics,
   *         antialias: true
   *     })
   * );
   *
   * // Clean up when done
   * extractedTexture.destroy(true);
   * ```
   * @see {@link ExtractOptions} For detailed options
   * @see {@link Texture} For texture management
   * @see {@link GenerateTextureSystem} For texture generation
   * @category rendering
   */
  texture(t) {
    return t = this._normalizeOptions(t), t.target instanceof Tt ? t.target : this._renderer.textureGenerator.generateTexture(t);
  }
  /**
   * Extracts and downloads content from the renderer as an image file.
   * This is a convenient way to save screenshots or export rendered content.
   * > [!NOTE] The download will use PNG format regardless of the filename extension
   * @param options - The options for downloading and extracting the image, or the target to extract
   * @example
   * ```ts
   * // Basic download with default filename
   * const sprite = new Sprite(texture);
   * renderer.extract.download(sprite); // Downloads as 'image.png'
   *
   * // Download with custom filename
   * renderer.extract.download({
   *     target: sprite,
   *     filename: 'screenshot.png'
   * });
   *
   * // Download with custom region
   * renderer.extract.download({
   *     target: container,
   *     filename: 'region.png',
   *     frame: new Rectangle(0, 0, 100, 100)
   * });
   *
   * // Download with high resolution and background
   * renderer.extract.download({
   *     target: stage,
   *     filename: 'hd-screenshot.png',
   *     resolution: 2,
   *     clearColor: '#ff0000'
   * });
   *
   * // Download with anti-aliasing
   * renderer.extract.download({
   *     target: graphics,
   *     filename: 'smooth.png',
   *     antialias: true
   * });
   * ```
   * @see {@link ExtractDownloadOptions} For detailed options
   * @see {@link ExtractSystem.image} For creating images without download
   * @see {@link ExtractSystem.canvas} For canvas output
   * @category rendering
   */
  download(t) {
    t = this._normalizeOptions(t);
    const e = this.canvas(t), i = document.createElement("a");
    i.download = t.filename ?? "image.png", i.href = e.toDataURL("image/png"), document.body.appendChild(i), i.click(), document.body.removeChild(i);
  }
  /**
   * Logs the target to the console as an image. This is a useful way to debug what's happening in the renderer.
   * The image will be displayed in the browser's console using CSS background images.
   * @param options - The options for logging the image, or the target to log
   * @param options.width - The width of the logged image preview in the console (in pixels)
   * @example
   * ```ts
   * // Basic usage
   * const sprite = new Sprite(texture);
   * renderer.extract.log(sprite);
   * ```
   * @see {@link ExtractSystem.canvas} For getting raw canvas output
   * @see {@link ExtractSystem.pixels} For raw pixel data
   * @category rendering
   * @advanced
   */
  log(t) {
    const e = t.width ?? 200;
    t = this._normalizeOptions(t);
    const i = this.canvas(t), s = i.toDataURL();
    console.log(`[Pixi Texture] ${i.width}px ${i.height}px`);
    const o = [
      "font-size: 1px;",
      `padding: ${e}px 300px;`,
      `background: url(${s}) no-repeat;`,
      "background-size: contain;"
    ].join(" ");
    console.log("%c ", o);
  }
  destroy() {
    this._renderer = null;
  }
};
Mg.extension = {
  type: [
    W.WebGLSystem,
    W.WebGPUSystem
  ],
  name: "extract"
};
Mg.defaultImageOptions = {
  format: "png",
  quality: 1
};
let I3 = Mg;
class Ag extends Tt {
  static create(t) {
    return new Ag({
      source: new rn(t)
    });
  }
  /**
   * Resizes the render texture.
   * @param width - The new width of the render texture.
   * @param height - The new height of the render texture.
   * @param resolution - The new resolution of the render texture.
   * @returns This texture.
   */
  resize(t, e, i) {
    return this.source.resize(t, e, i), this;
  }
}
const z3 = new ne(), L3 = new Cn(), F3 = [0, 0, 0, 0];
class pw {
  constructor(t) {
    this._renderer = t;
  }
  /**
   * Creates a texture from a display object that can be used for creating sprites and other textures.
   * This is particularly useful for optimizing performance when a complex container needs to be reused.
   * @param options - Generate texture options or a container to convert to texture
   * @returns A new RenderTexture containing the rendered display object
   * @example
   * ```ts
   * // Basic usage with a container
   * const container = new Container();
   * container.addChild(
   *     new Graphics()
   *         .circle(0, 0, 50)
   *         .fill('red')
   * );
   *
   * const texture = renderer.textureGenerator.generateTexture(container);
   *
   * // Advanced usage with options
   * const texture = renderer.textureGenerator.generateTexture({
   *     target: container,
   *     frame: new Rectangle(0, 0, 100, 100), // Specific region
   *     resolution: 2,                        // High DPI
   *     clearColor: '#ff0000',               // Red background
   *     antialias: true                      // Smooth edges
   * });
   *
   * // Create a sprite from the generated texture
   * const sprite = new Sprite(texture);
   *
   * // Clean up when done
   * texture.destroy(true);
   * ```
   * @see {@link GenerateTextureOptions} For detailed texture generation options
   * @see {@link RenderTexture} For the type of texture created
   * @category rendering
   */
  generateTexture(t) {
    t instanceof Rn && (t = {
      target: t,
      frame: void 0,
      textureSourceOptions: {},
      resolution: void 0
    });
    const e = t.resolution || this._renderer.resolution, i = t.antialias || this._renderer.view.antialias, s = t.target;
    let o = t.clearColor;
    o ? o = Array.isArray(o) && o.length === 4 ? o : Pe.shared.setValue(o).toArray() : o = F3;
    const l = t.frame?.copyTo(z3) || tg(s, L3).rectangle;
    l.width = Math.max(l.width, 1 / e) | 0, l.height = Math.max(l.height, 1 / e) | 0;
    const c = Ag.create({
      ...t.textureSourceOptions,
      width: l.width,
      height: l.height,
      resolution: e,
      antialias: i
    }), d = bt.shared.translate(-l.x, -l.y);
    return this._renderer.render({
      container: s,
      transform: d,
      target: c,
      clearColor: o
    }), c.source.updateMipmaps(), c;
  }
  destroy() {
    this._renderer = null;
  }
}
pw.extension = {
  type: [
    W.WebGLSystem,
    W.WebGPUSystem
  ],
  name: "textureGenerator"
};
function tu(n, t, e) {
  const i = (n >> 24 & 255) / 255;
  t[e++] = (n & 255) / 255 * i, t[e++] = (n >> 8 & 255) / 255 * i, t[e++] = (n >> 16 & 255) / 255 * i, t[e++] = i;
}
class mw {
  constructor(t) {
    this._stackIndex = 0, this._globalUniformDataStack = [], this._uniformsPool = [], this._activeUniforms = [], this._bindGroupPool = [], this._activeBindGroups = [], this._renderer = t;
  }
  reset() {
    this._stackIndex = 0;
    for (let t = 0; t < this._activeUniforms.length; t++)
      this._uniformsPool.push(this._activeUniforms[t]);
    for (let t = 0; t < this._activeBindGroups.length; t++)
      this._bindGroupPool.push(this._activeBindGroups[t]);
    this._activeUniforms.length = 0, this._activeBindGroups.length = 0;
  }
  start(t) {
    this.reset(), this.push(t);
  }
  bind({
    size: t,
    projectionMatrix: e,
    worldTransformMatrix: i,
    worldColor: s,
    offset: o
  }) {
    const l = this._renderer.renderTarget.renderTarget, c = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : {
      worldTransformMatrix: new bt(),
      worldColor: 4294967295,
      offset: new Ut()
    }, d = {
      projectionMatrix: e || this._renderer.renderTarget.projectionMatrix,
      resolution: t || l.size,
      worldTransformMatrix: i || c.worldTransformMatrix,
      worldColor: s || c.worldColor,
      offset: o || c.offset,
      bindGroup: null
    }, f = this._uniformsPool.pop() || this._createUniforms();
    this._activeUniforms.push(f);
    const m = f.uniforms;
    m.uProjectionMatrix = d.projectionMatrix, m.uResolution = d.resolution, m.uWorldTransformMatrix.copyFrom(d.worldTransformMatrix), m.uWorldTransformMatrix.tx -= d.offset.x, m.uWorldTransformMatrix.ty -= d.offset.y, tu(
      d.worldColor,
      m.uWorldColorAlpha,
      0
    ), f.update();
    let y;
    this._renderer.renderPipes.uniformBatch ? y = this._renderer.renderPipes.uniformBatch.getUniformBindGroup(f, !1) : (y = this._bindGroupPool.pop() || new yr(), this._activeBindGroups.push(y), y.setResource(f, 0)), d.bindGroup = y, this._currentGlobalUniformData = d;
  }
  push(t) {
    this.bind(t), this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData;
  }
  pop() {
    this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1], this._renderer.type === Ti.WEBGL && this._currentGlobalUniformData.bindGroup.resources[0].update();
  }
  get bindGroup() {
    return this._currentGlobalUniformData.bindGroup;
  }
  get globalUniformData() {
    return this._currentGlobalUniformData;
  }
  get uniformGroup() {
    return this._currentGlobalUniformData.bindGroup.resources[0];
  }
  _createUniforms() {
    return new Pn({
      uProjectionMatrix: { value: new bt(), type: "mat3x3<f32>" },
      uWorldTransformMatrix: { value: new bt(), type: "mat3x3<f32>" },
      // TODO - someone smart - set this to be a unorm8x4 rather than a vec4<f32>
      uWorldColorAlpha: { value: new Float32Array(4), type: "vec4<f32>" },
      uResolution: { value: [0, 0], type: "vec2<f32>" }
    }, {
      isStatic: !0
    });
  }
  destroy() {
    this._renderer = null, this._globalUniformDataStack.length = 0, this._uniformsPool.length = 0, this._activeUniforms.length = 0, this._bindGroupPool.length = 0, this._activeBindGroups.length = 0, this._currentGlobalUniformData = null;
  }
}
mw.extension = {
  type: [
    W.WebGLSystem,
    W.WebGPUSystem,
    W.CanvasSystem
  ],
  name: "globalUniforms"
};
let H3 = 1;
class gw {
  constructor() {
    this._tasks = [], this._offset = 0;
  }
  /** Initializes the scheduler system and starts the ticker. */
  init() {
    Kn.system.add(this._update, this);
  }
  /**
   * Schedules a repeating task.
   * @param func - The function to execute.
   * @param duration - The interval duration in milliseconds.
   * @param useOffset - this will spread out tasks so that they do not all run at the same time
   * @returns The unique identifier for the scheduled task.
   */
  repeat(t, e, i = !0) {
    const s = H3++;
    let o = 0;
    return i && (this._offset += 1e3, o = this._offset), this._tasks.push({
      func: t,
      duration: e,
      start: performance.now(),
      offset: o,
      last: performance.now(),
      repeat: !0,
      id: s
    }), s;
  }
  /**
   * Cancels a scheduled task.
   * @param id - The unique identifier of the task to cancel.
   */
  cancel(t) {
    for (let e = 0; e < this._tasks.length; e++)
      if (this._tasks[e].id === t) {
        this._tasks.splice(e, 1);
        return;
      }
  }
  /**
   * Updates and executes the scheduled tasks.
   * @private
   */
  _update() {
    const t = performance.now();
    for (let e = 0; e < this._tasks.length; e++) {
      const i = this._tasks[e];
      if (t - i.offset - i.last >= i.duration) {
        const s = t - i.start;
        i.func(s), i.last = t;
      }
    }
  }
  /**
   * Destroys the scheduler system and removes all tasks.
   * @internal
   */
  destroy() {
    Kn.system.remove(this._update, this), this._tasks.length = 0;
  }
}
gw.extension = {
  type: [
    W.WebGLSystem,
    W.WebGPUSystem,
    W.CanvasSystem
  ],
  name: "scheduler",
  priority: 0
};
let G0 = !1;
function $3(n) {
  if (!G0) {
    if (ve.get().getNavigator().userAgent.toLowerCase().indexOf("chrome") > -1) {
      const t = [
        `%c  %c  %c  %c  %c PixiJS %c v${ih} (${n}) http://www.pixijs.com/

`,
        "background: #E72264; padding:5px 0;",
        "background: #6CA2EA; padding:5px 0;",
        "background: #B5D33D; padding:5px 0;",
        "background: #FED23F; padding:5px 0;",
        "color: #FFFFFF; background: #E72264; padding:5px 0;",
        "color: #E72264; background: #FFFFFF; padding:5px 0;"
      ];
      globalThis.console.log(...t);
    } else globalThis.console && globalThis.console.log(`PixiJS ${ih} - ${n} - http://www.pixijs.com/`);
    G0 = !0;
  }
}
class Rg {
  constructor(t) {
    this._renderer = t;
  }
  /**
   * It all starts here! This initiates every system, passing in the options for any system by name.
   * @param options - the config for the renderer and all its systems
   */
  init(t) {
    if (t.hello) {
      let e = this._renderer.name;
      this._renderer.type === Ti.WEBGL && (e += ` ${this._renderer.context.webGLVersion}`), $3(e);
    }
  }
}
Rg.extension = {
  type: [
    W.WebGLSystem,
    W.WebGPUSystem,
    W.CanvasSystem
  ],
  name: "hello",
  priority: -2
};
Rg.defaultOptions = {
  /** {@link WebGLOptions.hello} */
  hello: !1
};
function W3(n) {
  let t = !1;
  for (const i in n)
    if (n[i] == null) {
      t = !0;
      break;
    }
  if (!t)
    return n;
  const e = /* @__PURE__ */ Object.create(null);
  for (const i in n) {
    const s = n[i];
    s && (e[i] = s);
  }
  return e;
}
function V3(n) {
  let t = 0;
  for (let e = 0; e < n.length; e++)
    n[e] == null ? t++ : n[e - t] = n[e];
  return n.length -= t, n;
}
let j3 = 0;
const Pg = class yw {
  /**
   * Creates a new RenderableGCSystem instance.
   * @param renderer - The renderer this garbage collection system works for
   */
  constructor(t) {
    this._managedRenderables = [], this._managedHashes = [], this._managedArrays = [], this._renderer = t;
  }
  /**
   * Initializes the garbage collection system with the provided options.
   * @param options - Configuration options for the renderer
   */
  init(t) {
    t = { ...yw.defaultOptions, ...t }, this.maxUnusedTime = t.renderableGCMaxUnusedTime, this._frequency = t.renderableGCFrequency, this.enabled = t.renderableGCActive;
  }
  /**
   * Gets whether the garbage collection system is currently enabled.
   * @returns True if GC is enabled, false otherwise
   */
  get enabled() {
    return !!this._handler;
  }
  /**
   * Enables or disables the garbage collection system.
   * When enabled, schedules periodic cleanup of resources.
   * When disabled, cancels all scheduled cleanups.
   */
  set enabled(t) {
    this.enabled !== t && (t ? (this._handler = this._renderer.scheduler.repeat(
      () => this.run(),
      this._frequency,
      !1
    ), this._hashHandler = this._renderer.scheduler.repeat(
      () => {
        for (const e of this._managedHashes)
          e.context[e.hash] = W3(e.context[e.hash]);
      },
      this._frequency
    ), this._arrayHandler = this._renderer.scheduler.repeat(
      () => {
        for (const e of this._managedArrays)
          V3(e.context[e.hash]);
      },
      this._frequency
    )) : (this._renderer.scheduler.cancel(this._handler), this._renderer.scheduler.cancel(this._hashHandler), this._renderer.scheduler.cancel(this._arrayHandler)));
  }
  /**
   * Adds a hash table to be managed by the garbage collector.
   * @param context - The object containing the hash table
   * @param hash - The property name of the hash table
   */
  addManagedHash(t, e) {
    this._managedHashes.push({ context: t, hash: e });
  }
  /**
   * Adds an array to be managed by the garbage collector.
   * @param context - The object containing the array
   * @param hash - The property name of the array
   */
  addManagedArray(t, e) {
    this._managedArrays.push({ context: t, hash: e });
  }
  /**
   * Updates the GC timestamp and tracking before rendering.
   * @param options - The render options
   * @param options.container - The container to render
   */
  prerender({
    container: t
  }) {
    this._now = performance.now(), t.renderGroup.gcTick = j3++, this._updateInstructionGCTick(t.renderGroup, t.renderGroup.gcTick);
  }
  /**
   * Starts tracking a renderable for garbage collection.
   * @param renderable - The renderable to track
   */
  addRenderable(t) {
    this.enabled && (t._lastUsed === -1 && (this._managedRenderables.push(t), t.once("destroyed", this._removeRenderable, this)), t._lastUsed = this._now);
  }
  /**
   * Performs garbage collection by cleaning up unused renderables.
   * Removes renderables that haven't been used for longer than maxUnusedTime.
   */
  run() {
    const t = this._now, e = this._managedRenderables, i = this._renderer.renderPipes;
    let s = 0;
    for (let o = 0; o < e.length; o++) {
      const l = e[o];
      if (l === null) {
        s++;
        continue;
      }
      const c = l.renderGroup ?? l.parentRenderGroup, d = c?.instructionSet?.gcTick ?? -1;
      if ((c?.gcTick ?? 0) === d && (l._lastUsed = t), t - l._lastUsed > this.maxUnusedTime) {
        if (!l.destroyed) {
          const f = i;
          c && (c.structureDidChange = !0), f[l.renderPipeId].destroyRenderable(l);
        }
        l._lastUsed = -1, s++, l.off("destroyed", this._removeRenderable, this);
      } else
        e[o - s] = l;
    }
    e.length -= s;
  }
  /** Cleans up the garbage collection system. Disables GC and removes all tracked resources. */
  destroy() {
    this.enabled = !1, this._renderer = null, this._managedRenderables.length = 0, this._managedHashes.length = 0, this._managedArrays.length = 0;
  }
  /**
   * Removes a renderable from being tracked when it's destroyed.
   * @param renderable - The renderable to stop tracking
   */
  _removeRenderable(t) {
    const e = this._managedRenderables.indexOf(t);
    e >= 0 && (t.off("destroyed", this._removeRenderable, this), this._managedRenderables[e] = null);
  }
  /**
   * Updates the GC tick counter for a render group and its children.
   * @param renderGroup - The render group to update
   * @param gcTick - The new tick value
   */
  _updateInstructionGCTick(t, e) {
    t.instructionSet.gcTick = e;
    for (const i of t.renderGroupChildren)
      this._updateInstructionGCTick(i, e);
  }
};
Pg.extension = {
  type: [
    W.WebGLSystem,
    W.WebGPUSystem
  ],
  name: "renderableGC",
  priority: 0
};
Pg.defaultOptions = {
  /** Enable/disable the garbage collector */
  renderableGCActive: !0,
  /** Time in ms before an unused resource is collected (default 1 minute) */
  renderableGCMaxUnusedTime: 6e4,
  /** How often to run garbage collection in ms (default 30 seconds) */
  renderableGCFrequency: 3e4
};
let Y3 = Pg;
const Bg = class bw {
  /** @param renderer - The renderer this System works for. */
  constructor(t) {
    this._renderer = t, this.count = 0, this.checkCount = 0;
  }
  init(t) {
    t = { ...bw.defaultOptions, ...t }, this.checkCountMax = t.textureGCCheckCountMax, this.maxIdle = t.textureGCAMaxIdle ?? t.textureGCMaxIdle, this.active = t.textureGCActive;
  }
  /**
   * Checks to see when the last time a texture was used.
   * If the texture has not been used for a specified amount of time, it will be removed from the GPU.
   */
  postrender() {
    this._renderer.renderingToScreen && (this.count++, this.active && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run())));
  }
  /**
   * Checks to see when the last time a texture was used.
   * If the texture has not been used for a specified amount of time, it will be removed from the GPU.
   */
  run() {
    const t = this._renderer.texture.managedTextures;
    for (let e = 0; e < t.length; e++) {
      const i = t[e];
      i.autoGarbageCollect && i.resource && i._touched > -1 && this.count - i._touched > this.maxIdle && (i._touched = -1, i.unload());
    }
  }
  destroy() {
    this._renderer = null;
  }
};
Bg.extension = {
  type: [
    W.WebGLSystem,
    W.WebGPUSystem
  ],
  name: "textureGC"
};
Bg.defaultOptions = {
  /**
   * If set to true, this will enable the garbage collector on the GPU.
   * @default true
   */
  textureGCActive: !0,
  /**
   * @deprecated since 8.3.0
   * @see {@link TextureGCSystemOptions.textureGCMaxIdle}
   */
  textureGCAMaxIdle: null,
  /**
   * The maximum idle frames before a texture is destroyed by garbage collection.
   * @default 60 * 60
   */
  textureGCMaxIdle: 3600,
  /**
   * Frames between two garbage collections.
   * @default 600
   */
  textureGCCheckCountMax: 600
};
let X3 = Bg;
const kg = class vw {
  /**
   * Whether CSS dimensions of canvas view should be resized to screen dimensions automatically.
   * This is only supported for HTMLCanvasElement and will be ignored if the canvas is an OffscreenCanvas.
   * @type {boolean}
   */
  get autoDensity() {
    return this.texture.source.autoDensity;
  }
  set autoDensity(t) {
    this.texture.source.autoDensity = t;
  }
  /** The resolution / device pixel ratio of the renderer. */
  get resolution() {
    return this.texture.source._resolution;
  }
  set resolution(t) {
    this.texture.source.resize(
      this.texture.source.width,
      this.texture.source.height,
      t
    );
  }
  /**
   * initiates the view system
   * @param options - the options for the view
   */
  init(t) {
    t = {
      ...vw.defaultOptions,
      ...t
    }, t.view && (zt(ae, "ViewSystem.view has been renamed to ViewSystem.canvas"), t.canvas = t.view), this.screen = new ne(0, 0, t.width, t.height), this.canvas = t.canvas || ve.get().createCanvas(), this.antialias = !!t.antialias, this.texture = VT(this.canvas, t), this.renderTarget = new Am({
      colorTextures: [this.texture],
      depth: !!t.depth,
      isRoot: !0
    }), this.texture.source.transparent = t.backgroundAlpha < 1, this.resolution = t.resolution;
  }
  /**
   * Resizes the screen and canvas to the specified dimensions.
   * @param desiredScreenWidth - The new width of the screen.
   * @param desiredScreenHeight - The new height of the screen.
   * @param resolution
   */
  resize(t, e, i) {
    this.texture.source.resize(t, e, i), this.screen.width = this.texture.frame.width, this.screen.height = this.texture.frame.height;
  }
  /**
   * Destroys this System and optionally removes the canvas from the dom.
   * @param {options | false} options - The options for destroying the view, or "false".
   * @example
   * viewSystem.destroy();
   * viewSystem.destroy(true);
   * viewSystem.destroy({ removeView: true });
   */
  destroy(t = !1) {
    (typeof t == "boolean" ? t : !!t?.removeView) && this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas), this.texture.destroy();
  }
};
kg.extension = {
  type: [
    W.WebGLSystem,
    W.WebGPUSystem,
    W.CanvasSystem
  ],
  name: "view",
  priority: 0
};
kg.defaultOptions = {
  /**
   * {@link WebGLOptions.width}
   * @default 800
   */
  width: 800,
  /**
   * {@link WebGLOptions.height}
   * @default 600
   */
  height: 600,
  /**
   * {@link WebGLOptions.autoDensity}
   * @default false
   */
  autoDensity: !1,
  /**
   * {@link WebGLOptions.antialias}
   * @default false
   */
  antialias: !1
};
let q3 = kg;
const xw = [
  N3,
  mw,
  Rg,
  q3,
  uw,
  X3,
  pw,
  I3,
  V1,
  Y3,
  gw
], _w = [
  dw,
  ET,
  cw,
  aw,
  MT,
  RT,
  AT,
  sw
], K3 = [
  ...xw,
  WT,
  jB,
  FB,
  IT,
  PT,
  nw,
  qT,
  DT,
  JT,
  QT,
  NT,
  x3,
  zT,
  UT
], Z3 = [..._w], Q3 = [TT, rw, iw], Sw = [], Tw = [], ww = [];
Nt.handleByNamedList(W.WebGLSystem, Sw);
Nt.handleByNamedList(W.WebGLPipes, Tw);
Nt.handleByNamedList(W.WebGLPipesAdaptor, ww);
Nt.add(...K3, ...Z3, ...Q3);
class J3 extends Sh {
  constructor() {
    const t = {
      name: "webgl",
      type: Ti.WEBGL,
      systems: Sw,
      renderPipes: Tw,
      renderPipeAdaptors: ww
    };
    super(t);
  }
}
const tk = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  WebGLRenderer: J3
}, Symbol.toStringTag, { value: "Module" }));
class Cw {
  constructor(t) {
    this._hash = /* @__PURE__ */ Object.create(null), this._renderer = t, this._renderer.renderableGC.addManagedHash(this, "_hash");
  }
  contextChange(t) {
    this._gpu = t;
  }
  getBindGroup(t, e, i) {
    return t._updateKey(), this._hash[t._key] || this._createBindGroup(t, e, i);
  }
  _createBindGroup(t, e, i) {
    const s = this._gpu.device, o = e.layout[i], l = [], c = this._renderer;
    for (const m in o) {
      const y = t.resources[m] ?? t.resources[o[m]];
      let b;
      if (y._resourceType === "uniformGroup") {
        const v = y;
        c.ubo.updateUniformGroup(v);
        const x = v.buffer;
        b = {
          buffer: c.buffer.getGPUBuffer(x),
          offset: 0,
          size: x.descriptor.size
        };
      } else if (y._resourceType === "buffer") {
        const v = y;
        b = {
          buffer: c.buffer.getGPUBuffer(v),
          offset: 0,
          size: v.descriptor.size
        };
      } else if (y._resourceType === "bufferResource") {
        const v = y;
        b = {
          buffer: c.buffer.getGPUBuffer(v.buffer),
          offset: v.offset,
          size: v.size
        };
      } else if (y._resourceType === "textureSampler") {
        const v = y;
        b = c.texture.getGpuSampler(v);
      } else if (y._resourceType === "textureSource") {
        const v = y;
        b = c.texture.getGpuSource(v).createView({});
      }
      l.push({
        binding: o[m],
        resource: b
      });
    }
    const d = c.shader.getProgramData(e).bindGroups[i], f = s.createBindGroup({
      layout: d,
      entries: l
    });
    return this._hash[t._key] = f, f;
  }
  destroy() {
    for (const t of Object.keys(this._hash))
      this._hash[t] = null;
    this._hash = null, this._renderer = null;
  }
}
Cw.extension = {
  type: [
    W.WebGPUSystem
  ],
  name: "bindGroup"
};
class Ew {
  constructor(t) {
    this._gpuBuffers = /* @__PURE__ */ Object.create(null), this._managedBuffers = [], t.renderableGC.addManagedHash(this, "_gpuBuffers");
  }
  contextChange(t) {
    this._gpu = t;
  }
  getGPUBuffer(t) {
    return this._gpuBuffers[t.uid] || this.createGPUBuffer(t);
  }
  updateBuffer(t) {
    const e = this._gpuBuffers[t.uid] || this.createGPUBuffer(t), i = t.data;
    return t._updateID && i && (t._updateID = 0, this._gpu.device.queue.writeBuffer(
      e,
      0,
      i.buffer,
      0,
      // round to the nearest 4 bytes
      (t._updateSize || i.byteLength) + 3 & -4
    )), e;
  }
  /** dispose all WebGL resources of all managed buffers */
  destroyAll() {
    for (const t in this._gpuBuffers)
      this._gpuBuffers[t].destroy();
    this._gpuBuffers = {};
  }
  createGPUBuffer(t) {
    this._gpuBuffers[t.uid] || (t.on("update", this.updateBuffer, this), t.on("change", this.onBufferChange, this), t.on("destroy", this.onBufferDestroy, this), this._managedBuffers.push(t));
    const e = this._gpu.device.createBuffer(t.descriptor);
    return t._updateID = 0, t.data && (Sm(t.data.buffer, e.getMappedRange()), e.unmap()), this._gpuBuffers[t.uid] = e, e;
  }
  onBufferChange(t) {
    this._gpuBuffers[t.uid].destroy(), t._updateID = 0, this._gpuBuffers[t.uid] = this.createGPUBuffer(t);
  }
  /**
   * Disposes buffer
   * @param buffer - buffer with data
   */
  onBufferDestroy(t) {
    this._managedBuffers.splice(this._managedBuffers.indexOf(t), 1), this._destroyBuffer(t);
  }
  destroy() {
    this._managedBuffers.forEach((t) => this._destroyBuffer(t)), this._managedBuffers = null, this._gpuBuffers = null;
  }
  _destroyBuffer(t) {
    this._gpuBuffers[t.uid].destroy(), t.off("update", this.updateBuffer, this), t.off("change", this.onBufferChange, this), t.off("destroy", this.onBufferDestroy, this), this._gpuBuffers[t.uid] = null;
  }
}
Ew.extension = {
  type: [
    W.WebGPUSystem
  ],
  name: "buffer"
};
class ek {
  constructor({ minUniformOffsetAlignment: t }) {
    this._minUniformOffsetAlignment = 256, this.byteIndex = 0, this._minUniformOffsetAlignment = t, this.data = new Float32Array(65535);
  }
  clear() {
    this.byteIndex = 0;
  }
  addEmptyGroup(t) {
    if (t > this._minUniformOffsetAlignment / 4)
      throw new Error(`UniformBufferBatch: array is too large: ${t * 4}`);
    const e = this.byteIndex;
    let i = e + t * 4;
    if (i = Math.ceil(i / this._minUniformOffsetAlignment) * this._minUniformOffsetAlignment, i > this.data.length * 4)
      throw new Error("UniformBufferBatch: ubo batch got too big");
    return this.byteIndex = i, e;
  }
  addGroup(t) {
    const e = this.addEmptyGroup(t.length);
    for (let i = 0; i < t.length; i++)
      this.data[e / 4 + i] = t[i];
    return e;
  }
  destroy() {
    this.data = null;
  }
}
class Mw {
  constructor(t) {
    this._colorMaskCache = 15, this._renderer = t;
  }
  setMask(t) {
    this._colorMaskCache !== t && (this._colorMaskCache = t, this._renderer.pipeline.setColorMask(t));
  }
  destroy() {
    this._renderer = null, this._colorMaskCache = null;
  }
}
Mw.extension = {
  type: [
    W.WebGPUSystem
  ],
  name: "colorMask"
};
class Og {
  /**
   * @param {WebGPURenderer} renderer - The renderer this System works for.
   */
  constructor(t) {
    this._renderer = t;
  }
  async init(t) {
    return this._initPromise ? this._initPromise : (this._initPromise = (t.gpu ? Promise.resolve(t.gpu) : this._createDeviceAndAdaptor(t)).then((e) => {
      this.gpu = e, this._renderer.runners.contextChange.emit(this.gpu);
    }), this._initPromise);
  }
  /**
   * Handle the context change event
   * @param gpu
   */
  contextChange(t) {
    this._renderer.gpu = t;
  }
  /**
   * Helper class to create a WebGL Context
   * @param {object} options - An options object that gets passed in to the canvas element containing the
   *    context attributes
   * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext
   * @returns {WebGLRenderingContext} the WebGL context
   */
  async _createDeviceAndAdaptor(t) {
    const e = await ve.get().getNavigator().gpu.requestAdapter({
      powerPreference: t.powerPreference,
      forceFallbackAdapter: t.forceFallbackAdapter
    }), i = [
      "texture-compression-bc",
      "texture-compression-astc",
      "texture-compression-etc2"
    ].filter((o) => e.features.has(o)), s = await e.requestDevice({
      requiredFeatures: i
    });
    return { adapter: e, device: s };
  }
  destroy() {
    this.gpu = null, this._renderer = null;
  }
}
Og.extension = {
  type: [
    W.WebGPUSystem
  ],
  name: "device"
};
Og.defaultOptions = {
  /**
   * {@link WebGPUOptions.powerPreference}
   * @default default
   */
  powerPreference: void 0,
  /**
   * Force the use of the fallback adapter
   * @default false
   */
  forceFallbackAdapter: !1
};
class Aw {
  constructor(t) {
    this._boundBindGroup = /* @__PURE__ */ Object.create(null), this._boundVertexBuffer = /* @__PURE__ */ Object.create(null), this._renderer = t;
  }
  renderStart() {
    this.commandFinished = new Promise((t) => {
      this._resolveCommandFinished = t;
    }), this.commandEncoder = this._renderer.gpu.device.createCommandEncoder();
  }
  beginRenderPass(t) {
    this.endRenderPass(), this._clearCache(), this.renderPassEncoder = this.commandEncoder.beginRenderPass(t.descriptor);
  }
  endRenderPass() {
    this.renderPassEncoder && this.renderPassEncoder.end(), this.renderPassEncoder = null;
  }
  setViewport(t) {
    this.renderPassEncoder.setViewport(t.x, t.y, t.width, t.height, 0, 1);
  }
  setPipelineFromGeometryProgramAndState(t, e, i, s) {
    const o = this._renderer.pipeline.getPipeline(t, e, i, s);
    this.setPipeline(o);
  }
  setPipeline(t) {
    this._boundPipeline !== t && (this._boundPipeline = t, this.renderPassEncoder.setPipeline(t));
  }
  _setVertexBuffer(t, e) {
    this._boundVertexBuffer[t] !== e && (this._boundVertexBuffer[t] = e, this.renderPassEncoder.setVertexBuffer(t, this._renderer.buffer.updateBuffer(e)));
  }
  _setIndexBuffer(t) {
    if (this._boundIndexBuffer === t)
      return;
    this._boundIndexBuffer = t;
    const e = t.data.BYTES_PER_ELEMENT === 2 ? "uint16" : "uint32";
    this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(t), e);
  }
  resetBindGroup(t) {
    this._boundBindGroup[t] = null;
  }
  setBindGroup(t, e, i) {
    if (this._boundBindGroup[t] === e)
      return;
    this._boundBindGroup[t] = e, e._touch(this._renderer.textureGC.count);
    const s = this._renderer.bindGroup.getBindGroup(e, i, t);
    this.renderPassEncoder.setBindGroup(t, s);
  }
  setGeometry(t, e) {
    const i = this._renderer.pipeline.getBufferNamesToBind(t, e);
    for (const s in i)
      this._setVertexBuffer(parseInt(s, 10), t.attributes[i[s]].buffer);
    t.indexBuffer && this._setIndexBuffer(t.indexBuffer);
  }
  _setShaderBindGroups(t, e) {
    for (const i in t.groups) {
      const s = t.groups[i];
      e || this._syncBindGroup(s), this.setBindGroup(i, s, t.gpuProgram);
    }
  }
  _syncBindGroup(t) {
    for (const e in t.resources) {
      const i = t.resources[e];
      i.isUniformGroup && this._renderer.ubo.updateUniformGroup(i);
    }
  }
  draw(t) {
    const { geometry: e, shader: i, state: s, topology: o, size: l, start: c, instanceCount: d, skipSync: f } = t;
    this.setPipelineFromGeometryProgramAndState(e, i.gpuProgram, s, o), this.setGeometry(e, i.gpuProgram), this._setShaderBindGroups(i, f), e.indexBuffer ? this.renderPassEncoder.drawIndexed(
      l || e.indexBuffer.data.length,
      d ?? e.instanceCount,
      c || 0
    ) : this.renderPassEncoder.draw(l || e.getSize(), d ?? e.instanceCount, c || 0);
  }
  finishRenderPass() {
    this.renderPassEncoder && (this.renderPassEncoder.end(), this.renderPassEncoder = null);
  }
  postrender() {
    this.finishRenderPass(), this._gpu.device.queue.submit([this.commandEncoder.finish()]), this._resolveCommandFinished(), this.commandEncoder = null;
  }
  // restores a render pass if finishRenderPass was called
  // not optimised as really used for debugging!
  // used when we want to stop drawing and log a texture..
  restoreRenderPass() {
    const t = this._renderer.renderTarget.adaptor.getDescriptor(
      this._renderer.renderTarget.renderTarget,
      !1,
      [0, 0, 0, 1]
    );
    this.renderPassEncoder = this.commandEncoder.beginRenderPass(t);
    const e = this._boundPipeline, i = { ...this._boundVertexBuffer }, s = this._boundIndexBuffer, o = { ...this._boundBindGroup };
    this._clearCache();
    const l = this._renderer.renderTarget.viewport;
    this.renderPassEncoder.setViewport(l.x, l.y, l.width, l.height, 0, 1), this.setPipeline(e);
    for (const c in i)
      this._setVertexBuffer(c, i[c]);
    for (const c in o)
      this.setBindGroup(c, o[c], null);
    this._setIndexBuffer(s);
  }
  _clearCache() {
    for (let t = 0; t < 16; t++)
      this._boundBindGroup[t] = null, this._boundVertexBuffer[t] = null;
    this._boundIndexBuffer = null, this._boundPipeline = null;
  }
  destroy() {
    this._renderer = null, this._gpu = null, this._boundBindGroup = null, this._boundVertexBuffer = null, this._boundIndexBuffer = null, this._boundPipeline = null;
  }
  contextChange(t) {
    this._gpu = t;
  }
}
Aw.extension = {
  type: [W.WebGPUSystem],
  name: "encoder",
  priority: 1
};
class Rw {
  constructor(t) {
    this._renderer = t;
  }
  contextChange() {
    this.maxTextures = this._renderer.device.gpu.device.limits.maxSampledTexturesPerShaderStage, this.maxBatchableTextures = this.maxTextures;
  }
  destroy() {
  }
}
Rw.extension = {
  type: [
    W.WebGPUSystem
  ],
  name: "limits"
};
class Pw {
  constructor(t) {
    this._renderTargetStencilState = /* @__PURE__ */ Object.create(null), this._renderer = t, t.renderTarget.onRenderTargetChange.add(this);
  }
  onRenderTargetChange(t) {
    let e = this._renderTargetStencilState[t.uid];
    e || (e = this._renderTargetStencilState[t.uid] = {
      stencilMode: Ye.DISABLED,
      stencilReference: 0
    }), this._activeRenderTarget = t, this.setStencilMode(e.stencilMode, e.stencilReference);
  }
  setStencilMode(t, e) {
    const i = this._renderTargetStencilState[this._activeRenderTarget.uid];
    i.stencilMode = t, i.stencilReference = e;
    const s = this._renderer;
    s.pipeline.setStencilMode(t), s.encoder.renderPassEncoder.setStencilReference(e);
  }
  destroy() {
    this._renderer.renderTarget.onRenderTargetChange.remove(this), this._renderer = null, this._activeRenderTarget = null, this._renderTargetStencilState = null;
  }
}
Pw.extension = {
  type: [
    W.WebGPUSystem
  ],
  name: "stencil"
};
const Xc = {
  i32: { align: 4, size: 4 },
  u32: { align: 4, size: 4 },
  f32: { align: 4, size: 4 },
  f16: { align: 2, size: 2 },
  "vec2<i32>": { align: 8, size: 8 },
  "vec2<u32>": { align: 8, size: 8 },
  "vec2<f32>": { align: 8, size: 8 },
  "vec2<f16>": { align: 4, size: 4 },
  "vec3<i32>": { align: 16, size: 12 },
  "vec3<u32>": { align: 16, size: 12 },
  "vec3<f32>": { align: 16, size: 12 },
  "vec3<f16>": { align: 8, size: 6 },
  "vec4<i32>": { align: 16, size: 16 },
  "vec4<u32>": { align: 16, size: 16 },
  "vec4<f32>": { align: 16, size: 16 },
  "vec4<f16>": { align: 8, size: 8 },
  "mat2x2<f32>": { align: 8, size: 16 },
  "mat2x2<f16>": { align: 4, size: 8 },
  "mat3x2<f32>": { align: 8, size: 24 },
  "mat3x2<f16>": { align: 4, size: 12 },
  "mat4x2<f32>": { align: 8, size: 32 },
  "mat4x2<f16>": { align: 4, size: 16 },
  "mat2x3<f32>": { align: 16, size: 32 },
  "mat2x3<f16>": { align: 8, size: 16 },
  "mat3x3<f32>": { align: 16, size: 48 },
  "mat3x3<f16>": { align: 8, size: 24 },
  "mat4x3<f32>": { align: 16, size: 64 },
  "mat4x3<f16>": { align: 8, size: 32 },
  "mat2x4<f32>": { align: 16, size: 32 },
  "mat2x4<f16>": { align: 8, size: 16 },
  "mat3x4<f32>": { align: 16, size: 48 },
  "mat3x4<f16>": { align: 8, size: 24 },
  "mat4x4<f32>": { align: 16, size: 64 },
  "mat4x4<f16>": { align: 8, size: 32 }
};
function nk(n) {
  const t = n.map((i) => ({
    data: i,
    offset: 0,
    size: 0
  }));
  let e = 0;
  for (let i = 0; i < t.length; i++) {
    const s = t[i];
    let o = Xc[s.data.type].size;
    const l = Xc[s.data.type].align;
    if (!Xc[s.data.type])
      throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${s.data.type}`);
    s.data.size > 1 && (o = Math.max(o, l) * s.data.size), e = Math.ceil(e / l) * l, s.size = o, s.offset = e, e += o;
  }
  return e = Math.ceil(e / 16) * 16, { uboElements: t, size: e };
}
function ik(n, t) {
  const { size: e, align: i } = Xc[n.data.type], s = (i - e) / 4, o = n.data.type.indexOf("i32") >= 0 ? "dataInt32" : "data";
  return `
         v = uv.${n.data.name};
         ${t !== 0 ? `offset += ${t};` : ""}

         arrayOffset = offset;

         t = 0;

         for(var i=0; i < ${n.data.size * (e / 4)}; i++)
         {
             for(var j = 0; j < ${e / 4}; j++)
             {
                 ${o}[arrayOffset++] = v[t++];
             }
             ${s !== 0 ? `arrayOffset += ${s};` : ""}
         }
     `;
}
function rk(n) {
  return HT(
    n,
    "uboWgsl",
    ik,
    qB
  );
}
class Bw extends LT {
  constructor() {
    super({
      createUboElements: nk,
      generateUboSync: rk
    });
  }
}
Bw.extension = {
  type: [W.WebGPUSystem],
  name: "ubo"
};
const Yr = 128;
class kw {
  constructor(t) {
    this._bindGroupHash = /* @__PURE__ */ Object.create(null), this._buffers = [], this._bindGroups = [], this._bufferResources = [], this._renderer = t, this._renderer.renderableGC.addManagedHash(this, "_bindGroupHash"), this._batchBuffer = new ek({ minUniformOffsetAlignment: Yr });
    const e = 256 / Yr;
    for (let i = 0; i < e; i++) {
      let s = Qt.UNIFORM | Qt.COPY_DST;
      i === 0 && (s |= Qt.COPY_SRC), this._buffers.push(new Zn({
        data: this._batchBuffer.data,
        usage: s
      }));
    }
  }
  renderEnd() {
    this._uploadBindGroups(), this._resetBindGroups();
  }
  _resetBindGroups() {
    for (const t in this._bindGroupHash)
      this._bindGroupHash[t] = null;
    this._batchBuffer.clear();
  }
  // just works for single bind groups for now
  getUniformBindGroup(t, e) {
    if (!e && this._bindGroupHash[t.uid])
      return this._bindGroupHash[t.uid];
    this._renderer.ubo.ensureUniformGroup(t);
    const i = t.buffer.data, s = this._batchBuffer.addEmptyGroup(i.length);
    return this._renderer.ubo.syncUniformGroup(t, this._batchBuffer.data, s / 4), this._bindGroupHash[t.uid] = this._getBindGroup(s / Yr), this._bindGroupHash[t.uid];
  }
  getUboResource(t) {
    this._renderer.ubo.updateUniformGroup(t);
    const e = t.buffer.data, i = this._batchBuffer.addGroup(e);
    return this._getBufferResource(i / Yr);
  }
  getArrayBindGroup(t) {
    const e = this._batchBuffer.addGroup(t);
    return this._getBindGroup(e / Yr);
  }
  getArrayBufferResource(t) {
    const i = this._batchBuffer.addGroup(t) / Yr;
    return this._getBufferResource(i);
  }
  _getBufferResource(t) {
    if (!this._bufferResources[t]) {
      const e = this._buffers[t % 2];
      this._bufferResources[t] = new Cg({
        buffer: e,
        offset: (t / 2 | 0) * 256,
        size: Yr
      });
    }
    return this._bufferResources[t];
  }
  _getBindGroup(t) {
    if (!this._bindGroups[t]) {
      const e = new yr({
        0: this._getBufferResource(t)
      });
      this._bindGroups[t] = e;
    }
    return this._bindGroups[t];
  }
  _uploadBindGroups() {
    const t = this._renderer.buffer, e = this._buffers[0];
    e.update(this._batchBuffer.byteIndex), t.updateBuffer(e);
    const i = this._renderer.gpu.device.createCommandEncoder();
    for (let s = 1; s < this._buffers.length; s++) {
      const o = this._buffers[s];
      i.copyBufferToBuffer(
        t.getGPUBuffer(e),
        Yr,
        t.getGPUBuffer(o),
        0,
        this._batchBuffer.byteIndex
      );
    }
    this._renderer.gpu.device.queue.submit([i.finish()]);
  }
  destroy() {
    for (let t = 0; t < this._bindGroups.length; t++)
      this._bindGroups[t]?.destroy();
    this._bindGroups = null, this._bindGroupHash = null;
    for (let t = 0; t < this._buffers.length; t++)
      this._buffers[t].destroy();
    this._buffers = null;
    for (let t = 0; t < this._bufferResources.length; t++)
      this._bufferResources[t].destroy();
    this._bufferResources = null, this._batchBuffer.destroy(), this._bindGroupHash = null, this._renderer = null;
  }
}
kw.extension = {
  type: [
    W.WebGPUPipes
  ],
  name: "uniformBatch"
};
const sk = {
  "point-list": 0,
  "line-list": 1,
  "line-strip": 2,
  "triangle-list": 3,
  "triangle-strip": 4
};
function ak(n, t, e, i, s) {
  return n << 24 | t << 16 | e << 10 | i << 5 | s;
}
function ok(n, t, e, i) {
  return e << 6 | n << 3 | i << 1 | t;
}
class Ow {
  constructor(t) {
    this._moduleCache = /* @__PURE__ */ Object.create(null), this._bufferLayoutsCache = /* @__PURE__ */ Object.create(null), this._bindingNamesCache = /* @__PURE__ */ Object.create(null), this._pipeCache = /* @__PURE__ */ Object.create(null), this._pipeStateCaches = /* @__PURE__ */ Object.create(null), this._colorMask = 15, this._multisampleCount = 1, this._renderer = t;
  }
  contextChange(t) {
    this._gpu = t, this.setStencilMode(Ye.DISABLED), this._updatePipeHash();
  }
  setMultisampleCount(t) {
    this._multisampleCount !== t && (this._multisampleCount = t, this._updatePipeHash());
  }
  setRenderTarget(t) {
    this._multisampleCount = t.msaaSamples, this._depthStencilAttachment = t.descriptor.depthStencilAttachment ? 1 : 0, this._updatePipeHash();
  }
  setColorMask(t) {
    this._colorMask !== t && (this._colorMask = t, this._updatePipeHash());
  }
  setStencilMode(t) {
    this._stencilMode !== t && (this._stencilMode = t, this._stencilState = ns[t], this._updatePipeHash());
  }
  setPipeline(t, e, i, s) {
    const o = this.getPipeline(t, e, i);
    s.setPipeline(o);
  }
  getPipeline(t, e, i, s) {
    t._layoutKey || (kT(t, e.attributeData), this._generateBufferKey(t)), s || (s = t.topology);
    const o = ak(
      t._layoutKey,
      e._layoutKey,
      i.data,
      i._blendModeId,
      sk[s]
    );
    return this._pipeCache[o] ? this._pipeCache[o] : (this._pipeCache[o] = this._createPipeline(t, e, i, s), this._pipeCache[o]);
  }
  _createPipeline(t, e, i, s) {
    const o = this._gpu.device, l = this._createVertexBufferLayouts(t, e), c = this._renderer.state.getColorTargets(i);
    c[0].writeMask = this._stencilMode === Ye.RENDERING_MASK_ADD ? 0 : this._colorMask;
    const d = this._renderer.shader.getProgramData(e).pipeline, f = {
      // TODO later check if its helpful to create..
      // layout,
      vertex: {
        module: this._getModule(e.vertex.source),
        entryPoint: e.vertex.entryPoint,
        // geometry..
        buffers: l
      },
      fragment: {
        module: this._getModule(e.fragment.source),
        entryPoint: e.fragment.entryPoint,
        targets: c
      },
      primitive: {
        topology: s,
        cullMode: i.cullMode
      },
      layout: d,
      multisample: {
        count: this._multisampleCount
      },
      // depthStencil,
      label: "PIXI Pipeline"
    };
    return this._depthStencilAttachment && (f.depthStencil = {
      ...this._stencilState,
      format: "depth24plus-stencil8",
      depthWriteEnabled: i.depthTest,
      depthCompare: i.depthTest ? "less" : "always"
    }), o.createRenderPipeline(f);
  }
  _getModule(t) {
    return this._moduleCache[t] || this._createModule(t);
  }
  _createModule(t) {
    const e = this._gpu.device;
    return this._moduleCache[t] = e.createShaderModule({
      code: t
    }), this._moduleCache[t];
  }
  _generateBufferKey(t) {
    const e = [];
    let i = 0;
    const s = Object.keys(t.attributes).sort();
    for (let l = 0; l < s.length; l++) {
      const c = t.attributes[s[l]];
      e[i++] = c.offset, e[i++] = c.format, e[i++] = c.stride, e[i++] = c.instance;
    }
    const o = e.join("|");
    return t._layoutKey = Nl(o, "geometry"), t._layoutKey;
  }
  _generateAttributeLocationsKey(t) {
    const e = [];
    let i = 0;
    const s = Object.keys(t.attributeData).sort();
    for (let l = 0; l < s.length; l++) {
      const c = t.attributeData[s[l]];
      e[i++] = c.location;
    }
    const o = e.join("|");
    return t._attributeLocationsKey = Nl(o, "programAttributes"), t._attributeLocationsKey;
  }
  /**
   * Returns a hash of buffer names mapped to bind locations.
   * This is used to bind the correct buffer to the correct location in the shader.
   * @param geometry - The geometry where to get the buffer names
   * @param program - The program where to get the buffer names
   * @returns An object of buffer names mapped to the bind location.
   */
  getBufferNamesToBind(t, e) {
    const i = t._layoutKey << 16 | e._attributeLocationsKey;
    if (this._bindingNamesCache[i])
      return this._bindingNamesCache[i];
    const s = this._createVertexBufferLayouts(t, e), o = /* @__PURE__ */ Object.create(null), l = e.attributeData;
    for (let c = 0; c < s.length; c++) {
      const f = Object.values(s[c].attributes)[0].shaderLocation;
      for (const m in l)
        if (l[m].location === f) {
          o[c] = m;
          break;
        }
    }
    return this._bindingNamesCache[i] = o, o;
  }
  _createVertexBufferLayouts(t, e) {
    e._attributeLocationsKey || this._generateAttributeLocationsKey(e);
    const i = t._layoutKey << 16 | e._attributeLocationsKey;
    if (this._bufferLayoutsCache[i])
      return this._bufferLayoutsCache[i];
    const s = [];
    return t.buffers.forEach((o) => {
      const l = {
        arrayStride: 0,
        stepMode: "vertex",
        attributes: []
      }, c = l.attributes;
      for (const d in e.attributeData) {
        const f = t.attributes[d];
        (f.divisor ?? 1) !== 1 && $t(`Attribute ${d} has an invalid divisor value of '${f.divisor}'. WebGPU only supports a divisor value of 1`), f.buffer === o && (l.arrayStride = f.stride, l.stepMode = f.instance ? "instance" : "vertex", c.push({
          shaderLocation: e.attributeData[d].location,
          offset: f.offset,
          format: f.format
        }));
      }
      c.length && s.push(l);
    }), this._bufferLayoutsCache[i] = s, s;
  }
  _updatePipeHash() {
    const t = ok(
      this._stencilMode,
      this._multisampleCount,
      this._colorMask,
      this._depthStencilAttachment
    );
    this._pipeStateCaches[t] || (this._pipeStateCaches[t] = /* @__PURE__ */ Object.create(null)), this._pipeCache = this._pipeStateCaches[t];
  }
  destroy() {
    this._renderer = null, this._bufferLayoutsCache = null;
  }
}
Ow.extension = {
  type: [W.WebGPUSystem],
  name: "pipeline"
};
class lk {
  constructor() {
    this.contexts = [], this.msaaTextures = [], this.msaaSamples = 1;
  }
}
class uk {
  init(t, e) {
    this._renderer = t, this._renderTargetSystem = e;
  }
  copyToTexture(t, e, i, s, o) {
    const l = this._renderer, c = this._getGpuColorTexture(
      t
    ), d = l.texture.getGpuSource(
      e.source
    );
    return l.encoder.commandEncoder.copyTextureToTexture(
      {
        texture: c,
        origin: i
      },
      {
        texture: d,
        origin: o
      },
      s
    ), e;
  }
  startRenderPass(t, e = !0, i, s) {
    const l = this._renderTargetSystem.getGpuRenderTarget(t), c = this.getDescriptor(t, e, i);
    l.descriptor = c, this._renderer.pipeline.setRenderTarget(l), this._renderer.encoder.beginRenderPass(l), this._renderer.encoder.setViewport(s);
  }
  finishRenderPass() {
    this._renderer.encoder.endRenderPass();
  }
  /**
   * returns the gpu texture for the first color texture in the render target
   * mainly used by the filter manager to get copy the texture for blending
   * @param renderTarget
   * @returns a gpu texture
   */
  _getGpuColorTexture(t) {
    const e = this._renderTargetSystem.getGpuRenderTarget(t);
    return e.contexts[0] ? e.contexts[0].getCurrentTexture() : this._renderer.texture.getGpuSource(
      t.colorTextures[0].source
    );
  }
  getDescriptor(t, e, i) {
    typeof e == "boolean" && (e = e ? Xn.ALL : Xn.NONE);
    const s = this._renderTargetSystem, o = s.getGpuRenderTarget(t), l = t.colorTextures.map(
      (f, m) => {
        const y = o.contexts[m];
        let b, v;
        y ? b = y.getCurrentTexture().createView() : b = this._renderer.texture.getGpuSource(f).createView({
          mipLevelCount: 1
        }), o.msaaTextures[m] && (v = b, b = this._renderer.texture.getTextureView(
          o.msaaTextures[m]
        ));
        const x = e & Xn.COLOR ? "clear" : "load";
        return i ?? (i = s.defaultClearColor), {
          view: b,
          resolveTarget: v,
          clearValue: i,
          storeOp: "store",
          loadOp: x
        };
      }
    );
    let c;
    if ((t.stencil || t.depth) && !t.depthStencilTexture && (t.ensureDepthStencilTexture(), t.depthStencilTexture.source.sampleCount = o.msaa ? 4 : 1), t.depthStencilTexture) {
      const f = e & Xn.STENCIL ? "clear" : "load", m = e & Xn.DEPTH ? "clear" : "load";
      c = {
        view: this._renderer.texture.getGpuSource(t.depthStencilTexture.source).createView(),
        stencilStoreOp: "store",
        stencilLoadOp: f,
        depthClearValue: 1,
        depthLoadOp: m,
        depthStoreOp: "store"
      };
    }
    return {
      colorAttachments: l,
      depthStencilAttachment: c
    };
  }
  clear(t, e = !0, i, s) {
    if (!e)
      return;
    const { gpu: o, encoder: l } = this._renderer, c = o.device;
    if (l.commandEncoder === null) {
      const f = c.createCommandEncoder(), m = this.getDescriptor(t, e, i), y = f.beginRenderPass(m);
      y.setViewport(s.x, s.y, s.width, s.height, 0, 1), y.end();
      const b = f.finish();
      c.queue.submit([b]);
    } else
      this.startRenderPass(t, e, i, s);
  }
  initGpuRenderTarget(t) {
    t.isRoot = !0;
    const e = new lk();
    return t.colorTextures.forEach((i, s) => {
      if (i instanceof gr) {
        const o = i.resource.getContext(
          "webgpu"
        ), l = i.transparent ? "premultiplied" : "opaque";
        try {
          o.configure({
            device: this._renderer.gpu.device,
            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
            format: "bgra8unorm",
            alphaMode: l
          });
        } catch (c) {
          console.error(c);
        }
        e.contexts[s] = o;
      }
      if (e.msaa = i.source.antialias, i.source.antialias) {
        const o = new rn({
          width: 0,
          height: 0,
          sampleCount: 4
        });
        e.msaaTextures[s] = o;
      }
    }), e.msaa && (e.msaaSamples = 4, t.depthStencilTexture && (t.depthStencilTexture.source.sampleCount = 4)), e;
  }
  destroyGpuRenderTarget(t) {
    t.contexts.forEach((e) => {
      e.unconfigure();
    }), t.msaaTextures.forEach((e) => {
      e.destroy();
    }), t.msaaTextures.length = 0, t.contexts.length = 0;
  }
  ensureDepthStencilTexture(t) {
    const e = this._renderTargetSystem.getGpuRenderTarget(t);
    t.depthStencilTexture && e.msaa && (t.depthStencilTexture.source.sampleCount = 4);
  }
  resizeGpuRenderTarget(t) {
    const e = this._renderTargetSystem.getGpuRenderTarget(t);
    e.width = t.width, e.height = t.height, e.msaa && t.colorTextures.forEach((i, s) => {
      e.msaaTextures[s]?.resize(
        i.source.width,
        i.source.height,
        i.source._resolution
      );
    });
  }
}
class Dw extends XT {
  constructor(t) {
    super(t), this.adaptor = new uk(), this.adaptor.init(t, this);
  }
}
Dw.extension = {
  type: [W.WebGPUSystem],
  name: "renderTarget"
};
class Gw {
  constructor() {
    this._gpuProgramData = /* @__PURE__ */ Object.create(null);
  }
  contextChange(t) {
    this._gpu = t;
  }
  getProgramData(t) {
    return this._gpuProgramData[t._layoutKey] || this._createGPUProgramData(t);
  }
  _createGPUProgramData(t) {
    const e = this._gpu.device, i = t.gpuLayout.map((o) => e.createBindGroupLayout({ entries: o })), s = { bindGroupLayouts: i };
    return this._gpuProgramData[t._layoutKey] = {
      bindGroups: i,
      pipeline: e.createPipelineLayout(s)
    }, this._gpuProgramData[t._layoutKey];
  }
  destroy() {
    this._gpu = null, this._gpuProgramData = null;
  }
}
Gw.extension = {
  type: [
    W.WebGPUSystem
  ],
  name: "shader"
};
const Nn = {};
Nn.normal = {
  alpha: {
    srcFactor: "one",
    dstFactor: "one-minus-src-alpha",
    operation: "add"
  },
  color: {
    srcFactor: "one",
    dstFactor: "one-minus-src-alpha",
    operation: "add"
  }
};
Nn.add = {
  alpha: {
    srcFactor: "src-alpha",
    dstFactor: "one-minus-src-alpha",
    operation: "add"
  },
  color: {
    srcFactor: "one",
    dstFactor: "one",
    operation: "add"
  }
};
Nn.multiply = {
  alpha: {
    srcFactor: "one",
    dstFactor: "one-minus-src-alpha",
    operation: "add"
  },
  color: {
    srcFactor: "dst",
    dstFactor: "one-minus-src-alpha",
    operation: "add"
  }
};
Nn.screen = {
  alpha: {
    srcFactor: "one",
    dstFactor: "one-minus-src-alpha",
    operation: "add"
  },
  color: {
    srcFactor: "one",
    dstFactor: "one-minus-src",
    operation: "add"
  }
};
Nn.overlay = {
  alpha: {
    srcFactor: "one",
    dstFactor: "one-minus-src-alpha",
    operation: "add"
  },
  color: {
    srcFactor: "one",
    dstFactor: "one-minus-src",
    operation: "add"
  }
};
Nn.none = {
  alpha: {
    srcFactor: "one",
    dstFactor: "one-minus-src-alpha",
    operation: "add"
  },
  color: {
    srcFactor: "zero",
    dstFactor: "zero",
    operation: "add"
  }
};
Nn["normal-npm"] = {
  alpha: {
    srcFactor: "one",
    dstFactor: "one-minus-src-alpha",
    operation: "add"
  },
  color: {
    srcFactor: "src-alpha",
    dstFactor: "one-minus-src-alpha",
    operation: "add"
  }
};
Nn["add-npm"] = {
  alpha: {
    srcFactor: "one",
    dstFactor: "one",
    operation: "add"
  },
  color: {
    srcFactor: "src-alpha",
    dstFactor: "one",
    operation: "add"
  }
};
Nn["screen-npm"] = {
  alpha: {
    srcFactor: "one",
    dstFactor: "one-minus-src-alpha",
    operation: "add"
  },
  color: {
    srcFactor: "src-alpha",
    dstFactor: "one-minus-src",
    operation: "add"
  }
};
Nn.erase = {
  alpha: {
    srcFactor: "zero",
    dstFactor: "one-minus-src-alpha",
    operation: "add"
  },
  color: {
    srcFactor: "zero",
    dstFactor: "one-minus-src",
    operation: "add"
  }
};
Nn.min = {
  alpha: {
    srcFactor: "one",
    dstFactor: "one",
    operation: "min"
  },
  color: {
    srcFactor: "one",
    dstFactor: "one",
    operation: "min"
  }
};
Nn.max = {
  alpha: {
    srcFactor: "one",
    dstFactor: "one",
    operation: "max"
  },
  color: {
    srcFactor: "one",
    dstFactor: "one",
    operation: "max"
  }
};
class Uw {
  constructor() {
    this.defaultState = new wi(), this.defaultState.blend = !0;
  }
  contextChange(t) {
    this.gpu = t;
  }
  /**
   * Gets the blend mode data for the current state
   * @param state - The state to get the blend mode from
   */
  getColorTargets(t) {
    return [
      {
        format: "bgra8unorm",
        writeMask: 0,
        blend: Nn[t.blendMode] || Nn.normal
      }
    ];
  }
  destroy() {
    this.gpu = null;
  }
}
Uw.extension = {
  type: [
    W.WebGPUSystem
  ],
  name: "state"
};
const ck = {
  type: "image",
  upload(n, t, e) {
    const i = n.resource, s = (n.pixelWidth | 0) * (n.pixelHeight | 0), o = i.byteLength / s;
    e.device.queue.writeTexture(
      { texture: t },
      i,
      {
        offset: 0,
        rowsPerImage: n.pixelHeight,
        bytesPerRow: n.pixelHeight * o
      },
      {
        width: n.pixelWidth,
        height: n.pixelHeight,
        depthOrArrayLayers: 1
      }
    );
  }
}, Nw = {
  "bc1-rgba-unorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },
  "bc2-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
  "bc3-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
  "bc7-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
  "etc1-rgb-unorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },
  "etc2-rgba8unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
  "astc-4x4-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 }
}, hk = { blockBytes: 4, blockWidth: 1, blockHeight: 1 }, dk = {
  type: "compressed",
  upload(n, t, e) {
    let i = n.pixelWidth, s = n.pixelHeight;
    const o = Nw[n.format] || hk;
    for (let l = 0; l < n.resource.length; l++) {
      const c = n.resource[l], d = Math.ceil(i / o.blockWidth) * o.blockBytes;
      e.device.queue.writeTexture(
        {
          texture: t,
          mipLevel: l
        },
        c,
        {
          offset: 0,
          bytesPerRow: d
        },
        {
          width: Math.ceil(i / o.blockWidth) * o.blockWidth,
          height: Math.ceil(s / o.blockHeight) * o.blockHeight,
          depthOrArrayLayers: 1
        }
      ), i = Math.max(i >> 1, 1), s = Math.max(s >> 1, 1);
    }
  }
}, Iw = {
  type: "image",
  upload(n, t, e) {
    const i = n.resource;
    if (!i)
      return;
    if (globalThis.HTMLImageElement && i instanceof HTMLImageElement) {
      const c = ve.get().createCanvas(i.width, i.height);
      c.getContext("2d").drawImage(i, 0, 0, i.width, i.height), n.resource = c, $t("ImageSource: Image element passed, converting to canvas and replacing resource.");
    }
    const s = Math.min(t.width, n.resourceWidth || n.pixelWidth), o = Math.min(t.height, n.resourceHeight || n.pixelHeight), l = n.alphaMode === "premultiply-alpha-on-upload";
    e.device.queue.copyExternalImageToTexture(
      { source: i },
      { texture: t, premultipliedAlpha: l },
      {
        width: s,
        height: o
      }
    );
  }
}, fk = {
  type: "video",
  upload(n, t, e) {
    Iw.upload(n, t, e);
  }
};
class pk {
  constructor(t) {
    this.device = t, this.sampler = t.createSampler({ minFilter: "linear" }), this.pipelines = {};
  }
  _getMipmapPipeline(t) {
    let e = this.pipelines[t];
    return e || (this.mipmapShaderModule || (this.mipmapShaderModule = this.device.createShaderModule({
      code: (
        /* wgsl */
        `
                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(
                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));

                        struct VertexOutput {
                        @builtin(position) position : vec4<f32>,
                        @location(0) texCoord : vec2<f32>,
                        };

                        @vertex
                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
                        var output : VertexOutput;
                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
                        return output;
                        }

                        @group(0) @binding(0) var imgSampler : sampler;
                        @group(0) @binding(1) var img : texture_2d<f32>;

                        @fragment
                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
                        return textureSample(img, imgSampler, texCoord);
                        }
                    `
      )
    })), e = this.device.createRenderPipeline({
      layout: "auto",
      vertex: {
        module: this.mipmapShaderModule,
        entryPoint: "vertexMain"
      },
      fragment: {
        module: this.mipmapShaderModule,
        entryPoint: "fragmentMain",
        targets: [{ format: t }]
      }
    }), this.pipelines[t] = e), e;
  }
  /**
   * Generates mipmaps for the given GPUTexture from the data in level 0.
   * @param {module:External.GPUTexture} texture - Texture to generate mipmaps for.
   * @returns {module:External.GPUTexture} - The originally passed texture
   */
  generateMipmap(t) {
    const e = this._getMipmapPipeline(t.format);
    if (t.dimension === "3d" || t.dimension === "1d")
      throw new Error("Generating mipmaps for non-2d textures is currently unsupported!");
    let i = t;
    const s = t.depthOrArrayLayers || 1, o = t.usage & GPUTextureUsage.RENDER_ATTACHMENT;
    if (!o) {
      const d = {
        size: {
          width: Math.ceil(t.width / 2),
          height: Math.ceil(t.height / 2),
          depthOrArrayLayers: s
        },
        format: t.format,
        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,
        mipLevelCount: t.mipLevelCount - 1
      };
      i = this.device.createTexture(d);
    }
    const l = this.device.createCommandEncoder({}), c = e.getBindGroupLayout(0);
    for (let d = 0; d < s; ++d) {
      let f = t.createView({
        baseMipLevel: 0,
        mipLevelCount: 1,
        dimension: "2d",
        baseArrayLayer: d,
        arrayLayerCount: 1
      }), m = o ? 1 : 0;
      for (let y = 1; y < t.mipLevelCount; ++y) {
        const b = i.createView({
          baseMipLevel: m++,
          mipLevelCount: 1,
          dimension: "2d",
          baseArrayLayer: d,
          arrayLayerCount: 1
        }), v = l.beginRenderPass({
          colorAttachments: [{
            view: b,
            storeOp: "store",
            loadOp: "clear",
            clearValue: { r: 0, g: 0, b: 0, a: 0 }
          }]
        }), x = this.device.createBindGroup({
          layout: c,
          entries: [{
            binding: 0,
            resource: this.sampler
          }, {
            binding: 1,
            resource: f
          }]
        });
        v.setPipeline(e), v.setBindGroup(0, x), v.draw(3, 1, 0, 0), v.end(), f = b;
      }
    }
    if (!o) {
      const d = {
        width: Math.ceil(t.width / 2),
        height: Math.ceil(t.height / 2),
        depthOrArrayLayers: s
      };
      for (let f = 1; f < t.mipLevelCount; ++f)
        l.copyTextureToTexture({
          texture: i,
          mipLevel: f - 1
        }, {
          texture: t,
          mipLevel: f
        }, d), d.width = Math.ceil(d.width / 2), d.height = Math.ceil(d.height / 2);
    }
    return this.device.queue.submit([l.finish()]), o || i.destroy(), t;
  }
}
class zw {
  constructor(t) {
    this.managedTextures = [], this._gpuSources = /* @__PURE__ */ Object.create(null), this._gpuSamplers = /* @__PURE__ */ Object.create(null), this._bindGroupHash = /* @__PURE__ */ Object.create(null), this._textureViewHash = /* @__PURE__ */ Object.create(null), this._uploads = {
      image: Iw,
      buffer: ck,
      video: fk,
      compressed: dk
    }, this._renderer = t, t.renderableGC.addManagedHash(this, "_gpuSources"), t.renderableGC.addManagedHash(this, "_gpuSamplers"), t.renderableGC.addManagedHash(this, "_bindGroupHash"), t.renderableGC.addManagedHash(this, "_textureViewHash");
  }
  contextChange(t) {
    this._gpu = t;
  }
  /**
   * Initializes a texture source, if it has already been initialized nothing will happen.
   * @param source - The texture source to initialize.
   * @returns The initialized texture source.
   */
  initSource(t) {
    return this._gpuSources[t.uid] ? this._gpuSources[t.uid] : this._initSource(t);
  }
  _initSource(t) {
    if (t.autoGenerateMipmaps) {
      const d = Math.max(t.pixelWidth, t.pixelHeight);
      t.mipLevelCount = Math.floor(Math.log2(d)) + 1;
    }
    let e = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;
    t.uploadMethodId !== "compressed" && (e |= GPUTextureUsage.RENDER_ATTACHMENT, e |= GPUTextureUsage.COPY_SRC);
    const i = Nw[t.format] || { blockWidth: 1, blockHeight: 1 }, s = Math.ceil(t.pixelWidth / i.blockWidth) * i.blockWidth, o = Math.ceil(t.pixelHeight / i.blockHeight) * i.blockHeight, l = {
      label: t.label,
      size: { width: s, height: o },
      format: t.format,
      sampleCount: t.sampleCount,
      mipLevelCount: t.mipLevelCount,
      dimension: t.dimension,
      usage: e
    }, c = this._gpuSources[t.uid] = this._gpu.device.createTexture(l);
    return this.managedTextures.includes(t) || (t.on("update", this.onSourceUpdate, this), t.on("resize", this.onSourceResize, this), t.on("destroy", this.onSourceDestroy, this), t.on("unload", this.onSourceUnload, this), t.on("updateMipmaps", this.onUpdateMipmaps, this), this.managedTextures.push(t)), this.onSourceUpdate(t), c;
  }
  onSourceUpdate(t) {
    const e = this.getGpuSource(t);
    e && (this._uploads[t.uploadMethodId] && this._uploads[t.uploadMethodId].upload(t, e, this._gpu), t.autoGenerateMipmaps && t.mipLevelCount > 1 && this.onUpdateMipmaps(t));
  }
  onSourceUnload(t) {
    const e = this._gpuSources[t.uid];
    e && (this._gpuSources[t.uid] = null, e.destroy());
  }
  onUpdateMipmaps(t) {
    this._mipmapGenerator || (this._mipmapGenerator = new pk(this._gpu.device));
    const e = this.getGpuSource(t);
    this._mipmapGenerator.generateMipmap(e);
  }
  onSourceDestroy(t) {
    t.off("update", this.onSourceUpdate, this), t.off("unload", this.onSourceUnload, this), t.off("destroy", this.onSourceDestroy, this), t.off("resize", this.onSourceResize, this), t.off("updateMipmaps", this.onUpdateMipmaps, this), this.managedTextures.splice(this.managedTextures.indexOf(t), 1), this.onSourceUnload(t);
  }
  onSourceResize(t) {
    const e = this._gpuSources[t.uid];
    e ? (e.width !== t.pixelWidth || e.height !== t.pixelHeight) && (this._textureViewHash[t.uid] = null, this._bindGroupHash[t.uid] = null, this.onSourceUnload(t), this.initSource(t)) : this.initSource(t);
  }
  _initSampler(t) {
    return this._gpuSamplers[t._resourceId] = this._gpu.device.createSampler(t), this._gpuSamplers[t._resourceId];
  }
  getGpuSampler(t) {
    return this._gpuSamplers[t._resourceId] || this._initSampler(t);
  }
  getGpuSource(t) {
    return this._gpuSources[t.uid] || this.initSource(t);
  }
  /**
   * this returns s bind group for a specific texture, the bind group contains
   * - the texture source
   * - the texture style
   * - the texture matrix
   * This is cached so the bind group should only be created once per texture
   * @param texture - the texture you want the bindgroup for
   * @returns the bind group for the texture
   */
  getTextureBindGroup(t) {
    return this._bindGroupHash[t.uid] ?? this._createTextureBindGroup(t);
  }
  _createTextureBindGroup(t) {
    const e = t.source;
    return this._bindGroupHash[t.uid] = new yr({
      0: e,
      1: e.style,
      2: new Pn({
        uTextureMatrix: { type: "mat3x3<f32>", value: t.textureMatrix.mapCoord }
      })
    }), this._bindGroupHash[t.uid];
  }
  getTextureView(t) {
    const e = t.source;
    return this._textureViewHash[e.uid] ?? this._createTextureView(e);
  }
  _createTextureView(t) {
    return this._textureViewHash[t.uid] = this.getGpuSource(t).createView(), this._textureViewHash[t.uid];
  }
  generateCanvas(t) {
    const e = this._renderer, i = e.gpu.device.createCommandEncoder(), s = ve.get().createCanvas();
    s.width = t.source.pixelWidth, s.height = t.source.pixelHeight;
    const o = s.getContext("webgpu");
    return o.configure({
      device: e.gpu.device,
      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,
      format: ve.get().getNavigator().gpu.getPreferredCanvasFormat(),
      alphaMode: "premultiplied"
    }), i.copyTextureToTexture({
      texture: e.texture.getGpuSource(t.source),
      origin: {
        x: 0,
        y: 0
      }
    }, {
      texture: o.getCurrentTexture()
    }, {
      width: s.width,
      height: s.height
    }), e.gpu.device.queue.submit([i.finish()]), s;
  }
  getPixels(t) {
    const e = this.generateCanvas(t), i = xr.getOptimalCanvasAndContext(e.width, e.height), s = i.context;
    s.drawImage(e, 0, 0);
    const { width: o, height: l } = e, c = s.getImageData(0, 0, o, l), d = new Uint8ClampedArray(c.data.buffer);
    return xr.returnCanvasAndContext(i), { pixels: d, width: o, height: l };
  }
  destroy() {
    this.managedTextures.slice().forEach((t) => this.onSourceDestroy(t)), this.managedTextures = null;
    for (const t of Object.keys(this._bindGroupHash)) {
      const e = Number(t);
      this._bindGroupHash[e]?.destroy(), this._bindGroupHash[e] = null;
    }
    this._gpu = null, this._mipmapGenerator = null, this._gpuSources = null, this._bindGroupHash = null, this._textureViewHash = null, this._gpuSamplers = null;
  }
}
zw.extension = {
  type: [
    W.WebGPUSystem
  ],
  name: "texture"
};
class Lw {
  constructor() {
    this._maxTextures = 0;
  }
  contextChange(t) {
    const e = new Pn({
      uTransformMatrix: { value: new bt(), type: "mat3x3<f32>" },
      uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
      uRound: { value: 0, type: "f32" }
    });
    this._maxTextures = t.limits.maxBatchableTextures;
    const i = Kl({
      name: "graphics",
      bits: [
        lg,
        cg(this._maxTextures),
        GB,
        Ql
      ]
    });
    this.shader = new fi({
      gpuProgram: i,
      resources: {
        // added on the fly!
        localUniforms: e
      }
    });
  }
  execute(t, e) {
    const i = e.context, s = i.customShader || this.shader, o = t.renderer, l = o.graphicsContext, {
      batcher: c,
      instructions: d
    } = l.getContextRenderData(i), f = o.encoder;
    f.setGeometry(c.geometry, s.gpuProgram);
    const m = o.globalUniforms.bindGroup;
    f.setBindGroup(0, m, s.gpuProgram);
    const y = o.renderPipes.uniformBatch.getUniformBindGroup(s.resources.localUniforms, !0);
    f.setBindGroup(2, y, s.gpuProgram);
    const b = d.instructions;
    let v = null;
    for (let x = 0; x < d.instructionSize; x++) {
      const S = b[x];
      if (S.topology !== v && (v = S.topology, f.setPipelineFromGeometryProgramAndState(
        c.geometry,
        s.gpuProgram,
        t.state,
        S.topology
      )), s.groups[1] = S.bindGroup, !S.gpuBindGroup) {
        const _ = S.textures;
        S.bindGroup = og(
          _.textures,
          _.count,
          this._maxTextures
        ), S.gpuBindGroup = o.bindGroup.getBindGroup(
          S.bindGroup,
          s.gpuProgram,
          1
        );
      }
      f.setBindGroup(1, S.bindGroup, s.gpuProgram), f.renderPassEncoder.drawIndexed(S.size, 1, S.start);
    }
  }
  destroy() {
    this.shader.destroy(!0), this.shader = null;
  }
}
Lw.extension = {
  type: [
    W.WebGPUPipesAdaptor
  ],
  name: "graphics"
};
class Fw {
  init() {
    const t = Kl({
      name: "mesh",
      bits: [
        Rl,
        UB,
        Ql
      ]
    });
    this._shader = new fi({
      gpuProgram: t,
      resources: {
        uTexture: Tt.EMPTY._source,
        uSampler: Tt.EMPTY._source.style,
        textureUniforms: {
          uTextureMatrix: { type: "mat3x3<f32>", value: new bt() }
        }
      }
    });
  }
  execute(t, e) {
    const i = t.renderer;
    let s = e._shader;
    if (!s)
      s = this._shader, s.groups[2] = i.texture.getTextureBindGroup(e.texture);
    else if (!s.gpuProgram) {
      $t("Mesh shader has no gpuProgram", e.shader);
      return;
    }
    const o = s.gpuProgram;
    if (o.autoAssignGlobalUniforms && (s.groups[0] = i.globalUniforms.bindGroup), o.autoAssignLocalUniforms) {
      const l = t.localUniforms;
      s.groups[1] = i.renderPipes.uniformBatch.getUniformBindGroup(l, !0);
    }
    i.encoder.draw({
      geometry: e._geometry,
      shader: s,
      state: e.state
    });
  }
  destroy() {
    this._shader.destroy(!0), this._shader = null;
  }
}
Fw.extension = {
  type: [
    W.WebGPUPipesAdaptor
  ],
  name: "mesh"
};
const mk = [
  ...xw,
  Bw,
  Aw,
  Og,
  Rw,
  Ew,
  zw,
  Dw,
  Gw,
  Uw,
  Ow,
  Mw,
  Pw,
  Cw
], gk = [..._w, kw], yk = [wT, Fw, Lw], Hw = [], $w = [], Ww = [];
Nt.handleByNamedList(W.WebGPUSystem, Hw);
Nt.handleByNamedList(W.WebGPUPipes, $w);
Nt.handleByNamedList(W.WebGPUPipesAdaptor, Ww);
Nt.add(...mk, ...gk, ...yk);
class bk extends Sh {
  constructor() {
    const t = {
      name: "webgpu",
      type: Ti.WEBGPU,
      systems: Hw,
      renderPipes: $w,
      renderPipeAdaptors: Ww
    };
    super(t);
  }
}
const vk = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  WebGPURenderer: bk
}, Symbol.toStringTag, { value: "Module" }));
class xk {
  constructor() {
    this.batches = [], this.batched = !1;
  }
  destroy() {
    this.batches.forEach((t) => {
      Qe.return(t);
    }), this.batches.length = 0;
  }
}
class Vw {
  constructor(t, e) {
    this.state = wi.for2d(), this.renderer = t, this._adaptor = e, this.renderer.runners.contextChange.add(this);
  }
  contextChange() {
    this._adaptor.contextChange(this.renderer);
  }
  validateRenderable(t) {
    const e = t.context, i = !!t._gpuData, s = this.renderer.graphicsContext.updateGpuContext(e);
    return !!(s.isBatchable || i !== s.isBatchable);
  }
  addRenderable(t, e) {
    const i = this.renderer.graphicsContext.updateGpuContext(t.context);
    t.didViewUpdate && this._rebuild(t), i.isBatchable ? this._addToBatcher(t, e) : (this.renderer.renderPipes.batch.break(e), e.add(t));
  }
  updateRenderable(t) {
    const i = this._getGpuDataForRenderable(t).batches;
    for (let s = 0; s < i.length; s++) {
      const o = i[s];
      o._batcher.updateElement(o);
    }
  }
  execute(t) {
    if (!t.isRenderable)
      return;
    const e = this.renderer, i = t.context;
    if (!e.graphicsContext.getGpuContext(i).batches.length)
      return;
    const o = i.customShader || this._adaptor.shader;
    this.state.blendMode = t.groupBlendMode;
    const l = o.resources.localUniforms.uniforms;
    l.uTransformMatrix = t.groupTransform, l.uRound = e._roundPixels | t._roundPixels, tu(
      t.groupColorAlpha,
      l.uColor,
      0
    ), this._adaptor.execute(this, t);
  }
  _rebuild(t) {
    const e = this._getGpuDataForRenderable(t), i = this.renderer.graphicsContext.updateGpuContext(t.context);
    e.destroy(), i.isBatchable && this._updateBatchesForRenderable(t, e);
  }
  _addToBatcher(t, e) {
    const i = this.renderer.renderPipes.batch, s = this._getGpuDataForRenderable(t).batches;
    for (let o = 0; o < s.length; o++) {
      const l = s[o];
      i.addToBatch(l, e);
    }
  }
  _getGpuDataForRenderable(t) {
    return t._gpuData[this.renderer.uid] || this._initGpuDataForRenderable(t);
  }
  _initGpuDataForRenderable(t) {
    const e = new xk();
    return t._gpuData[this.renderer.uid] = e, e;
  }
  _updateBatchesForRenderable(t, e) {
    const i = t.context, s = this.renderer.graphicsContext.getGpuContext(i), o = this.renderer._roundPixels | t._roundPixels;
    e.batches = s.batches.map((l) => {
      const c = Qe.get(pg);
      return l.copyTo(c), c.renderable = t, c.roundPixels = o, c;
    });
  }
  destroy() {
    this.renderer = null, this._adaptor.destroy(), this._adaptor = null, this.state = null;
  }
}
Vw.extension = {
  type: [
    W.WebGLPipes,
    W.WebGPUPipes,
    W.CanvasPipes
  ],
  name: "graphics"
};
const jw = class Yw extends xg {
  constructor(...t) {
    super({});
    let e = t[0] ?? {};
    typeof e == "number" && (zt(ae, "PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead"), e = {
      width: e,
      height: t[1],
      verticesX: t[2],
      verticesY: t[3]
    }), this.build(e);
  }
  /**
   * Refreshes plane coordinates
   * @param options - Options to be applied to plane geometry
   */
  build(t) {
    t = { ...Yw.defaultOptions, ...t }, this.verticesX = this.verticesX ?? t.verticesX, this.verticesY = this.verticesY ?? t.verticesY, this.width = this.width ?? t.width, this.height = this.height ?? t.height;
    const e = this.verticesX * this.verticesY, i = [], s = [], o = [], l = this.verticesX - 1, c = this.verticesY - 1, d = this.width / l, f = this.height / c;
    for (let y = 0; y < e; y++) {
      const b = y % this.verticesX, v = y / this.verticesX | 0;
      i.push(b * d, v * f), s.push(b / l, v / c);
    }
    const m = l * c;
    for (let y = 0; y < m; y++) {
      const b = y % l, v = y / l | 0, x = v * this.verticesX + b, S = v * this.verticesX + b + 1, _ = (v + 1) * this.verticesX + b, C = (v + 1) * this.verticesX + b + 1;
      o.push(
        x,
        S,
        _,
        S,
        C,
        _
      );
    }
    this.buffers[0].data = new Float32Array(i), this.buffers[1].data = new Float32Array(s), this.indexBuffer.data = new Uint32Array(o), this.buffers[0].update(), this.buffers[1].update(), this.indexBuffer.update();
  }
};
jw.defaultOptions = {
  width: 100,
  height: 100,
  verticesX: 10,
  verticesY: 10
};
let _k = jw;
class Dg {
  constructor() {
    this.batcherName = "default", this.packAsQuad = !1, this.indexOffset = 0, this.attributeOffset = 0, this.roundPixels = 0, this._batcher = null, this._batch = null, this._textureMatrixUpdateId = -1, this._uvUpdateId = -1;
  }
  get blendMode() {
    return this.renderable.groupBlendMode;
  }
  get topology() {
    return this._topology || this.geometry.topology;
  }
  set topology(t) {
    this._topology = t;
  }
  reset() {
    this.renderable = null, this.texture = null, this._batcher = null, this._batch = null, this.geometry = null, this._uvUpdateId = -1, this._textureMatrixUpdateId = -1;
  }
  /**
   * Sets the texture for the batchable mesh.
   * As it does so, it resets the texture matrix update ID.
   * this is to ensure that the texture matrix is recalculated when the uvs are referenced
   * @param value - The texture to set.
   */
  setTexture(t) {
    this.texture !== t && (this.texture = t, this._textureMatrixUpdateId = -1);
  }
  get uvs() {
    const e = this.geometry.getBuffer("aUV"), i = e.data;
    let s = i;
    const o = this.texture.textureMatrix;
    return o.isSimple || (s = this._transformedUvs, (this._textureMatrixUpdateId !== o._updateID || this._uvUpdateId !== e._updateID) && ((!s || s.length < i.length) && (s = this._transformedUvs = new Float32Array(i.length)), this._textureMatrixUpdateId = o._updateID, this._uvUpdateId = e._updateID, o.multiplyUvs(i, s))), s;
  }
  get positions() {
    return this.geometry.positions;
  }
  get indices() {
    return this.geometry.indices;
  }
  get color() {
    return this.renderable.groupColorAlpha;
  }
  get groupTransform() {
    return this.renderable.groupTransform;
  }
  get attributeSize() {
    return this.geometry.positions.length / 2;
  }
  get indexSize() {
    return this.geometry.indices.length;
  }
}
class U0 {
  destroy() {
  }
}
class Xw {
  constructor(t, e) {
    this.localUniforms = new Pn({
      uTransformMatrix: { value: new bt(), type: "mat3x3<f32>" },
      uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
      uRound: { value: 0, type: "f32" }
    }), this.localUniformsBindGroup = new yr({
      0: this.localUniforms
    }), this.renderer = t, this._adaptor = e, this._adaptor.init();
  }
  validateRenderable(t) {
    const e = this._getMeshData(t), i = e.batched, s = t.batched;
    if (e.batched = s, i !== s)
      return !0;
    if (s) {
      const o = t._geometry;
      if (o.indices.length !== e.indexSize || o.positions.length !== e.vertexSize)
        return e.indexSize = o.indices.length, e.vertexSize = o.positions.length, !0;
      const l = this._getBatchableMesh(t);
      return l.texture.uid !== t._texture.uid && (l._textureMatrixUpdateId = -1), !l._batcher.checkAndUpdateTexture(
        l,
        t._texture
      );
    }
    return !1;
  }
  addRenderable(t, e) {
    const i = this.renderer.renderPipes.batch, s = this._getMeshData(t);
    if (t.didViewUpdate && (s.indexSize = t._geometry.indices?.length, s.vertexSize = t._geometry.positions?.length), s.batched) {
      const o = this._getBatchableMesh(t);
      o.setTexture(t._texture), o.geometry = t._geometry, i.addToBatch(o, e);
    } else
      i.break(e), e.add(t);
  }
  updateRenderable(t) {
    if (t.batched) {
      const e = this._getBatchableMesh(t);
      e.setTexture(t._texture), e.geometry = t._geometry, e._batcher.updateElement(e);
    }
  }
  execute(t) {
    if (!t.isRenderable)
      return;
    t.state.blendMode = Fl(t.groupBlendMode, t.texture._source);
    const e = this.localUniforms;
    e.uniforms.uTransformMatrix = t.groupTransform, e.uniforms.uRound = this.renderer._roundPixels | t._roundPixels, e.update(), tu(
      t.groupColorAlpha,
      e.uniforms.uColor,
      0
    ), this._adaptor.execute(this, t);
  }
  _getMeshData(t) {
    var e, i;
    return (e = t._gpuData)[i = this.renderer.uid] || (e[i] = new U0()), t._gpuData[this.renderer.uid].meshData || this._initMeshData(t);
  }
  _initMeshData(t) {
    return t._gpuData[this.renderer.uid].meshData = {
      batched: t.batched,
      indexSize: 0,
      vertexSize: 0
    }, t._gpuData[this.renderer.uid].meshData;
  }
  _getBatchableMesh(t) {
    var e, i;
    return (e = t._gpuData)[i = this.renderer.uid] || (e[i] = new U0()), t._gpuData[this.renderer.uid].batchableMesh || this._initBatchableMesh(t);
  }
  _initBatchableMesh(t) {
    const e = new Dg();
    return e.renderable = t, e.setTexture(t._texture), e.transform = t.groupTransform, e.roundPixels = this.renderer._roundPixels | t._roundPixels, t._gpuData[this.renderer.uid].batchableMesh = e, e;
  }
  destroy() {
    this.localUniforms = null, this.localUniformsBindGroup = null, this._adaptor.destroy(), this._adaptor = null, this.renderer = null;
  }
}
Xw.extension = {
  type: [
    W.WebGLPipes,
    W.WebGPUPipes,
    W.CanvasPipes
  ],
  name: "mesh"
};
class Sk {
  execute(t, e) {
    const i = t.state, s = t.renderer, o = e.shader || t.defaultShader;
    o.resources.uTexture = e.texture._source, o.resources.uniforms = t.localUniforms;
    const l = s.gl, c = t.getBuffers(e);
    s.shader.bind(o), s.state.set(i), s.geometry.bind(c.geometry, o.glProgram);
    const f = c.geometry.indexBuffer.data.BYTES_PER_ELEMENT === 2 ? l.UNSIGNED_SHORT : l.UNSIGNED_INT;
    l.drawElements(l.TRIANGLES, e.particleChildren.length * 6, f, 0);
  }
}
class Tk {
  execute(t, e) {
    const i = t.renderer, s = e.shader || t.defaultShader;
    s.groups[0] = i.renderPipes.uniformBatch.getUniformBindGroup(t.localUniforms, !0), s.groups[1] = i.texture.getTextureBindGroup(e.texture);
    const o = t.state, l = t.getBuffers(e);
    i.encoder.draw({
      geometry: l.geometry,
      shader: e.shader || t.defaultShader,
      state: o,
      size: e.particleChildren.length * 6
    });
  }
}
function N0(n, t = null) {
  const e = n * 6;
  if (e > 65535 ? t || (t = new Uint32Array(e)) : t || (t = new Uint16Array(e)), t.length !== e)
    throw new Error(`Out buffer length is incorrect, got ${t.length} and expected ${e}`);
  for (let i = 0, s = 0; i < e; i += 6, s += 4)
    t[i + 0] = s + 0, t[i + 1] = s + 1, t[i + 2] = s + 2, t[i + 3] = s + 0, t[i + 4] = s + 2, t[i + 5] = s + 3;
  return t;
}
function wk(n) {
  return {
    dynamicUpdate: I0(n, !0),
    staticUpdate: I0(n, !1)
  };
}
function I0(n, t) {
  const e = [];
  e.push(`

        var index = 0;

        for (let i = 0; i < ps.length; ++i)
        {
            const p = ps[i];

            `);
  let i = 0;
  for (const o in n) {
    const l = n[o];
    if (t !== l.dynamic)
      continue;
    e.push(`offset = index + ${i}`), e.push(l.code);
    const c = Jr(l.format);
    i += c.stride / 4;
  }
  e.push(`
            index += stride * 4;
        }
    `), e.unshift(`
        var stride = ${i};
    `);
  const s = e.join(`
`);
  return new Function("ps", "f32v", "u32v", s);
}
class Ck {
  constructor(t) {
    this._size = 0, this._generateParticleUpdateCache = {};
    const e = this._size = t.size ?? 1e3, i = t.properties;
    let s = 0, o = 0;
    for (const m in i) {
      const y = i[m], b = Jr(y.format);
      y.dynamic ? o += b.stride : s += b.stride;
    }
    this._dynamicStride = o / 4, this._staticStride = s / 4, this.staticAttributeBuffer = new Fa(e * 4 * s), this.dynamicAttributeBuffer = new Fa(e * 4 * o), this.indexBuffer = N0(e);
    const l = new ql();
    let c = 0, d = 0;
    this._staticBuffer = new Zn({
      data: new Float32Array(1),
      label: "static-particle-buffer",
      shrinkToFit: !1,
      usage: Qt.VERTEX | Qt.COPY_DST
    }), this._dynamicBuffer = new Zn({
      data: new Float32Array(1),
      label: "dynamic-particle-buffer",
      shrinkToFit: !1,
      usage: Qt.VERTEX | Qt.COPY_DST
    });
    for (const m in i) {
      const y = i[m], b = Jr(y.format);
      y.dynamic ? (l.addAttribute(y.attributeName, {
        buffer: this._dynamicBuffer,
        stride: this._dynamicStride * 4,
        offset: c * 4,
        format: y.format
      }), c += b.size) : (l.addAttribute(y.attributeName, {
        buffer: this._staticBuffer,
        stride: this._staticStride * 4,
        offset: d * 4,
        format: y.format
      }), d += b.size);
    }
    l.addIndex(this.indexBuffer);
    const f = this.getParticleUpdate(i);
    this._dynamicUpload = f.dynamicUpdate, this._staticUpload = f.staticUpdate, this.geometry = l;
  }
  getParticleUpdate(t) {
    const e = Ek(t);
    return this._generateParticleUpdateCache[e] ? this._generateParticleUpdateCache[e] : (this._generateParticleUpdateCache[e] = this.generateParticleUpdate(t), this._generateParticleUpdateCache[e]);
  }
  generateParticleUpdate(t) {
    return wk(t);
  }
  update(t, e) {
    t.length > this._size && (e = !0, this._size = Math.max(t.length, this._size * 1.5 | 0), this.staticAttributeBuffer = new Fa(this._size * this._staticStride * 4 * 4), this.dynamicAttributeBuffer = new Fa(this._size * this._dynamicStride * 4 * 4), this.indexBuffer = N0(this._size), this.geometry.indexBuffer.setDataWithSize(
      this.indexBuffer,
      this.indexBuffer.byteLength,
      !0
    ));
    const i = this.dynamicAttributeBuffer;
    if (this._dynamicUpload(t, i.float32View, i.uint32View), this._dynamicBuffer.setDataWithSize(
      this.dynamicAttributeBuffer.float32View,
      t.length * this._dynamicStride * 4,
      !0
    ), e) {
      const s = this.staticAttributeBuffer;
      this._staticUpload(t, s.float32View, s.uint32View), this._staticBuffer.setDataWithSize(
        s.float32View,
        t.length * this._staticStride * 4,
        !0
      );
    }
  }
  destroy() {
    this._staticBuffer.destroy(), this._dynamicBuffer.destroy(), this.geometry.destroy();
  }
}
function Ek(n) {
  const t = [];
  for (const e in n) {
    const i = n[e];
    t.push(e, i.code, i.dynamic ? "d" : "s");
  }
  return t.join("_");
}
var Mk = `varying vec2 vUV;
varying vec4 vColor;

uniform sampler2D uTexture;

void main(void){
    vec4 color = texture2D(uTexture, vUV) * vColor;
    gl_FragColor = color;
}`, Ak = `attribute vec2 aVertex;
attribute vec2 aUV;
attribute vec4 aColor;

attribute vec2 aPosition;
attribute float aRotation;

uniform mat3 uTranslationMatrix;
uniform float uRound;
uniform vec2 uResolution;
uniform vec4 uColor;

varying vec2 vUV;
varying vec4 vColor;

vec2 roundPixels(vec2 position, vec2 targetSize)
{       
    return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
}

void main(void){
    float cosRotation = cos(aRotation);
    float sinRotation = sin(aRotation);
    float x = aVertex.x * cosRotation - aVertex.y * sinRotation;
    float y = aVertex.x * sinRotation + aVertex.y * cosRotation;

    vec2 v = vec2(x, y);
    v = v + aPosition;

    gl_Position = vec4((uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

    if(uRound == 1.0)
    {
        gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
    }

    vUV = aUV;
    vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uColor;
}
`, z0 = `
struct ParticleUniforms {
  uTranslationMatrix:mat3x3<f32>,
  uColor:vec4<f32>,
  uRound:f32,
  uResolution:vec2<f32>,
};

fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32>
{
  return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
}

@group(0) @binding(0) var<uniform> uniforms: ParticleUniforms;

@group(1) @binding(0) var uTexture: texture_2d<f32>;
@group(1) @binding(1) var uSampler : sampler;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
    @location(1) color : vec4<f32>,
  };
@vertex
fn mainVertex(
  @location(0) aVertex: vec2<f32>,
  @location(1) aPosition: vec2<f32>,
  @location(2) aUV: vec2<f32>,
  @location(3) aColor: vec4<f32>,
  @location(4) aRotation: f32,
) -> VSOutput {
  
   let v = vec2(
       aVertex.x * cos(aRotation) - aVertex.y * sin(aRotation),
       aVertex.x * sin(aRotation) + aVertex.y * cos(aRotation)
   ) + aPosition;

   var position = vec4((uniforms.uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

   if(uniforms.uRound == 1.0) {
       position = vec4(roundPixels(position.xy, uniforms.uResolution), position.zw);
   }

    let vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uniforms.uColor;

  return VSOutput(
   position,
   aUV,
   vColor,
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @location(1) color: vec4<f32>,
  @builtin(position) position: vec4<f32>,
) -> @location(0) vec4<f32> {

    var sample = textureSample(uTexture, uSampler, uv) * color;
   
    return sample;
}`;
class Rk extends fi {
  constructor() {
    const t = eo.from({
      vertex: Ak,
      fragment: Mk
    }), e = Ns.from({
      fragment: {
        source: z0,
        entryPoint: "mainFragment"
      },
      vertex: {
        source: z0,
        entryPoint: "mainVertex"
      }
    });
    super({
      glProgram: t,
      gpuProgram: e,
      resources: {
        // this will be replaced with the texture from the particle container
        uTexture: Tt.WHITE.source,
        // this will be replaced with the texture style from the particle container
        uSampler: new Qr({}),
        // this will be replaced with the local uniforms from the particle container
        uniforms: {
          uTranslationMatrix: { value: new bt(), type: "mat3x3<f32>" },
          uColor: { value: new Pe(16777215), type: "vec4<f32>" },
          uRound: { value: 1, type: "f32" },
          uResolution: { value: [0, 0], type: "vec2<f32>" }
        }
      }
    });
  }
}
class qw {
  /**
   * @param renderer - The renderer this sprite batch works for.
   * @param adaptor
   */
  constructor(t, e) {
    this.state = wi.for2d(), this.localUniforms = new Pn({
      uTranslationMatrix: { value: new bt(), type: "mat3x3<f32>" },
      uColor: { value: new Float32Array(4), type: "vec4<f32>" },
      uRound: { value: 1, type: "f32" },
      uResolution: { value: [0, 0], type: "vec2<f32>" }
    }), this.renderer = t, this.adaptor = e, this.defaultShader = new Rk(), this.state = wi.for2d();
  }
  validateRenderable(t) {
    return !1;
  }
  addRenderable(t, e) {
    this.renderer.renderPipes.batch.break(e), e.add(t);
  }
  getBuffers(t) {
    return t._gpuData[this.renderer.uid] || this._initBuffer(t);
  }
  _initBuffer(t) {
    return t._gpuData[this.renderer.uid] = new Ck({
      size: t.particleChildren.length,
      properties: t._properties
    }), t._gpuData[this.renderer.uid];
  }
  updateRenderable(t) {
  }
  execute(t) {
    const e = t.particleChildren;
    if (e.length === 0)
      return;
    const i = this.renderer, s = this.getBuffers(t);
    t.texture || (t.texture = e[0].texture);
    const o = this.state;
    s.update(e, t._childrenDirty), t._childrenDirty = !1, o.blendMode = Fl(t.blendMode, t.texture._source);
    const l = this.localUniforms.uniforms, c = l.uTranslationMatrix;
    t.worldTransform.copyTo(c), c.prepend(i.globalUniforms.globalUniformData.projectionMatrix), l.uResolution = i.globalUniforms.globalUniformData.resolution, l.uRound = i._roundPixels | t._roundPixels, tu(
      t.groupColorAlpha,
      l.uColor,
      0
    ), this.adaptor.execute(this, t);
  }
  /** Destroys the ParticleRenderer. */
  destroy() {
    this.renderer = null, this.defaultShader && (this.defaultShader.destroy(), this.defaultShader = null);
  }
}
class Kw extends qw {
  constructor(t) {
    super(t, new Sk());
  }
}
Kw.extension = {
  type: [
    W.WebGLPipes
  ],
  name: "particle"
};
class Zw extends qw {
  constructor(t) {
    super(t, new Tk());
  }
}
Zw.extension = {
  type: [
    W.WebGPUPipes
  ],
  name: "particle"
};
const Qw = class Jw extends _k {
  constructor(t = {}) {
    t = { ...Jw.defaultOptions, ...t }, super({
      width: t.width,
      height: t.height,
      verticesX: 4,
      verticesY: 4
    }), this.update(t);
  }
  /**
   * Updates the NineSliceGeometry with the options.
   * @param options - The options of the NineSliceGeometry.
   */
  update(t) {
    this.width = t.width ?? this.width, this.height = t.height ?? this.height, this._originalWidth = t.originalWidth ?? this._originalWidth, this._originalHeight = t.originalHeight ?? this._originalHeight, this._leftWidth = t.leftWidth ?? this._leftWidth, this._rightWidth = t.rightWidth ?? this._rightWidth, this._topHeight = t.topHeight ?? this._topHeight, this._bottomHeight = t.bottomHeight ?? this._bottomHeight, this._anchorX = t.anchor?.x, this._anchorY = t.anchor?.y, this.updateUvs(), this.updatePositions();
  }
  /** Updates the positions of the vertices. */
  updatePositions() {
    const t = this.positions, {
      width: e,
      height: i,
      _leftWidth: s,
      _rightWidth: o,
      _topHeight: l,
      _bottomHeight: c,
      _anchorX: d,
      _anchorY: f
    } = this, m = s + o, y = e > m ? 1 : e / m, b = l + c, v = i > b ? 1 : i / b, x = Math.min(y, v), S = d * e, _ = f * i;
    t[0] = t[8] = t[16] = t[24] = -S, t[2] = t[10] = t[18] = t[26] = s * x - S, t[4] = t[12] = t[20] = t[28] = e - o * x - S, t[6] = t[14] = t[22] = t[30] = e - S, t[1] = t[3] = t[5] = t[7] = -_, t[9] = t[11] = t[13] = t[15] = l * x - _, t[17] = t[19] = t[21] = t[23] = i - c * x - _, t[25] = t[27] = t[29] = t[31] = i - _, this.getBuffer("aPosition").update();
  }
  /** Updates the UVs of the vertices. */
  updateUvs() {
    const t = this.uvs;
    t[0] = t[8] = t[16] = t[24] = 0, t[1] = t[3] = t[5] = t[7] = 0, t[6] = t[14] = t[22] = t[30] = 1, t[25] = t[27] = t[29] = t[31] = 1;
    const e = 1 / this._originalWidth, i = 1 / this._originalHeight;
    t[2] = t[10] = t[18] = t[26] = e * this._leftWidth, t[9] = t[11] = t[13] = t[15] = i * this._topHeight, t[4] = t[12] = t[20] = t[28] = 1 - e * this._rightWidth, t[17] = t[19] = t[21] = t[23] = 1 - i * this._bottomHeight, this.getBuffer("aUV").update();
  }
};
Qw.defaultOptions = {
  /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */
  width: 100,
  /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */
  height: 100,
  /** The width of the left column. */
  leftWidth: 10,
  /** The height of the top row. */
  topHeight: 10,
  /** The width of the right column. */
  rightWidth: 10,
  /** The height of the bottom row. */
  bottomHeight: 10,
  /** The original width of the texture */
  originalWidth: 100,
  /** The original height of the texture */
  originalHeight: 100
};
let Pk = Qw;
class Bk extends Dg {
  constructor() {
    super(), this.geometry = new Pk();
  }
  destroy() {
    this.geometry.destroy();
  }
}
class tC {
  constructor(t) {
    this._renderer = t;
  }
  addRenderable(t, e) {
    const i = this._getGpuSprite(t);
    t.didViewUpdate && this._updateBatchableSprite(t, i), this._renderer.renderPipes.batch.addToBatch(i, e);
  }
  updateRenderable(t) {
    const e = this._getGpuSprite(t);
    t.didViewUpdate && this._updateBatchableSprite(t, e), e._batcher.updateElement(e);
  }
  validateRenderable(t) {
    const e = this._getGpuSprite(t);
    return !e._batcher.checkAndUpdateTexture(
      e,
      t._texture
    );
  }
  _updateBatchableSprite(t, e) {
    e.geometry.update(t), e.setTexture(t._texture);
  }
  _getGpuSprite(t) {
    return t._gpuData[this._renderer.uid] || this._initGPUSprite(t);
  }
  _initGPUSprite(t) {
    const e = t._gpuData[this._renderer.uid] = new Bk(), i = e;
    return i.renderable = t, i.transform = t.groupTransform, i.texture = t._texture, i.roundPixels = this._renderer._roundPixels | t._roundPixels, t.didViewUpdate || this._updateBatchableSprite(t, i), e;
  }
  destroy() {
    this._renderer = null;
  }
}
tC.extension = {
  type: [
    W.WebGLPipes,
    W.WebGPUPipes,
    W.CanvasPipes
  ],
  name: "nineSliceSprite"
};
const kk = {
  name: "tiling-bit",
  vertex: {
    header: (
      /* wgsl */
      `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `
    ),
    main: (
      /* wgsl */
      `
            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;

            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;
        `
    )
  },
  fragment: {
    header: (
      /* wgsl */
      `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `
    ),
    main: (
      /* wgsl */
      `

            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);
            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;
            var unclamped = coord;
            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);

            var bias = 0.;

            if(unclamped.x == coord.x && unclamped.y == coord.y)
            {
                bias = -32.;
            }

            outColor = textureSampleBias(uTexture, uSampler, coord, bias);
        `
    )
  }
}, Ok = {
  name: "tiling-bit",
  vertex: {
    header: (
      /* glsl */
      `
            uniform mat3 uTextureTransform;
            uniform vec4 uSizeAnchor;

        `
    ),
    main: (
      /* glsl */
      `
            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;

            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;
        `
    )
  },
  fragment: {
    header: (
      /* glsl */
      `
            uniform sampler2D uTexture;
            uniform mat3 uMapCoord;
            uniform vec4 uClampFrame;
            uniform vec2 uClampOffset;
        `
    ),
    main: (
      /* glsl */
      `

        vec2 coord = vUV + ceil(uClampOffset - vUV);
        coord = (uMapCoord * vec3(coord, 1.0)).xy;
        vec2 unclamped = coord;
        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0

        `
    )
  }
};
let $p, Wp;
class Dk extends fi {
  constructor() {
    $p ?? ($p = Kl({
      name: "tiling-sprite-shader",
      bits: [
        Rl,
        kk,
        Ql
      ]
    })), Wp ?? (Wp = Zl({
      name: "tiling-sprite-shader",
      bits: [
        Sg,
        Ok,
        Jl
      ]
    }));
    const t = new Pn({
      uMapCoord: { value: new bt(), type: "mat3x3<f32>" },
      uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: "vec4<f32>" },
      uClampOffset: { value: new Float32Array([0, 0]), type: "vec2<f32>" },
      uTextureTransform: { value: new bt(), type: "mat3x3<f32>" },
      uSizeAnchor: { value: new Float32Array([100, 100, 0.5, 0.5]), type: "vec4<f32>" }
    });
    super({
      glProgram: Wp,
      gpuProgram: $p,
      resources: {
        localUniforms: new Pn({
          uTransformMatrix: { value: new bt(), type: "mat3x3<f32>" },
          uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
          uRound: { value: 0, type: "f32" }
        }),
        tilingUniforms: t,
        uTexture: Tt.EMPTY.source,
        uSampler: Tt.EMPTY.source.style
      }
    });
  }
  updateUniforms(t, e, i, s, o, l) {
    const c = this.resources.tilingUniforms, d = l.width, f = l.height, m = l.textureMatrix, y = c.uniforms.uTextureTransform;
    y.set(
      i.a * d / t,
      i.b * d / e,
      i.c * f / t,
      i.d * f / e,
      i.tx / t,
      i.ty / e
    ), y.invert(), c.uniforms.uMapCoord = m.mapCoord, c.uniforms.uClampFrame = m.uClampFrame, c.uniforms.uClampOffset = m.uClampOffset, c.uniforms.uTextureTransform = y, c.uniforms.uSizeAnchor[0] = t, c.uniforms.uSizeAnchor[1] = e, c.uniforms.uSizeAnchor[2] = s, c.uniforms.uSizeAnchor[3] = o, l && (this.resources.uTexture = l.source, this.resources.uSampler = l.source.style);
  }
}
class Gk extends xg {
  constructor() {
    super({
      positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
      uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
      indices: new Uint32Array([0, 1, 2, 0, 2, 3])
    });
  }
}
function Uk(n, t) {
  const e = n.anchor.x, i = n.anchor.y;
  t[0] = -e * n.width, t[1] = -i * n.height, t[2] = (1 - e) * n.width, t[3] = -i * n.height, t[4] = (1 - e) * n.width, t[5] = (1 - i) * n.height, t[6] = -e * n.width, t[7] = (1 - i) * n.height;
}
function Nk(n, t, e, i) {
  let s = 0;
  const o = n.length / t, l = i.a, c = i.b, d = i.c, f = i.d, m = i.tx, y = i.ty;
  for (e *= t; s < o; ) {
    const b = n[e], v = n[e + 1];
    n[e] = l * b + d * v + m, n[e + 1] = c * b + f * v + y, e += t, s++;
  }
}
function Ik(n, t) {
  const e = n.texture, i = e.frame.width, s = e.frame.height;
  let o = 0, l = 0;
  n.applyAnchorToTexture && (o = n.anchor.x, l = n.anchor.y), t[0] = t[6] = -o, t[2] = t[4] = 1 - o, t[1] = t[3] = -l, t[5] = t[7] = 1 - l;
  const c = bt.shared;
  c.copyFrom(n._tileTransform.matrix), c.tx /= n.width, c.ty /= n.height, c.invert(), c.scale(n.width / i, n.height / s), Nk(t, 2, 0, c);
}
const qc = new Gk();
class zk {
  constructor() {
    this.canBatch = !0, this.geometry = new xg({
      indices: qc.indices.slice(),
      positions: qc.positions.slice(),
      uvs: qc.uvs.slice()
    });
  }
  destroy() {
    this.geometry.destroy(), this.shader?.destroy();
  }
}
class eC {
  constructor(t) {
    this._state = wi.default2d, this._renderer = t;
  }
  validateRenderable(t) {
    const e = this._getTilingSpriteData(t), i = e.canBatch;
    this._updateCanBatch(t);
    const s = e.canBatch;
    if (s && s === i) {
      const { batchableMesh: o } = e;
      return !o._batcher.checkAndUpdateTexture(
        o,
        t.texture
      );
    }
    return i !== s;
  }
  addRenderable(t, e) {
    const i = this._renderer.renderPipes.batch;
    this._updateCanBatch(t);
    const s = this._getTilingSpriteData(t), { geometry: o, canBatch: l } = s;
    if (l) {
      s.batchableMesh || (s.batchableMesh = new Dg());
      const c = s.batchableMesh;
      t.didViewUpdate && (this._updateBatchableMesh(t), c.geometry = o, c.renderable = t, c.transform = t.groupTransform, c.setTexture(t._texture)), c.roundPixels = this._renderer._roundPixels | t._roundPixels, i.addToBatch(c, e);
    } else
      i.break(e), s.shader || (s.shader = new Dk()), this.updateRenderable(t), e.add(t);
  }
  execute(t) {
    const { shader: e } = this._getTilingSpriteData(t);
    e.groups[0] = this._renderer.globalUniforms.bindGroup;
    const i = e.resources.localUniforms.uniforms;
    i.uTransformMatrix = t.groupTransform, i.uRound = this._renderer._roundPixels | t._roundPixels, tu(
      t.groupColorAlpha,
      i.uColor,
      0
    ), this._state.blendMode = Fl(t.groupBlendMode, t.texture._source), this._renderer.encoder.draw({
      geometry: qc,
      shader: e,
      state: this._state
    });
  }
  updateRenderable(t) {
    const e = this._getTilingSpriteData(t), { canBatch: i } = e;
    if (i) {
      const { batchableMesh: s } = e;
      t.didViewUpdate && this._updateBatchableMesh(t), s._batcher.updateElement(s);
    } else if (t.didViewUpdate) {
      const { shader: s } = e;
      s.updateUniforms(
        t.width,
        t.height,
        t._tileTransform.matrix,
        t.anchor.x,
        t.anchor.y,
        t.texture
      );
    }
  }
  _getTilingSpriteData(t) {
    return t._gpuData[this._renderer.uid] || this._initTilingSpriteData(t);
  }
  _initTilingSpriteData(t) {
    const e = new zk();
    return e.renderable = t, t._gpuData[this._renderer.uid] = e, e;
  }
  _updateBatchableMesh(t) {
    const e = this._getTilingSpriteData(t), { geometry: i } = e, s = t.texture.source.style;
    s.addressMode !== "repeat" && (s.addressMode = "repeat", s.update()), Ik(t, i.uvs), Uk(t, i.positions);
  }
  destroy() {
    this._renderer = null;
  }
  _updateCanBatch(t) {
    const e = this._getTilingSpriteData(t), i = t.texture;
    let s = !0;
    return this._renderer.type === Ti.WEBGL && (s = this._renderer.context.supports.nonPowOf2wrapping), e.canBatch = i.textureMatrix.isSimple && (s || i.source.isPowerOfTwo), e.canBatch;
  }
}
eC.extension = {
  type: [
    W.WebGLPipes,
    W.WebGPUPipes,
    W.CanvasPipes
  ],
  name: "tilingSprite"
};
const Lk = {
  name: "local-uniform-msdf-bit",
  vertex: {
    header: (
      /* wgsl */
      `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32,
                uRound:f32,
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `
    ),
    main: (
      /* wgsl */
      `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `
    ),
    end: (
      /* wgsl */
      `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `
    )
  },
  fragment: {
    header: (
      /* wgsl */
      `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
         `
    ),
    main: (
      /* wgsl */
      `
            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));
        `
    )
  }
}, Fk = {
  name: "local-uniform-msdf-bit",
  vertex: {
    header: (
      /* glsl */
      `
            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `
    ),
    main: (
      /* glsl */
      `
            vColor *= uColor;
            modelMatrix *= uTransformMatrix;
        `
    ),
    end: (
      /* glsl */
      `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `
    )
  },
  fragment: {
    header: (
      /* glsl */
      `
            uniform float uDistance;
         `
    ),
    main: (
      /* glsl */
      `
            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));
        `
    )
  }
}, Hk = {
  name: "msdf-bit",
  fragment: {
    header: (
      /* wgsl */
      `
            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {

                // MSDF
                var median = msdfColor.r + msdfColor.g + msdfColor.b -
                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));

                // SDF
                median = min(median, msdfColor.a);

                var screenPxDistance = distance * (median - 0.5);
                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));
                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);
                var coverage: f32 = pow(shapeColor.a * alpha, gamma);

                return coverage;

            }
        `
    )
  }
}, $k = {
  name: "msdf-bit",
  fragment: {
    header: (
      /* glsl */
      `
            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {

                // MSDF
                float median = msdfColor.r + msdfColor.g + msdfColor.b -
                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));

                // SDF
                median = min(median, msdfColor.a);

                float screenPxDistance = distance * (median - 0.5);
                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);

                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));
                float gamma = mix(1.0, 1.0 / 2.2, luma);
                float coverage = pow(shapeColor.a * alpha, gamma);

                return coverage;
            }
        `
    )
  }
};
let Vp, jp;
class Wk extends fi {
  constructor(t) {
    const e = new Pn({
      uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
      uTransformMatrix: { value: new bt(), type: "mat3x3<f32>" },
      uDistance: { value: 4, type: "f32" },
      uRound: { value: 0, type: "f32" }
    });
    Vp ?? (Vp = Kl({
      name: "sdf-shader",
      bits: [
        lg,
        cg(t),
        Lk,
        Hk,
        Ql
      ]
    })), jp ?? (jp = Zl({
      name: "sdf-shader",
      bits: [
        ug,
        hg(t),
        Fk,
        $k,
        Jl
      ]
    })), super({
      glProgram: jp,
      gpuProgram: Vp,
      resources: {
        localUniforms: e,
        batchSamplers: dg(t)
      }
    });
  }
}
class Vk extends $l {
  destroy() {
    this.context.customShader && this.context.customShader.destroy(), super.destroy();
  }
}
class nC {
  constructor(t) {
    this._renderer = t;
  }
  validateRenderable(t) {
    const e = this._getGpuBitmapText(t);
    return this._renderer.renderPipes.graphics.validateRenderable(e);
  }
  addRenderable(t, e) {
    const i = this._getGpuBitmapText(t);
    L0(t, i), t._didTextUpdate && (t._didTextUpdate = !1, this._updateContext(t, i)), this._renderer.renderPipes.graphics.addRenderable(i, e), i.context.customShader && this._updateDistanceField(t);
  }
  updateRenderable(t) {
    const e = this._getGpuBitmapText(t);
    L0(t, e), this._renderer.renderPipes.graphics.updateRenderable(e), e.context.customShader && this._updateDistanceField(t);
  }
  _updateContext(t, e) {
    const { context: i } = e, s = yB.getFont(t.text, t._style);
    i.clear(), s.distanceField.type !== "none" && (i.customShader || (i.customShader = new Wk(this._renderer.limits.maxBatchableTextures)));
    const o = Li.graphemeSegmenter(t.text), l = t._style;
    let c = s.baseLineOffset;
    const d = mT(o, l, s, !0), f = l.padding, m = d.scale;
    let y = d.width, b = d.height + d.offsetY;
    l._stroke && (y += l._stroke.width / m, b += l._stroke.width / m), i.translate(-t._anchor._x * y - f, -t._anchor._y * b - f).scale(m, m);
    const v = s.applyFillAsTint ? l._fill.color : 16777215;
    let x = s.fontMetrics.fontSize, S = s.lineHeight;
    l.lineHeight && (x = l.fontSize / m, S = l.lineHeight / m);
    let _ = (S - x) / 2;
    _ - s.baseLineOffset < 0 && (_ = 0);
    for (let C = 0; C < d.lines.length; C++) {
      const R = d.lines[C];
      for (let w = 0; w < R.charPositions.length; w++) {
        const E = R.chars[w], P = s.chars[E];
        if (P?.texture) {
          const k = P.texture;
          i.texture(
            k,
            v || "black",
            Math.round(R.charPositions[w] + P.xOffset),
            Math.round(c + P.yOffset + _),
            k.orig.width,
            k.orig.height
          );
        }
      }
      c += S;
    }
  }
  _getGpuBitmapText(t) {
    return t._gpuData[this._renderer.uid] || this.initGpuText(t);
  }
  initGpuText(t) {
    const e = new Vk();
    return t._gpuData[this._renderer.uid] = e, this._updateContext(t, e), e;
  }
  _updateDistanceField(t) {
    const e = this._getGpuBitmapText(t).context, i = t._style.fontFamily, s = Sn.get(`${i}-bitmap`), { a: o, b: l, c, d } = t.groupTransform, f = Math.sqrt(o * o + l * l), m = Math.sqrt(c * c + d * d), y = (Math.abs(f) + Math.abs(m)) / 2, b = s.baseRenderedFontSize / t._style.fontSize, v = y * s.distanceField.range * (1 / b);
    e.customShader.resources.localUniforms.uniforms.uDistance = v;
  }
  destroy() {
    this._renderer = null;
  }
}
nC.extension = {
  type: [
    W.WebGLPipes,
    W.WebGPUPipes,
    W.CanvasPipes
  ],
  name: "bitmapText"
};
function L0(n, t) {
  t.groupTransform = n.groupTransform, t.groupColorAlpha = n.groupColorAlpha, t.groupColor = n.groupColor, t.groupBlendMode = n.groupBlendMode, t.globalDisplayStatus = n.globalDisplayStatus, t.groupTransform = n.groupTransform, t.localDisplayStatus = n.localDisplayStatus, t.groupAlpha = n.groupAlpha, t._roundPixels = n._roundPixels;
}
class jk extends Ch {
  /**
   * Creates an instance of BatchableHTMLText.
   * @param renderer - The renderer instance to be used.
   */
  constructor(t) {
    super(), this.generatingTexture = !1, this.currentKey = "--", this._renderer = t, t.runners.resolutionChange.add(this);
  }
  /** Handles resolution changes for the HTML text. If the text has auto resolution enabled, it triggers a view update. */
  resolutionChange() {
    const t = this.renderable;
    t._autoResolution && t.onViewUpdate();
  }
  /** Destroys the BatchableHTMLText instance. Returns the texture promise to the renderer and cleans up references. */
  destroy() {
    const { htmlText: t } = this._renderer;
    t.getReferenceCount(this.currentKey) === null ? t.returnTexturePromise(this.texturePromise) : t.decreaseReferenceCount(this.currentKey), this._renderer.runners.resolutionChange.remove(this), this.texturePromise = null, this._renderer = null;
  }
}
function km(n, t) {
  const { texture: e, bounds: i } = n, s = t._style._getFinalPadding();
  n1(i, t._anchor, e);
  const o = t._anchor._x * s * 2, l = t._anchor._y * s * 2;
  i.minX -= s - o, i.minY -= s - l, i.maxX -= s - o, i.maxY -= s - l;
}
class iC {
  constructor(t) {
    this._renderer = t;
  }
  validateRenderable(t) {
    const e = this._getGpuText(t), i = t.styleKey;
    return e.currentKey !== i;
  }
  addRenderable(t, e) {
    const i = this._getGpuText(t);
    if (t._didTextUpdate) {
      const s = t._autoResolution ? this._renderer.resolution : t.resolution;
      (i.currentKey !== t.styleKey || t.resolution !== s) && this._updateGpuText(t).catch((o) => {
        console.error(o);
      }), t._didTextUpdate = !1, km(i, t);
    }
    this._renderer.renderPipes.batch.addToBatch(i, e);
  }
  updateRenderable(t) {
    const e = this._getGpuText(t);
    e._batcher.updateElement(e);
  }
  async _updateGpuText(t) {
    t._didTextUpdate = !1;
    const e = this._getGpuText(t);
    if (e.generatingTexture)
      return;
    const i = e.texturePromise;
    e.texturePromise = null, e.generatingTexture = !0, t._resolution = t._autoResolution ? this._renderer.resolution : t.resolution;
    let s = this._renderer.htmlText.getTexturePromise(t);
    i && (s = s.finally(() => {
      this._renderer.htmlText.decreaseReferenceCount(e.currentKey), this._renderer.htmlText.returnTexturePromise(i);
    })), e.texturePromise = s, e.currentKey = t.styleKey, e.texture = await s;
    const o = t.renderGroup || t.parentRenderGroup;
    o && (o.structureDidChange = !0), e.generatingTexture = !1, km(e, t);
  }
  _getGpuText(t) {
    return t._gpuData[this._renderer.uid] || this.initGpuText(t);
  }
  initGpuText(t) {
    const e = new jk(this._renderer);
    return e.renderable = t, e.transform = t.groupTransform, e.texture = Tt.EMPTY, e.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 }, e.roundPixels = this._renderer._roundPixels | t._roundPixels, t._resolution = t._autoResolution ? this._renderer.resolution : t.resolution, t._gpuData[this._renderer.uid] = e, e;
  }
  destroy() {
    this._renderer = null;
  }
}
iC.extension = {
  type: [
    W.WebGLPipes,
    W.WebGPUPipes,
    W.CanvasPipes
  ],
  name: "htmlText"
};
function Yk() {
  const { userAgent: n } = ve.get().getNavigator();
  return /^((?!chrome|android).)*safari/i.test(n);
}
const Xk = new Cn();
function rC(n, t, e, i) {
  const s = Xk;
  s.minX = 0, s.minY = 0, s.maxX = n.width / i | 0, s.maxY = n.height / i | 0;
  const o = mn.getOptimalTexture(
    s.width,
    s.height,
    i,
    !1
  );
  return o.source.uploadMethodId = "image", o.source.resource = n, o.source.alphaMode = "premultiply-alpha-on-upload", o.frame.width = t / i, o.frame.height = e / i, o.source.emit("update", o.source), o.updateUvs(), o;
}
function qk(n, t) {
  const e = t.fontFamily, i = [], s = {}, o = /font-family:([^;"\s]+)/g, l = n.match(o);
  function c(d) {
    s[d] || (i.push(d), s[d] = !0);
  }
  if (Array.isArray(e))
    for (let d = 0; d < e.length; d++)
      c(e[d]);
  else
    c(e);
  l && l.forEach((d) => {
    const f = d.split(":")[1].trim();
    c(f);
  });
  for (const d in t.tagStyles) {
    const f = t.tagStyles[d].fontFamily;
    c(f);
  }
  return i;
}
async function Kk(n) {
  const e = await (await ve.get().fetch(n)).blob(), i = new FileReader();
  return await new Promise((o, l) => {
    i.onloadend = () => o(i.result), i.onerror = l, i.readAsDataURL(e);
  });
}
async function Zk(n, t) {
  const e = await Kk(t);
  return `@font-face {
        font-family: "${n.fontFamily}";
        font-weight: ${n.fontWeight};
        font-style: ${n.fontStyle};
        src: url('${e}');
    }`;
}
const Yp = /* @__PURE__ */ new Map();
async function Qk(n) {
  const t = n.filter((e) => Sn.has(`${e}-and-url`)).map((e) => {
    if (!Yp.has(e)) {
      const { entries: i } = Sn.get(`${e}-and-url`), s = [];
      i.forEach((o) => {
        const l = o.url, d = o.faces.map((f) => ({ weight: f.weight, style: f.style }));
        s.push(
          ...d.map(
            (f) => Zk(
              {
                fontWeight: f.weight,
                fontStyle: f.style,
                fontFamily: e
              },
              l
            )
          )
        );
      }), Yp.set(
        e,
        Promise.all(s).then((o) => o.join(`
`))
      );
    }
    return Yp.get(e);
  });
  return (await Promise.all(t)).join(`
`);
}
function Jk(n, t, e, i, s) {
  const { domElement: o, styleElement: l, svgRoot: c } = s;
  o.innerHTML = `<style>${t.cssStyle}</style><div style='padding:0;'>${n}</div>`, o.setAttribute("style", `transform: scale(${e});transform-origin: top left; display: inline-block`), l.textContent = i;
  const { width: d, height: f } = s.image;
  return c.setAttribute("width", d.toString()), c.setAttribute("height", f.toString()), new XMLSerializer().serializeToString(c);
}
function tO(n, t) {
  const e = xr.getOptimalCanvasAndContext(
    n.width,
    n.height,
    t
  ), { context: i } = e;
  return i.clearRect(0, 0, n.width, n.height), i.drawImage(n, 0, 0), e;
}
function eO(n, t, e) {
  return new Promise(async (i) => {
    e && await new Promise((s) => setTimeout(s, 100)), n.onload = () => {
      i();
    }, n.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(t)}`, n.crossOrigin = "anonymous";
  });
}
class sC {
  constructor(t) {
    this._activeTextures = {}, this._renderer = t, this._createCanvas = t.type === Ti.WEBGPU;
  }
  /**
   * @param options
   * @deprecated Use getTexturePromise instead
   */
  getTexture(t) {
    return this.getTexturePromise(t);
  }
  /**
   * Increases the reference count for a texture.
   * @param text - The HTMLText instance associated with the texture.
   */
  getManagedTexture(t) {
    const e = t.styleKey;
    if (this._activeTextures[e])
      return this._increaseReferenceCount(e), this._activeTextures[e].promise;
    const i = this._buildTexturePromise(t).then((s) => (this._activeTextures[e].texture = s, s));
    return this._activeTextures[e] = {
      texture: null,
      promise: i,
      usageCount: 1
    }, i;
  }
  /**
   * Gets the current reference count for a texture associated with a text key.
   * @param textKey - The unique key identifying the text style configuration
   * @returns The number of Text instances currently using this texture
   */
  getReferenceCount(t) {
    return this._activeTextures[t]?.usageCount ?? null;
  }
  _increaseReferenceCount(t) {
    this._activeTextures[t].usageCount++;
  }
  /**
   * Decreases the reference count for a texture.
   * If the count reaches zero, the texture is cleaned up.
   * @param textKey - The key associated with the HTMLText instance.
   */
  decreaseReferenceCount(t) {
    const e = this._activeTextures[t];
    e && (e.usageCount--, e.usageCount === 0 && (e.texture ? this._cleanUp(e.texture) : e.promise.then((i) => {
      e.texture = i, this._cleanUp(e.texture);
    }).catch(() => {
      $t("HTMLTextSystem: Failed to clean texture");
    }), this._activeTextures[t] = null));
  }
  /**
   * Returns a promise that resolves to a texture for the given HTMLText options.
   * @param options - The options for the HTMLText.
   * @returns A promise that resolves to a Texture.
   */
  getTexturePromise(t) {
    return this._buildTexturePromise(t);
  }
  async _buildTexturePromise(t) {
    const { text: e, style: i, resolution: s, textureStyle: o } = t, l = Qe.get(ST), c = qk(e, i), d = await Qk(c), f = DB(e, i, d, l), m = Math.ceil(Math.ceil(Math.max(1, f.width) + i.padding * 2) * s), y = Math.ceil(Math.ceil(Math.max(1, f.height) + i.padding * 2) * s), b = l.image, v = 2;
    b.width = (m | 0) + v, b.height = (y | 0) + v;
    const x = Jk(e, i, s, d, l);
    await eO(b, x, Yk() && c.length > 0);
    const S = b;
    let _;
    this._createCanvas && (_ = tO(b, s));
    const C = rC(
      _ ? _.canvas : S,
      b.width - v,
      b.height - v,
      s
    );
    return o && (C.source.style = o), this._createCanvas && (this._renderer.texture.initSource(C.source), xr.returnCanvasAndContext(_)), Qe.return(l), C;
  }
  returnTexturePromise(t) {
    t.then((e) => {
      this._cleanUp(e);
    }).catch(() => {
      $t("HTMLTextSystem: Failed to clean texture");
    });
  }
  _cleanUp(t) {
    mn.returnTexture(t, !0), t.source.resource = null, t.source.uploadMethodId = "unknown";
  }
  destroy() {
    this._renderer = null;
    for (const t in this._activeTextures)
      this._activeTextures[t] && this.returnTexturePromise(this._activeTextures[t].promise);
    this._activeTextures = null;
  }
}
sC.extension = {
  type: [
    W.WebGLSystem,
    W.WebGPUSystem,
    W.CanvasSystem
  ],
  name: "htmlText"
};
class nO extends Ch {
  constructor(t) {
    super(), this._renderer = t, t.runners.resolutionChange.add(this);
  }
  resolutionChange() {
    const t = this.renderable;
    t._autoResolution && t.onViewUpdate();
  }
  destroy() {
    const { canvasText: t } = this._renderer;
    t.getReferenceCount(this.currentKey) > 0 ? t.decreaseReferenceCount(this.currentKey) : this.texture && t.returnTexture(this.texture), this._renderer.runners.resolutionChange.remove(this), this._renderer = null;
  }
}
class aC {
  constructor(t) {
    this._renderer = t;
  }
  validateRenderable(t) {
    const e = this._getGpuText(t), i = t.styleKey;
    return e.currentKey !== i ? !0 : t._didTextUpdate;
  }
  addRenderable(t, e) {
    const i = this._getGpuText(t);
    if (t._didTextUpdate) {
      const s = t._autoResolution ? this._renderer.resolution : t.resolution;
      (i.currentKey !== t.styleKey || t.resolution !== s) && this._updateGpuText(t), t._didTextUpdate = !1;
    }
    this._renderer.renderPipes.batch.addToBatch(i, e);
  }
  updateRenderable(t) {
    const e = this._getGpuText(t);
    e._batcher.updateElement(e);
  }
  _updateGpuText(t) {
    const e = this._getGpuText(t);
    e.texture && this._renderer.canvasText.decreaseReferenceCount(e.currentKey), t._resolution = t._autoResolution ? this._renderer.resolution : t.resolution, e.texture = this._renderer.canvasText.getManagedTexture(t), e.currentKey = t.styleKey, km(e, t);
  }
  _getGpuText(t) {
    return t._gpuData[this._renderer.uid] || this.initGpuText(t);
  }
  initGpuText(t) {
    const e = new nO(this._renderer);
    return e.currentKey = "--", e.renderable = t, e.transform = t.groupTransform, e.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 }, e.roundPixels = this._renderer._roundPixels | t._roundPixels, t._gpuData[this._renderer.uid] = e, e;
  }
  destroy() {
    this._renderer = null;
  }
}
aC.extension = {
  type: [
    W.WebGLPipes,
    W.WebGPUPipes,
    W.CanvasPipes
  ],
  name: "text"
};
class oC {
  constructor(t) {
    this._activeTextures = {}, this._renderer = t;
  }
  getTexture(t, e, i, s) {
    typeof t == "string" && (zt("8.0.0", "CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments"), t = {
      text: t,
      style: i,
      resolution: e
    }), t.style instanceof qa || (t.style = new qa(t.style)), t.textureStyle instanceof Qr || (t.textureStyle = new Qr(t.textureStyle)), typeof t.text != "string" && (t.text = t.text.toString());
    const { text: o, style: l, textureStyle: c } = t, d = t.resolution ?? this._renderer.resolution, { frame: f, canvasAndContext: m } = zp.getCanvasAndContext({
      text: o,
      style: l,
      resolution: d
    }), y = rC(m.canvas, f.width, f.height, d);
    if (c && (y.source.style = c), l.trim && (f.pad(l.padding), y.frame.copyFrom(f), y.frame.scale(1 / d), y.updateUvs()), l.filters) {
      const b = this._applyFilters(y, l.filters);
      return this.returnTexture(y), zp.returnCanvasAndContext(m), b;
    }
    return this._renderer.texture.initSource(y._source), zp.returnCanvasAndContext(m), y;
  }
  /**
   * Returns a texture that was created wit the above `getTexture` function.
   * Handy if you are done with a texture and want to return it to the pool.
   * @param texture - The texture to be returned.
   */
  returnTexture(t) {
    const e = t.source;
    e.resource = null, e.uploadMethodId = "unknown", e.alphaMode = "no-premultiply-alpha", mn.returnTexture(t, !0);
  }
  /**
   * Renders text to its canvas, and updates its texture.
   * @deprecated since 8.10.0
   */
  renderTextToCanvas() {
    zt(
      "8.10.0",
      "CanvasTextSystem.renderTextToCanvas: no longer supported, use CanvasTextSystem.getTexture instead"
    );
  }
  /**
   * Gets or creates a managed texture for a Text object. This method handles texture reuse and reference counting.
   * @param text - The Text object that needs a texture
   * @returns A Texture instance that represents the rendered text
   * @remarks
   * This method performs the following:
   * 1. Sets the appropriate resolution based on auto-resolution settings
   * 2. Checks if a texture already exists for the text's style
   * 3. Creates a new texture if needed or returns an existing one
   * 4. Manages reference counting for texture reuse
   */
  getManagedTexture(t) {
    t._resolution = t._autoResolution ? this._renderer.resolution : t.resolution;
    const e = t.styleKey;
    if (this._activeTextures[e])
      return this._increaseReferenceCount(e), this._activeTextures[e].texture;
    const i = this.getTexture({
      text: t.text,
      style: t.style,
      resolution: t._resolution,
      textureStyle: t.textureStyle
    });
    return this._activeTextures[e] = {
      texture: i,
      usageCount: 1
    }, i;
  }
  /**
   * Decreases the reference count for a texture associated with a text key.
   * When the reference count reaches zero, the texture is returned to the pool.
   * @param textKey - The unique key identifying the text style configuration
   * @remarks
   * This method is crucial for memory management, ensuring textures are properly
   * cleaned up when they are no longer needed by any Text instances.
   */
  decreaseReferenceCount(t) {
    const e = this._activeTextures[t];
    e.usageCount--, e.usageCount === 0 && (this.returnTexture(e.texture), this._activeTextures[t] = null);
  }
  /**
   * Gets the current reference count for a texture associated with a text key.
   * @param textKey - The unique key identifying the text style configuration
   * @returns The number of Text instances currently using this texture
   */
  getReferenceCount(t) {
    return this._activeTextures[t]?.usageCount ?? 0;
  }
  _increaseReferenceCount(t) {
    this._activeTextures[t].usageCount++;
  }
  /**
   * Applies the specified filters to the given texture.
   *
   * This method takes a texture and a list of filters, applies the filters to the texture,
   * and returns the resulting texture. It also ensures that the alpha mode of the resulting
   * texture is set to 'premultiplied-alpha'.
   * @param {Texture} texture - The texture to which the filters will be applied.
   * @param {Filter[]} filters - The filters to apply to the texture.
   * @returns {Texture} The resulting texture after all filters have been applied.
   */
  _applyFilters(t, e) {
    const i = this._renderer.renderTarget.renderTarget, s = this._renderer.filter.generateFilteredTexture({
      texture: t,
      filters: e
    });
    return this._renderer.renderTarget.bind(i, !1), s;
  }
  destroy() {
    this._renderer = null;
    for (const t in this._activeTextures)
      this._activeTextures[t] && this.returnTexture(this._activeTextures[t].texture);
    this._activeTextures = null;
  }
}
oC.extension = {
  type: [
    W.WebGLSystem,
    W.WebGPUSystem,
    W.CanvasSystem
  ],
  name: "canvasText"
};
Nt.add(MM, AM);
var iO = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function rO(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
var lC = { exports: {} };
(function(n, t) {
  (function() {
    var e, i;
    i = function(s) {
      return n.exports = s;
    }, e = {
      linear: function(s, o, l, c) {
        return l * s / c + o;
      },
      easeInQuad: function(s, o, l, c) {
        return l * (s /= c) * s + o;
      },
      easeOutQuad: function(s, o, l, c) {
        return -l * (s /= c) * (s - 2) + o;
      },
      easeInOutQuad: function(s, o, l, c) {
        return (s /= c / 2) < 1 ? l / 2 * s * s + o : -l / 2 * (--s * (s - 2) - 1) + o;
      },
      easeInCubic: function(s, o, l, c) {
        return l * (s /= c) * s * s + o;
      },
      easeOutCubic: function(s, o, l, c) {
        return l * ((s = s / c - 1) * s * s + 1) + o;
      },
      easeInOutCubic: function(s, o, l, c) {
        return (s /= c / 2) < 1 ? l / 2 * s * s * s + o : l / 2 * ((s -= 2) * s * s + 2) + o;
      },
      easeInQuart: function(s, o, l, c) {
        return l * (s /= c) * s * s * s + o;
      },
      easeOutQuart: function(s, o, l, c) {
        return -l * ((s = s / c - 1) * s * s * s - 1) + o;
      },
      easeInOutQuart: function(s, o, l, c) {
        return (s /= c / 2) < 1 ? l / 2 * s * s * s * s + o : -l / 2 * ((s -= 2) * s * s * s - 2) + o;
      },
      easeInQuint: function(s, o, l, c) {
        return l * (s /= c) * s * s * s * s + o;
      },
      easeOutQuint: function(s, o, l, c) {
        return l * ((s = s / c - 1) * s * s * s * s + 1) + o;
      },
      easeInOutQuint: function(s, o, l, c) {
        return (s /= c / 2) < 1 ? l / 2 * s * s * s * s * s + o : l / 2 * ((s -= 2) * s * s * s * s + 2) + o;
      },
      easeInSine: function(s, o, l, c) {
        return -l * Math.cos(s / c * (Math.PI / 2)) + l + o;
      },
      easeOutSine: function(s, o, l, c) {
        return l * Math.sin(s / c * (Math.PI / 2)) + o;
      },
      easeInOutSine: function(s, o, l, c) {
        return -l / 2 * (Math.cos(Math.PI * s / c) - 1) + o;
      },
      easeInExpo: function(s, o, l, c) {
        return s === 0 ? o : l * Math.pow(2, 10 * (s / c - 1)) + o;
      },
      easeOutExpo: function(s, o, l, c) {
        return s === c ? o + l : l * (-Math.pow(2, -10 * s / c) + 1) + o;
      },
      easeInOutExpo: function(s, o, l, c) {
        return (s /= c / 2) < 1 ? l / 2 * Math.pow(2, 10 * (s - 1)) + o : l / 2 * (-Math.pow(2, -10 * --s) + 2) + o;
      },
      easeInCirc: function(s, o, l, c) {
        return -l * (Math.sqrt(1 - (s /= c) * s) - 1) + o;
      },
      easeOutCirc: function(s, o, l, c) {
        return l * Math.sqrt(1 - (s = s / c - 1) * s) + o;
      },
      easeInOutCirc: function(s, o, l, c) {
        return (s /= c / 2) < 1 ? -l / 2 * (Math.sqrt(1 - s * s) - 1) + o : l / 2 * (Math.sqrt(1 - (s -= 2) * s) + 1) + o;
      },
      easeInElastic: function(s, o, l, c) {
        var d, f, m;
        return m = 1.70158, f = 0, d = l, s === 0 || (s /= c), f || (f = c * 0.3), d < Math.abs(l) ? (d = l, m = f / 4) : m = f / (2 * Math.PI) * Math.asin(l / d), -(d * Math.pow(2, 10 * (s -= 1)) * Math.sin((s * c - m) * (2 * Math.PI) / f)) + o;
      },
      easeOutElastic: function(s, o, l, c) {
        var d, f, m;
        return m = 1.70158, f = 0, d = l, s === 0 || (s /= c), f || (f = c * 0.3), d < Math.abs(l) ? (d = l, m = f / 4) : m = f / (2 * Math.PI) * Math.asin(l / d), d * Math.pow(2, -10 * s) * Math.sin((s * c - m) * (2 * Math.PI) / f) + l + o;
      },
      easeInOutElastic: function(s, o, l, c) {
        var d, f, m;
        return m = 1.70158, f = 0, d = l, s === 0 || (s /= c / 2), f || (f = c * (0.3 * 1.5)), d < Math.abs(l) ? (d = l, m = f / 4) : m = f / (2 * Math.PI) * Math.asin(l / d), s < 1 ? -0.5 * (d * Math.pow(2, 10 * (s -= 1)) * Math.sin((s * c - m) * (2 * Math.PI) / f)) + o : d * Math.pow(2, -10 * (s -= 1)) * Math.sin((s * c - m) * (2 * Math.PI) / f) * 0.5 + l + o;
      },
      easeInBack: function(s, o, l, c, d) {
        return d === void 0 && (d = 1.70158), l * (s /= c) * s * ((d + 1) * s - d) + o;
      },
      easeOutBack: function(s, o, l, c, d) {
        return d === void 0 && (d = 1.70158), l * ((s = s / c - 1) * s * ((d + 1) * s + d) + 1) + o;
      },
      easeInOutBack: function(s, o, l, c, d) {
        return d === void 0 && (d = 1.70158), (s /= c / 2) < 1 ? l / 2 * (s * s * (((d *= 1.525) + 1) * s - d)) + o : l / 2 * ((s -= 2) * s * (((d *= 1.525) + 1) * s + d) + 2) + o;
      },
      easeInBounce: function(s, o, l, c) {
        var d;
        return d = e.easeOutBounce(c - s, 0, l, c), l - d + o;
      },
      easeOutBounce: function(s, o, l, c) {
        return (s /= c) < 1 / 2.75 ? l * (7.5625 * s * s) + o : s < 2 / 2.75 ? l * (7.5625 * (s -= 1.5 / 2.75) * s + 0.75) + o : s < 2.5 / 2.75 ? l * (7.5625 * (s -= 2.25 / 2.75) * s + 0.9375) + o : l * (7.5625 * (s -= 2.625 / 2.75) * s + 0.984375) + o;
      },
      easeInOutBounce: function(s, o, l, c) {
        var d;
        return s < c / 2 ? (d = e.easeInBounce(s * 2, 0, l, c), d * 0.5 + o) : (d = e.easeOutBounce(s * 2 - c, 0, l, c), d * 0.5 + l * 0.5 + o);
      }
    }, i(e);
  }).call(iO);
})(lC);
var sO = lC.exports;
const F0 = /* @__PURE__ */ rO(sO);
function Eh(n, t) {
  if (n) {
    if (typeof n == "function")
      return n;
    if (typeof n == "string")
      return F0[n];
  } else
    return F0[t];
}
class aO {
  constructor(t) {
    this.viewport = t, this.touches = [], this.addListeners();
  }
  /** Add input listeners */
  addListeners() {
    this.viewport.eventMode = "static", this.viewport.forceHitArea || (this.viewport.hitArea = new ne(0, 0, this.viewport.worldWidth, this.viewport.worldHeight)), this.viewport.on("pointerdown", this.down, this), this.viewport.options.allowPreserveDragOutside ? this.viewport.on("globalpointermove", this.move, this) : this.viewport.on("pointermove", this.move, this), this.viewport.on("pointerup", this.up, this), this.viewport.on("pointerupoutside", this.up, this), this.viewport.on("pointercancel", this.up, this), this.viewport.options.allowPreserveDragOutside || this.viewport.on("pointerleave", this.up, this), this.wheelFunction = (t) => this.handleWheel(t), this.viewport.options.events.domElement.addEventListener(
      "wheel",
      this.wheelFunction,
      { passive: this.viewport.options.passiveWheel }
    ), this.isMouseDown = !1;
  }
  /**
   * Removes all event listeners from viewport
   * (useful for cleanup of wheel when removing viewport)
   */
  destroy() {
    var t;
    (t = this.viewport.options.events.domElement) == null || t.removeEventListener("wheel", this.wheelFunction);
  }
  /**
   * handle down events for viewport
   *
   * @param {PIXI.FederatedPointerEvent} event
   */
  down(t) {
    if (!(this.viewport.pause || !this.viewport.visible)) {
      if (t.pointerType === "mouse" ? this.isMouseDown = !0 : this.get(t.pointerId) || this.touches.push({ id: t.pointerId, last: null }), this.count() === 1) {
        this.last = t.global.clone();
        const e = this.viewport.plugins.get("decelerate", !0), i = this.viewport.plugins.get("bounce", !0);
        (!e || !e.isActive()) && (!i || !i.isActive()) ? this.clickedAvailable = !0 : this.clickedAvailable = !1;
      } else
        this.clickedAvailable = !1;
      this.viewport.plugins.down(t) && this.viewport.options.stopPropagation && t.stopPropagation();
    }
  }
  /** Clears all pointer events */
  clear() {
    this.isMouseDown = !1, this.touches = [], this.last = null;
  }
  /**
   * @param {number} change
   * @returns whether change exceeds threshold
   */
  checkThreshold(t) {
    return Math.abs(t) >= this.viewport.threshold;
  }
  /** Handle move events for viewport */
  move(t) {
    if (this.viewport.pause || !this.viewport.visible)
      return;
    const e = this.viewport.plugins.move(t);
    if (this.clickedAvailable && this.last) {
      const i = t.global.x - this.last.x, s = t.global.y - this.last.y;
      (this.checkThreshold(i) || this.checkThreshold(s)) && (this.clickedAvailable = !1);
    }
    e && this.viewport.options.stopPropagation && t.stopPropagation();
  }
  /** Handle up events for viewport */
  up(t) {
    if (this.viewport.pause || !this.viewport.visible)
      return;
    t.pointerType === "mouse" && (this.isMouseDown = !1), t.pointerType !== "mouse" && this.remove(t.pointerId);
    const e = this.viewport.plugins.up(t);
    this.clickedAvailable && this.count() === 0 && this.last && (this.viewport.emit("clicked", {
      event: t,
      screen: this.last,
      world: this.viewport.toWorld(this.last),
      viewport: this.viewport
    }), this.clickedAvailable = !1), e && this.viewport.options.stopPropagation && t.stopPropagation();
  }
  /** Gets pointer position if this.interaction is set */
  getPointerPosition(t) {
    const e = new Ut();
    return this.viewport.options.events.mapPositionToPoint(e, t.clientX, t.clientY), e;
  }
  /** Handle wheel events */
  handleWheel(t) {
    if (this.viewport.pause || !this.viewport.visible)
      return;
    const e = this.viewport.toLocal(this.getPointerPosition(t));
    this.viewport.left <= e.x && e.x <= this.viewport.right && this.viewport.top <= e.y && e.y <= this.viewport.bottom && this.viewport.plugins.wheel(t) && !this.viewport.options.passiveWheel && t.preventDefault();
  }
  pause() {
    this.touches = [], this.isMouseDown = !1;
  }
  /** Get touch by id */
  get(t) {
    for (const e of this.touches)
      if (e.id === t)
        return e;
    return null;
  }
  /** Remove touch by number */
  remove(t) {
    for (let e = 0; e < this.touches.length; e++)
      if (this.touches[e].id === t) {
        this.touches.splice(e, 1);
        return;
      }
  }
  /**
   * @returns {number} count of mouse/touch pointers that are down on the viewport
   */
  count() {
    return (this.isMouseDown ? 1 : 0) + this.touches.length;
  }
}
const cl = [
  "drag",
  "pinch",
  "wheel",
  "follow",
  "mouse-edges",
  "decelerate",
  "animate",
  "bounce",
  "snap-zoom",
  "clamp-zoom",
  "snap",
  "clamp"
];
class oO {
  /** This is called by {@link Viewport} to initialize the {@link Viewport.plugins plugins}. */
  constructor(t) {
    this.viewport = t, this.list = [], this.plugins = {};
  }
  /**
   * Inserts a named plugin or a user plugin into the viewport
   * default plugin order: 'drag', 'pinch', 'wheel', 'follow', 'mouse-edges', 'decelerate', 'bounce',
   * 'snap-zoom', 'clamp-zoom', 'snap', 'clamp'
   *
   * @param {string} name of plugin
   * @param {Plugin} plugin - instantiated Plugin class
   * @param {number} index to insert userPlugin (otherwise inserts it at the end)
   */
  add(t, e, i = cl.length) {
    const s = this.plugins[t];
    s && s.destroy(), this.plugins[t] = e;
    const o = cl.indexOf(t);
    o !== -1 && cl.splice(o, 1), cl.splice(i, 0, t), this.sort();
  }
  /**
   * Get plugin
   *
   * @param {string} name of plugin
   * @param {boolean} [ignorePaused] return null if plugin is paused
   */
  get(t, e) {
    var i;
    return e && (i = this.plugins[t]) != null && i.paused ? null : this.plugins[t];
  }
  /**
   * Update all active plugins
   *
   * @internal
   * @ignore
   * @param {number} elapsed type in milliseconds since last update
   */
  update(t) {
    for (const e of this.list)
      e.update(t);
  }
  /**
   * Resize all active plugins
   *
   * @internal
   * @ignore
   */
  resize() {
    for (const t of this.list)
      t.resize();
  }
  /** Clamps and resets bounce and decelerate (as needed) after manually moving viewport */
  reset() {
    for (const t of this.list)
      t.reset();
  }
  /** removes all installed plugins */
  removeAll() {
    this.list.forEach((t) => {
      t.destroy();
    }), this.plugins = {}, this.sort();
  }
  /**
   * Removes installed plugin
   *
   * @param {string} name of plugin (e.g., 'drag', 'pinch')
   */
  remove(t) {
    var e;
    this.plugins[t] && ((e = this.plugins[t]) == null || e.destroy(), delete this.plugins[t], this.viewport.emit("plugin-remove", t), this.sort());
  }
  /**
   * Pause plugin
   *
   * @param {string} name of plugin (e.g., 'drag', 'pinch')
   */
  pause(t) {
    var e;
    (e = this.plugins[t]) == null || e.pause();
  }
  /**
   * Resume plugin
   *
   * @param {string} name of plugin (e.g., 'drag', 'pinch')
   */
  resume(t) {
    var e;
    (e = this.plugins[t]) == null || e.resume();
  }
  /**
   * Sort plugins according to PLUGIN_ORDER
   *
   * @internal
   * @ignore
   */
  sort() {
    this.list = [];
    for (const t of cl)
      this.plugins[t] && this.list.push(this.plugins[t]);
  }
  /**
   * Handle down for all plugins
   *
   * @internal
   * @ignore
   */
  down(t) {
    let e = !1;
    for (const i of this.list)
      i.down(t) && (e = !0);
    return e;
  }
  /**
   * Handle move for all plugins
   *
   * @internal
   * @ignore
   */
  move(t) {
    let e = !1;
    for (const i of this.viewport.plugins.list)
      i.move(t) && (e = !0);
    return e;
  }
  /**
   * Handle up for all plugins
   *
   * @internal
   * @ignore
   */
  up(t) {
    let e = !1;
    for (const i of this.list)
      i.up(t) && (e = !0);
    return e;
  }
  /**
   * Handle wheel event for all plugins
   *
   * @internal
   * @ignore
   */
  wheel(t) {
    let e = !1;
    for (const i of this.list)
      i.wheel(t) && (e = !0);
    return e;
  }
}
class pi {
  /** @param {Viewport} parent */
  constructor(t) {
    this.parent = t, this.paused = !1;
  }
  /** Called when plugin is removed */
  destroy() {
  }
  /** Handler for pointerdown PIXI event */
  down(t) {
    return !1;
  }
  /** Handler for pointermove PIXI event */
  move(t) {
    return !1;
  }
  /** Handler for pointerup PIXI event */
  up(t) {
    return !1;
  }
  /** Handler for wheel event on div */
  wheel(t) {
    return !1;
  }
  /**
   * Called on each tick
   * @param {number} elapsed time in millisecond since last update
   */
  update(t) {
  }
  /** Called when the viewport is resized */
  resize() {
  }
  /** Called when the viewport is manually moved */
  reset() {
  }
  /** Pause the plugin */
  pause() {
    this.paused = !0;
  }
  /** Un-pause the plugin */
  resume() {
    this.paused = !1;
  }
}
const lO = {
  removeOnInterrupt: !1,
  ease: "linear",
  time: 1e3
};
class uO extends pi {
  /**
   * This is called by {@link Viewport.animate}.
   *
   * @param parent
   * @param options
   */
  constructor(t, e = {}) {
    super(t), this.startWidth = null, this.startHeight = null, this.deltaWidth = null, this.deltaHeight = null, this.width = null, this.height = null, this.time = 0, this.options = Object.assign({}, lO, e), this.options.ease = Eh(this.options.ease), this.setupPosition(), this.setupZoom(), this.time = 0;
  }
  /**
   * Setup `startX`, `startY`, `deltaX`, `deltaY`, `keepCenter`.
   *
   * This is called during construction.
   */
  setupPosition() {
    typeof this.options.position < "u" ? (this.startX = this.parent.center.x, this.startY = this.parent.center.y, this.deltaX = this.options.position.x - this.parent.center.x, this.deltaY = this.options.position.y - this.parent.center.y, this.keepCenter = !1) : this.keepCenter = !0;
  }
  /**
   * Setup `startWidth, `startHeight`, `deltaWidth, `deltaHeight, `width`, `height`.
   *
   * This is called during construction.
   */
  setupZoom() {
    this.width = null, this.height = null, typeof this.options.scale < "u" ? this.width = this.parent.screenWidth / this.options.scale : typeof this.options.scaleX < "u" || typeof this.options.scaleY < "u" ? (typeof this.options.scaleX < "u" && (this.width = this.parent.screenWidth / this.options.scaleX), typeof this.options.scaleY < "u" && (this.height = this.parent.screenHeight / this.options.scaleY)) : (typeof this.options.width < "u" && (this.width = this.options.width), typeof this.options.height < "u" && (this.height = this.options.height)), this.width !== null && (this.startWidth = this.parent.screenWidthInWorldPixels, this.deltaWidth = this.width - this.startWidth), this.height !== null && (this.startHeight = this.parent.screenHeightInWorldPixels, this.deltaHeight = this.height - this.startHeight);
  }
  down() {
    return this.options.removeOnInterrupt && this.parent.plugins.remove("animate"), !1;
  }
  complete() {
    this.parent.plugins.remove("animate"), this.width !== null && this.parent.fitWidth(this.width, this.keepCenter, this.height === null), this.height !== null && this.parent.fitHeight(this.height, this.keepCenter, this.width === null), !this.keepCenter && this.options.position && this.parent.moveCenter(this.options.position), this.parent.emit("animate-end", this.parent), this.options.callbackOnComplete && this.options.callbackOnComplete(this.parent);
  }
  update(t) {
    if (this.paused)
      return;
    this.time += t;
    const e = new Ut(this.parent.scale.x, this.parent.scale.y);
    if (this.time >= this.options.time) {
      const i = this.parent.width, s = this.parent.height;
      this.complete(), (i !== this.parent.width || s !== this.parent.height) && this.parent.emit("zoomed", { viewport: this.parent, original: e, type: "animate" });
    } else {
      const i = this.options.ease(this.time, 0, 1, this.options.time);
      if (this.width !== null) {
        const s = this.startWidth, o = this.deltaWidth;
        this.parent.fitWidth(
          s + o * i,
          this.keepCenter,
          this.height === null
        );
      }
      if (this.height !== null) {
        const s = this.startHeight, o = this.deltaHeight;
        this.parent.fitHeight(
          s + o * i,
          this.keepCenter,
          this.width === null
        );
      }
      if (this.width === null ? this.parent.scale.x = this.parent.scale.y : this.height === null && (this.parent.scale.y = this.parent.scale.x), !this.keepCenter) {
        const s = this.startX, o = this.startY, l = this.deltaX, c = this.deltaY, d = new Ut(this.parent.x, this.parent.y);
        this.parent.moveCenter(s + l * i, o + c * i), this.parent.emit("moved", { viewport: this.parent, original: d, type: "animate" });
      }
      (this.width || this.height) && this.parent.emit("zoomed", { viewport: this.parent, original: e, type: "animate" });
    }
  }
}
const cO = {
  sides: "all",
  friction: 0.5,
  time: 150,
  ease: "easeInOutSine",
  underflow: "center",
  bounceBox: null
};
class hO extends pi {
  /**
   * This is called by {@link Viewport.bounce}.
   */
  constructor(t, e = {}) {
    super(t), this.options = Object.assign({}, cO, e), this.ease = Eh(this.options.ease, "easeInOutSine"), this.options.sides ? this.options.sides === "all" ? this.top = this.bottom = this.left = this.right = !0 : this.options.sides === "horizontal" ? (this.right = this.left = !0, this.top = this.bottom = !1) : this.options.sides === "vertical" ? (this.left = this.right = !1, this.top = this.bottom = !0) : (this.top = this.options.sides.indexOf("top") !== -1, this.bottom = this.options.sides.indexOf("bottom") !== -1, this.left = this.options.sides.indexOf("left") !== -1, this.right = this.options.sides.indexOf("right") !== -1) : this.left = this.top = this.right = this.bottom = !1;
    const i = this.options.underflow.toLowerCase();
    i === "center" ? (this.underflowX = 0, this.underflowY = 0) : (this.underflowX = i.indexOf("left") !== -1 ? -1 : i.indexOf("right") !== -1 ? 1 : 0, this.underflowY = i.indexOf("top") !== -1 ? -1 : i.indexOf("bottom") !== -1 ? 1 : 0), this.reset();
  }
  isActive() {
    return this.toX !== null || this.toY !== null;
  }
  down() {
    return this.toX = this.toY = null, !1;
  }
  up() {
    return this.bounce(), !1;
  }
  update(t) {
    if (!this.paused) {
      if (this.bounce(), this.toX) {
        const e = this.toX;
        e.time += t, this.parent.emit("moved", { viewport: this.parent, type: "bounce-x" }), e.time >= this.options.time ? (this.parent.x = e.end, this.toX = null, this.parent.emit("bounce-x-end", this.parent)) : this.parent.x = this.ease(e.time, e.start, e.delta, this.options.time);
      }
      if (this.toY) {
        const e = this.toY;
        e.time += t, this.parent.emit("moved", { viewport: this.parent, type: "bounce-y" }), e.time >= this.options.time ? (this.parent.y = e.end, this.toY = null, this.parent.emit("bounce-y-end", this.parent)) : this.parent.y = this.ease(e.time, e.start, e.delta, this.options.time);
      }
    }
  }
  /** @internal */
  calcUnderflowX() {
    let t;
    switch (this.underflowX) {
      case -1:
        t = 0;
        break;
      case 1:
        t = this.parent.screenWidth - this.parent.screenWorldWidth;
        break;
      default:
        t = (this.parent.screenWidth - this.parent.screenWorldWidth) / 2;
    }
    return t;
  }
  /** @internal */
  calcUnderflowY() {
    let t;
    switch (this.underflowY) {
      case -1:
        t = 0;
        break;
      case 1:
        t = this.parent.screenHeight - this.parent.screenWorldHeight;
        break;
      default:
        t = (this.parent.screenHeight - this.parent.screenWorldHeight) / 2;
    }
    return t;
  }
  oob() {
    const t = this.options.bounceBox;
    if (t) {
      const e = typeof t.x > "u" ? 0 : t.x, i = typeof t.y > "u" ? 0 : t.y, s = typeof t.width > "u" ? this.parent.worldWidth : t.width, o = typeof t.height > "u" ? this.parent.worldHeight : t.height;
      return {
        left: this.parent.left < e,
        right: this.parent.right > s,
        top: this.parent.top < i,
        bottom: this.parent.bottom > o,
        topLeft: new Ut(
          e * this.parent.scale.x,
          i * this.parent.scale.y
        ),
        bottomRight: new Ut(
          s * this.parent.scale.x - this.parent.screenWidth,
          o * this.parent.scale.y - this.parent.screenHeight
        )
      };
    }
    return {
      left: this.parent.left < 0,
      right: this.parent.right > this.parent.worldWidth,
      top: this.parent.top < 0,
      bottom: this.parent.bottom > this.parent.worldHeight,
      topLeft: new Ut(0, 0),
      bottomRight: new Ut(
        this.parent.worldWidth * this.parent.scale.x - this.parent.screenWidth,
        this.parent.worldHeight * this.parent.scale.y - this.parent.screenHeight
      )
    };
  }
  bounce() {
    var t, e;
    if (this.paused)
      return;
    let i, s = this.parent.plugins.get("decelerate", !0);
    s && (s.x || s.y) && (s.x && s.percentChangeX === ((t = s.options) == null ? void 0 : t.friction) || s.y && s.percentChangeY === ((e = s.options) == null ? void 0 : e.friction)) && (i = this.oob(), (i.left && this.left || i.right && this.right) && (s.percentChangeX = this.options.friction), (i.top && this.top || i.bottom && this.bottom) && (s.percentChangeY = this.options.friction));
    const o = this.parent.plugins.get("drag", !0) || {}, l = this.parent.plugins.get("pinch", !0) || {};
    if (s = s || {}, !(o != null && o.active) && !(l != null && l.active) && (!this.toX || !this.toY) && (!s.x || !s.y)) {
      i = i || this.oob();
      const c = i.topLeft, d = i.bottomRight;
      if (!this.toX && !s.x) {
        let f = null;
        i.left && this.left ? f = this.parent.screenWorldWidth < this.parent.screenWidth ? this.calcUnderflowX() : -c.x : i.right && this.right && (f = this.parent.screenWorldWidth < this.parent.screenWidth ? this.calcUnderflowX() : -d.x), f !== null && this.parent.x !== f && (this.toX = { time: 0, start: this.parent.x, delta: f - this.parent.x, end: f }, this.parent.emit("bounce-x-start", this.parent));
      }
      if (!this.toY && !s.y) {
        let f = null;
        i.top && this.top ? f = this.parent.screenWorldHeight < this.parent.screenHeight ? this.calcUnderflowY() : -c.y : i.bottom && this.bottom && (f = this.parent.screenWorldHeight < this.parent.screenHeight ? this.calcUnderflowY() : -d.y), f !== null && this.parent.y !== f && (this.toY = { time: 0, start: this.parent.y, delta: f - this.parent.y, end: f }, this.parent.emit("bounce-y-start", this.parent));
      }
    }
  }
  reset() {
    this.toX = this.toY = null, this.bounce();
  }
}
const dO = {
  left: !1,
  right: !1,
  top: !1,
  bottom: !1,
  direction: null,
  underflow: "center"
};
class fO extends pi {
  /**
  * This is called by {@link Viewport.clamp}.
  */
  constructor(t, e = {}) {
    super(t), this.options = Object.assign({}, dO, e), this.options.direction && (this.options.left = this.options.direction === "x" || this.options.direction === "all" ? !0 : null, this.options.right = this.options.direction === "x" || this.options.direction === "all" ? !0 : null, this.options.top = this.options.direction === "y" || this.options.direction === "all" ? !0 : null, this.options.bottom = this.options.direction === "y" || this.options.direction === "all" ? !0 : null), this.parseUnderflow(), this.last = { x: null, y: null, scaleX: null, scaleY: null }, this.update();
  }
  parseUnderflow() {
    const t = this.options.underflow.toLowerCase();
    t === "none" ? this.noUnderflow = !0 : t === "center" ? (this.underflowX = this.underflowY = 0, this.noUnderflow = !1) : (this.underflowX = t.indexOf("left") !== -1 ? -1 : t.indexOf("right") !== -1 ? 1 : 0, this.underflowY = t.indexOf("top") !== -1 ? -1 : t.indexOf("bottom") !== -1 ? 1 : 0, this.noUnderflow = !1);
  }
  move() {
    return this.update(), !1;
  }
  update() {
    if (this.paused || this.parent.x === this.last.x && this.parent.y === this.last.y && this.parent.scale.x === this.last.scaleX && this.parent.scale.y === this.last.scaleY)
      return;
    const t = new Ut(this.parent.x, this.parent.y), e = this.parent.plugins.decelerate || {};
    if (this.options.left !== null || this.options.right !== null) {
      let i = !1;
      if (!this.noUnderflow && this.parent.screenWorldWidth < this.parent.screenWidth)
        switch (this.underflowX) {
          case -1:
            this.parent.x !== 0 && (this.parent.x = 0, i = !0);
            break;
          case 1:
            this.parent.x !== this.parent.screenWidth - this.parent.screenWorldWidth && (this.parent.x = this.parent.screenWidth - this.parent.screenWorldWidth, i = !0);
            break;
          default:
            this.parent.x !== (this.parent.screenWidth - this.parent.screenWorldWidth) / 2 && (this.parent.x = (this.parent.screenWidth - this.parent.screenWorldWidth) / 2, i = !0);
        }
      else
        this.options.left !== null && this.parent.left < (this.options.left === !0 ? 0 : this.options.left) && (this.parent.x = -(this.options.left === !0 ? 0 : this.options.left) * this.parent.scale.x, e.x = 0, i = !0), this.options.right !== null && this.parent.right > (this.options.right === !0 ? this.parent.worldWidth : this.options.right) && (this.parent.x = -(this.options.right === !0 ? this.parent.worldWidth : this.options.right) * this.parent.scale.x + this.parent.screenWidth, e.x = 0, i = !0);
      i && this.parent.emit("moved", {
        viewport: this.parent,
        original: t,
        type: "clamp-x"
      });
    }
    if (this.options.top !== null || this.options.bottom !== null) {
      let i = !1;
      if (!this.noUnderflow && this.parent.screenWorldHeight < this.parent.screenHeight)
        switch (this.underflowY) {
          case -1:
            this.parent.y !== 0 && (this.parent.y = 0, i = !0);
            break;
          case 1:
            this.parent.y !== this.parent.screenHeight - this.parent.screenWorldHeight && (this.parent.y = this.parent.screenHeight - this.parent.screenWorldHeight, i = !0);
            break;
          default:
            this.parent.y !== (this.parent.screenHeight - this.parent.screenWorldHeight) / 2 && (this.parent.y = (this.parent.screenHeight - this.parent.screenWorldHeight) / 2, i = !0);
        }
      else
        this.options.top !== null && this.parent.top < (this.options.top === !0 ? 0 : this.options.top) && (this.parent.y = -(this.options.top === !0 ? 0 : this.options.top) * this.parent.scale.y, e.y = 0, i = !0), this.options.bottom !== null && this.parent.bottom > (this.options.bottom === !0 ? this.parent.worldHeight : this.options.bottom) && (this.parent.y = -(this.options.bottom === !0 ? this.parent.worldHeight : this.options.bottom) * this.parent.scale.y + this.parent.screenHeight, e.y = 0, i = !0);
      i && this.parent.emit("moved", {
        viewport: this.parent,
        original: t,
        type: "clamp-y"
      });
    }
    this.last.x = this.parent.x, this.last.y = this.parent.y, this.last.scaleX = this.parent.scale.x, this.last.scaleY = this.parent.scale.y;
  }
  reset() {
    this.update();
  }
}
const pO = {
  minWidth: null,
  minHeight: null,
  maxWidth: null,
  maxHeight: null,
  minScale: null,
  maxScale: null
};
class mO extends pi {
  /**
   * This is called by {@link Viewport.clampZoom}.
   */
  constructor(t, e = {}) {
    super(t), this.options = Object.assign({}, pO, e), this.clamp();
  }
  resize() {
    this.clamp();
  }
  /** Clamp the viewport scale zoom) */
  clamp() {
    if (!this.paused) {
      if (this.options.minWidth || this.options.minHeight || this.options.maxWidth || this.options.maxHeight) {
        let t = this.parent.worldScreenWidth, e = this.parent.worldScreenHeight;
        if (this.options.minWidth !== null && t < this.options.minWidth) {
          const i = this.parent.scale.x;
          this.parent.fitWidth(this.options.minWidth, !1, !1, !0), this.parent.scale.y *= this.parent.scale.x / i, t = this.parent.worldScreenWidth, e = this.parent.worldScreenHeight, this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" });
        }
        if (this.options.maxWidth !== null && t > this.options.maxWidth) {
          const i = this.parent.scale.x;
          this.parent.fitWidth(this.options.maxWidth, !1, !1, !0), this.parent.scale.y *= this.parent.scale.x / i, t = this.parent.worldScreenWidth, e = this.parent.worldScreenHeight, this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" });
        }
        if (this.options.minHeight !== null && e < this.options.minHeight) {
          const i = this.parent.scale.y;
          this.parent.fitHeight(this.options.minHeight, !1, !1, !0), this.parent.scale.x *= this.parent.scale.y / i, t = this.parent.worldScreenWidth, e = this.parent.worldScreenHeight, this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" });
        }
        if (this.options.maxHeight !== null && e > this.options.maxHeight) {
          const i = this.parent.scale.y;
          this.parent.fitHeight(this.options.maxHeight, !1, !1, !0), this.parent.scale.x *= this.parent.scale.y / i, this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" });
        }
      } else if (this.options.minScale || this.options.maxScale) {
        const t = { x: null, y: null }, e = { x: null, y: null };
        if (typeof this.options.minScale == "number")
          t.x = this.options.minScale, t.y = this.options.minScale;
        else if (this.options.minScale !== null) {
          const o = this.options.minScale;
          t.x = typeof o.x > "u" ? null : o.x, t.y = typeof o.y > "u" ? null : o.y;
        }
        if (typeof this.options.maxScale == "number")
          e.x = this.options.maxScale, e.y = this.options.maxScale;
        else if (this.options.maxScale !== null) {
          const o = this.options.maxScale;
          e.x = typeof o.x > "u" ? null : o.x, e.y = typeof o.y > "u" ? null : o.y;
        }
        let i = this.parent.scale.x, s = this.parent.scale.y;
        t.x !== null && i < t.x && (i = t.x), e.x !== null && i > e.x && (i = e.x), t.y !== null && s < t.y && (s = t.y), e.y !== null && s > e.y && (s = e.y), (i !== this.parent.scale.x || s !== this.parent.scale.y) && (this.parent.scale.set(i, s), this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" }));
      }
    }
  }
  reset() {
    this.clamp();
  }
}
const gO = {
  friction: 0.98,
  bounce: 0.8,
  minSpeed: 0.01
}, Xr = 16;
class yO extends pi {
  /**
   * This is called by {@link Viewport.decelerate}.
   */
  constructor(t, e = {}) {
    super(t), this.options = Object.assign({}, gO, e), this.saved = [], this.timeSinceRelease = 0, this.reset(), this.parent.on("moved", (i) => this.handleMoved(i));
  }
  down() {
    return this.saved = [], this.x = this.y = null, !1;
  }
  isActive() {
    return !!(this.x || this.y);
  }
  move() {
    if (this.paused)
      return !1;
    const t = this.parent.input.count();
    return (t === 1 || t > 1 && !this.parent.plugins.get("pinch", !0)) && (this.saved.push({ x: this.parent.x, y: this.parent.y, time: performance.now() }), this.saved.length > 60 && this.saved.splice(0, 30)), !1;
  }
  /** Listener to viewport's "moved" event. */
  handleMoved(t) {
    if (this.saved.length) {
      const e = this.saved[this.saved.length - 1];
      t.type === "clamp-x" && t.original ? e.x === t.original.x && (e.x = this.parent.x) : t.type === "clamp-y" && t.original && e.y === t.original.y && (e.y = this.parent.y);
    }
  }
  up() {
    if (this.parent.input.count() === 0 && this.saved.length) {
      const t = performance.now();
      for (const e of this.saved)
        if (e.time >= t - 100) {
          const i = t - e.time;
          this.x = (this.parent.x - e.x) / i, this.y = (this.parent.y - e.y) / i, this.percentChangeX = this.percentChangeY = this.options.friction, this.timeSinceRelease = 0;
          break;
        }
    }
    return !1;
  }
  /**
   * Manually activate deceleration, starting from the (x, y) velocity components passed in the options.
   *
   * @param {object} options
   * @param {number} [options.x] - Specify x-component of initial velocity.
   * @param {number} [options.y] - Specify y-component of initial velocity.
   */
  activate(t) {
    t = t || {}, typeof t.x < "u" && (this.x = t.x, this.percentChangeX = this.options.friction), typeof t.y < "u" && (this.y = t.y, this.percentChangeY = this.options.friction);
  }
  update(t) {
    if (this.paused)
      return;
    const e = this.x || this.y, i = this.timeSinceRelease, s = this.timeSinceRelease + t;
    if (this.x) {
      const o = this.percentChangeX, l = Math.log(o);
      this.parent.x += this.x * Xr / l * (Math.pow(o, s / Xr) - Math.pow(o, i / Xr)), this.x *= Math.pow(this.percentChangeX, t / Xr);
    }
    if (this.y) {
      const o = this.percentChangeY, l = Math.log(o);
      this.parent.y += this.y * Xr / l * (Math.pow(o, s / Xr) - Math.pow(o, i / Xr)), this.y *= Math.pow(this.percentChangeY, t / Xr);
    }
    this.timeSinceRelease += t, this.x && this.y ? Math.abs(this.x) < this.options.minSpeed && Math.abs(this.y) < this.options.minSpeed && (this.x = 0, this.y = 0) : (Math.abs(this.x || 0) < this.options.minSpeed && (this.x = 0), Math.abs(this.y || 0) < this.options.minSpeed && (this.y = 0)), e && this.parent.emit("moved", { viewport: this.parent, type: "decelerate" });
  }
  reset() {
    this.x = this.y = null;
  }
}
const bO = {
  direction: "all",
  pressDrag: !0,
  wheel: !0,
  wheelScroll: 1,
  reverse: !1,
  clampWheel: !1,
  underflow: "center",
  factor: 1,
  mouseButtons: "all",
  keyToPress: null,
  ignoreKeyToPressOnTouch: !1,
  lineHeight: 20,
  wheelSwapAxes: !1
};
class vO extends pi {
  /**
  * This is called by {@link Viewport.drag}.
  */
  constructor(t, e = {}) {
    super(t), this.windowEventHandlers = [], this.options = Object.assign({}, bO, e), this.moved = !1, this.reverse = this.options.reverse ? 1 : -1, this.xDirection = !this.options.direction || this.options.direction === "all" || this.options.direction === "x", this.yDirection = !this.options.direction || this.options.direction === "all" || this.options.direction === "y", this.keyIsPressed = !1, this.parseUnderflow(), this.mouseButtons(this.options.mouseButtons), this.options.keyToPress && this.handleKeyPresses(this.options.keyToPress);
  }
  /**
  * Handles keypress events and set the keyIsPressed boolean accordingly
  *
  * @param {array} codes - key codes that can be used to trigger drag event
  */
  handleKeyPresses(t) {
    const e = (s) => {
      t.includes(s.code) && (this.keyIsPressed = !0);
    }, i = (s) => {
      t.includes(s.code) && (this.keyIsPressed = !1);
    };
    this.addWindowEventHandler("keyup", i), this.addWindowEventHandler("keydown", e);
  }
  addWindowEventHandler(t, e) {
    typeof window > "u" || (window.addEventListener(t, e), this.windowEventHandlers.push({ event: t, handler: e }));
  }
  destroy() {
    typeof window > "u" || this.windowEventHandlers.forEach(({ event: t, handler: e }) => {
      window.removeEventListener(t, e);
    });
  }
  /**
  * initialize mousebuttons array
  * @param {string} buttons
  */
  mouseButtons(t) {
    !t || t === "all" ? this.mouse = [!0, !0, !0] : this.mouse = [
      t.indexOf("left") !== -1,
      t.indexOf("middle") !== -1,
      t.indexOf("right") !== -1
    ];
  }
  parseUnderflow() {
    const t = this.options.underflow.toLowerCase();
    t === "center" ? (this.underflowX = 0, this.underflowY = 0) : (t.includes("left") ? this.underflowX = -1 : t.includes("right") ? this.underflowX = 1 : this.underflowX = 0, t.includes("top") ? this.underflowY = -1 : t.includes("bottom") ? this.underflowY = 1 : this.underflowY = 0);
  }
  /**
  * @param {PIXI.FederatedPointerEvent} event
  * @returns {boolean}
  */
  checkButtons(t) {
    const e = t.pointerType === "mouse", i = this.parent.input.count();
    return !!((i === 1 || i > 1 && !this.parent.plugins.get("pinch", !0)) && (!e || this.mouse[t.button]));
  }
  /**
  * @param {PIXI.FederatedPointerEvent} event
  * @returns {boolean}
  */
  checkKeyPress(t) {
    return !this.options.keyToPress || this.keyIsPressed || this.options.ignoreKeyToPressOnTouch && t.data.pointerType === "touch";
  }
  down(t) {
    return this.paused || !this.options.pressDrag ? !1 : this.checkButtons(t) && this.checkKeyPress(t) ? (this.last = { x: t.global.x, y: t.global.y }, (this.parent.parent || this.parent).toLocal(
      this.last,
      void 0,
      this.last
    ), this.current = t.pointerId, !0) : (this.last = null, !1);
  }
  get active() {
    return this.moved;
  }
  move(t) {
    if (this.paused || !this.options.pressDrag)
      return !1;
    if (this.last && this.current === t.data.pointerId) {
      const e = t.global.x, i = t.global.y, s = this.parent.input.count();
      if (s === 1 || s > 1 && !this.parent.plugins.get("pinch", !0)) {
        const o = { x: e, y: i };
        (this.parent.parent || this.parent).toLocal(
          o,
          void 0,
          o
        );
        const l = o.x - this.last.x, c = o.y - this.last.y;
        if (this.moved || this.xDirection && this.parent.input.checkThreshold(l) || this.yDirection && this.parent.input.checkThreshold(c))
          return this.xDirection && (this.parent.x += (o.x - this.last.x) * this.options.factor), this.yDirection && (this.parent.y += (o.y - this.last.y) * this.options.factor), this.last = o, this.moved || this.parent.emit("drag-start", {
            event: t,
            screen: new Ut(this.last.x, this.last.y),
            world: this.parent.toWorld(new Ut(this.last.x, this.last.y)),
            viewport: this.parent
          }), this.moved = !0, this.parent.emit("moved", { viewport: this.parent, type: "drag" }), !0;
      } else
        this.moved = !1;
    }
    return !1;
  }
  up(t) {
    if (this.paused)
      return !1;
    const e = this.parent.input.touches;
    if (e.length === 1) {
      const i = e[0];
      return i.last && (this.last = { x: i.last.x, y: i.last.y }, this.current = i.id), this.moved = !1, !0;
    } else if (this.last && this.moved) {
      const i = new Ut(this.last.x, this.last.y);
      return (this.parent.parent || this.parent).toGlobal(i, i, !0), this.parent.emit("drag-end", {
        event: t,
        screen: i,
        world: this.parent.toWorld(i),
        viewport: this.parent
      }), this.last = null, this.moved = !1, !0;
    }
    return !1;
  }
  wheel(t) {
    if (this.paused)
      return !1;
    if (this.options.wheel) {
      const e = this.parent.plugins.get("wheel", !0);
      if (!e || !e.options.wheelZoom && !t.ctrlKey) {
        const i = t.deltaMode ? this.options.lineHeight : 1, s = [t.deltaX, t.deltaY], [o, l] = this.options.wheelSwapAxes ? s.reverse() : s;
        return this.xDirection && (this.parent.x += o * i * this.options.wheelScroll * this.reverse), this.yDirection && (this.parent.y += l * i * this.options.wheelScroll * this.reverse), this.options.clampWheel && this.clamp(), this.parent.emit("wheel-scroll", this.parent), this.parent.emit("moved", { viewport: this.parent, type: "wheel" }), this.parent.options.passiveWheel || t.preventDefault(), this.parent.options.stopPropagation && t.stopPropagation(), !0;
      }
    }
    return !1;
  }
  resume() {
    this.last = null, this.paused = !1;
  }
  clamp() {
    const t = this.parent.plugins.get("decelerate", !0) || {};
    if (this.options.clampWheel !== "y")
      if (this.parent.screenWorldWidth < this.parent.screenWidth)
        switch (this.underflowX) {
          case -1:
            this.parent.x = 0;
            break;
          case 1:
            this.parent.x = this.parent.screenWidth - this.parent.screenWorldWidth;
            break;
          default:
            this.parent.x = (this.parent.screenWidth - this.parent.screenWorldWidth) / 2;
        }
      else
        this.parent.left < 0 ? (this.parent.x = 0, t.x = 0) : this.parent.right > this.parent.worldWidth && (this.parent.x = -this.parent.worldWidth * this.parent.scale.x + this.parent.screenWidth, t.x = 0);
    if (this.options.clampWheel !== "x")
      if (this.parent.screenWorldHeight < this.parent.screenHeight)
        switch (this.underflowY) {
          case -1:
            this.parent.y = 0;
            break;
          case 1:
            this.parent.y = this.parent.screenHeight - this.parent.screenWorldHeight;
            break;
          default:
            this.parent.y = (this.parent.screenHeight - this.parent.screenWorldHeight) / 2;
        }
      else
        this.parent.top < 0 && (this.parent.y = 0, t.y = 0), this.parent.bottom > this.parent.worldHeight && (this.parent.y = -this.parent.worldHeight * this.parent.scale.y + this.parent.screenHeight, t.y = 0);
  }
}
const xO = {
  speed: 0,
  acceleration: null,
  radius: null
};
class _O extends pi {
  /**
   * This is called by {@link Viewport.follow}.
   *
   * @param parent
   * @param target - target to follow
   * @param options
   */
  constructor(t, e, i = {}) {
    super(t), this.target = e, this.options = Object.assign({}, xO, i), this.velocity = { x: 0, y: 0 };
  }
  update(t) {
    if (this.paused)
      return;
    const e = this.parent.center;
    let i = this.target.x, s = this.target.y;
    if (this.options.radius)
      if (Math.sqrt(Math.pow(this.target.y - e.y, 2) + Math.pow(this.target.x - e.x, 2)) > this.options.radius) {
        const c = Math.atan2(this.target.y - e.y, this.target.x - e.x);
        i = this.target.x - Math.cos(c) * this.options.radius, s = this.target.y - Math.sin(c) * this.options.radius;
      } else
        return;
    const o = i - e.x, l = s - e.y;
    if (o || l)
      if (this.options.speed)
        if (this.options.acceleration) {
          const c = Math.atan2(s - e.y, i - e.x), d = Math.sqrt(Math.pow(o, 2) + Math.pow(l, 2));
          if (d) {
            const f = (Math.pow(this.velocity.x, 2) + Math.pow(this.velocity.y, 2)) / (2 * this.options.acceleration);
            d > f ? this.velocity = {
              x: Math.min(this.velocity.x + (this.options.acceleration * t, this.options.speed)),
              y: Math.min(this.velocity.y + (this.options.acceleration * t, this.options.speed))
            } : this.velocity = {
              x: Math.max(this.velocity.x - this.options.acceleration * this.options.speed, 0),
              y: Math.max(this.velocity.y - this.options.acceleration * this.options.speed, 0)
            };
            const m = Math.cos(c) * this.velocity.x, y = Math.sin(c) * this.velocity.y, b = Math.abs(m) > Math.abs(o) ? i : e.x + m, v = Math.abs(y) > Math.abs(l) ? s : e.y + y;
            this.parent.moveCenter(b, v), this.parent.emit("moved", { viewport: this.parent, type: "follow" });
          }
        } else {
          const c = Math.atan2(s - e.y, i - e.x), d = Math.cos(c) * this.options.speed, f = Math.sin(c) * this.options.speed, m = Math.abs(d) > Math.abs(o) ? i : e.x + d, y = Math.abs(f) > Math.abs(l) ? s : e.y + f;
          this.parent.moveCenter(m, y), this.parent.emit("moved", { viewport: this.parent, type: "follow" });
        }
      else
        this.parent.moveCenter(i, s), this.parent.emit("moved", { viewport: this.parent, type: "follow" });
  }
}
const SO = {
  radius: null,
  distance: null,
  top: null,
  bottom: null,
  left: null,
  right: null,
  speed: 8,
  reverse: !1,
  noDecelerate: !1,
  linear: !1,
  allowButtons: !1
};
class TO extends pi {
  /**
   * This is called by {@link Viewport.mouseEdges}.
   */
  constructor(t, e = {}) {
    super(t), this.options = Object.assign({}, SO, e), this.reverse = this.options.reverse ? 1 : -1, this.radiusSquared = typeof this.options.radius == "number" ? Math.pow(this.options.radius, 2) : null, this.resize();
  }
  resize() {
    const t = this.options.distance;
    t !== null ? (this.left = t, this.top = t, this.right = this.parent.screenWidth - t, this.bottom = this.parent.screenHeight - t) : this.options.radius || (this.left = this.options.left, this.top = this.options.top, this.right = this.options.right === null ? null : this.parent.screenWidth - this.options.right, this.bottom = this.options.bottom === null ? null : this.parent.screenHeight - this.options.bottom);
  }
  down() {
    return this.paused || this.options.allowButtons || (this.horizontal = this.vertical = null), !1;
  }
  move(t) {
    if (this.paused || t.pointerType !== "mouse" && t.pointerId !== 1 || !this.options.allowButtons && t.buttons !== 0)
      return !1;
    const e = t.global.x, i = t.global.y;
    if (this.radiusSquared) {
      const s = this.parent.toScreen(this.parent.center);
      if (Math.pow(s.x - e, 2) + Math.pow(s.y - i, 2) >= this.radiusSquared) {
        const o = Math.atan2(s.y - i, s.x - e);
        this.options.linear ? (this.horizontal = Math.round(Math.cos(o)) * this.options.speed * this.reverse * (60 / 1e3), this.vertical = Math.round(Math.sin(o)) * this.options.speed * this.reverse * (60 / 1e3)) : (this.horizontal = Math.cos(o) * this.options.speed * this.reverse * (60 / 1e3), this.vertical = Math.sin(o) * this.options.speed * this.reverse * (60 / 1e3));
      } else
        this.horizontal && this.decelerateHorizontal(), this.vertical && this.decelerateVertical(), this.horizontal = this.vertical = 0;
    } else
      this.left !== null && e < this.left ? this.horizontal = Number(this.reverse) * this.options.speed * (60 / 1e3) : this.right !== null && e > this.right ? this.horizontal = -1 * this.reverse * this.options.speed * (60 / 1e3) : (this.decelerateHorizontal(), this.horizontal = 0), this.top !== null && i < this.top ? this.vertical = Number(this.reverse) * this.options.speed * (60 / 1e3) : this.bottom !== null && i > this.bottom ? this.vertical = -1 * this.reverse * this.options.speed * (60 / 1e3) : (this.decelerateVertical(), this.vertical = 0);
    return !1;
  }
  decelerateHorizontal() {
    const t = this.parent.plugins.get("decelerate", !0);
    this.horizontal && t && !this.options.noDecelerate && t.activate({ x: this.horizontal * this.options.speed * this.reverse / (1e3 / 60) });
  }
  decelerateVertical() {
    const t = this.parent.plugins.get("decelerate", !0);
    this.vertical && t && !this.options.noDecelerate && t.activate({ y: this.vertical * this.options.speed * this.reverse / (1e3 / 60) });
  }
  up() {
    return this.paused || (this.horizontal && this.decelerateHorizontal(), this.vertical && this.decelerateVertical(), this.horizontal = this.vertical = null), !1;
  }
  update() {
    if (!this.paused && (this.horizontal || this.vertical)) {
      const t = this.parent.center;
      this.horizontal && (t.x += this.horizontal * this.options.speed), this.vertical && (t.y += this.vertical * this.options.speed), this.parent.moveCenter(t), this.parent.emit("moved", { viewport: this.parent, type: "mouse-edges" });
    }
  }
}
const wO = {
  noDrag: !1,
  percent: 1,
  center: null,
  factor: 1,
  axis: "all"
}, CO = new Ut();
class EO extends pi {
  /**
  * This is called by {@link Viewport.pinch}.
  */
  constructor(t, e = {}) {
    super(t), this.active = !1, this.pinching = !1, this.moved = !1, this.options = Object.assign({}, wO, e);
  }
  down() {
    return this.parent.input.count() >= 2 ? (this.active = !0, !0) : !1;
  }
  isAxisX() {
    return ["all", "x"].includes(this.options.axis);
  }
  isAxisY() {
    return ["all", "y"].includes(this.options.axis);
  }
  move(t) {
    if (this.paused || !this.active)
      return !1;
    const { x: e, y: i } = (this.parent.parent || this.parent).toLocal(
      t.global,
      void 0,
      CO
    ), s = this.parent.input.touches;
    if (s.length >= 2) {
      const o = s[0], l = s[1], c = o.last && l.last ? Math.sqrt(
        Math.pow(l.last.x - o.last.x, 2) + Math.pow(l.last.y - o.last.y, 2)
      ) : null;
      if (o.id === t.pointerId ? o.last = { x: e, y: i, data: t } : l.id === t.pointerId && (l.last = { x: e, y: i, data: t }), c) {
        let d;
        const f = new Ut(
          o.last.x + (l.last.x - o.last.x) / 2,
          o.last.y + (l.last.y - o.last.y) / 2
        );
        this.options.center || (d = this.parent.toLocal(
          f,
          this.parent.parent || this.parent
        ));
        let m = Math.sqrt(
          Math.pow(
            l.last.x - o.last.x,
            2
          ) + Math.pow(
            l.last.y - o.last.y,
            2
          )
        );
        m = m === 0 ? m = 1e-10 : m;
        const y = (1 - c / m) * this.options.percent * (this.isAxisX() ? this.parent.scale.x : this.parent.scale.y);
        this.isAxisX() && (this.parent.scale.x += y), this.isAxisY() && (this.parent.scale.y += y), this.parent.emit("zoomed", {
          viewport: this.parent,
          type: "pinch",
          center: f
        });
        const b = this.parent.plugins.get("clamp-zoom", !0);
        if (b && b.clamp(), this.options.center)
          this.parent.moveCenter(this.options.center);
        else {
          const v = (this.parent.parent || this.parent).toLocal(
            d,
            this.parent
          );
          this.parent.x += (f.x - v.x) * this.options.factor, this.parent.y += (f.y - v.y) * this.options.factor, this.parent.emit("moved", { viewport: this.parent, type: "pinch" });
        }
        !this.options.noDrag && this.lastCenter && (this.parent.x += (f.x - this.lastCenter.x) * this.options.factor, this.parent.y += (f.y - this.lastCenter.y) * this.options.factor, this.parent.emit("moved", { viewport: this.parent, type: "pinch" })), this.lastCenter = f, this.moved = !0;
      } else
        this.pinching || (this.parent.emit("pinch-start", this.parent), this.pinching = !0);
      return !0;
    }
    return !1;
  }
  up() {
    return this.pinching && this.parent.input.touches.length <= 1 ? (this.active = !1, this.lastCenter = null, this.pinching = !1, this.moved = !1, this.parent.emit("pinch-end", this.parent), !0) : !1;
  }
}
const MO = {
  topLeft: !1,
  friction: 0.8,
  time: 1e3,
  ease: "easeInOutSine",
  interrupt: !0,
  removeOnComplete: !1,
  removeOnInterrupt: !1,
  forceStart: !1
};
class AO extends pi {
  /**
   * This is called by {@link Viewport.snap}.
   */
  constructor(t, e, i, s = {}) {
    super(t), this.options = Object.assign({}, MO, s), this.ease = Eh(s.ease, "easeInOutSine"), this.x = e, this.y = i, this.options.forceStart && this.snapStart();
  }
  snapStart() {
    this.percent = 0, this.snapping = { time: 0 };
    const t = this.options.topLeft ? this.parent.corner : this.parent.center;
    this.deltaX = this.x - t.x, this.deltaY = this.y - t.y, this.startX = t.x, this.startY = t.y, this.parent.emit("snap-start", this.parent);
  }
  wheel() {
    return this.options.removeOnInterrupt && this.parent.plugins.remove("snap"), !1;
  }
  down() {
    return this.options.removeOnInterrupt ? this.parent.plugins.remove("snap") : this.options.interrupt && (this.snapping = null), !1;
  }
  up() {
    if (this.parent.input.count() === 0) {
      const t = this.parent.plugins.get("decelerate", !0);
      t && (t.x || t.y) && (t.percentChangeX = t.percentChangeY = this.options.friction);
    }
    return !1;
  }
  update(t) {
    if (!this.paused && !(this.options.interrupt && this.parent.input.count() !== 0))
      if (this.snapping) {
        const e = this.snapping;
        e.time += t;
        let i, s, o;
        const l = this.startX, c = this.startY, d = this.deltaX, f = this.deltaY;
        if (e.time > this.options.time)
          i = !0, s = l + d, o = c + f;
        else {
          const m = this.ease(e.time, 0, 1, this.options.time);
          s = l + d * m, o = c + f * m;
        }
        this.options.topLeft ? this.parent.moveCorner(s, o) : this.parent.moveCenter(s, o), this.parent.emit("moved", { viewport: this.parent, type: "snap" }), i && (this.options.removeOnComplete && this.parent.plugins.remove("snap"), this.parent.emit("snap-end", this.parent), this.snapping = null);
      } else {
        const e = this.options.topLeft ? this.parent.corner : this.parent.center;
        (e.x !== this.x || e.y !== this.y) && this.snapStart();
      }
  }
}
const RO = {
  width: 0,
  height: 0,
  time: 1e3,
  ease: "easeInOutSine",
  center: null,
  interrupt: !0,
  removeOnComplete: !1,
  removeOnInterrupt: !1,
  forceStart: !1,
  noMove: !1
};
class PO extends pi {
  /**
   * This is called by {@link Viewport.snapZoom}.
   */
  constructor(t, e = {}) {
    super(t), this.options = Object.assign({}, RO, e), this.ease = Eh(this.options.ease), this.xIndependent = !1, this.yIndependent = !1, this.xScale = 0, this.yScale = 0, this.options.width > 0 && (this.xScale = t.screenWidth / this.options.width, this.xIndependent = !0), this.options.height > 0 && (this.yScale = t.screenHeight / this.options.height, this.yIndependent = !0), this.xScale = this.xIndependent ? this.xScale : this.yScale, this.yScale = this.yIndependent ? this.yScale : this.xScale, this.options.time === 0 ? (t.container.scale.x = this.xScale, t.container.scale.y = this.yScale, this.options.removeOnComplete && this.parent.plugins.remove("snap-zoom")) : e.forceStart && this.createSnapping();
  }
  createSnapping() {
    const t = this.parent.worldScreenWidth, e = this.parent.worldScreenHeight, i = this.parent.screenWidth / this.xScale, s = this.parent.screenHeight / this.yScale;
    this.snapping = {
      time: 0,
      startX: t,
      startY: e,
      deltaX: i - t,
      deltaY: s - e
    }, this.parent.emit("snap-zoom-start", this.parent);
  }
  resize() {
    this.snapping = null, this.options.width > 0 && (this.xScale = this.parent.screenWidth / this.options.width), this.options.height > 0 && (this.yScale = this.parent.screenHeight / this.options.height), this.xScale = this.xIndependent ? this.xScale : this.yScale, this.yScale = this.yIndependent ? this.yScale : this.xScale;
  }
  wheel() {
    return this.options.removeOnInterrupt && this.parent.plugins.remove("snap-zoom"), !1;
  }
  down() {
    return this.options.removeOnInterrupt ? this.parent.plugins.remove("snap-zoom") : this.options.interrupt && (this.snapping = null), !1;
  }
  update(t) {
    if (this.paused || this.options.interrupt && this.parent.input.count() !== 0)
      return;
    let e;
    if (!this.options.center && !this.options.noMove && (e = this.parent.center), !this.snapping)
      (this.parent.scale.x !== this.xScale || this.parent.scale.y !== this.yScale) && this.createSnapping();
    else if (this.snapping) {
      const i = this.snapping;
      if (i.time += t, i.time >= this.options.time)
        this.parent.scale.set(this.xScale, this.yScale), this.options.removeOnComplete && this.parent.plugins.remove("snap-zoom"), this.parent.emit("snap-zoom-end", this.parent), this.snapping = null;
      else {
        const o = this.snapping, l = this.ease(o.time, o.startX, o.deltaX, this.options.time), c = this.ease(o.time, o.startY, o.deltaY, this.options.time);
        this.parent.scale.x = this.parent.screenWidth / l, this.parent.scale.y = this.parent.screenHeight / c;
      }
      const s = this.parent.plugins.get("clamp-zoom", !0);
      s && s.clamp(), this.options.noMove || (this.options.center ? this.parent.moveCenter(this.options.center) : this.parent.moveCenter(e));
    }
  }
  resume() {
    this.snapping = null, super.resume();
  }
}
const BO = {
  percent: 0.1,
  smooth: !1,
  interrupt: !0,
  reverse: !1,
  center: null,
  lineHeight: 20,
  axis: "all",
  keyToPress: null,
  trackpadPinch: !1,
  wheelZoom: !0
};
class kO extends pi {
  /**
  * This is called by {@link Viewport.wheel}.
  */
  constructor(t, e = {}) {
    super(t), this.options = Object.assign({}, BO, e), this.keyIsPressed = !1, this.options.keyToPress && this.handleKeyPresses(this.options.keyToPress);
  }
  /**
  * Handles keypress events and set the keyIsPressed boolean accordingly
  *
  * @param {array} codes - key codes that can be used to trigger zoom event
  */
  handleKeyPresses(t) {
    typeof window > "u" || (window.addEventListener("keydown", (e) => {
      t.includes(e.code) && (this.keyIsPressed = !0);
    }), window.addEventListener("keyup", (e) => {
      t.includes(e.code) && (this.keyIsPressed = !1);
    }));
  }
  checkKeyPress() {
    return !this.options.keyToPress || this.keyIsPressed;
  }
  down() {
    return this.options.interrupt && (this.smoothing = null), !1;
  }
  isAxisX() {
    return ["all", "x"].includes(this.options.axis);
  }
  isAxisY() {
    return ["all", "y"].includes(this.options.axis);
  }
  update() {
    if (this.smoothing) {
      const t = this.smoothingCenter, e = this.smoothing;
      let i;
      this.options.center || (i = this.parent.toLocal(t)), this.isAxisX() && (this.parent.scale.x += e.x), this.isAxisY() && (this.parent.scale.y += e.y), this.parent.emit("zoomed", { viewport: this.parent, type: "wheel" });
      const s = this.parent.plugins.get("clamp-zoom", !0);
      if (s && s.clamp(), this.options.center)
        this.parent.moveCenter(this.options.center);
      else {
        const o = this.parent.parent || this.parent;
        o.toLocal(i, this.parent, i);
        const l = o.toLocal(t);
        this.parent.x += l.x - i.x, this.parent.y += l.y - i.y;
      }
      this.parent.emit("moved", { viewport: this.parent, type: "wheel" }), this.smoothingCount++, typeof this.options.smooth == "number" && this.smoothingCount >= this.options.smooth && (this.smoothing = null);
    }
  }
  pinch(t) {
    if (this.paused)
      return;
    const e = this.parent.input.getPointerPosition(t), i = -t.deltaY * (t.deltaMode ? this.options.lineHeight : 1) / 200, s = Math.pow(2, (1 + this.options.percent) * i);
    let o;
    this.options.center || (o = this.parent.toLocal(e)), this.isAxisX() && (this.parent.scale.x *= s), this.isAxisY() && (this.parent.scale.y *= s), this.parent.emit("zoomed", { viewport: this.parent, type: "wheel" });
    const l = this.parent.plugins.get("clamp-zoom", !0);
    if (l && l.clamp(), this.options.center)
      this.parent.moveCenter(this.options.center);
    else {
      const c = this.parent.parent || this.parent;
      c.toLocal(o, this.parent, o);
      const d = c.toLocal(e);
      this.parent.x += d.x - o.x, this.parent.y += d.y - o.y;
    }
    this.parent.emit("moved", { viewport: this.parent, type: "wheel" }), this.parent.emit("wheel-start", { event: t, viewport: this.parent });
  }
  wheel(t) {
    if (this.paused || !this.checkKeyPress())
      return !1;
    if (t.ctrlKey && this.options.trackpadPinch)
      this.pinch(t);
    else if (this.options.wheelZoom) {
      const e = this.parent.input.getPointerPosition(t), i = (this.options.reverse ? -1 : 1) * -t.deltaY * (t.deltaMode ? this.options.lineHeight : 1) / 500, s = Math.pow(2, (1 + this.options.percent) * i);
      if (this.options.smooth) {
        const o = {
          x: this.smoothing ? this.smoothing.x * (this.options.smooth - this.smoothingCount) : 0,
          y: this.smoothing ? this.smoothing.y * (this.options.smooth - this.smoothingCount) : 0
        };
        this.smoothing = {
          x: ((this.parent.scale.x + o.x) * s - this.parent.scale.x) / this.options.smooth,
          y: ((this.parent.scale.y + o.y) * s - this.parent.scale.y) / this.options.smooth
        }, this.smoothingCount = 0, this.smoothingCenter = e;
      } else {
        let o;
        this.options.center || (o = this.parent.toLocal(e)), this.isAxisX() && (this.parent.scale.x *= s), this.isAxisY() && (this.parent.scale.y *= s), this.parent.emit("zoomed", { viewport: this.parent, type: "wheel" });
        const l = this.parent.plugins.get("clamp-zoom", !0);
        if (l && l.clamp(), this.options.center)
          this.parent.moveCenter(this.options.center);
        else {
          const c = this.parent.parent || this.parent;
          c.toLocal(o, this.parent, o);
          const d = c.toLocal(e);
          this.parent.x += d.x - o.x, this.parent.y += d.y - o.y;
        }
      }
      this.parent.emit("moved", { viewport: this.parent, type: "wheel" }), this.parent.emit("wheel-start", { event: t, viewport: this.parent });
    }
    return !this.parent.options.passiveWheel;
  }
}
const OO = {
  screenWidth: typeof window > "u" ? 0 : window.innerWidth,
  screenHeight: typeof window > "u" ? 0 : window.innerHeight,
  worldWidth: null,
  worldHeight: null,
  threshold: 5,
  passiveWheel: !0,
  stopPropagation: !1,
  forceHitArea: null,
  noTicker: !1,
  disableOnContextMenu: !1,
  ticker: Kn.shared,
  allowPreserveDragOutside: !1
};
class DO extends Rn {
  /**
   * @param {IViewportOptions} ViewportOptions
   * @param {number} [options.screenWidth=window.innerWidth]
   * @param {number} [options.screenHeight=window.innerHeight]
   * @param {number} [options.worldWidth=this.width]
   * @param {number} [options.worldHeight=this.height]
   * @param {number} [options.threshold=5] number of pixels to move to trigger an input event (e.g., drag, pinch)
   * or disable a clicked event
   * @param {boolean} [options.passiveWheel=true] whether the 'wheel' event is set to passive (note: if false,
   * e.preventDefault() will be called when wheel is used over the viewport)
   * @param {boolean} [options.stopPropagation=false] whether to stopPropagation of events that impact the viewport
   * (except wheel events, see options.passiveWheel)
   * @param {HitArea} [options.forceHitArea] change the default hitArea from world size to a new value
   * @param {boolean} [options.noTicker] set this if you want to manually call update() function on each frame
   * @param {PIXI.Ticker} [options.ticker=PIXI.Ticker.shared] use this PIXI.ticker for updates
   * @param {PIXI.EventSystem} [options.events] EventSystem available from app.events or added manually and passed here
   * location on screen
   * @param {boolean} [options.disableOnContextMenu] remove oncontextmenu=() => {} from the pixi's events.domElement
   */
  constructor(t) {
    super(), this._disableOnContextMenu = (e) => e.preventDefault(), this.options = {
      ...OO,
      ...t
    }, this.screenWidth = this.options.screenWidth, this.screenHeight = this.options.screenHeight, this._worldWidth = this.options.worldWidth, this._worldHeight = this.options.worldHeight, this.forceHitArea = this.options.forceHitArea, this.threshold = this.options.threshold, this.options.disableOnContextMenu && this.options.events.domElement.addEventListener("contextmenu", this._disableOnContextMenu), this.options.noTicker || (this.tickerFunction = () => this.update(this.options.ticker.elapsedMS), this.options.ticker.add(this.tickerFunction)), this.input = new aO(this), this.plugins = new oO(this);
  }
  /** Overrides PIXI.Container's destroy to also remove the 'wheel' and PIXI.Ticker listeners */
  destroy(t) {
    var e;
    !this.options.noTicker && this.tickerFunction && this.options.ticker.remove(this.tickerFunction), this.options.disableOnContextMenu && ((e = this.options.events.domElement) == null || e.removeEventListener("contextmenu", this._disableOnContextMenu)), this.input.destroy(), super.destroy(t);
  }
  /**
   * Update viewport on each frame.
   *
   * By default, you do not need to call this unless you set `options.noTicker=true`.
   *
   * @param {number} elapsed time in milliseconds since last update
   */
  update(t) {
    this.pause || (this.plugins.update(t), this.lastViewport && (this.lastViewport.x !== this.x || this.lastViewport.y !== this.y ? this.moving = !0 : this.moving && (this.emit("moved-end", this), this.moving = !1), this.lastViewport.scaleX !== this.scale.x || this.lastViewport.scaleY !== this.scale.y ? this.zooming = !0 : this.zooming && (this.emit("zoomed-end", this), this.zooming = !1)), this.forceHitArea || (this._hitAreaDefault = new ne(this.left, this.top, this.worldScreenWidth, this.worldScreenHeight), this.hitArea = this._hitAreaDefault), this._dirty = this._dirty || !this.lastViewport || this.lastViewport.x !== this.x || this.lastViewport.y !== this.y || this.lastViewport.scaleX !== this.scale.x || this.lastViewport.scaleY !== this.scale.y, this.lastViewport = {
      x: this.x,
      y: this.y,
      scaleX: this.scale.x,
      scaleY: this.scale.y
    }, this.emit("frame-end", this));
  }
  /**
   * Use this to set screen and world sizes, needed for pinch/wheel/clamp/bounce.
   * @param {number} screenWidth=window.innerWidth
   * @param {number} screenHeight=window.innerHeight
   * @param {number} [worldWidth]
   * @param {number} [worldHeight]
   */
  resize(t = typeof window > "u" ? 0 : window.innerWidth, e = typeof window > "u" ? 0 : window.innerHeight, i, s) {
    this.screenWidth = t, this.screenHeight = e, typeof i < "u" && (this._worldWidth = i), typeof s < "u" && (this._worldHeight = s), this.plugins.resize(), this.dirty = !0;
  }
  /** World width, in pixels */
  get worldWidth() {
    return this._worldWidth ? this._worldWidth : this.width / this.scale.x;
  }
  set worldWidth(t) {
    this._worldWidth = t, this.plugins.resize();
  }
  /** World height, in pixels */
  get worldHeight() {
    return this._worldHeight ? this._worldHeight : this.height / this.scale.y;
  }
  set worldHeight(t) {
    this._worldHeight = t, this.plugins.resize();
  }
  /** Get visible world bounds of viewport */
  getVisibleBounds() {
    return new ne(this.left, this.top, this.worldScreenWidth, this.worldScreenHeight);
  }
  /**
   * Changes coordinate from screen to world
   * @param {number|PIXI.Point} x
   * @param {number} y
   * @returns {PIXI.Point}
   */
  toWorld(t, e) {
    return arguments.length === 2 ? this.toLocal(new Ut(t, e)) : this.toLocal(t);
  }
  /**
   * Changes coordinate from world to screen
   * @param {number|PIXI.Point} x
   * @param {number} y
   * @returns {PIXI.Point}
   */
  toScreen(t, e) {
    return arguments.length === 2 ? this.toGlobal(new Ut(t, e)) : this.toGlobal(t);
  }
  /** Screen width in world coordinates */
  get worldScreenWidth() {
    return this.screenWidth / this.scale.x;
  }
  /** Screen height in world coordinates */
  get worldScreenHeight() {
    return this.screenHeight / this.scale.y;
  }
  /** World width in screen coordinates */
  get screenWorldWidth() {
    return this.worldWidth * this.scale.x;
  }
  /** World height in screen coordinates */
  get screenWorldHeight() {
    return this.worldHeight * this.scale.y;
  }
  /** Center of screen in world coordinates */
  get center() {
    return new Ut(
      this.worldScreenWidth / 2 - this.x / this.scale.x,
      this.worldScreenHeight / 2 - this.y / this.scale.y
    );
  }
  set center(t) {
    this.moveCenter(t);
  }
  /**
   * Move center of viewport to (x, y)
   * @param {number|PIXI.Point} x
   * @param {number} [y]
   * @return {Viewport}
   */
  moveCenter(...t) {
    let e, i;
    typeof t[0] == "number" ? (e = t[0], i = t[1]) : (e = t[0].x, i = t[0].y);
    const s = (this.worldScreenWidth / 2 - e) * this.scale.x, o = (this.worldScreenHeight / 2 - i) * this.scale.y;
    return (this.x !== s || this.y !== o) && (this.position.set(s, o), this.plugins.reset(), this.dirty = !0), this;
  }
  /** Top-left corner of Viewport */
  get corner() {
    return new Ut(-this.x / this.scale.x, -this.y / this.scale.y);
  }
  set corner(t) {
    this.moveCorner(t);
  }
  /**
   * MoveCorner
   * @param {number|PIXI.Point} x
   * @param {number} [y]
   * @returns {Viewport}
   */
  moveCorner(...t) {
    let e, i;
    return t.length === 1 ? (e = -t[0].x * this.scale.x, i = -t[0].y * this.scale.y) : (e = -t[0] * this.scale.x, i = -t[1] * this.scale.y), (e !== this.x || i !== this.y) && (this.position.set(e, i), this.plugins.reset(), this.dirty = !0), this;
  }
  /** Get how many world pixels fit in screen's width */
  get screenWidthInWorldPixels() {
    return this.screenWidth / this.scale.x;
  }
  /** Get how many world pixels fit on screen's height */
  get screenHeightInWorldPixels() {
    return this.screenHeight / this.scale.y;
  }
  /**
   * Find the scale value that fits a world width on the screen
   * does not change the viewport (use fit... to change)
   *
   * @param width - Width in world pixels
   * @return - scale
   */
  findFitWidth(t) {
    return this.screenWidth / t;
  }
  /**
   * Finds the scale value that fits a world height on the screens
   * does not change the viewport (use fit... to change)
   *
   * @param height - Height in world pixels
   * @return - scale
   */
  findFitHeight(t) {
    return this.screenHeight / t;
  }
  /**
   * Finds the scale value that fits the smaller of a world width and world height on the screen
   * does not change the viewport (use fit... to change)
   *
   * @param {number} width in world pixels
   * @param {number} height in world pixels
   * @returns {number} scale
   */
  findFit(t, e) {
    const i = this.screenWidth / t, s = this.screenHeight / e;
    return Math.min(i, s);
  }
  /**
   * Finds the scale value that fits the larger of a world width and world height on the screen
   * does not change the viewport (use fit... to change)
   *
   * @param {number} width in world pixels
   * @param {number} height in world pixels
   * @returns {number} scale
   */
  findCover(t, e) {
    const i = this.screenWidth / t, s = this.screenHeight / e;
    return Math.max(i, s);
  }
  /**
   * Change zoom so the width fits in the viewport
   *
   * @param width - width in world coordinates
   * @param center - maintain the same center
   * @param scaleY - whether to set scaleY=scaleX
   * @param noClamp - whether to disable clamp-zoom
   * @returns {Viewport} this
   */
  fitWidth(t = this.worldWidth, e, i = !0, s) {
    let o;
    e && (o = this.center), this.scale.x = this.screenWidth / t, i && (this.scale.y = this.scale.x);
    const l = this.plugins.get("clamp-zoom", !0);
    return !s && l && l.clamp(), e && o && this.moveCenter(o), this;
  }
  /**
   * Change zoom so the height fits in the viewport
   *
   * @param {number} [height=this.worldHeight] in world coordinates
   * @param {boolean} [center] maintain the same center of the screen after zoom
   * @param {boolean} [scaleX=true] whether to set scaleX = scaleY
   * @param {boolean} [noClamp] whether to disable clamp-zoom
   * @returns {Viewport} this
   */
  fitHeight(t = this.worldHeight, e, i = !0, s) {
    let o;
    e && (o = this.center), this.scale.y = this.screenHeight / t, i && (this.scale.x = this.scale.y);
    const l = this.plugins.get("clamp-zoom", !0);
    return !s && l && l.clamp(), e && o && this.moveCenter(o), this;
  }
  /**
   * Change zoom so it fits the entire world in the viewport
   *
   * @param {boolean} center maintain the same center of the screen after zoom
   * @returns {Viewport} this
   */
  fitWorld(t) {
    let e;
    t && (e = this.center), this.scale.x = this.screenWidth / this.worldWidth, this.scale.y = this.screenHeight / this.worldHeight, this.scale.x < this.scale.y ? this.scale.y = this.scale.x : this.scale.x = this.scale.y;
    const i = this.plugins.get("clamp-zoom", !0);
    return i && i.clamp(), t && e && this.moveCenter(e), this;
  }
  /**
   * Change zoom so it fits the size or the entire world in the viewport
   *
   * @param {boolean} [center] maintain the same center of the screen after zoom
   * @param {number} [width=this.worldWidth] desired width
   * @param {number} [height=this.worldHeight] desired height
   * @returns {Viewport} this
   */
  fit(t, e = this.worldWidth, i = this.worldHeight) {
    let s;
    t && (s = this.center), this.scale.x = this.screenWidth / e, this.scale.y = this.screenHeight / i, this.scale.x < this.scale.y ? this.scale.y = this.scale.x : this.scale.x = this.scale.y;
    const o = this.plugins.get("clamp-zoom", !0);
    return o && o.clamp(), t && s && this.moveCenter(s), this;
  }
  /**
   * Zoom viewport to specific value.
   *
   * @param {number} scale value (e.g., 1 would be 100%, 0.25 would be 25%)
   * @param {boolean} [center] maintain the same center of the screen after zoom
   * @return {Viewport} this
   */
  setZoom(t, e) {
    let i;
    e && (i = this.center), this.scale.set(t);
    const s = this.plugins.get("clamp-zoom", !0);
    return s && s.clamp(), e && i && this.moveCenter(i), this;
  }
  /**
   * Zoom viewport by a certain percent (in both x and y direction).
   *
   * @param {number} percent change (e.g., 0.25 would increase a starting scale of 1.0 to 1.25)
   * @param {boolean} [center] maintain the same center of the screen after zoom
   * @return {Viewport} this
   */
  zoomPercent(t, e) {
    return this.setZoom(this.scale.x + this.scale.x * t, e);
  }
  /**
   * Zoom viewport by increasing/decreasing width by a certain number of pixels.
   *
   * @param {number} change in pixels
   * @param {boolean} [center] maintain the same center of the screen after zoom
   * @return {Viewport} this
   */
  zoom(t, e) {
    return this.fitWidth(t + this.worldScreenWidth, e), this;
  }
  /** Changes scale of viewport and maintains center of viewport */
  get scaled() {
    return this.scale.x;
  }
  set scaled(t) {
    this.setZoom(t, !0);
  }
  /**
   * Returns zoom to the desired scale
   *
   * @param {ISnapZoomOptions} options
   * @param {number} [options.width=0] - the desired width to snap (to maintain aspect ratio, choose width or height)
   * @param {number} [options.height=0] - the desired height to snap (to maintain aspect ratio, choose width or height)
   * @param {number} [options.time=1000] - time for snapping in ms
   * @param {(string|function)} [options.ease=easeInOutSine] ease function or name (see http://easings.net/
   *   for supported names)
   * @param {PIXI.Point} [options.center] - place this point at center during zoom instead of center of the viewport
   * @param {boolean} [options.interrupt=true] - pause snapping with any user input on the viewport
   * @param {boolean} [options.removeOnComplete] - removes this plugin after snapping is complete
   * @param {boolean} [options.removeOnInterrupt] - removes this plugin if interrupted by any user input
   * @param {boolean} [options.forceStart] - starts the snap immediately regardless of whether the viewport is at the
   *   desired zoom
   * @param {boolean} [options.noMove] - zoom but do not move
   */
  snapZoom(t) {
    return this.plugins.add("snap-zoom", new PO(this, t)), this;
  }
  /** Is container out of world bounds */
  OOB() {
    return {
      left: this.left < 0,
      right: this.right > this.worldWidth,
      top: this.top < 0,
      bottom: this.bottom > this.worldHeight,
      cornerPoint: new Ut(
        this.worldWidth * this.scale.x - this.screenWidth,
        this.worldHeight * this.scale.y - this.screenHeight
      )
    };
  }
  /** World coordinates of the right edge of the screen */
  get right() {
    return -this.x / this.scale.x + this.worldScreenWidth;
  }
  set right(t) {
    this.x = -t * this.scale.x + this.screenWidth, this.plugins.reset();
  }
  /** World coordinates of the left edge of the screen */
  get left() {
    return -this.x / this.scale.x;
  }
  set left(t) {
    this.x = -t * this.scale.x, this.plugins.reset();
  }
  /** World coordinates of the top edge of the screen */
  get top() {
    return -this.y / this.scale.y;
  }
  set top(t) {
    this.y = -t * this.scale.y, this.plugins.reset();
  }
  /** World coordinates of the bottom edge of the screen */
  get bottom() {
    return -this.y / this.scale.y + this.worldScreenHeight;
  }
  set bottom(t) {
    this.y = -t * this.scale.y + this.screenHeight, this.plugins.reset();
  }
  /**
   * Determines whether the viewport is dirty (i.e., needs to be rendered to the screen because of a change)
   */
  get dirty() {
    return !!this._dirty;
  }
  set dirty(t) {
    this._dirty = t;
  }
  /**
   * Permanently changes the Viewport's hitArea
   *
   * NOTE: if not set then hitArea = PIXI.Rectangle(Viewport.left, Viewport.top, Viewport.worldScreenWidth,
   * Viewport.worldScreenHeight)
   */
  get forceHitArea() {
    return this._forceHitArea;
  }
  set forceHitArea(t) {
    t ? (this._forceHitArea = t, this.hitArea = t) : (this._forceHitArea = null, this.hitArea = new ne(0, 0, this.worldWidth, this.worldHeight));
  }
  /**
   * Enable one-finger touch to drag
   *
   * NOTE: if you expect users to use right-click dragging, you should enable `viewport.options.disableOnContextMenu`
   * to avoid the context menu popping up on each right-click drag.
   *
   * @param {IDragOptions} [options]
   * @param {string} [options.direction=all] direction to drag
   * @param {boolean} [options.pressDrag=true] whether click to drag is active
   * @param {boolean} [options.wheel=true] use wheel to scroll in direction (unless wheel plugin is active)
   * @param {number} [options.wheelScroll=1] number of pixels to scroll with each wheel spin
   * @param {boolean} [options.reverse] reverse the direction of the wheel scroll
   * @param {(boolean|string)} [options.clampWheel=false] clamp wheel(to avoid weird bounce with mouse wheel)
   * @param {string} [options.underflow=center] where to place world if too small for screen
   * @param {number} [options.factor=1] factor to multiply drag to increase the speed of movement
   * @param {string} [options.mouseButtons=all] changes which mouse buttons trigger drag, use: 'all', 'left',
   *  'right' 'middle', or some combination, like, 'middle-right'; you may want to set
   *   viewport.options.disableOnContextMenu if you want to use right-click dragging
   * @param {string[]} [options.keyToPress=null] - array containing
   *  {@link key|https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code} codes of keys that can be
   *  pressed for the drag to be triggered, e.g.: ['ShiftLeft', 'ShiftRight'}.
   * @param {boolean} [options.ignoreKeyToPressOnTouch=false] - ignore keyToPress for touch events
   * @param {number} [options.lineHeight=20] - scaling factor for non-DOM_DELTA_PIXEL scrolling events
   * @returns {Viewport} this
   */
  drag(t) {
    return this.plugins.add("drag", new vO(this, t)), this;
  }
  /**
   * Clamp to world boundaries or other provided boundaries
   * There are three ways to clamp:
   * 1. direction: 'all' = the world is clamped to its world boundaries, ie, you cannot drag any part of offscreen
   *    direction: 'x' | 'y' = only the x or y direction is clamped to its world boundary
   * 2. left, right, top, bottom = true | number = the world is clamped to the world's pixel location for each side;
   *    if any of these are set to true, then the location is set to the boundary
   *    [0, viewport.worldWidth/viewport.worldHeight], eg: to allow the world to be completely dragged offscreen,
   *    set [-viewport.worldWidth, -viewport.worldHeight, viewport.worldWidth * 2, viewport.worldHeight * 2]
   *
   * Underflow determines what happens when the world is smaller than the viewport
   * 1. none = the world is clamped but there is no special behavior
   * 2. center = the world is centered on the viewport
   * 3. combination of top/bottom/center and left/right/center (case insensitive) = the world is stuck to the
   *     appropriate boundaries
   *
   * NOTES:
   *   clamp is disabled if called with no options; use { direction: 'all' } for all edge clamping
   *   screenWidth, screenHeight, worldWidth, and worldHeight needs to be set for this to work properly
   *
   * @param {object} [options]
   * @param {(number|boolean)} [options.left=false] - clamp left; true = 0
   * @param {(number|boolean)} [options.right=false] - clamp right; true = viewport.worldWidth
   * @param {(number|boolean)} [options.top=false] - clamp top; true = 0
   * @param {(number|boolean)} [options.bottom=false] - clamp bottom; true = viewport.worldHeight
   * @param {string} [direction] - (all, x, or y) using clamps of [0, viewport.worldWidth/viewport.worldHeight];
   *  replaces left/right/top/bottom if set
   * @param {string} [underflow=center] - where to place world if too small for screen (e.g., top-right, center,
   *  none, bottomLeft)     * @returns {Viewport} this
   */
  clamp(t) {
    return this.plugins.add("clamp", new fO(this, t)), this;
  }
  /**
   * Decelerate after a move
   *
   * NOTE: this fires 'moved' event during deceleration
   *
   * @param {IDecelerateOptions} [options]
   * @param {number} [options.friction=0.95] - percent to decelerate after movement
   * @param {number} [options.bounce=0.8] - percent to decelerate when past boundaries (only applicable when
   *   viewport.bounce() is active)
   * @param {number} [options.minSpeed=0.01] - minimum velocity before stopping/reversing acceleration
   * @return {Viewport} this
   */
  decelerate(t) {
    return this.plugins.add("decelerate", new yO(this, t)), this;
  }
  /**
   * Bounce on borders
   * NOTES:
   *    screenWidth, screenHeight, worldWidth, and worldHeight needs to be set for this to work properly
   *    fires 'moved', 'bounce-x-start', 'bounce-y-start', 'bounce-x-end', and 'bounce-y-end' events
   * @param {object} [options]
   * @param {string} [options.sides=all] - all, horizontal, vertical, or combination of top, bottom, right, left
   *  (e.g., 'top-bottom-right')
   * @param {number} [options.friction=0.5] - friction to apply to decelerate if active
   * @param {number} [options.time=150] - time in ms to finish bounce
   * @param {object} [options.bounceBox] - use this bounceBox instead of (0, 0, viewport.worldWidth, viewport.worldHeight)
   * @param {number} [options.bounceBox.x=0]
   * @param {number} [options.bounceBox.y=0]
   * @param {number} [options.bounceBox.width=viewport.worldWidth]
   * @param {number} [options.bounceBox.height=viewport.worldHeight]
   * @param {string|function} [options.ease=easeInOutSine] - ease function or name
   *  (see http://easings.net/ for supported names)
   * @param {string} [options.underflow=center] - (top/bottom/center and left/right/center, or center)
   *  where to place world if too small for screen
   * @return {Viewport} this
   */
  bounce(t) {
    return this.plugins.add("bounce", new hO(this, t)), this;
  }
  /**
   * Enable pinch to zoom and two-finger touch to drag
   *
   * @param {PinchOptions} [options]
   * @param {boolean} [options.noDrag] - disable two-finger dragging
   * @param {number} [options.percent=1] - percent to modify pinch speed
   * @param {number} [options.factor=1] - factor to multiply two-finger drag to increase the speed of movement
   * @param {PIXI.Point} [options.center] - place this point at center during zoom instead of center of two fingers
   * @param {('all'|'x'|'y')} [options.axis=all] - axis to zoom
   * @return {Viewport} this
   */
  pinch(t) {
    return this.plugins.add("pinch", new EO(this, t)), this;
  }
  /**
   * Snap to a point
   *
   * @param {number} x
   * @param {number} y
   * @param {ISnapOptions} [options]
   * @param {boolean} [options.topLeft] - snap to the top-left of viewport instead of center
   * @param {number} [options.friction=0.8] - friction/frame to apply if decelerate is active
   * @param {number} [options.time=1000] - time in ms to snap
   * @param {string|function} [options.ease=easeInOutSine] - ease function or name (see http://easings.net/
   *   for supported names)
   * @param {boolean} [options.interrupt=true] - pause snapping with any user input on the viewport
   * @param {boolean} [options.removeOnComplete] - removes this plugin after snapping is complete
   * @param {boolean} [options.removeOnInterrupt] - removes this plugin if interrupted by any user input
   * @param {boolean} [options.forceStart] - starts the snap immediately regardless of whether the viewport is at
   *   the desired location
   * @return {Viewport} this
   */
  snap(t, e, i) {
    return this.plugins.add("snap", new AO(this, t, e, i)), this;
  }
  /**
   * Follow a target
   *
   * NOTES:
   *    uses the (x, y) as the center to follow; for PIXI.Sprite to work properly, use sprite.anchor.set(0.5)
   *    options.acceleration is not perfect as it doesn't know the velocity of the target. It adds acceleration
   *    to the start of movement and deceleration to the end of movement when the target is stopped.
   *    To cancel the follow, use: `viewport.plugins.remove('follow')`
   *
   * @fires 'moved' event
   *
   * @param {PIXI.DisplayObject} target to follow
   * @param {IFollowOptions} [options]
   * @param {number} [options.speed=0] - to follow in pixels/frame (0=teleport to location)
   * @param {number} [options.acceleration] - set acceleration to accelerate and decelerate at this rate; speed
   *   cannot be 0 to use acceleration
   * @param {number} [options.radius] - radius (in world coordinates) of center circle where movement is allowed
   *   without moving the viewport     * @returns {Viewport} this
   * @returns {Viewport} this
   */
  follow(t, e) {
    return this.plugins.add("follow", new _O(this, t, e)), this;
  }
  /**
   * Zoom using mouse wheel
   *
   * NOTE: the default event listener for 'wheel' event is the options.events.domElement.
   *
   * @param {IWheelOptions} [options]
   * @param {number} [options.percent=0.1] - percent to scroll with each spin
   * @param {number} [options.smooth] - smooth the zooming by providing the number of frames to zoom between wheel spins
   * @param {boolean} [options.interrupt=true] - stop smoothing with any user input on the viewport
   * @param {boolean} [options.reverse] - reverse the direction of the scroll
   * @param {PIXI.Point} [options.center] - place this point at center during zoom instead of current mouse position
   * @param {number} [options.lineHeight=20] - scaling factor for non-DOM_DELTA_PIXEL scrolling events
   * @param {('all'|'x'|'y')} [options.axis=all] - axis to zoom
   * @return {Viewport} this
   */
  wheel(t) {
    return this.plugins.add("wheel", new kO(this, t)), this;
  }
  /**
   * Animate the position and/or scale of the viewport
   * To set the zoom level, use: (1) scale, (2) scaleX and scaleY, or (3) width and/or height
   * @param {object} options
   * @param {number} [options.time=1000] - time to animate
   * @param {PIXI.Point} [options.position=viewport.center] - position to move viewport
   * @param {number} [options.width] - desired viewport width in world pixels (use instead of scale;
   *  aspect ratio is maintained if height is not provided)
   * @param {number} [options.height] - desired viewport height in world pixels (use instead of scale;
   *  aspect ratio is maintained if width is not provided)
   * @param {number} [options.scale] - scale to change zoom (scale.x = scale.y)
   * @param {number} [options.scaleX] - independently change zoom in x-direction
   * @param {number} [options.scaleY] - independently change zoom in y-direction
   * @param {(function|string)} [options.ease=linear] - easing function to use
   * @param {function} [options.callbackOnComplete]
   * @param {boolean} [options.removeOnInterrupt] removes this plugin if interrupted by any user input
   * @returns {Viewport} this
   */
  animate(t) {
    return this.plugins.add("animate", new uO(this, t)), this;
  }
  /**
   * Enable clamping of zoom to constraints
   *
   * The minWidth/Height settings are how small the world can get (as it would appear on the screen)
   * before clamping. The maxWidth/maxHeight is how larger the world can scale (as it would appear on
   * the screen) before clamping.
   *
   * For example, if you have a world size of 1000 x 1000 and a screen size of 100 x 100, if you set
   * minWidth/Height = 100 then the world will not be able to zoom smaller than the screen size (ie,
   * zooming out so it appears smaller than the screen). Similarly, if you set maxWidth/Height = 100
   * the world will not be able to zoom larger than the screen size (ie, zooming in so it appears
   * larger than the screen).
   *
   * @param {object} [options]
   * @param {number} [options.minWidth] - minimum width
   * @param {number} [options.minHeight] - minimum height
   * @param {number} [options.maxWidth] - maximum width
   * @param {number} [options.maxHeight] - maximum height
   * @param {number} [options.minScale] - minimum scale
   * @param {number} [options.maxScale] - minimum scale
   * @return {Viewport} this
   */
  clampZoom(t) {
    return this.plugins.add("clamp-zoom", new mO(this, t)), this;
  }
  /**
   * Scroll viewport when mouse hovers near one of the edges or radius-distance from center of screen.
   *
   * NOTES: fires 'moved' event; there's a known bug where the mouseEdges does not work properly with "windowed" viewports
   *
   * @param {IMouseEdgesOptions} [options]
   * @param {number} [options.radius] - distance from center of screen in screen pixels
   * @param {number} [options.distance] - distance from all sides in screen pixels
   * @param {number} [options.top] - alternatively, set top distance (leave unset for no top scroll)
   * @param {number} [options.bottom] - alternatively, set bottom distance (leave unset for no top scroll)
   * @param {number} [options.left] - alternatively, set left distance (leave unset for no top scroll)
   * @param {number} [options.right] - alternatively, set right distance (leave unset for no top scroll)
   * @param {number} [options.speed=8] - speed in pixels/frame to scroll viewport
   * @param {boolean} [options.reverse] - reverse direction of scroll
   * @param {boolean} [options.noDecelerate] - don't use decelerate plugin even if it's installed
   * @param {boolean} [options.linear] - if using radius, use linear movement (+/- 1, +/- 1) instead of angled
   *   movement (Math.cos(angle from center), Math.sin(angle from center))
   * @param {boolean} [options.allowButtons] allows plugin to continue working even when there's a mousedown event
   */
  mouseEdges(t) {
    return this.plugins.add("mouse-edges", new TO(this, t)), this;
  }
  /** Pause viewport (including animation updates such as decelerate) */
  get pause() {
    return !!this._pause;
  }
  set pause(t) {
    this._pause = t, this.lastViewport = null, this.moving = !1, this.zooming = !1, t && this.input.pause();
  }
  /**
   * Move the viewport so the bounding box is visible
   *
   * @param x - left
   * @param y - top
   * @param width
   * @param height
   * @param resizeToFit - Resize the viewport so the box fits within the viewport
   */
  ensureVisible(t, e, i, s, o) {
    o && (i > this.worldScreenWidth || s > this.worldScreenHeight) && (this.fit(!0, i, s), this.emit("zoomed", { viewport: this, type: "ensureVisible" }));
    let l = !1;
    t < this.left ? (this.left = t, l = !0) : t + i > this.right && (this.right = t + i, l = !0), e < this.top ? (this.top = e, l = !0) : e + s > this.bottom && (this.bottom = e + s, l = !0), l && this.emit("moved", { viewport: this, type: "ensureVisible" });
  }
}
const GO = ({ cells: n, rows: t, cols: e, onCellClick: i }) => {
  const s = O.useRef(null), o = O.useRef(null), l = O.useRef(null), [c, d] = O.useState(!1), f = O.useRef({
    active: !1,
    alreadyDoneCells: /* @__PURE__ */ new Set()
  }), m = O.useRef(/* @__PURE__ */ new Map());
  O.useEffect(() => (b(), () => {
    if (s.current) {
      const x = document.getElementById("pixi-container");
      x && s.current.canvas && x.removeChild(s.current.canvas), s.current.destroy();
    }
  }), []), O.useEffect(() => {
    c && y();
  }, [n, c]);
  const y = () => {
    o.current && (m.current.forEach((x) => {
      o.current.removeChild(x), x.destroy();
    }), m.current.clear(), n.forEach((x) => {
      v(x);
    }));
  }, b = async () => {
    const x = new Y1(), S = new Rn();
    x.stage.interactive = !0, s.current = x, await x.init({
      background: 5719350,
      resizeTo: window
    });
    const _ = document.getElementById("pixi-container");
    _ && _.appendChild(x.canvas);
    const C = new DO({
      screenWidth: window.innerWidth,
      screenHeight: window.innerHeight,
      worldWidth: 1e3,
      worldHeight: 1e3,
      events: x.renderer.events
    });
    C.clampZoom({
      minScale: 0.05,
      maxScale: 3
    }), x.stage.addChild(C), C.drag().pinch().wheel().decelerate(), o.current = S, l.current = C, C.addChild(S), C.setZoom(1), window.addEventListener("resize", () => {
      C.resize(window.innerWidth, window.innerHeight, e * 110, t * 110), C.moveCenter(e * 110 / 2, t * 110 / 2);
    }), C.moveCenter(e * 110 / 2, t * 110 / 2), window.addEventListener("mouseup", (R) => {
      f.current.active = !1, f.current.alreadyDoneCells.clear(), l.current.plugins.resume("drag"), l.current.plugins.resume("pinch"), l.current.plugins.resume("wheel");
    }), d(!0);
  }, v = (x) => {
    const S = m.current.get(x.id);
    if (S)
      return S;
    const _ = 100, C = new $l();
    C.rect(0, 0, _, _), C.fill(x.state === 1 ? 2316116 : 3966), C.interactive = !0, C.buttonMode = !0, C.x = x.row * (_ + 10), C.y = x.col * (_ + 10), C.on("pointerdown", () => {
      f.current.active = !0, i && (i(x.id), f.current.alreadyDoneCells.add(x.id), l.current.plugins.pause("drag"), l.current.plugins.pause("pinch"), l.current.plugins.pause("wheel"));
    }), C.on("pointerover", () => {
      C.alpha = 0.7, f.current.active && !f.current.alreadyDoneCells.has(x.id) && (i(x.id), f.current.alreadyDoneCells.add(x.id));
    }), C.on("pointerout", () => {
      C.alpha = 1;
    }), m.current.set(x.id, C), o.current.addChild(C);
  };
  return /* @__PURE__ */ et.jsx("div", { id: "pixi-container", className: "w-full h-full" });
}, Wl = {
  black: "#000",
  white: "#fff"
}, Aa = {
  300: "#e57373",
  400: "#ef5350",
  500: "#f44336",
  700: "#d32f2f",
  800: "#c62828"
}, Ra = {
  50: "#f3e5f5",
  200: "#ce93d8",
  300: "#ba68c8",
  400: "#ab47bc",
  500: "#9c27b0",
  700: "#7b1fa2"
}, Pa = {
  50: "#e3f2fd",
  200: "#90caf9",
  400: "#42a5f5",
  700: "#1976d2",
  800: "#1565c0"
}, Ba = {
  300: "#4fc3f7",
  400: "#29b6f6",
  500: "#03a9f4",
  700: "#0288d1",
  900: "#01579b"
}, ka = {
  300: "#81c784",
  400: "#66bb6a",
  500: "#4caf50",
  700: "#388e3c",
  800: "#2e7d32",
  900: "#1b5e20"
}, hl = {
  300: "#ffb74d",
  400: "#ffa726",
  500: "#ff9800",
  700: "#f57c00",
  900: "#e65100"
}, UO = {
  50: "#fafafa",
  100: "#f5f5f5",
  200: "#eeeeee",
  300: "#e0e0e0",
  400: "#bdbdbd",
  500: "#9e9e9e",
  600: "#757575",
  700: "#616161",
  800: "#424242",
  900: "#212121",
  A100: "#f5f5f5",
  A200: "#eeeeee",
  A400: "#bdbdbd",
  A700: "#616161"
};
function _r(n, ...t) {
  const e = new URL(`https://mui.com/production-error/?code=${n}`);
  return t.forEach((i) => e.searchParams.append("args[]", i)), `Minified MUI error #${n}; visit ${e} for the full message.`;
}
const Gg = "$$material";
function uh() {
  return uh = Object.assign ? Object.assign.bind() : function(n) {
    for (var t = 1; t < arguments.length; t++) {
      var e = arguments[t];
      for (var i in e) ({}).hasOwnProperty.call(e, i) && (n[i] = e[i]);
    }
    return n;
  }, uh.apply(null, arguments);
}
function NO(n) {
  if (n.sheet)
    return n.sheet;
  for (var t = 0; t < document.styleSheets.length; t++)
    if (document.styleSheets[t].ownerNode === n)
      return document.styleSheets[t];
}
function IO(n) {
  var t = document.createElement("style");
  return t.setAttribute("data-emotion", n.key), n.nonce !== void 0 && t.setAttribute("nonce", n.nonce), t.appendChild(document.createTextNode("")), t.setAttribute("data-s", ""), t;
}
var zO = /* @__PURE__ */ (function() {
  function n(e) {
    var i = this;
    this._insertTag = function(s) {
      var o;
      i.tags.length === 0 ? i.insertionPoint ? o = i.insertionPoint.nextSibling : i.prepend ? o = i.container.firstChild : o = i.before : o = i.tags[i.tags.length - 1].nextSibling, i.container.insertBefore(s, o), i.tags.push(s);
    }, this.isSpeedy = e.speedy === void 0 ? !0 : e.speedy, this.tags = [], this.ctr = 0, this.nonce = e.nonce, this.key = e.key, this.container = e.container, this.prepend = e.prepend, this.insertionPoint = e.insertionPoint, this.before = null;
  }
  var t = n.prototype;
  return t.hydrate = function(i) {
    i.forEach(this._insertTag);
  }, t.insert = function(i) {
    this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(IO(this));
    var s = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var o = NO(s);
      try {
        o.insertRule(i, o.cssRules.length);
      } catch {
      }
    } else
      s.appendChild(document.createTextNode(i));
    this.ctr++;
  }, t.flush = function() {
    this.tags.forEach(function(i) {
      var s;
      return (s = i.parentNode) == null ? void 0 : s.removeChild(i);
    }), this.tags = [], this.ctr = 0;
  }, n;
})(), xn = "-ms-", ch = "-moz-", re = "-webkit-", uC = "comm", Ug = "rule", Ng = "decl", LO = "@import", cC = "@keyframes", FO = "@layer", HO = Math.abs, Mh = String.fromCharCode, $O = Object.assign;
function WO(n, t) {
  return gn(n, 0) ^ 45 ? (((t << 2 ^ gn(n, 0)) << 2 ^ gn(n, 1)) << 2 ^ gn(n, 2)) << 2 ^ gn(n, 3) : 0;
}
function hC(n) {
  return n.trim();
}
function VO(n, t) {
  return (n = t.exec(n)) ? n[0] : n;
}
function se(n, t, e) {
  return n.replace(t, e);
}
function Om(n, t) {
  return n.indexOf(t);
}
function gn(n, t) {
  return n.charCodeAt(t) | 0;
}
function Vl(n, t, e) {
  return n.slice(t, e);
}
function Ii(n) {
  return n.length;
}
function Ig(n) {
  return n.length;
}
function Uc(n, t) {
  return t.push(n), n;
}
function jO(n, t) {
  return n.map(t).join("");
}
var Ah = 1, Za = 1, dC = 0, In = 0, Ze = 0, no = "";
function Rh(n, t, e, i, s, o, l) {
  return { value: n, root: t, parent: e, type: i, props: s, children: o, line: Ah, column: Za, length: l, return: "" };
}
function dl(n, t) {
  return $O(Rh("", null, null, "", null, null, 0), n, { length: -n.length }, t);
}
function YO() {
  return Ze;
}
function XO() {
  return Ze = In > 0 ? gn(no, --In) : 0, Za--, Ze === 10 && (Za = 1, Ah--), Ze;
}
function Qn() {
  return Ze = In < dC ? gn(no, In++) : 0, Za++, Ze === 10 && (Za = 1, Ah++), Ze;
}
function Hi() {
  return gn(no, In);
}
function Kc() {
  return In;
}
function eu(n, t) {
  return Vl(no, n, t);
}
function jl(n) {
  switch (n) {
    // \0 \t \n \r \s whitespace token
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    // ! + , / > @ ~ isolate token
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    // ; { } breakpoint token
    case 59:
    case 123:
    case 125:
      return 4;
    // : accompanied token
    case 58:
      return 3;
    // " ' ( [ opening delimit token
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    // ) ] closing delimit token
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function fC(n) {
  return Ah = Za = 1, dC = Ii(no = n), In = 0, [];
}
function pC(n) {
  return no = "", n;
}
function Zc(n) {
  return hC(eu(In - 1, Dm(n === 91 ? n + 2 : n === 40 ? n + 1 : n)));
}
function qO(n) {
  for (; (Ze = Hi()) && Ze < 33; )
    Qn();
  return jl(n) > 2 || jl(Ze) > 3 ? "" : " ";
}
function KO(n, t) {
  for (; --t && Qn() && !(Ze < 48 || Ze > 102 || Ze > 57 && Ze < 65 || Ze > 70 && Ze < 97); )
    ;
  return eu(n, Kc() + (t < 6 && Hi() == 32 && Qn() == 32));
}
function Dm(n) {
  for (; Qn(); )
    switch (Ze) {
      // ] ) " '
      case n:
        return In;
      // " '
      case 34:
      case 39:
        n !== 34 && n !== 39 && Dm(Ze);
        break;
      // (
      case 40:
        n === 41 && Dm(n);
        break;
      // \
      case 92:
        Qn();
        break;
    }
  return In;
}
function ZO(n, t) {
  for (; Qn() && n + Ze !== 57; )
    if (n + Ze === 84 && Hi() === 47)
      break;
  return "/*" + eu(t, In - 1) + "*" + Mh(n === 47 ? n : Qn());
}
function QO(n) {
  for (; !jl(Hi()); )
    Qn();
  return eu(n, In);
}
function JO(n) {
  return pC(Qc("", null, null, null, [""], n = fC(n), 0, [0], n));
}
function Qc(n, t, e, i, s, o, l, c, d) {
  for (var f = 0, m = 0, y = l, b = 0, v = 0, x = 0, S = 1, _ = 1, C = 1, R = 0, w = "", E = s, P = o, k = i, G = w; _; )
    switch (x = R, R = Qn()) {
      // (
      case 40:
        if (x != 108 && gn(G, y - 1) == 58) {
          Om(G += se(Zc(R), "&", "&\f"), "&\f") != -1 && (C = -1);
          break;
        }
      // " ' [
      case 34:
      case 39:
      case 91:
        G += Zc(R);
        break;
      // \t \n \r \s
      case 9:
      case 10:
      case 13:
      case 32:
        G += qO(x);
        break;
      // \
      case 92:
        G += KO(Kc() - 1, 7);
        continue;
      // /
      case 47:
        switch (Hi()) {
          case 42:
          case 47:
            Uc(tD(ZO(Qn(), Kc()), t, e), d);
            break;
          default:
            G += "/";
        }
        break;
      // {
      case 123 * S:
        c[f++] = Ii(G) * C;
      // } ; \0
      case 125 * S:
      case 59:
      case 0:
        switch (R) {
          // \0 }
          case 0:
          case 125:
            _ = 0;
          // ;
          case 59 + m:
            C == -1 && (G = se(G, /\f/g, "")), v > 0 && Ii(G) - y && Uc(v > 32 ? $0(G + ";", i, e, y - 1) : $0(se(G, " ", "") + ";", i, e, y - 2), d);
            break;
          // @ ;
          case 59:
            G += ";";
          // { rule/at-rule
          default:
            if (Uc(k = H0(G, t, e, f, m, s, c, w, E = [], P = [], y), o), R === 123)
              if (m === 0)
                Qc(G, t, k, k, E, o, y, c, P);
              else
                switch (b === 99 && gn(G, 3) === 110 ? 100 : b) {
                  // d l m s
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    Qc(n, k, k, i && Uc(H0(n, k, k, 0, 0, s, c, w, s, E = [], y), P), s, P, y, c, i ? E : P);
                    break;
                  default:
                    Qc(G, k, k, k, [""], P, 0, c, P);
                }
        }
        f = m = v = 0, S = C = 1, w = G = "", y = l;
        break;
      // :
      case 58:
        y = 1 + Ii(G), v = x;
      default:
        if (S < 1) {
          if (R == 123)
            --S;
          else if (R == 125 && S++ == 0 && XO() == 125)
            continue;
        }
        switch (G += Mh(R), R * S) {
          // &
          case 38:
            C = m > 0 ? 1 : (G += "\f", -1);
            break;
          // ,
          case 44:
            c[f++] = (Ii(G) - 1) * C, C = 1;
            break;
          // @
          case 64:
            Hi() === 45 && (G += Zc(Qn())), b = Hi(), m = y = Ii(w = G += QO(Kc())), R++;
            break;
          // -
          case 45:
            x === 45 && Ii(G) == 2 && (S = 0);
        }
    }
  return o;
}
function H0(n, t, e, i, s, o, l, c, d, f, m) {
  for (var y = s - 1, b = s === 0 ? o : [""], v = Ig(b), x = 0, S = 0, _ = 0; x < i; ++x)
    for (var C = 0, R = Vl(n, y + 1, y = HO(S = l[x])), w = n; C < v; ++C)
      (w = hC(S > 0 ? b[C] + " " + R : se(R, /&\f/g, b[C]))) && (d[_++] = w);
  return Rh(n, t, e, s === 0 ? Ug : c, d, f, m);
}
function tD(n, t, e) {
  return Rh(n, t, e, uC, Mh(YO()), Vl(n, 2, -2), 0);
}
function $0(n, t, e, i) {
  return Rh(n, t, e, Ng, Vl(n, 0, i), Vl(n, i + 1, -1), i);
}
function Ha(n, t) {
  for (var e = "", i = Ig(n), s = 0; s < i; s++)
    e += t(n[s], s, n, t) || "";
  return e;
}
function eD(n, t, e, i) {
  switch (n.type) {
    case FO:
      if (n.children.length) break;
    case LO:
    case Ng:
      return n.return = n.return || n.value;
    case uC:
      return "";
    case cC:
      return n.return = n.value + "{" + Ha(n.children, i) + "}";
    case Ug:
      n.value = n.props.join(",");
  }
  return Ii(e = Ha(n.children, i)) ? n.return = n.value + "{" + e + "}" : "";
}
function nD(n) {
  var t = Ig(n);
  return function(e, i, s, o) {
    for (var l = "", c = 0; c < t; c++)
      l += n[c](e, i, s, o) || "";
    return l;
  };
}
function iD(n) {
  return function(t) {
    t.root || (t = t.return) && n(t);
  };
}
function mC(n) {
  var t = /* @__PURE__ */ Object.create(null);
  return function(e) {
    return t[e] === void 0 && (t[e] = n(e)), t[e];
  };
}
var rD = function(t, e, i) {
  for (var s = 0, o = 0; s = o, o = Hi(), s === 38 && o === 12 && (e[i] = 1), !jl(o); )
    Qn();
  return eu(t, In);
}, sD = function(t, e) {
  var i = -1, s = 44;
  do
    switch (jl(s)) {
      case 0:
        s === 38 && Hi() === 12 && (e[i] = 1), t[i] += rD(In - 1, e, i);
        break;
      case 2:
        t[i] += Zc(s);
        break;
      case 4:
        if (s === 44) {
          t[++i] = Hi() === 58 ? "&\f" : "", e[i] = t[i].length;
          break;
        }
      // fallthrough
      default:
        t[i] += Mh(s);
    }
  while (s = Qn());
  return t;
}, aD = function(t, e) {
  return pC(sD(fC(t), e));
}, W0 = /* @__PURE__ */ new WeakMap(), oD = function(t) {
  if (!(t.type !== "rule" || !t.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  t.length < 1)) {
    for (var e = t.value, i = t.parent, s = t.column === i.column && t.line === i.line; i.type !== "rule"; )
      if (i = i.parent, !i) return;
    if (!(t.props.length === 1 && e.charCodeAt(0) !== 58 && !W0.get(i)) && !s) {
      W0.set(t, !0);
      for (var o = [], l = aD(e, o), c = i.props, d = 0, f = 0; d < l.length; d++)
        for (var m = 0; m < c.length; m++, f++)
          t.props[f] = o[d] ? l[d].replace(/&\f/g, c[m]) : c[m] + " " + l[d];
    }
  }
}, lD = function(t) {
  if (t.type === "decl") {
    var e = t.value;
    // charcode for l
    e.charCodeAt(0) === 108 && // charcode for b
    e.charCodeAt(2) === 98 && (t.return = "", t.value = "");
  }
};
function gC(n, t) {
  switch (WO(n, t)) {
    // color-adjust
    case 5103:
      return re + "print-" + n + n;
    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return re + n + n;
    // appearance, user-select, transform, hyphens, text-size-adjust
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return re + n + ch + n + xn + n + n;
    // flex, flex-direction
    case 6828:
    case 4268:
      return re + n + xn + n + n;
    // order
    case 6165:
      return re + n + xn + "flex-" + n + n;
    // align-items
    case 5187:
      return re + n + se(n, /(\w+).+(:[^]+)/, re + "box-$1$2" + xn + "flex-$1$2") + n;
    // align-self
    case 5443:
      return re + n + xn + "flex-item-" + se(n, /flex-|-self/, "") + n;
    // align-content
    case 4675:
      return re + n + xn + "flex-line-pack" + se(n, /align-content|flex-|-self/, "") + n;
    // flex-shrink
    case 5548:
      return re + n + xn + se(n, "shrink", "negative") + n;
    // flex-basis
    case 5292:
      return re + n + xn + se(n, "basis", "preferred-size") + n;
    // flex-grow
    case 6060:
      return re + "box-" + se(n, "-grow", "") + re + n + xn + se(n, "grow", "positive") + n;
    // transition
    case 4554:
      return re + se(n, /([^-])(transform)/g, "$1" + re + "$2") + n;
    // cursor
    case 6187:
      return se(se(se(n, /(zoom-|grab)/, re + "$1"), /(image-set)/, re + "$1"), n, "") + n;
    // background, background-image
    case 5495:
    case 3959:
      return se(n, /(image-set\([^]*)/, re + "$1$`$1");
    // justify-content
    case 4968:
      return se(se(n, /(.+:)(flex-)?(.*)/, re + "box-pack:$3" + xn + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + re + n + n;
    // (margin|padding)-inline-(start|end)
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return se(n, /(.+)-inline(.+)/, re + "$1$2") + n;
    // (min|max)?(width|height|inline-size|block-size)
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (Ii(n) - 1 - t > 6) switch (gn(n, t + 1)) {
        // (m)ax-content, (m)in-content
        case 109:
          if (gn(n, t + 4) !== 45) break;
        // (f)ill-available, (f)it-content
        case 102:
          return se(n, /(.+:)(.+)-([^]+)/, "$1" + re + "$2-$3$1" + ch + (gn(n, t + 3) == 108 ? "$3" : "$2-$3")) + n;
        // (s)tretch
        case 115:
          return ~Om(n, "stretch") ? gC(se(n, "stretch", "fill-available"), t) + n : n;
      }
      break;
    // position: sticky
    case 4949:
      if (gn(n, t + 1) !== 115) break;
    // display: (flex|inline-flex)
    case 6444:
      switch (gn(n, Ii(n) - 3 - (~Om(n, "!important") && 10))) {
        // stic(k)y
        case 107:
          return se(n, ":", ":" + re) + n;
        // (inline-)?fl(e)x
        case 101:
          return se(n, /(.+:)([^;!]+)(;|!.+)?/, "$1" + re + (gn(n, 14) === 45 ? "inline-" : "") + "box$3$1" + re + "$2$3$1" + xn + "$2box$3") + n;
      }
      break;
    // writing-mode
    case 5936:
      switch (gn(n, t + 11)) {
        // vertical-l(r)
        case 114:
          return re + n + xn + se(n, /[svh]\w+-[tblr]{2}/, "tb") + n;
        // vertical-r(l)
        case 108:
          return re + n + xn + se(n, /[svh]\w+-[tblr]{2}/, "tb-rl") + n;
        // horizontal(-)tb
        case 45:
          return re + n + xn + se(n, /[svh]\w+-[tblr]{2}/, "lr") + n;
      }
      return re + n + xn + n + n;
  }
  return n;
}
var uD = function(t, e, i, s) {
  if (t.length > -1 && !t.return) switch (t.type) {
    case Ng:
      t.return = gC(t.value, t.length);
      break;
    case cC:
      return Ha([dl(t, {
        value: se(t.value, "@", "@" + re)
      })], s);
    case Ug:
      if (t.length) return jO(t.props, function(o) {
        switch (VO(o, /(::plac\w+|:read-\w+)/)) {
          // :read-(only|write)
          case ":read-only":
          case ":read-write":
            return Ha([dl(t, {
              props: [se(o, /:(read-\w+)/, ":" + ch + "$1")]
            })], s);
          // :placeholder
          case "::placeholder":
            return Ha([dl(t, {
              props: [se(o, /:(plac\w+)/, ":" + re + "input-$1")]
            }), dl(t, {
              props: [se(o, /:(plac\w+)/, ":" + ch + "$1")]
            }), dl(t, {
              props: [se(o, /:(plac\w+)/, xn + "input-$1")]
            })], s);
        }
        return "";
      });
  }
}, cD = [uD], hD = function(t) {
  var e = t.key;
  if (e === "css") {
    var i = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(i, function(S) {
      var _ = S.getAttribute("data-emotion");
      _.indexOf(" ") !== -1 && (document.head.appendChild(S), S.setAttribute("data-s", ""));
    });
  }
  var s = t.stylisPlugins || cD, o = {}, l, c = [];
  l = t.container || document.head, Array.prototype.forEach.call(
    // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll('style[data-emotion^="' + e + ' "]'),
    function(S) {
      for (var _ = S.getAttribute("data-emotion").split(" "), C = 1; C < _.length; C++)
        o[_[C]] = !0;
      c.push(S);
    }
  );
  var d, f = [oD, lD];
  {
    var m, y = [eD, iD(function(S) {
      m.insert(S);
    })], b = nD(f.concat(s, y)), v = function(_) {
      return Ha(JO(_), b);
    };
    d = function(_, C, R, w) {
      m = R, v(_ ? _ + "{" + C.styles + "}" : C.styles), w && (x.inserted[C.name] = !0);
    };
  }
  var x = {
    key: e,
    sheet: new zO({
      key: e,
      container: l,
      nonce: t.nonce,
      speedy: t.speedy,
      prepend: t.prepend,
      insertionPoint: t.insertionPoint
    }),
    nonce: t.nonce,
    inserted: o,
    registered: {},
    insert: d
  };
  return x.sheet.hydrate(c), x;
}, Xp = { exports: {} }, oe = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var V0;
function dD() {
  if (V0) return oe;
  V0 = 1;
  var n = typeof Symbol == "function" && Symbol.for, t = n ? Symbol.for("react.element") : 60103, e = n ? Symbol.for("react.portal") : 60106, i = n ? Symbol.for("react.fragment") : 60107, s = n ? Symbol.for("react.strict_mode") : 60108, o = n ? Symbol.for("react.profiler") : 60114, l = n ? Symbol.for("react.provider") : 60109, c = n ? Symbol.for("react.context") : 60110, d = n ? Symbol.for("react.async_mode") : 60111, f = n ? Symbol.for("react.concurrent_mode") : 60111, m = n ? Symbol.for("react.forward_ref") : 60112, y = n ? Symbol.for("react.suspense") : 60113, b = n ? Symbol.for("react.suspense_list") : 60120, v = n ? Symbol.for("react.memo") : 60115, x = n ? Symbol.for("react.lazy") : 60116, S = n ? Symbol.for("react.block") : 60121, _ = n ? Symbol.for("react.fundamental") : 60117, C = n ? Symbol.for("react.responder") : 60118, R = n ? Symbol.for("react.scope") : 60119;
  function w(P) {
    if (typeof P == "object" && P !== null) {
      var k = P.$$typeof;
      switch (k) {
        case t:
          switch (P = P.type, P) {
            case d:
            case f:
            case i:
            case o:
            case s:
            case y:
              return P;
            default:
              switch (P = P && P.$$typeof, P) {
                case c:
                case m:
                case x:
                case v:
                case l:
                  return P;
                default:
                  return k;
              }
          }
        case e:
          return k;
      }
    }
  }
  function E(P) {
    return w(P) === f;
  }
  return oe.AsyncMode = d, oe.ConcurrentMode = f, oe.ContextConsumer = c, oe.ContextProvider = l, oe.Element = t, oe.ForwardRef = m, oe.Fragment = i, oe.Lazy = x, oe.Memo = v, oe.Portal = e, oe.Profiler = o, oe.StrictMode = s, oe.Suspense = y, oe.isAsyncMode = function(P) {
    return E(P) || w(P) === d;
  }, oe.isConcurrentMode = E, oe.isContextConsumer = function(P) {
    return w(P) === c;
  }, oe.isContextProvider = function(P) {
    return w(P) === l;
  }, oe.isElement = function(P) {
    return typeof P == "object" && P !== null && P.$$typeof === t;
  }, oe.isForwardRef = function(P) {
    return w(P) === m;
  }, oe.isFragment = function(P) {
    return w(P) === i;
  }, oe.isLazy = function(P) {
    return w(P) === x;
  }, oe.isMemo = function(P) {
    return w(P) === v;
  }, oe.isPortal = function(P) {
    return w(P) === e;
  }, oe.isProfiler = function(P) {
    return w(P) === o;
  }, oe.isStrictMode = function(P) {
    return w(P) === s;
  }, oe.isSuspense = function(P) {
    return w(P) === y;
  }, oe.isValidElementType = function(P) {
    return typeof P == "string" || typeof P == "function" || P === i || P === f || P === o || P === s || P === y || P === b || typeof P == "object" && P !== null && (P.$$typeof === x || P.$$typeof === v || P.$$typeof === l || P.$$typeof === c || P.$$typeof === m || P.$$typeof === _ || P.$$typeof === C || P.$$typeof === R || P.$$typeof === S);
  }, oe.typeOf = w, oe;
}
var j0;
function fD() {
  return j0 || (j0 = 1, Xp.exports = dD()), Xp.exports;
}
var qp, Y0;
function pD() {
  if (Y0) return qp;
  Y0 = 1;
  var n = fD(), t = {
    childContextTypes: !0,
    contextType: !0,
    contextTypes: !0,
    defaultProps: !0,
    displayName: !0,
    getDefaultProps: !0,
    getDerivedStateFromError: !0,
    getDerivedStateFromProps: !0,
    mixins: !0,
    propTypes: !0,
    type: !0
  }, e = {
    name: !0,
    length: !0,
    prototype: !0,
    caller: !0,
    callee: !0,
    arguments: !0,
    arity: !0
  }, i = {
    $$typeof: !0,
    render: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0
  }, s = {
    $$typeof: !0,
    compare: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0,
    type: !0
  }, o = {};
  o[n.ForwardRef] = i, o[n.Memo] = s;
  function l(x) {
    return n.isMemo(x) ? s : o[x.$$typeof] || t;
  }
  var c = Object.defineProperty, d = Object.getOwnPropertyNames, f = Object.getOwnPropertySymbols, m = Object.getOwnPropertyDescriptor, y = Object.getPrototypeOf, b = Object.prototype;
  function v(x, S, _) {
    if (typeof S != "string") {
      if (b) {
        var C = y(S);
        C && C !== b && v(x, C, _);
      }
      var R = d(S);
      f && (R = R.concat(f(S)));
      for (var w = l(x), E = l(S), P = 0; P < R.length; ++P) {
        var k = R[P];
        if (!e[k] && !(_ && _[k]) && !(E && E[k]) && !(w && w[k])) {
          var G = m(S, k);
          try {
            c(x, k, G);
          } catch {
          }
        }
      }
    }
    return x;
  }
  return qp = v, qp;
}
pD();
var mD = !0;
function yC(n, t, e) {
  var i = "";
  return e.split(" ").forEach(function(s) {
    n[s] !== void 0 ? t.push(n[s] + ";") : s && (i += s + " ");
  }), i;
}
var zg = function(t, e, i) {
  var s = t.key + "-" + e.name;
  // we only need to add the styles to the registered cache if the
  // class name could be used further down
  // the tree but if it's a string tag, we know it won't
  // so we don't have to add it to registered cache.
  // this improves memory usage since we can avoid storing the whole style string
  (i === !1 || // we need to always store it if we're in compat mode and
  // in node since emotion-server relies on whether a style is in
  // the registered cache to know whether a style is global or not
  // also, note that this check will be dead code eliminated in the browser
  mD === !1) && t.registered[s] === void 0 && (t.registered[s] = e.styles);
}, Lg = function(t, e, i) {
  zg(t, e, i);
  var s = t.key + "-" + e.name;
  if (t.inserted[e.name] === void 0) {
    var o = e;
    do
      t.insert(e === o ? "." + s : "", o, t.sheet, !0), o = o.next;
    while (o !== void 0);
  }
};
function gD(n) {
  for (var t = 0, e, i = 0, s = n.length; s >= 4; ++i, s -= 4)
    e = n.charCodeAt(i) & 255 | (n.charCodeAt(++i) & 255) << 8 | (n.charCodeAt(++i) & 255) << 16 | (n.charCodeAt(++i) & 255) << 24, e = /* Math.imul(k, m): */
    (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16), e ^= /* k >>> r: */
    e >>> 24, t = /* Math.imul(k, m): */
    (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  switch (s) {
    case 3:
      t ^= (n.charCodeAt(i + 2) & 255) << 16;
    case 2:
      t ^= (n.charCodeAt(i + 1) & 255) << 8;
    case 1:
      t ^= n.charCodeAt(i) & 255, t = /* Math.imul(h, m): */
      (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  }
  return t ^= t >>> 13, t = /* Math.imul(h, m): */
  (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), ((t ^ t >>> 15) >>> 0).toString(36);
}
var yD = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, bD = /[A-Z]|^ms/g, vD = /_EMO_([^_]+?)_([^]*?)_EMO_/g, bC = function(t) {
  return t.charCodeAt(1) === 45;
}, X0 = function(t) {
  return t != null && typeof t != "boolean";
}, Kp = /* @__PURE__ */ mC(function(n) {
  return bC(n) ? n : n.replace(bD, "-$&").toLowerCase();
}), q0 = function(t, e) {
  switch (t) {
    case "animation":
    case "animationName":
      if (typeof e == "string")
        return e.replace(vD, function(i, s, o) {
          return zi = {
            name: s,
            styles: o,
            next: zi
          }, s;
        });
  }
  return yD[t] !== 1 && !bC(t) && typeof e == "number" && e !== 0 ? e + "px" : e;
};
function Yl(n, t, e) {
  if (e == null)
    return "";
  var i = e;
  if (i.__emotion_styles !== void 0)
    return i;
  switch (typeof e) {
    case "boolean":
      return "";
    case "object": {
      var s = e;
      if (s.anim === 1)
        return zi = {
          name: s.name,
          styles: s.styles,
          next: zi
        }, s.name;
      var o = e;
      if (o.styles !== void 0) {
        var l = o.next;
        if (l !== void 0)
          for (; l !== void 0; )
            zi = {
              name: l.name,
              styles: l.styles,
              next: zi
            }, l = l.next;
        var c = o.styles + ";";
        return c;
      }
      return xD(n, t, e);
    }
    case "function": {
      if (n !== void 0) {
        var d = zi, f = e(n);
        return zi = d, Yl(n, t, f);
      }
      break;
    }
  }
  var m = e;
  if (t == null)
    return m;
  var y = t[m];
  return y !== void 0 ? y : m;
}
function xD(n, t, e) {
  var i = "";
  if (Array.isArray(e))
    for (var s = 0; s < e.length; s++)
      i += Yl(n, t, e[s]) + ";";
  else
    for (var o in e) {
      var l = e[o];
      if (typeof l != "object") {
        var c = l;
        t != null && t[c] !== void 0 ? i += o + "{" + t[c] + "}" : X0(c) && (i += Kp(o) + ":" + q0(o, c) + ";");
      } else if (Array.isArray(l) && typeof l[0] == "string" && (t == null || t[l[0]] === void 0))
        for (var d = 0; d < l.length; d++)
          X0(l[d]) && (i += Kp(o) + ":" + q0(o, l[d]) + ";");
      else {
        var f = Yl(n, t, l);
        switch (o) {
          case "animation":
          case "animationName": {
            i += Kp(o) + ":" + f + ";";
            break;
          }
          default:
            i += o + "{" + f + "}";
        }
      }
    }
  return i;
}
var K0 = /label:\s*([^\s;{]+)\s*(;|$)/g, zi;
function nu(n, t, e) {
  if (n.length === 1 && typeof n[0] == "object" && n[0] !== null && n[0].styles !== void 0)
    return n[0];
  var i = !0, s = "";
  zi = void 0;
  var o = n[0];
  if (o == null || o.raw === void 0)
    i = !1, s += Yl(e, t, o);
  else {
    var l = o;
    s += l[0];
  }
  for (var c = 1; c < n.length; c++)
    if (s += Yl(e, t, n[c]), i) {
      var d = o;
      s += d[c];
    }
  K0.lastIndex = 0;
  for (var f = "", m; (m = K0.exec(s)) !== null; )
    f += "-" + m[1];
  var y = gD(s) + f;
  return {
    name: y,
    styles: s,
    next: zi
  };
}
var _D = function(t) {
  return t();
}, vC = am.useInsertionEffect ? am.useInsertionEffect : !1, xC = vC || _D, Z0 = vC || O.useLayoutEffect, _C = /* @__PURE__ */ O.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement < "u" ? /* @__PURE__ */ hD({
    key: "css"
  }) : null
);
_C.Provider;
var Fg = function(t) {
  return /* @__PURE__ */ O.forwardRef(function(e, i) {
    var s = O.useContext(_C);
    return t(e, s, i);
  });
}, Ph = /* @__PURE__ */ O.createContext({}), Hg = {}.hasOwnProperty, Gm = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__", SD = function(t, e) {
  var i = {};
  for (var s in e)
    Hg.call(e, s) && (i[s] = e[s]);
  return i[Gm] = t, i;
}, TD = function(t) {
  var e = t.cache, i = t.serialized, s = t.isStringTag;
  return zg(e, i, s), xC(function() {
    return Lg(e, i, s);
  }), null;
}, wD = /* @__PURE__ */ Fg(function(n, t, e) {
  var i = n.css;
  typeof i == "string" && t.registered[i] !== void 0 && (i = t.registered[i]);
  var s = n[Gm], o = [i], l = "";
  typeof n.className == "string" ? l = yC(t.registered, o, n.className) : n.className != null && (l = n.className + " ");
  var c = nu(o, void 0, O.useContext(Ph));
  l += t.key + "-" + c.name;
  var d = {};
  for (var f in n)
    Hg.call(n, f) && f !== "css" && f !== Gm && (d[f] = n[f]);
  return d.className = l, e && (d.ref = e), /* @__PURE__ */ O.createElement(O.Fragment, null, /* @__PURE__ */ O.createElement(TD, {
    cache: t,
    serialized: c,
    isStringTag: typeof s == "string"
  }), /* @__PURE__ */ O.createElement(s, d));
}), CD = wD, Q0 = function(t, e) {
  var i = arguments;
  if (e == null || !Hg.call(e, "css"))
    return O.createElement.apply(void 0, i);
  var s = i.length, o = new Array(s);
  o[0] = CD, o[1] = SD(t, e);
  for (var l = 2; l < s; l++)
    o[l] = i[l];
  return O.createElement.apply(null, o);
};
(function(n) {
  var t;
  t || (t = n.JSX || (n.JSX = {}));
})(Q0 || (Q0 = {}));
var ED = /* @__PURE__ */ Fg(function(n, t) {
  var e = n.styles, i = nu([e], void 0, O.useContext(Ph)), s = O.useRef();
  return Z0(function() {
    var o = t.key + "-global", l = new t.sheet.constructor({
      key: o,
      nonce: t.sheet.nonce,
      container: t.sheet.container,
      speedy: t.sheet.isSpeedy
    }), c = !1, d = document.querySelector('style[data-emotion="' + o + " " + i.name + '"]');
    return t.sheet.tags.length && (l.before = t.sheet.tags[0]), d !== null && (c = !0, d.setAttribute("data-emotion", o), l.hydrate([d])), s.current = [l, c], function() {
      l.flush();
    };
  }, [t]), Z0(function() {
    var o = s.current, l = o[0], c = o[1];
    if (c) {
      o[1] = !1;
      return;
    }
    if (i.next !== void 0 && Lg(t, i.next, !0), l.tags.length) {
      var d = l.tags[l.tags.length - 1].nextElementSibling;
      l.before = d, l.flush();
    }
    t.insert("", i, l, !1);
  }, [t, i.name]), null;
});
function $g() {
  for (var n = arguments.length, t = new Array(n), e = 0; e < n; e++)
    t[e] = arguments[e];
  return nu(t);
}
function iu() {
  var n = $g.apply(void 0, arguments), t = "animation-" + n.name;
  return {
    name: t,
    styles: "@keyframes " + t + "{" + n.styles + "}",
    anim: 1,
    toString: function() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
}
var MD = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|popover|popoverTarget|popoverTargetAction|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, AD = /* @__PURE__ */ mC(
  function(n) {
    return MD.test(n) || n.charCodeAt(0) === 111 && n.charCodeAt(1) === 110 && n.charCodeAt(2) < 91;
  }
  /* Z+1 */
), RD = AD, PD = function(t) {
  return t !== "theme";
}, J0 = function(t) {
  return typeof t == "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  t.charCodeAt(0) > 96 ? RD : PD;
}, tS = function(t, e, i) {
  var s;
  if (e) {
    var o = e.shouldForwardProp;
    s = t.__emotion_forwardProp && o ? function(l) {
      return t.__emotion_forwardProp(l) && o(l);
    } : o;
  }
  return typeof s != "function" && i && (s = t.__emotion_forwardProp), s;
}, BD = function(t) {
  var e = t.cache, i = t.serialized, s = t.isStringTag;
  return zg(e, i, s), xC(function() {
    return Lg(e, i, s);
  }), null;
}, kD = function n(t, e) {
  var i = t.__emotion_real === t, s = i && t.__emotion_base || t, o, l;
  e !== void 0 && (o = e.label, l = e.target);
  var c = tS(t, e, i), d = c || J0(s), f = !d("as");
  return function() {
    var m = arguments, y = i && t.__emotion_styles !== void 0 ? t.__emotion_styles.slice(0) : [];
    if (o !== void 0 && y.push("label:" + o + ";"), m[0] == null || m[0].raw === void 0)
      y.push.apply(y, m);
    else {
      var b = m[0];
      y.push(b[0]);
      for (var v = m.length, x = 1; x < v; x++)
        y.push(m[x], b[x]);
    }
    var S = Fg(function(_, C, R) {
      var w = f && _.as || s, E = "", P = [], k = _;
      if (_.theme == null) {
        k = {};
        for (var G in _)
          k[G] = _[G];
        k.theme = O.useContext(Ph);
      }
      typeof _.className == "string" ? E = yC(C.registered, P, _.className) : _.className != null && (E = _.className + " ");
      var $ = nu(y.concat(P), C.registered, k);
      E += C.key + "-" + $.name, l !== void 0 && (E += " " + l);
      var F = f && c === void 0 ? J0(w) : d, j = {};
      for (var H in _)
        f && H === "as" || F(H) && (j[H] = _[H]);
      return j.className = E, R && (j.ref = R), /* @__PURE__ */ O.createElement(O.Fragment, null, /* @__PURE__ */ O.createElement(BD, {
        cache: C,
        serialized: $,
        isStringTag: typeof w == "string"
      }), /* @__PURE__ */ O.createElement(w, j));
    });
    return S.displayName = o !== void 0 ? o : "Styled(" + (typeof s == "string" ? s : s.displayName || s.name || "Component") + ")", S.defaultProps = t.defaultProps, S.__emotion_real = S, S.__emotion_base = s, S.__emotion_styles = y, S.__emotion_forwardProp = c, Object.defineProperty(S, "toString", {
      value: function() {
        return "." + l;
      }
    }), S.withComponent = function(_, C) {
      var R = n(_, uh({}, e, C, {
        shouldForwardProp: tS(S, C, !0)
      }));
      return R.apply(void 0, y);
    }, S;
  };
}, OD = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
], Um = kD.bind(null);
OD.forEach(function(n) {
  Um[n] = Um(n);
});
function DD(n) {
  return n == null || Object.keys(n).length === 0;
}
function GD(n) {
  const {
    styles: t,
    defaultTheme: e = {}
  } = n, i = typeof t == "function" ? (s) => t(DD(s) ? e : s) : t;
  return /* @__PURE__ */ et.jsx(ED, {
    styles: i
  });
}
function UD(n, t) {
  return Um(n, t);
}
function ND(n, t) {
  Array.isArray(n.__emotion_styles) && (n.__emotion_styles = t(n.__emotion_styles));
}
const eS = [];
function Kr(n) {
  return eS[0] = n, nu(eS);
}
var Zp = { exports: {} }, be = {};
/**
 * @license React
 * react-is.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var nS;
function ID() {
  if (nS) return be;
  nS = 1;
  var n = Symbol.for("react.transitional.element"), t = Symbol.for("react.portal"), e = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), s = Symbol.for("react.profiler"), o = Symbol.for("react.consumer"), l = Symbol.for("react.context"), c = Symbol.for("react.forward_ref"), d = Symbol.for("react.suspense"), f = Symbol.for("react.suspense_list"), m = Symbol.for("react.memo"), y = Symbol.for("react.lazy"), b = Symbol.for("react.view_transition"), v = Symbol.for("react.client.reference");
  function x(S) {
    if (typeof S == "object" && S !== null) {
      var _ = S.$$typeof;
      switch (_) {
        case n:
          switch (S = S.type, S) {
            case e:
            case s:
            case i:
            case d:
            case f:
            case b:
              return S;
            default:
              switch (S = S && S.$$typeof, S) {
                case l:
                case c:
                case y:
                case m:
                  return S;
                case o:
                  return S;
                default:
                  return _;
              }
          }
        case t:
          return _;
      }
    }
  }
  return be.ContextConsumer = o, be.ContextProvider = l, be.Element = n, be.ForwardRef = c, be.Fragment = e, be.Lazy = y, be.Memo = m, be.Portal = t, be.Profiler = s, be.StrictMode = i, be.Suspense = d, be.SuspenseList = f, be.isContextConsumer = function(S) {
    return x(S) === o;
  }, be.isContextProvider = function(S) {
    return x(S) === l;
  }, be.isElement = function(S) {
    return typeof S == "object" && S !== null && S.$$typeof === n;
  }, be.isForwardRef = function(S) {
    return x(S) === c;
  }, be.isFragment = function(S) {
    return x(S) === e;
  }, be.isLazy = function(S) {
    return x(S) === y;
  }, be.isMemo = function(S) {
    return x(S) === m;
  }, be.isPortal = function(S) {
    return x(S) === t;
  }, be.isProfiler = function(S) {
    return x(S) === s;
  }, be.isStrictMode = function(S) {
    return x(S) === i;
  }, be.isSuspense = function(S) {
    return x(S) === d;
  }, be.isSuspenseList = function(S) {
    return x(S) === f;
  }, be.isValidElementType = function(S) {
    return typeof S == "string" || typeof S == "function" || S === e || S === s || S === i || S === d || S === f || typeof S == "object" && S !== null && (S.$$typeof === y || S.$$typeof === m || S.$$typeof === l || S.$$typeof === o || S.$$typeof === c || S.$$typeof === v || S.getModuleId !== void 0);
  }, be.typeOf = x, be;
}
var iS;
function zD() {
  return iS || (iS = 1, Zp.exports = /* @__PURE__ */ ID()), Zp.exports;
}
var SC = /* @__PURE__ */ zD();
function pr(n) {
  if (typeof n != "object" || n === null)
    return !1;
  const t = Object.getPrototypeOf(n);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in n) && !(Symbol.iterator in n);
}
function TC(n) {
  if (/* @__PURE__ */ O.isValidElement(n) || SC.isValidElementType(n) || !pr(n))
    return n;
  const t = {};
  return Object.keys(n).forEach((e) => {
    t[e] = TC(n[e]);
  }), t;
}
function wn(n, t, e = {
  clone: !0
}) {
  const i = e.clone ? {
    ...n
  } : n;
  return pr(n) && pr(t) && Object.keys(t).forEach((s) => {
    /* @__PURE__ */ O.isValidElement(t[s]) || SC.isValidElementType(t[s]) ? i[s] = t[s] : pr(t[s]) && // Avoid prototype pollution
    Object.prototype.hasOwnProperty.call(n, s) && pr(n[s]) ? i[s] = wn(n[s], t[s], e) : e.clone ? i[s] = pr(t[s]) ? TC(t[s]) : t[s] : i[s] = t[s];
  }), i;
}
const LD = (n) => {
  const t = Object.keys(n).map((e) => ({
    key: e,
    val: n[e]
  })) || [];
  return t.sort((e, i) => e.val - i.val), t.reduce((e, i) => ({
    ...e,
    [i.key]: i.val
  }), {});
};
function FD(n) {
  const {
    // The breakpoint **start** at this value.
    // For instance with the first breakpoint xs: [xs, sm).
    values: t = {
      xs: 0,
      // phone
      sm: 600,
      // tablet
      md: 900,
      // small laptop
      lg: 1200,
      // desktop
      xl: 1536
      // large screen
    },
    unit: e = "px",
    step: i = 5,
    ...s
  } = n, o = LD(t), l = Object.keys(o);
  function c(b) {
    return `@media (min-width:${typeof t[b] == "number" ? t[b] : b}${e})`;
  }
  function d(b) {
    return `@media (max-width:${(typeof t[b] == "number" ? t[b] : b) - i / 100}${e})`;
  }
  function f(b, v) {
    const x = l.indexOf(v);
    return `@media (min-width:${typeof t[b] == "number" ? t[b] : b}${e}) and (max-width:${(x !== -1 && typeof t[l[x]] == "number" ? t[l[x]] : v) - i / 100}${e})`;
  }
  function m(b) {
    return l.indexOf(b) + 1 < l.length ? f(b, l[l.indexOf(b) + 1]) : c(b);
  }
  function y(b) {
    const v = l.indexOf(b);
    return v === 0 ? c(l[1]) : v === l.length - 1 ? d(l[v]) : f(b, l[l.indexOf(b) + 1]).replace("@media", "@media not all and");
  }
  return {
    keys: l,
    values: o,
    up: c,
    down: d,
    between: f,
    only: m,
    not: y,
    unit: e,
    ...s
  };
}
function rS(n, t) {
  if (!n.containerQueries)
    return t;
  const e = Object.keys(t).filter((i) => i.startsWith("@container")).sort((i, s) => {
    const o = /min-width:\s*([0-9.]+)/;
    return +(i.match(o)?.[1] || 0) - +(s.match(o)?.[1] || 0);
  });
  return e.length ? e.reduce((i, s) => {
    const o = t[s];
    return delete i[s], i[s] = o, i;
  }, {
    ...t
  }) : t;
}
function HD(n, t) {
  return t === "@" || t.startsWith("@") && (n.some((e) => t.startsWith(`@${e}`)) || !!t.match(/^@\d/));
}
function $D(n, t) {
  const e = t.match(/^@([^/]+)?\/?(.+)?$/);
  if (!e)
    return null;
  const [, i, s] = e, o = Number.isNaN(+i) ? i || 0 : +i;
  return n.containerQueries(s).up(o);
}
function WD(n) {
  const t = (o, l) => o.replace("@media", l ? `@container ${l}` : "@container");
  function e(o, l) {
    o.up = (...c) => t(n.breakpoints.up(...c), l), o.down = (...c) => t(n.breakpoints.down(...c), l), o.between = (...c) => t(n.breakpoints.between(...c), l), o.only = (...c) => t(n.breakpoints.only(...c), l), o.not = (...c) => {
      const d = t(n.breakpoints.not(...c), l);
      return d.includes("not all and") ? d.replace("not all and ", "").replace("min-width:", "width<").replace("max-width:", "width>").replace("and", "or") : d;
    };
  }
  const i = {}, s = (o) => (e(i, o), i);
  return e(s), {
    ...n,
    containerQueries: s
  };
}
const VD = {
  borderRadius: 4
};
function Bl(n, t) {
  return t ? wn(n, t, {
    clone: !1
    // No need to clone deep, it's way faster.
  }) : n;
}
const Bh = {
  xs: 0,
  // phone
  sm: 600,
  // tablet
  md: 900,
  // small laptop
  lg: 1200,
  // desktop
  xl: 1536
  // large screen
}, sS = {
  // Sorted ASC by size. That's important.
  // It can't be configured as it's used statically for propTypes.
  keys: ["xs", "sm", "md", "lg", "xl"],
  up: (n) => `@media (min-width:${Bh[n]}px)`
}, jD = {
  containerQueries: (n) => ({
    up: (t) => {
      let e = typeof t == "number" ? t : Bh[t] || t;
      return typeof e == "number" && (e = `${e}px`), n ? `@container ${n} (min-width:${e})` : `@container (min-width:${e})`;
    }
  })
};
function Sr(n, t, e) {
  const i = n.theme || {};
  if (Array.isArray(t)) {
    const o = i.breakpoints || sS;
    return t.reduce((l, c, d) => (l[o.up(o.keys[d])] = e(t[d]), l), {});
  }
  if (typeof t == "object") {
    const o = i.breakpoints || sS;
    return Object.keys(t).reduce((l, c) => {
      if (HD(o.keys, c)) {
        const d = $D(i.containerQueries ? i : jD, c);
        d && (l[d] = e(t[c], c));
      } else if (Object.keys(o.values || Bh).includes(c)) {
        const d = o.up(c);
        l[d] = e(t[c], c);
      } else {
        const d = c;
        l[d] = t[d];
      }
      return l;
    }, {});
  }
  return e(t);
}
function YD(n = {}) {
  return n.keys?.reduce((e, i) => {
    const s = n.up(i);
    return e[s] = {}, e;
  }, {}) || {};
}
function aS(n, t) {
  return n.reduce((e, i) => {
    const s = e[i];
    return (!s || Object.keys(s).length === 0) && delete e[i], e;
  }, t);
}
function St(n) {
  if (typeof n != "string")
    throw new Error(_r(7));
  return n.charAt(0).toUpperCase() + n.slice(1);
}
function kh(n, t, e = !0) {
  if (!t || typeof t != "string")
    return null;
  if (n && n.vars && e) {
    const i = `vars.${t}`.split(".").reduce((s, o) => s && s[o] ? s[o] : null, n);
    if (i != null)
      return i;
  }
  return t.split(".").reduce((i, s) => i && i[s] != null ? i[s] : null, n);
}
function hh(n, t, e, i = e) {
  let s;
  return typeof n == "function" ? s = n(e) : Array.isArray(n) ? s = n[e] || i : s = kh(n, e) || i, t && (s = t(s, i, n)), s;
}
function Xe(n) {
  const {
    prop: t,
    cssProperty: e = n.prop,
    themeKey: i,
    transform: s
  } = n, o = (l) => {
    if (l[t] == null)
      return null;
    const c = l[t], d = l.theme, f = kh(d, i) || {};
    return Sr(l, c, (y) => {
      let b = hh(f, s, y);
      return y === b && typeof y == "string" && (b = hh(f, s, `${t}${y === "default" ? "" : St(y)}`, y)), e === !1 ? b : {
        [e]: b
      };
    });
  };
  return o.propTypes = {}, o.filterProps = [t], o;
}
function XD(n) {
  const t = {};
  return (e) => (t[e] === void 0 && (t[e] = n(e)), t[e]);
}
const qD = {
  m: "margin",
  p: "padding"
}, KD = {
  t: "Top",
  r: "Right",
  b: "Bottom",
  l: "Left",
  x: ["Left", "Right"],
  y: ["Top", "Bottom"]
}, oS = {
  marginX: "mx",
  marginY: "my",
  paddingX: "px",
  paddingY: "py"
}, ZD = XD((n) => {
  if (n.length > 2)
    if (oS[n])
      n = oS[n];
    else
      return [n];
  const [t, e] = n.split(""), i = qD[t], s = KD[e] || "";
  return Array.isArray(s) ? s.map((o) => i + o) : [i + s];
}), Wg = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"], Vg = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"];
[...Wg, ...Vg];
function ru(n, t, e, i) {
  const s = kh(n, t, !0) ?? e;
  return typeof s == "number" || typeof s == "string" ? (o) => typeof o == "string" ? o : typeof s == "string" ? s.startsWith("var(") && o === 0 ? 0 : s.startsWith("var(") && o === 1 ? s : `calc(${o} * ${s})` : s * o : Array.isArray(s) ? (o) => {
    if (typeof o == "string")
      return o;
    const l = Math.abs(o), c = s[l];
    return o >= 0 ? c : typeof c == "number" ? -c : typeof c == "string" && c.startsWith("var(") ? `calc(-1 * ${c})` : `-${c}`;
  } : typeof s == "function" ? s : () => {
  };
}
function jg(n) {
  return ru(n, "spacing", 8);
}
function su(n, t) {
  return typeof t == "string" || t == null ? t : n(t);
}
function QD(n, t) {
  return (e) => n.reduce((i, s) => (i[s] = su(t, e), i), {});
}
function JD(n, t, e, i) {
  if (!t.includes(e))
    return null;
  const s = ZD(e), o = QD(s, i), l = n[e];
  return Sr(n, l, o);
}
function wC(n, t) {
  const e = jg(n.theme);
  return Object.keys(n).map((i) => JD(n, t, i, e)).reduce(Bl, {});
}
function Fe(n) {
  return wC(n, Wg);
}
Fe.propTypes = {};
Fe.filterProps = Wg;
function He(n) {
  return wC(n, Vg);
}
He.propTypes = {};
He.filterProps = Vg;
function CC(n = 8, t = jg({
  spacing: n
})) {
  if (n.mui)
    return n;
  const e = (...i) => (i.length === 0 ? [1] : i).map((o) => {
    const l = t(o);
    return typeof l == "number" ? `${l}px` : l;
  }).join(" ");
  return e.mui = !0, e;
}
function Oh(...n) {
  const t = n.reduce((i, s) => (s.filterProps.forEach((o) => {
    i[o] = s;
  }), i), {}), e = (i) => Object.keys(i).reduce((s, o) => t[o] ? Bl(s, t[o](i)) : s, {});
  return e.propTypes = {}, e.filterProps = n.reduce((i, s) => i.concat(s.filterProps), []), e;
}
function ci(n) {
  return typeof n != "number" ? n : `${n}px solid`;
}
function mi(n, t) {
  return Xe({
    prop: n,
    themeKey: "borders",
    transform: t
  });
}
const tG = mi("border", ci), eG = mi("borderTop", ci), nG = mi("borderRight", ci), iG = mi("borderBottom", ci), rG = mi("borderLeft", ci), sG = mi("borderColor"), aG = mi("borderTopColor"), oG = mi("borderRightColor"), lG = mi("borderBottomColor"), uG = mi("borderLeftColor"), cG = mi("outline", ci), hG = mi("outlineColor"), Dh = (n) => {
  if (n.borderRadius !== void 0 && n.borderRadius !== null) {
    const t = ru(n.theme, "shape.borderRadius", 4), e = (i) => ({
      borderRadius: su(t, i)
    });
    return Sr(n, n.borderRadius, e);
  }
  return null;
};
Dh.propTypes = {};
Dh.filterProps = ["borderRadius"];
Oh(tG, eG, nG, iG, rG, sG, aG, oG, lG, uG, Dh, cG, hG);
const Gh = (n) => {
  if (n.gap !== void 0 && n.gap !== null) {
    const t = ru(n.theme, "spacing", 8), e = (i) => ({
      gap: su(t, i)
    });
    return Sr(n, n.gap, e);
  }
  return null;
};
Gh.propTypes = {};
Gh.filterProps = ["gap"];
const Uh = (n) => {
  if (n.columnGap !== void 0 && n.columnGap !== null) {
    const t = ru(n.theme, "spacing", 8), e = (i) => ({
      columnGap: su(t, i)
    });
    return Sr(n, n.columnGap, e);
  }
  return null;
};
Uh.propTypes = {};
Uh.filterProps = ["columnGap"];
const Nh = (n) => {
  if (n.rowGap !== void 0 && n.rowGap !== null) {
    const t = ru(n.theme, "spacing", 8), e = (i) => ({
      rowGap: su(t, i)
    });
    return Sr(n, n.rowGap, e);
  }
  return null;
};
Nh.propTypes = {};
Nh.filterProps = ["rowGap"];
const dG = Xe({
  prop: "gridColumn"
}), fG = Xe({
  prop: "gridRow"
}), pG = Xe({
  prop: "gridAutoFlow"
}), mG = Xe({
  prop: "gridAutoColumns"
}), gG = Xe({
  prop: "gridAutoRows"
}), yG = Xe({
  prop: "gridTemplateColumns"
}), bG = Xe({
  prop: "gridTemplateRows"
}), vG = Xe({
  prop: "gridTemplateAreas"
}), xG = Xe({
  prop: "gridArea"
});
Oh(Gh, Uh, Nh, dG, fG, pG, mG, gG, yG, bG, vG, xG);
function $a(n, t) {
  return t === "grey" ? t : n;
}
const _G = Xe({
  prop: "color",
  themeKey: "palette",
  transform: $a
}), SG = Xe({
  prop: "bgcolor",
  cssProperty: "backgroundColor",
  themeKey: "palette",
  transform: $a
}), TG = Xe({
  prop: "backgroundColor",
  themeKey: "palette",
  transform: $a
});
Oh(_G, SG, TG);
function qn(n) {
  return n <= 1 && n !== 0 ? `${n * 100}%` : n;
}
const wG = Xe({
  prop: "width",
  transform: qn
}), Yg = (n) => {
  if (n.maxWidth !== void 0 && n.maxWidth !== null) {
    const t = (e) => {
      const i = n.theme?.breakpoints?.values?.[e] || Bh[e];
      return i ? n.theme?.breakpoints?.unit !== "px" ? {
        maxWidth: `${i}${n.theme.breakpoints.unit}`
      } : {
        maxWidth: i
      } : {
        maxWidth: qn(e)
      };
    };
    return Sr(n, n.maxWidth, t);
  }
  return null;
};
Yg.filterProps = ["maxWidth"];
const CG = Xe({
  prop: "minWidth",
  transform: qn
}), EG = Xe({
  prop: "height",
  transform: qn
}), MG = Xe({
  prop: "maxHeight",
  transform: qn
}), AG = Xe({
  prop: "minHeight",
  transform: qn
});
Xe({
  prop: "size",
  cssProperty: "width",
  transform: qn
});
Xe({
  prop: "size",
  cssProperty: "height",
  transform: qn
});
const RG = Xe({
  prop: "boxSizing"
});
Oh(wG, Yg, CG, EG, MG, AG, RG);
const Ih = {
  // borders
  border: {
    themeKey: "borders",
    transform: ci
  },
  borderTop: {
    themeKey: "borders",
    transform: ci
  },
  borderRight: {
    themeKey: "borders",
    transform: ci
  },
  borderBottom: {
    themeKey: "borders",
    transform: ci
  },
  borderLeft: {
    themeKey: "borders",
    transform: ci
  },
  borderColor: {
    themeKey: "palette"
  },
  borderTopColor: {
    themeKey: "palette"
  },
  borderRightColor: {
    themeKey: "palette"
  },
  borderBottomColor: {
    themeKey: "palette"
  },
  borderLeftColor: {
    themeKey: "palette"
  },
  outline: {
    themeKey: "borders",
    transform: ci
  },
  outlineColor: {
    themeKey: "palette"
  },
  borderRadius: {
    themeKey: "shape.borderRadius",
    style: Dh
  },
  // palette
  color: {
    themeKey: "palette",
    transform: $a
  },
  bgcolor: {
    themeKey: "palette",
    cssProperty: "backgroundColor",
    transform: $a
  },
  backgroundColor: {
    themeKey: "palette",
    transform: $a
  },
  // spacing
  p: {
    style: He
  },
  pt: {
    style: He
  },
  pr: {
    style: He
  },
  pb: {
    style: He
  },
  pl: {
    style: He
  },
  px: {
    style: He
  },
  py: {
    style: He
  },
  padding: {
    style: He
  },
  paddingTop: {
    style: He
  },
  paddingRight: {
    style: He
  },
  paddingBottom: {
    style: He
  },
  paddingLeft: {
    style: He
  },
  paddingX: {
    style: He
  },
  paddingY: {
    style: He
  },
  paddingInline: {
    style: He
  },
  paddingInlineStart: {
    style: He
  },
  paddingInlineEnd: {
    style: He
  },
  paddingBlock: {
    style: He
  },
  paddingBlockStart: {
    style: He
  },
  paddingBlockEnd: {
    style: He
  },
  m: {
    style: Fe
  },
  mt: {
    style: Fe
  },
  mr: {
    style: Fe
  },
  mb: {
    style: Fe
  },
  ml: {
    style: Fe
  },
  mx: {
    style: Fe
  },
  my: {
    style: Fe
  },
  margin: {
    style: Fe
  },
  marginTop: {
    style: Fe
  },
  marginRight: {
    style: Fe
  },
  marginBottom: {
    style: Fe
  },
  marginLeft: {
    style: Fe
  },
  marginX: {
    style: Fe
  },
  marginY: {
    style: Fe
  },
  marginInline: {
    style: Fe
  },
  marginInlineStart: {
    style: Fe
  },
  marginInlineEnd: {
    style: Fe
  },
  marginBlock: {
    style: Fe
  },
  marginBlockStart: {
    style: Fe
  },
  marginBlockEnd: {
    style: Fe
  },
  // display
  displayPrint: {
    cssProperty: !1,
    transform: (n) => ({
      "@media print": {
        display: n
      }
    })
  },
  display: {},
  overflow: {},
  textOverflow: {},
  visibility: {},
  whiteSpace: {},
  // flexbox
  flexBasis: {},
  flexDirection: {},
  flexWrap: {},
  justifyContent: {},
  alignItems: {},
  alignContent: {},
  order: {},
  flex: {},
  flexGrow: {},
  flexShrink: {},
  alignSelf: {},
  justifyItems: {},
  justifySelf: {},
  // grid
  gap: {
    style: Gh
  },
  rowGap: {
    style: Nh
  },
  columnGap: {
    style: Uh
  },
  gridColumn: {},
  gridRow: {},
  gridAutoFlow: {},
  gridAutoColumns: {},
  gridAutoRows: {},
  gridTemplateColumns: {},
  gridTemplateRows: {},
  gridTemplateAreas: {},
  gridArea: {},
  // positions
  position: {},
  zIndex: {
    themeKey: "zIndex"
  },
  top: {},
  right: {},
  bottom: {},
  left: {},
  // shadows
  boxShadow: {
    themeKey: "shadows"
  },
  // sizing
  width: {
    transform: qn
  },
  maxWidth: {
    style: Yg
  },
  minWidth: {
    transform: qn
  },
  height: {
    transform: qn
  },
  maxHeight: {
    transform: qn
  },
  minHeight: {
    transform: qn
  },
  boxSizing: {},
  // typography
  font: {
    themeKey: "font"
  },
  fontFamily: {
    themeKey: "typography"
  },
  fontSize: {
    themeKey: "typography"
  },
  fontStyle: {
    themeKey: "typography"
  },
  fontWeight: {
    themeKey: "typography"
  },
  letterSpacing: {},
  textTransform: {},
  lineHeight: {},
  textAlign: {},
  typography: {
    cssProperty: !1,
    themeKey: "typography"
  }
};
function PG(...n) {
  const t = n.reduce((i, s) => i.concat(Object.keys(s)), []), e = new Set(t);
  return n.every((i) => e.size === Object.keys(i).length);
}
function BG(n, t) {
  return typeof n == "function" ? n(t) : n;
}
function kG() {
  function n(e, i, s, o) {
    const l = {
      [e]: i,
      theme: s
    }, c = o[e];
    if (!c)
      return {
        [e]: i
      };
    const {
      cssProperty: d = e,
      themeKey: f,
      transform: m,
      style: y
    } = c;
    if (i == null)
      return null;
    if (f === "typography" && i === "inherit")
      return {
        [e]: i
      };
    const b = kh(s, f) || {};
    return y ? y(l) : Sr(l, i, (x) => {
      let S = hh(b, m, x);
      return x === S && typeof x == "string" && (S = hh(b, m, `${e}${x === "default" ? "" : St(x)}`, x)), d === !1 ? S : {
        [d]: S
      };
    });
  }
  function t(e) {
    const {
      sx: i,
      theme: s = {},
      nested: o
    } = e || {};
    if (!i)
      return null;
    const l = s.unstable_sxConfig ?? Ih;
    function c(d) {
      let f = d;
      if (typeof d == "function")
        f = d(s);
      else if (typeof d != "object")
        return d;
      if (!f)
        return null;
      const m = YD(s.breakpoints), y = Object.keys(m);
      let b = m;
      return Object.keys(f).forEach((v) => {
        const x = BG(f[v], s);
        if (x != null)
          if (typeof x == "object")
            if (l[v])
              b = Bl(b, n(v, x, s, l));
            else {
              const S = Sr({
                theme: s
              }, x, (_) => ({
                [v]: _
              }));
              PG(S, x) ? b[v] = t({
                sx: x,
                theme: s,
                nested: !0
              }) : b = Bl(b, S);
            }
          else
            b = Bl(b, n(v, x, s, l));
      }), !o && s.modularCssLayers ? {
        "@layer sx": rS(s, aS(y, b))
      } : rS(s, aS(y, b));
    }
    return Array.isArray(i) ? i.map(c) : c(i);
  }
  return t;
}
const Qa = kG();
Qa.filterProps = ["sx"];
function OG(n, t) {
  const e = this;
  if (e.vars) {
    if (!e.colorSchemes?.[n] || typeof e.getColorSchemeSelector != "function")
      return {};
    let i = e.getColorSchemeSelector(n);
    return i === "&" ? t : ((i.includes("data-") || i.includes(".")) && (i = `*:where(${i.replace(/\s*&$/, "")}) &`), {
      [i]: t
    });
  }
  return e.palette.mode === n ? t : {};
}
function Xg(n = {}, ...t) {
  const {
    breakpoints: e = {},
    palette: i = {},
    spacing: s,
    shape: o = {},
    ...l
  } = n, c = FD(e), d = CC(s);
  let f = wn({
    breakpoints: c,
    direction: "ltr",
    components: {},
    // Inject component definitions.
    palette: {
      mode: "light",
      ...i
    },
    spacing: d,
    shape: {
      ...VD,
      ...o
    }
  }, l);
  return f = WD(f), f.applyStyles = OG, f = t.reduce((m, y) => wn(m, y), f), f.unstable_sxConfig = {
    ...Ih,
    ...l?.unstable_sxConfig
  }, f.unstable_sx = function(y) {
    return Qa({
      sx: y,
      theme: this
    });
  }, f;
}
function DG(n) {
  return Object.keys(n).length === 0;
}
function GG(n = null) {
  const t = O.useContext(Ph);
  return !t || DG(t) ? n : t;
}
const UG = Xg();
function EC(n = UG) {
  return GG(n);
}
function Qp(n) {
  const t = Kr(n);
  return n !== t && t.styles ? (t.styles.match(/^@layer\s+[^{]*$/) || (t.styles = `@layer global{${t.styles}}`), t) : n;
}
function NG({
  styles: n,
  themeId: t,
  defaultTheme: e = {}
}) {
  const i = EC(e), s = t && i[t] || i;
  let o = typeof n == "function" ? n(s) : n;
  return s.modularCssLayers && (Array.isArray(o) ? o = o.map((l) => Qp(typeof l == "function" ? l(s) : l)) : o = Qp(o)), /* @__PURE__ */ et.jsx(GD, {
    styles: o
  });
}
const lS = (n) => n, IG = () => {
  let n = lS;
  return {
    configure(t) {
      n = t;
    },
    generate(t) {
      return n(t);
    },
    reset() {
      n = lS;
    }
  };
}, zG = IG();
function MC(n) {
  var t, e, i = "";
  if (typeof n == "string" || typeof n == "number") i += n;
  else if (typeof n == "object") if (Array.isArray(n)) {
    var s = n.length;
    for (t = 0; t < s; t++) n[t] && (e = MC(n[t])) && (i && (i += " "), i += e);
  } else for (e in n) n[e] && (i && (i += " "), i += e);
  return i;
}
function Lt() {
  for (var n, t, e = 0, i = "", s = arguments.length; e < s; e++) (n = arguments[e]) && (t = MC(n)) && (i && (i += " "), i += t);
  return i;
}
const LG = {
  active: "active",
  checked: "checked",
  completed: "completed",
  disabled: "disabled",
  error: "error",
  expanded: "expanded",
  focused: "focused",
  focusVisible: "focusVisible",
  open: "open",
  readOnly: "readOnly",
  required: "required",
  selected: "selected"
};
function Be(n, t, e = "Mui") {
  const i = LG[t];
  return i ? `${e}-${i}` : `${zG.generate(n)}-${t}`;
}
function ke(n, t, e = "Mui") {
  const i = {};
  return t.forEach((s) => {
    i[s] = Be(n, s, e);
  }), i;
}
function AC(n) {
  const {
    variants: t,
    ...e
  } = n, i = {
    variants: t,
    style: Kr(e),
    isProcessed: !0
  };
  return i.style === e || t && t.forEach((s) => {
    typeof s.style != "function" && (s.style = Kr(s.style));
  }), i;
}
const FG = Xg();
function Jp(n) {
  return n !== "ownerState" && n !== "theme" && n !== "sx" && n !== "as";
}
function Ds(n, t) {
  return t && n && typeof n == "object" && n.styles && !n.styles.startsWith("@layer") && (n.styles = `@layer ${t}{${String(n.styles)}}`), n;
}
function HG(n) {
  return n ? (t, e) => e[n] : null;
}
function $G(n, t, e) {
  n.theme = jG(n.theme) ? e : n.theme[t] || n.theme;
}
function Jc(n, t, e) {
  const i = typeof t == "function" ? t(n) : t;
  if (Array.isArray(i))
    return i.flatMap((s) => Jc(n, s, e));
  if (Array.isArray(i?.variants)) {
    let s;
    if (i.isProcessed)
      s = e ? Ds(i.style, e) : i.style;
    else {
      const {
        variants: o,
        ...l
      } = i;
      s = e ? Ds(Kr(l), e) : l;
    }
    return RC(n, i.variants, [s], e);
  }
  return i?.isProcessed ? e ? Ds(Kr(i.style), e) : i.style : e ? Ds(Kr(i), e) : i;
}
function RC(n, t, e = [], i = void 0) {
  let s;
  t: for (let o = 0; o < t.length; o += 1) {
    const l = t[o];
    if (typeof l.props == "function") {
      if (s ??= {
        ...n,
        ...n.ownerState,
        ownerState: n.ownerState
      }, !l.props(s))
        continue;
    } else
      for (const c in l.props)
        if (n[c] !== l.props[c] && n.ownerState?.[c] !== l.props[c])
          continue t;
    typeof l.style == "function" ? (s ??= {
      ...n,
      ...n.ownerState,
      ownerState: n.ownerState
    }, e.push(i ? Ds(Kr(l.style(s)), i) : l.style(s))) : e.push(i ? Ds(Kr(l.style), i) : l.style);
  }
  return e;
}
function WG(n = {}) {
  const {
    themeId: t,
    defaultTheme: e = FG,
    rootShouldForwardProp: i = Jp,
    slotShouldForwardProp: s = Jp
  } = n;
  function o(c) {
    $G(c, t, e);
  }
  return (c, d = {}) => {
    ND(c, (k) => k.filter((G) => G !== Qa));
    const {
      name: f,
      slot: m,
      skipVariantsResolver: y,
      skipSx: b,
      // TODO v6: remove `lowercaseFirstLetter()` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      overridesResolver: v = HG(XG(m)),
      ...x
    } = d, S = f && f.startsWith("Mui") || m ? "components" : "custom", _ = y !== void 0 ? y : (
      // TODO v6: remove `Root` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      m && m !== "Root" && m !== "root" || !1
    ), C = b || !1;
    let R = Jp;
    m === "Root" || m === "root" ? R = i : m ? R = s : YG(c) && (R = void 0);
    const w = UD(c, {
      shouldForwardProp: R,
      label: VG(),
      ...x
    }), E = (k) => {
      if (k.__emotion_real === k)
        return k;
      if (typeof k == "function")
        return function($) {
          return Jc($, k, $.theme.modularCssLayers ? S : void 0);
        };
      if (pr(k)) {
        const G = AC(k);
        return function(F) {
          return G.variants ? Jc(F, G, F.theme.modularCssLayers ? S : void 0) : F.theme.modularCssLayers ? Ds(G.style, S) : G.style;
        };
      }
      return k;
    }, P = (...k) => {
      const G = [], $ = k.map(E), F = [];
      if (G.push(o), f && v && F.push(function(Y) {
        const Q = Y.theme.components?.[f]?.styleOverrides;
        if (!Q)
          return null;
        const B = {};
        for (const I in Q)
          B[I] = Jc(Y, Q[I], Y.theme.modularCssLayers ? "theme" : void 0);
        return v(Y, B);
      }), f && !_ && F.push(function(Y) {
        const Q = Y.theme?.components?.[f]?.variants;
        return Q ? RC(Y, Q, [], Y.theme.modularCssLayers ? "theme" : void 0) : null;
      }), C || F.push(Qa), Array.isArray($[0])) {
        const M = $.shift(), Y = new Array(G.length).fill(""), L = new Array(F.length).fill("");
        let Q;
        Q = [...Y, ...M, ...L], Q.raw = [...Y, ...M.raw, ...L], G.unshift(Q);
      }
      const j = [...G, ...$, ...F], H = w(...j);
      return c.muiName && (H.muiName = c.muiName), H;
    };
    return w.withConfig && (P.withConfig = w.withConfig), P;
  };
}
function VG(n, t) {
  return void 0;
}
function jG(n) {
  for (const t in n)
    return !1;
  return !0;
}
function YG(n) {
  return typeof n == "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  n.charCodeAt(0) > 96;
}
function XG(n) {
  return n && n.charAt(0).toLowerCase() + n.slice(1);
}
function dh(n, t, e = !1) {
  const i = {
    ...t
  };
  for (const s in n)
    if (Object.prototype.hasOwnProperty.call(n, s)) {
      const o = s;
      if (o === "components" || o === "slots")
        i[o] = {
          ...n[o],
          ...i[o]
        };
      else if (o === "componentsProps" || o === "slotProps") {
        const l = n[o], c = t[o];
        if (!c)
          i[o] = l || {};
        else if (!l)
          i[o] = c;
        else {
          i[o] = {
            ...c
          };
          for (const d in l)
            if (Object.prototype.hasOwnProperty.call(l, d)) {
              const f = d;
              i[o][f] = dh(l[f], c[f], e);
            }
        }
      } else o === "className" && e && t.className ? i.className = Lt(n?.className, t?.className) : o === "style" && e && t.style ? i.style = {
        ...n?.style,
        ...t?.style
      } : i[o] === void 0 && (i[o] = n[o]);
    }
  return i;
}
const ts = typeof window < "u" ? O.useLayoutEffect : O.useEffect;
function Ia(n, t = Number.MIN_SAFE_INTEGER, e = Number.MAX_SAFE_INTEGER) {
  return Math.max(t, Math.min(n, e));
}
function qg(n, t = 0, e = 1) {
  return Ia(n, t, e);
}
function qG(n) {
  n = n.slice(1);
  const t = new RegExp(`.{1,${n.length >= 6 ? 2 : 1}}`, "g");
  let e = n.match(t);
  return e && e[0].length === 1 && (e = e.map((i) => i + i)), e ? `rgb${e.length === 4 ? "a" : ""}(${e.map((i, s) => s < 3 ? parseInt(i, 16) : Math.round(parseInt(i, 16) / 255 * 1e3) / 1e3).join(", ")})` : "";
}
function es(n) {
  if (n.type)
    return n;
  if (n.charAt(0) === "#")
    return es(qG(n));
  const t = n.indexOf("("), e = n.substring(0, t);
  if (!["rgb", "rgba", "hsl", "hsla", "color"].includes(e))
    throw new Error(_r(9, n));
  let i = n.substring(t + 1, n.length - 1), s;
  if (e === "color") {
    if (i = i.split(" "), s = i.shift(), i.length === 4 && i[3].charAt(0) === "/" && (i[3] = i[3].slice(1)), !["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].includes(s))
      throw new Error(_r(10, s));
  } else
    i = i.split(",");
  return i = i.map((o) => parseFloat(o)), {
    type: e,
    values: i,
    colorSpace: s
  };
}
const KG = (n) => {
  const t = es(n);
  return t.values.slice(0, 3).map((e, i) => t.type.includes("hsl") && i !== 0 ? `${e}%` : e).join(" ");
}, _l = (n, t) => {
  try {
    return KG(n);
  } catch {
    return n;
  }
};
function zh(n) {
  const {
    type: t,
    colorSpace: e
  } = n;
  let {
    values: i
  } = n;
  return t.includes("rgb") ? i = i.map((s, o) => o < 3 ? parseInt(s, 10) : s) : t.includes("hsl") && (i[1] = `${i[1]}%`, i[2] = `${i[2]}%`), t.includes("color") ? i = `${e} ${i.join(" ")}` : i = `${i.join(", ")}`, `${t}(${i})`;
}
function PC(n) {
  n = es(n);
  const {
    values: t
  } = n, e = t[0], i = t[1] / 100, s = t[2] / 100, o = i * Math.min(s, 1 - s), l = (f, m = (f + e / 30) % 12) => s - o * Math.max(Math.min(m - 3, 9 - m, 1), -1);
  let c = "rgb";
  const d = [Math.round(l(0) * 255), Math.round(l(8) * 255), Math.round(l(4) * 255)];
  return n.type === "hsla" && (c += "a", d.push(t[3])), zh({
    type: c,
    values: d
  });
}
function Nm(n) {
  n = es(n);
  let t = n.type === "hsl" || n.type === "hsla" ? es(PC(n)).values : n.values;
  return t = t.map((e) => (n.type !== "color" && (e /= 255), e <= 0.03928 ? e / 12.92 : ((e + 0.055) / 1.055) ** 2.4)), Number((0.2126 * t[0] + 0.7152 * t[1] + 0.0722 * t[2]).toFixed(3));
}
function ZG(n, t) {
  const e = Nm(n), i = Nm(t);
  return (Math.max(e, i) + 0.05) / (Math.min(e, i) + 0.05);
}
function fh(n, t) {
  return n = es(n), t = qg(t), (n.type === "rgb" || n.type === "hsl") && (n.type += "a"), n.type === "color" ? n.values[3] = `/${t}` : n.values[3] = t, zh(n);
}
function Ts(n, t, e) {
  try {
    return fh(n, t);
  } catch {
    return n;
  }
}
function Lh(n, t) {
  if (n = es(n), t = qg(t), n.type.includes("hsl"))
    n.values[2] *= 1 - t;
  else if (n.type.includes("rgb") || n.type.includes("color"))
    for (let e = 0; e < 3; e += 1)
      n.values[e] *= 1 - t;
  return zh(n);
}
function de(n, t, e) {
  try {
    return Lh(n, t);
  } catch {
    return n;
  }
}
function Fh(n, t) {
  if (n = es(n), t = qg(t), n.type.includes("hsl"))
    n.values[2] += (100 - n.values[2]) * t;
  else if (n.type.includes("rgb"))
    for (let e = 0; e < 3; e += 1)
      n.values[e] += (255 - n.values[e]) * t;
  else if (n.type.includes("color"))
    for (let e = 0; e < 3; e += 1)
      n.values[e] += (1 - n.values[e]) * t;
  return zh(n);
}
function fe(n, t, e) {
  try {
    return Fh(n, t);
  } catch {
    return n;
  }
}
function QG(n, t = 0.15) {
  return Nm(n) > 0.5 ? Lh(n, t) : Fh(n, t);
}
function Nc(n, t, e) {
  try {
    return QG(n, t);
  } catch {
    return n;
  }
}
const JG = /* @__PURE__ */ O.createContext(), BC = () => O.useContext(JG) ?? !1, tU = /* @__PURE__ */ O.createContext(void 0);
function eU(n) {
  const {
    theme: t,
    name: e,
    props: i
  } = n;
  if (!t || !t.components || !t.components[e])
    return i;
  const s = t.components[e];
  return s.defaultProps ? dh(s.defaultProps, i, t.components.mergeClassNameAndStyle) : !s.styleOverrides && !s.variants ? dh(s, i, t.components.mergeClassNameAndStyle) : i;
}
function nU({
  props: n,
  name: t
}) {
  const e = O.useContext(tU);
  return eU({
    props: n,
    name: t,
    theme: {
      components: e
    }
  });
}
let uS = 0;
function iU(n) {
  const [t, e] = O.useState(n), i = n || t;
  return O.useEffect(() => {
    t == null && (uS += 1, e(`mui-${uS}`));
  }, [t]), i;
}
const rU = {
  ...am
}, cS = rU.useId;
function Kg(n) {
  if (cS !== void 0) {
    const t = cS();
    return n ?? t;
  }
  return iU(n);
}
const hS = {
  theme: void 0
};
function sU(n) {
  let t, e;
  return function(s) {
    let o = t;
    return (o === void 0 || s.theme !== e) && (hS.theme = s.theme, o = AC(n(hS)), t = o, e = s.theme), o;
  };
}
function aU(n = "") {
  function t(...i) {
    if (!i.length)
      return "";
    const s = i[0];
    return typeof s == "string" && !s.match(/(#|\(|\)|(-?(\d*\.)?\d+)(px|em|%|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc))|^(-?(\d*\.)?\d+)$|(\d+ \d+ \d+)/) ? `, var(--${n ? `${n}-` : ""}${s}${t(...i.slice(1))})` : `, ${s}`;
  }
  return (i, ...s) => `var(--${n ? `${n}-` : ""}${i}${t(...s)})`;
}
const dS = (n, t, e, i = []) => {
  let s = n;
  t.forEach((o, l) => {
    l === t.length - 1 ? Array.isArray(s) ? s[Number(o)] = e : s && typeof s == "object" && (s[o] = e) : s && typeof s == "object" && (s[o] || (s[o] = i.includes(o) ? [] : {}), s = s[o]);
  });
}, oU = (n, t, e) => {
  function i(s, o = [], l = []) {
    Object.entries(s).forEach(([c, d]) => {
      (!e || e && !e([...o, c])) && d != null && (typeof d == "object" && Object.keys(d).length > 0 ? i(d, [...o, c], Array.isArray(d) ? [...l, c] : l) : t([...o, c], d, l));
    });
  }
  i(n);
}, lU = (n, t) => typeof t == "number" ? ["lineHeight", "fontWeight", "opacity", "zIndex"].some((i) => n.includes(i)) || n[n.length - 1].toLowerCase().includes("opacity") ? t : `${t}px` : t;
function tm(n, t) {
  const {
    prefix: e,
    shouldSkipGeneratingVar: i
  } = t || {}, s = {}, o = {}, l = {};
  return oU(
    n,
    (c, d, f) => {
      if ((typeof d == "string" || typeof d == "number") && (!i || !i(c, d))) {
        const m = `--${e ? `${e}-` : ""}${c.join("-")}`, y = lU(c, d);
        Object.assign(s, {
          [m]: y
        }), dS(o, c, `var(${m})`, f), dS(l, c, `var(${m}, ${y})`, f);
      }
    },
    (c) => c[0] === "vars"
    // skip 'vars/*' paths
  ), {
    css: s,
    vars: o,
    varsWithDefaults: l
  };
}
function uU(n, t = {}) {
  const {
    getSelector: e = C,
    disableCssColorScheme: i,
    colorSchemeSelector: s,
    enableContrastVars: o
  } = t, {
    colorSchemes: l = {},
    components: c,
    defaultColorScheme: d = "light",
    ...f
  } = n, {
    vars: m,
    css: y,
    varsWithDefaults: b
  } = tm(f, t);
  let v = b;
  const x = {}, {
    [d]: S,
    ..._
  } = l;
  if (Object.entries(_ || {}).forEach(([E, P]) => {
    const {
      vars: k,
      css: G,
      varsWithDefaults: $
    } = tm(P, t);
    v = wn(v, $), x[E] = {
      css: G,
      vars: k
    };
  }), S) {
    const {
      css: E,
      vars: P,
      varsWithDefaults: k
    } = tm(S, t);
    v = wn(v, k), x[d] = {
      css: E,
      vars: P
    };
  }
  function C(E, P) {
    let k = s;
    if (s === "class" && (k = ".%s"), s === "data" && (k = "[data-%s]"), s?.startsWith("data-") && !s.includes("%s") && (k = `[${s}="%s"]`), E) {
      if (k === "media")
        return n.defaultColorScheme === E ? ":root" : {
          [`@media (prefers-color-scheme: ${l[E]?.palette?.mode || E})`]: {
            ":root": P
          }
        };
      if (k)
        return n.defaultColorScheme === E ? `:root, ${k.replace("%s", String(E))}` : k.replace("%s", String(E));
    }
    return ":root";
  }
  return {
    vars: v,
    generateThemeVars: () => {
      let E = {
        ...m
      };
      return Object.entries(x).forEach(([, {
        vars: P
      }]) => {
        E = wn(E, P);
      }), E;
    },
    generateStyleSheets: () => {
      const E = [], P = n.defaultColorScheme || "light";
      function k(F, j) {
        Object.keys(j).length && E.push(typeof F == "string" ? {
          [F]: {
            ...j
          }
        } : F);
      }
      k(e(void 0, {
        ...y
      }), y);
      const {
        [P]: G,
        ...$
      } = x;
      if (G) {
        const {
          css: F
        } = G, j = l[P]?.palette?.mode, H = !i && j ? {
          colorScheme: j,
          ...F
        } : {
          ...F
        };
        k(e(P, {
          ...H
        }), H);
      }
      return Object.entries($).forEach(([F, {
        css: j
      }]) => {
        const H = l[F]?.palette?.mode, M = !i && H ? {
          colorScheme: H,
          ...j
        } : {
          ...j
        };
        k(e(F, {
          ...M
        }), M);
      }), o && E.push({
        ":root": {
          // use double underscore to indicate that these are private variables
          "--__l-threshold": "0.7",
          "--__l": "clamp(0, (l / var(--__l-threshold) - 1) * -infinity, 1)",
          "--__a": "clamp(0.87, (l / var(--__l-threshold) - 1) * -infinity, 1)"
          // 0.87 is the default alpha value for black text.
        }
      }), E;
    }
  };
}
function cU(n) {
  return function(e) {
    return n === "media" ? `@media (prefers-color-scheme: ${e})` : n ? n.startsWith("data-") && !n.includes("%s") ? `[${n}="${e}"] &` : n === "class" ? `.${e} &` : n === "data" ? `[data-${e}] &` : `${n.replace("%s", e)} &` : "&";
  };
}
function Oe(n, t, e = void 0) {
  const i = {};
  for (const s in n) {
    const o = n[s];
    let l = "", c = !0;
    for (let d = 0; d < o.length; d += 1) {
      const f = o[d];
      f && (l += (c === !0 ? "" : " ") + t(f), c = !1, e && e[f] && (l += " " + e[f]));
    }
    i[s] = l;
  }
  return i;
}
function em(n, t) {
  return /* @__PURE__ */ O.isValidElement(n) && t.indexOf(
    // For server components `muiName` is available in element.type._payload.value.muiName
    // relevant info - https://github.com/facebook/react/blob/2807d781a08db8e9873687fccc25c0f12b4fb3d4/packages/react/src/ReactLazy.js#L45
    // eslint-disable-next-line no-underscore-dangle
    n.type.muiName ?? n.type?._payload?.value?.muiName
  ) !== -1;
}
function kC() {
  return {
    // The colors used to style the text.
    text: {
      // The most important text.
      primary: "rgba(0, 0, 0, 0.87)",
      // Secondary text.
      secondary: "rgba(0, 0, 0, 0.6)",
      // Disabled text have even lower visual prominence.
      disabled: "rgba(0, 0, 0, 0.38)"
    },
    // The color used to divide different elements.
    divider: "rgba(0, 0, 0, 0.12)",
    // The background colors used to style the surfaces.
    // Consistency between these values is important.
    background: {
      paper: Wl.white,
      default: Wl.white
    },
    // The colors used to style the action elements.
    action: {
      // The color of an active action like an icon button.
      active: "rgba(0, 0, 0, 0.54)",
      // The color of an hovered action.
      hover: "rgba(0, 0, 0, 0.04)",
      hoverOpacity: 0.04,
      // The color of a selected action.
      selected: "rgba(0, 0, 0, 0.08)",
      selectedOpacity: 0.08,
      // The color of a disabled action.
      disabled: "rgba(0, 0, 0, 0.26)",
      // The background color of a disabled action.
      disabledBackground: "rgba(0, 0, 0, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(0, 0, 0, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.12
    }
  };
}
const OC = kC();
function DC() {
  return {
    text: {
      primary: Wl.white,
      secondary: "rgba(255, 255, 255, 0.7)",
      disabled: "rgba(255, 255, 255, 0.5)",
      icon: "rgba(255, 255, 255, 0.5)"
    },
    divider: "rgba(255, 255, 255, 0.12)",
    background: {
      paper: "#121212",
      default: "#121212"
    },
    action: {
      active: Wl.white,
      hover: "rgba(255, 255, 255, 0.08)",
      hoverOpacity: 0.08,
      selected: "rgba(255, 255, 255, 0.16)",
      selectedOpacity: 0.16,
      disabled: "rgba(255, 255, 255, 0.3)",
      disabledBackground: "rgba(255, 255, 255, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(255, 255, 255, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.24
    }
  };
}
const Im = DC();
function fS(n, t, e, i) {
  const s = i.light || i, o = i.dark || i * 1.5;
  n[t] || (n.hasOwnProperty(e) ? n[t] = n[e] : t === "light" ? n.light = Fh(n.main, s) : t === "dark" && (n.dark = Lh(n.main, o)));
}
function pS(n, t, e, i, s) {
  const o = s.light || s, l = s.dark || s * 1.5;
  t[e] || (t.hasOwnProperty(i) ? t[e] = t[i] : e === "light" ? t.light = `color-mix(in ${n}, ${t.main}, #fff ${(o * 100).toFixed(0)}%)` : e === "dark" && (t.dark = `color-mix(in ${n}, ${t.main}, #000 ${(l * 100).toFixed(0)}%)`));
}
function hU(n = "light") {
  return n === "dark" ? {
    main: Pa[200],
    light: Pa[50],
    dark: Pa[400]
  } : {
    main: Pa[700],
    light: Pa[400],
    dark: Pa[800]
  };
}
function dU(n = "light") {
  return n === "dark" ? {
    main: Ra[200],
    light: Ra[50],
    dark: Ra[400]
  } : {
    main: Ra[500],
    light: Ra[300],
    dark: Ra[700]
  };
}
function fU(n = "light") {
  return n === "dark" ? {
    main: Aa[500],
    light: Aa[300],
    dark: Aa[700]
  } : {
    main: Aa[700],
    light: Aa[400],
    dark: Aa[800]
  };
}
function pU(n = "light") {
  return n === "dark" ? {
    main: Ba[400],
    light: Ba[300],
    dark: Ba[700]
  } : {
    main: Ba[700],
    light: Ba[500],
    dark: Ba[900]
  };
}
function mU(n = "light") {
  return n === "dark" ? {
    main: ka[400],
    light: ka[300],
    dark: ka[700]
  } : {
    main: ka[800],
    light: ka[500],
    dark: ka[900]
  };
}
function gU(n = "light") {
  return n === "dark" ? {
    main: hl[400],
    light: hl[300],
    dark: hl[700]
  } : {
    main: "#ed6c02",
    // closest to orange[800] that pass 3:1.
    light: hl[500],
    dark: hl[900]
  };
}
function yU(n) {
  return `oklch(from ${n} var(--__l) 0 h / var(--__a))`;
}
function Zg(n) {
  const {
    mode: t = "light",
    contrastThreshold: e = 3,
    tonalOffset: i = 0.2,
    colorSpace: s,
    ...o
  } = n, l = n.primary || hU(t), c = n.secondary || dU(t), d = n.error || fU(t), f = n.info || pU(t), m = n.success || mU(t), y = n.warning || gU(t);
  function b(_) {
    return s ? yU(_) : ZG(_, Im.text.primary) >= e ? Im.text.primary : OC.text.primary;
  }
  const v = ({
    color: _,
    name: C,
    mainShade: R = 500,
    lightShade: w = 300,
    darkShade: E = 700
  }) => {
    if (_ = {
      ..._
    }, !_.main && _[R] && (_.main = _[R]), !_.hasOwnProperty("main"))
      throw new Error(_r(11, C ? ` (${C})` : "", R));
    if (typeof _.main != "string")
      throw new Error(_r(12, C ? ` (${C})` : "", JSON.stringify(_.main)));
    return s ? (pS(s, _, "light", w, i), pS(s, _, "dark", E, i)) : (fS(_, "light", w, i), fS(_, "dark", E, i)), _.contrastText || (_.contrastText = b(_.main)), _;
  };
  let x;
  return t === "light" ? x = kC() : t === "dark" && (x = DC()), wn({
    // A collection of common colors.
    common: {
      ...Wl
    },
    // prevent mutable object.
    // The palette mode, can be light or dark.
    mode: t,
    // The colors used to represent primary interface elements for a user.
    primary: v({
      color: l,
      name: "primary"
    }),
    // The colors used to represent secondary interface elements for a user.
    secondary: v({
      color: c,
      name: "secondary",
      mainShade: "A400",
      lightShade: "A200",
      darkShade: "A700"
    }),
    // The colors used to represent interface elements that the user should be made aware of.
    error: v({
      color: d,
      name: "error"
    }),
    // The colors used to represent potentially dangerous actions or important messages.
    warning: v({
      color: y,
      name: "warning"
    }),
    // The colors used to present information to the user that is neutral and not necessarily important.
    info: v({
      color: f,
      name: "info"
    }),
    // The colors used to indicate the successful completion of an action that user triggered.
    success: v({
      color: m,
      name: "success"
    }),
    // The grey colors.
    grey: UO,
    // Used by `getContrastText()` to maximize the contrast between
    // the background and the text.
    contrastThreshold: e,
    // Takes a background color and returns the text color that maximizes the contrast.
    getContrastText: b,
    // Generate a rich color object.
    augmentColor: v,
    // Used by the functions below to shift a color's luminance by approximately
    // two indexes within its tonal palette.
    // E.g., shift from Red 500 to Red 300 or Red 700.
    tonalOffset: i,
    // The light and dark mode object.
    ...x
  }, o);
}
function bU(n) {
  const t = {};
  return Object.entries(n).forEach((i) => {
    const [s, o] = i;
    typeof o == "object" && (t[s] = `${o.fontStyle ? `${o.fontStyle} ` : ""}${o.fontVariant ? `${o.fontVariant} ` : ""}${o.fontWeight ? `${o.fontWeight} ` : ""}${o.fontStretch ? `${o.fontStretch} ` : ""}${o.fontSize || ""}${o.lineHeight ? `/${o.lineHeight} ` : ""}${o.fontFamily || ""}`);
  }), t;
}
function vU(n, t) {
  return {
    toolbar: {
      minHeight: 56,
      [n.up("xs")]: {
        "@media (orientation: landscape)": {
          minHeight: 48
        }
      },
      [n.up("sm")]: {
        minHeight: 64
      }
    },
    ...t
  };
}
function xU(n) {
  return Math.round(n * 1e5) / 1e5;
}
const mS = {
  textTransform: "uppercase"
}, gS = '"Roboto", "Helvetica", "Arial", sans-serif';
function _U(n, t) {
  const {
    fontFamily: e = gS,
    // The default font size of the Material Specification.
    fontSize: i = 14,
    // px
    fontWeightLight: s = 300,
    fontWeightRegular: o = 400,
    fontWeightMedium: l = 500,
    fontWeightBold: c = 700,
    // Tell MUI what's the font-size on the html element.
    // 16px is the default font-size used by browsers.
    htmlFontSize: d = 16,
    // Apply the CSS properties to all the variants.
    allVariants: f,
    pxToRem: m,
    ...y
  } = typeof t == "function" ? t(n) : t, b = i / 14, v = m || ((_) => `${_ / d * b}rem`), x = (_, C, R, w, E) => ({
    fontFamily: e,
    fontWeight: _,
    fontSize: v(C),
    // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
    lineHeight: R,
    // The letter spacing was designed for the Roboto font-family. Using the same letter-spacing
    // across font-families can cause issues with the kerning.
    ...e === gS ? {
      letterSpacing: `${xU(w / C)}em`
    } : {},
    ...E,
    ...f
  }), S = {
    h1: x(s, 96, 1.167, -1.5),
    h2: x(s, 60, 1.2, -0.5),
    h3: x(o, 48, 1.167, 0),
    h4: x(o, 34, 1.235, 0.25),
    h5: x(o, 24, 1.334, 0),
    h6: x(l, 20, 1.6, 0.15),
    subtitle1: x(o, 16, 1.75, 0.15),
    subtitle2: x(l, 14, 1.57, 0.1),
    body1: x(o, 16, 1.5, 0.15),
    body2: x(o, 14, 1.43, 0.15),
    button: x(l, 14, 1.75, 0.4, mS),
    caption: x(o, 12, 1.66, 0.4),
    overline: x(o, 12, 2.66, 1, mS),
    // TODO v6: Remove handling of 'inherit' variant from the theme as it is already handled in Material UI's Typography component. Also, remember to remove the associated types.
    inherit: {
      fontFamily: "inherit",
      fontWeight: "inherit",
      fontSize: "inherit",
      lineHeight: "inherit",
      letterSpacing: "inherit"
    }
  };
  return wn({
    htmlFontSize: d,
    pxToRem: v,
    fontFamily: e,
    fontSize: i,
    fontWeightLight: s,
    fontWeightRegular: o,
    fontWeightMedium: l,
    fontWeightBold: c,
    ...S
  }, y, {
    clone: !1
    // No need to clone deep
  });
}
const SU = 0.2, TU = 0.14, wU = 0.12;
function Re(...n) {
  return [`${n[0]}px ${n[1]}px ${n[2]}px ${n[3]}px rgba(0,0,0,${SU})`, `${n[4]}px ${n[5]}px ${n[6]}px ${n[7]}px rgba(0,0,0,${TU})`, `${n[8]}px ${n[9]}px ${n[10]}px ${n[11]}px rgba(0,0,0,${wU})`].join(",");
}
const CU = ["none", Re(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), Re(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), Re(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), Re(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), Re(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), Re(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), Re(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), Re(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), Re(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), Re(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), Re(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), Re(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), Re(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), Re(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), Re(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), Re(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), Re(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), Re(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), Re(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), Re(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), Re(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), Re(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), Re(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), Re(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)], EU = {
  // This is the most common easing curve.
  easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
  // Objects enter the screen at full velocity from off-screen and
  // slowly decelerate to a resting point.
  easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
  // Objects leave the screen at full velocity. They do not decelerate when off-screen.
  easeIn: "cubic-bezier(0.4, 0, 1, 1)",
  // The sharp curve is used by objects that may return to the screen at any time.
  sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
}, MU = {
  shortest: 150,
  shorter: 200,
  short: 250,
  // most basic recommended timing
  standard: 300,
  // this is to be used in complex animations
  complex: 375,
  // recommended when something is entering screen
  enteringScreen: 225,
  // recommended when something is leaving screen
  leavingScreen: 195
};
function yS(n) {
  return `${Math.round(n)}ms`;
}
function AU(n) {
  if (!n)
    return 0;
  const t = n / 36;
  return Math.min(Math.round((4 + 15 * t ** 0.25 + t / 5) * 10), 3e3);
}
function RU(n) {
  const t = {
    ...EU,
    ...n.easing
  }, e = {
    ...MU,
    ...n.duration
  };
  return {
    getAutoHeightDuration: AU,
    create: (s = ["all"], o = {}) => {
      const {
        duration: l = e.standard,
        easing: c = t.easeInOut,
        delay: d = 0,
        ...f
      } = o;
      return (Array.isArray(s) ? s : [s]).map((m) => `${m} ${typeof l == "string" ? l : yS(l)} ${c} ${typeof d == "string" ? d : yS(d)}`).join(",");
    },
    ...n,
    easing: t,
    duration: e
  };
}
const PU = {
  mobileStepper: 1e3,
  fab: 1050,
  speedDial: 1050,
  appBar: 1100,
  drawer: 1200,
  modal: 1300,
  snackbar: 1400,
  tooltip: 1500
};
function BU(n) {
  return pr(n) || typeof n > "u" || typeof n == "string" || typeof n == "boolean" || typeof n == "number" || Array.isArray(n);
}
function GC(n = {}) {
  const t = {
    ...n
  };
  function e(i) {
    const s = Object.entries(i);
    for (let o = 0; o < s.length; o++) {
      const [l, c] = s[o];
      !BU(c) || l.startsWith("unstable_") ? delete i[l] : pr(c) && (i[l] = {
        ...c
      }, e(i[l]));
    }
  }
  return e(t), `import { unstable_createBreakpoints as createBreakpoints, createTransitions } from '@mui/material/styles';

const theme = ${JSON.stringify(t, null, 2)};

theme.breakpoints = createBreakpoints(theme.breakpoints || {});
theme.transitions = createTransitions(theme.transitions || {});

export default theme;`;
}
function bS(n) {
  return typeof n == "number" ? `${(n * 100).toFixed(0)}%` : `calc((${n}) * 100%)`;
}
const kU = (n) => {
  if (!Number.isNaN(+n))
    return +n;
  const t = n.match(/\d*\.?\d+/g);
  if (!t)
    return 0;
  let e = 0;
  for (let i = 0; i < t.length; i += 1)
    e += +t[i];
  return e;
};
function OU(n) {
  Object.assign(n, {
    alpha(t, e) {
      const i = this || n;
      return i.colorSpace ? `oklch(from ${t} l c h / ${typeof e == "string" ? `calc(${e})` : e})` : i.vars ? `rgba(${t.replace(/var\(--([^,\s)]+)(?:,[^)]+)?\)+/g, "var(--$1Channel)")} / ${typeof e == "string" ? `calc(${e})` : e})` : fh(t, kU(e));
    },
    lighten(t, e) {
      const i = this || n;
      return i.colorSpace ? `color-mix(in ${i.colorSpace}, ${t}, #fff ${bS(e)})` : Fh(t, e);
    },
    darken(t, e) {
      const i = this || n;
      return i.colorSpace ? `color-mix(in ${i.colorSpace}, ${t}, #000 ${bS(e)})` : Lh(t, e);
    }
  });
}
function zm(n = {}, ...t) {
  const {
    breakpoints: e,
    mixins: i = {},
    spacing: s,
    palette: o = {},
    transitions: l = {},
    typography: c = {},
    shape: d,
    colorSpace: f,
    ...m
  } = n;
  if (n.vars && // The error should throw only for the root theme creation because user is not allowed to use a custom node `vars`.
  // `generateThemeVars` is the closest identifier for checking that the `options` is a result of `createTheme` with CSS variables so that user can create new theme for nested ThemeProvider.
  n.generateThemeVars === void 0)
    throw new Error(_r(20));
  const y = Zg({
    ...o,
    colorSpace: f
  }), b = Xg(n);
  let v = wn(b, {
    mixins: vU(b.breakpoints, i),
    palette: y,
    // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
    shadows: CU.slice(),
    typography: _U(y, c),
    transitions: RU(l),
    zIndex: {
      ...PU
    }
  });
  return v = wn(v, m), v = t.reduce((x, S) => wn(x, S), v), v.unstable_sxConfig = {
    ...Ih,
    ...m?.unstable_sxConfig
  }, v.unstable_sx = function(S) {
    return Qa({
      sx: S,
      theme: this
    });
  }, v.toRuntimeSource = GC, OU(v), v;
}
function Lm(n) {
  let t;
  return n < 1 ? t = 5.11916 * n ** 2 : t = 4.5 * Math.log(n + 1) + 2, Math.round(t * 10) / 1e3;
}
const DU = [...Array(25)].map((n, t) => {
  if (t === 0)
    return "none";
  const e = Lm(t);
  return `linear-gradient(rgba(255 255 255 / ${e}), rgba(255 255 255 / ${e}))`;
});
function UC(n) {
  return {
    inputPlaceholder: n === "dark" ? 0.5 : 0.42,
    inputUnderline: n === "dark" ? 0.7 : 0.42,
    switchTrackDisabled: n === "dark" ? 0.2 : 0.12,
    switchTrack: n === "dark" ? 0.3 : 0.38
  };
}
function NC(n) {
  return n === "dark" ? DU : [];
}
function GU(n) {
  const {
    palette: t = {
      mode: "light"
    },
    // need to cast to avoid module augmentation test
    opacity: e,
    overlays: i,
    colorSpace: s,
    ...o
  } = n, l = Zg({
    ...t,
    colorSpace: s
  });
  return {
    palette: l,
    opacity: {
      ...UC(l.mode),
      ...e
    },
    overlays: i || NC(l.mode),
    ...o
  };
}
function UU(n) {
  return !!n[0].match(/(cssVarPrefix|colorSchemeSelector|modularCssLayers|rootSelector|typography|mixins|breakpoints|direction|transitions)/) || !!n[0].match(/sxConfig$/) || // ends with sxConfig
  n[0] === "palette" && !!n[1]?.match(/(mode|contrastThreshold|tonalOffset)/);
}
const NU = (n) => [...[...Array(25)].map((t, e) => `--${n ? `${n}-` : ""}overlays-${e}`), `--${n ? `${n}-` : ""}palette-AppBar-darkBg`, `--${n ? `${n}-` : ""}palette-AppBar-darkColor`], IU = (n) => (t, e) => {
  const i = n.rootSelector || ":root", s = n.colorSchemeSelector;
  let o = s;
  if (s === "class" && (o = ".%s"), s === "data" && (o = "[data-%s]"), s?.startsWith("data-") && !s.includes("%s") && (o = `[${s}="%s"]`), n.defaultColorScheme === t) {
    if (t === "dark") {
      const l = {};
      return NU(n.cssVarPrefix).forEach((c) => {
        l[c] = e[c], delete e[c];
      }), o === "media" ? {
        [i]: e,
        "@media (prefers-color-scheme: dark)": {
          [i]: l
        }
      } : o ? {
        [o.replace("%s", t)]: l,
        [`${i}, ${o.replace("%s", t)}`]: e
      } : {
        [i]: {
          ...e,
          ...l
        }
      };
    }
    if (o && o !== "media")
      return `${i}, ${o.replace("%s", String(t))}`;
  } else if (t) {
    if (o === "media")
      return {
        [`@media (prefers-color-scheme: ${String(t)})`]: {
          [i]: e
        }
      };
    if (o)
      return o.replace("%s", String(t));
  }
  return i;
};
function zU(n, t) {
  t.forEach((e) => {
    n[e] || (n[e] = {});
  });
}
function tt(n, t, e) {
  !n[t] && e && (n[t] = e);
}
function Sl(n) {
  return typeof n != "string" || !n.startsWith("hsl") ? n : PC(n);
}
function ur(n, t) {
  `${t}Channel` in n || (n[`${t}Channel`] = _l(Sl(n[t])));
}
function LU(n) {
  return typeof n == "number" ? `${n}px` : typeof n == "string" || typeof n == "function" || Array.isArray(n) ? n : "8px";
}
const Di = (n) => {
  try {
    return n();
  } catch {
  }
}, FU = (n = "mui") => aU(n);
function nm(n, t, e, i, s) {
  if (!e)
    return;
  e = e === !0 ? {} : e;
  const o = s === "dark" ? "dark" : "light";
  if (!i) {
    t[s] = GU({
      ...e,
      palette: {
        mode: o,
        ...e?.palette
      },
      colorSpace: n
    });
    return;
  }
  const {
    palette: l,
    ...c
  } = zm({
    ...i,
    palette: {
      mode: o,
      ...e?.palette
    },
    colorSpace: n
  });
  return t[s] = {
    ...e,
    palette: l,
    opacity: {
      ...UC(o),
      ...e?.opacity
    },
    overlays: e?.overlays || NC(o)
  }, c;
}
function HU(n = {}, ...t) {
  const {
    colorSchemes: e = {
      light: !0
    },
    defaultColorScheme: i,
    disableCssColorScheme: s = !1,
    cssVarPrefix: o = "mui",
    nativeColor: l = !1,
    shouldSkipGeneratingVar: c = UU,
    colorSchemeSelector: d = e.light && e.dark ? "media" : void 0,
    rootSelector: f = ":root",
    ...m
  } = n, y = Object.keys(e)[0], b = i || (e.light && y !== "light" ? "light" : y), v = FU(o), {
    [b]: x,
    light: S,
    dark: _,
    ...C
  } = e, R = {
    ...C
  };
  let w = x;
  if ((b === "dark" && !("dark" in e) || b === "light" && !("light" in e)) && (w = !0), !w)
    throw new Error(_r(21, b));
  let E;
  l && (E = "oklch");
  const P = nm(E, R, w, m, b);
  S && !R.light && nm(E, R, S, void 0, "light"), _ && !R.dark && nm(E, R, _, void 0, "dark");
  let k = {
    defaultColorScheme: b,
    ...P,
    cssVarPrefix: o,
    colorSchemeSelector: d,
    rootSelector: f,
    getCssVar: v,
    colorSchemes: R,
    font: {
      ...bU(P.typography),
      ...P.font
    },
    spacing: LU(m.spacing)
  };
  Object.keys(k.colorSchemes).forEach((H) => {
    const M = k.colorSchemes[H].palette, Y = (Q) => {
      const B = Q.split("-"), I = B[1], rt = B[2];
      return v(Q, M[I][rt]);
    };
    M.mode === "light" && (tt(M.common, "background", "#fff"), tt(M.common, "onBackground", "#000")), M.mode === "dark" && (tt(M.common, "background", "#000"), tt(M.common, "onBackground", "#fff"));
    function L(Q, B, I) {
      if (E) {
        let rt;
        return Q === Ts && (rt = `transparent ${((1 - I) * 100).toFixed(0)}%`), Q === de && (rt = `#000 ${(I * 100).toFixed(0)}%`), Q === fe && (rt = `#fff ${(I * 100).toFixed(0)}%`), `color-mix(in ${E}, ${B}, ${rt})`;
      }
      return Q(B, I);
    }
    if (zU(M, ["Alert", "AppBar", "Avatar", "Button", "Chip", "FilledInput", "LinearProgress", "Skeleton", "Slider", "SnackbarContent", "SpeedDialAction", "StepConnector", "StepContent", "Switch", "TableCell", "Tooltip"]), M.mode === "light") {
      tt(M.Alert, "errorColor", L(de, M.error.light, 0.6)), tt(M.Alert, "infoColor", L(de, M.info.light, 0.6)), tt(M.Alert, "successColor", L(de, M.success.light, 0.6)), tt(M.Alert, "warningColor", L(de, M.warning.light, 0.6)), tt(M.Alert, "errorFilledBg", Y("palette-error-main")), tt(M.Alert, "infoFilledBg", Y("palette-info-main")), tt(M.Alert, "successFilledBg", Y("palette-success-main")), tt(M.Alert, "warningFilledBg", Y("palette-warning-main")), tt(M.Alert, "errorFilledColor", Di(() => M.getContrastText(M.error.main))), tt(M.Alert, "infoFilledColor", Di(() => M.getContrastText(M.info.main))), tt(M.Alert, "successFilledColor", Di(() => M.getContrastText(M.success.main))), tt(M.Alert, "warningFilledColor", Di(() => M.getContrastText(M.warning.main))), tt(M.Alert, "errorStandardBg", L(fe, M.error.light, 0.9)), tt(M.Alert, "infoStandardBg", L(fe, M.info.light, 0.9)), tt(M.Alert, "successStandardBg", L(fe, M.success.light, 0.9)), tt(M.Alert, "warningStandardBg", L(fe, M.warning.light, 0.9)), tt(M.Alert, "errorIconColor", Y("palette-error-main")), tt(M.Alert, "infoIconColor", Y("palette-info-main")), tt(M.Alert, "successIconColor", Y("palette-success-main")), tt(M.Alert, "warningIconColor", Y("palette-warning-main")), tt(M.AppBar, "defaultBg", Y("palette-grey-100")), tt(M.Avatar, "defaultBg", Y("palette-grey-400")), tt(M.Button, "inheritContainedBg", Y("palette-grey-300")), tt(M.Button, "inheritContainedHoverBg", Y("palette-grey-A100")), tt(M.Chip, "defaultBorder", Y("palette-grey-400")), tt(M.Chip, "defaultAvatarColor", Y("palette-grey-700")), tt(M.Chip, "defaultIconColor", Y("palette-grey-700")), tt(M.FilledInput, "bg", "rgba(0, 0, 0, 0.06)"), tt(M.FilledInput, "hoverBg", "rgba(0, 0, 0, 0.09)"), tt(M.FilledInput, "disabledBg", "rgba(0, 0, 0, 0.12)"), tt(M.LinearProgress, "primaryBg", L(fe, M.primary.main, 0.62)), tt(M.LinearProgress, "secondaryBg", L(fe, M.secondary.main, 0.62)), tt(M.LinearProgress, "errorBg", L(fe, M.error.main, 0.62)), tt(M.LinearProgress, "infoBg", L(fe, M.info.main, 0.62)), tt(M.LinearProgress, "successBg", L(fe, M.success.main, 0.62)), tt(M.LinearProgress, "warningBg", L(fe, M.warning.main, 0.62)), tt(M.Skeleton, "bg", E ? L(Ts, M.text.primary, 0.11) : `rgba(${Y("palette-text-primaryChannel")} / 0.11)`), tt(M.Slider, "primaryTrack", L(fe, M.primary.main, 0.62)), tt(M.Slider, "secondaryTrack", L(fe, M.secondary.main, 0.62)), tt(M.Slider, "errorTrack", L(fe, M.error.main, 0.62)), tt(M.Slider, "infoTrack", L(fe, M.info.main, 0.62)), tt(M.Slider, "successTrack", L(fe, M.success.main, 0.62)), tt(M.Slider, "warningTrack", L(fe, M.warning.main, 0.62));
      const Q = E ? L(de, M.background.default, 0.6825) : Nc(M.background.default, 0.8);
      tt(M.SnackbarContent, "bg", Q), tt(M.SnackbarContent, "color", Di(() => E ? Im.text.primary : M.getContrastText(Q))), tt(M.SpeedDialAction, "fabHoverBg", Nc(M.background.paper, 0.15)), tt(M.StepConnector, "border", Y("palette-grey-400")), tt(M.StepContent, "border", Y("palette-grey-400")), tt(M.Switch, "defaultColor", Y("palette-common-white")), tt(M.Switch, "defaultDisabledColor", Y("palette-grey-100")), tt(M.Switch, "primaryDisabledColor", L(fe, M.primary.main, 0.62)), tt(M.Switch, "secondaryDisabledColor", L(fe, M.secondary.main, 0.62)), tt(M.Switch, "errorDisabledColor", L(fe, M.error.main, 0.62)), tt(M.Switch, "infoDisabledColor", L(fe, M.info.main, 0.62)), tt(M.Switch, "successDisabledColor", L(fe, M.success.main, 0.62)), tt(M.Switch, "warningDisabledColor", L(fe, M.warning.main, 0.62)), tt(M.TableCell, "border", L(fe, L(Ts, M.divider, 1), 0.88)), tt(M.Tooltip, "bg", L(Ts, M.grey[700], 0.92));
    }
    if (M.mode === "dark") {
      tt(M.Alert, "errorColor", L(fe, M.error.light, 0.6)), tt(M.Alert, "infoColor", L(fe, M.info.light, 0.6)), tt(M.Alert, "successColor", L(fe, M.success.light, 0.6)), tt(M.Alert, "warningColor", L(fe, M.warning.light, 0.6)), tt(M.Alert, "errorFilledBg", Y("palette-error-dark")), tt(M.Alert, "infoFilledBg", Y("palette-info-dark")), tt(M.Alert, "successFilledBg", Y("palette-success-dark")), tt(M.Alert, "warningFilledBg", Y("palette-warning-dark")), tt(M.Alert, "errorFilledColor", Di(() => M.getContrastText(M.error.dark))), tt(M.Alert, "infoFilledColor", Di(() => M.getContrastText(M.info.dark))), tt(M.Alert, "successFilledColor", Di(() => M.getContrastText(M.success.dark))), tt(M.Alert, "warningFilledColor", Di(() => M.getContrastText(M.warning.dark))), tt(M.Alert, "errorStandardBg", L(de, M.error.light, 0.9)), tt(M.Alert, "infoStandardBg", L(de, M.info.light, 0.9)), tt(M.Alert, "successStandardBg", L(de, M.success.light, 0.9)), tt(M.Alert, "warningStandardBg", L(de, M.warning.light, 0.9)), tt(M.Alert, "errorIconColor", Y("palette-error-main")), tt(M.Alert, "infoIconColor", Y("palette-info-main")), tt(M.Alert, "successIconColor", Y("palette-success-main")), tt(M.Alert, "warningIconColor", Y("palette-warning-main")), tt(M.AppBar, "defaultBg", Y("palette-grey-900")), tt(M.AppBar, "darkBg", Y("palette-background-paper")), tt(M.AppBar, "darkColor", Y("palette-text-primary")), tt(M.Avatar, "defaultBg", Y("palette-grey-600")), tt(M.Button, "inheritContainedBg", Y("palette-grey-800")), tt(M.Button, "inheritContainedHoverBg", Y("palette-grey-700")), tt(M.Chip, "defaultBorder", Y("palette-grey-700")), tt(M.Chip, "defaultAvatarColor", Y("palette-grey-300")), tt(M.Chip, "defaultIconColor", Y("palette-grey-300")), tt(M.FilledInput, "bg", "rgba(255, 255, 255, 0.09)"), tt(M.FilledInput, "hoverBg", "rgba(255, 255, 255, 0.13)"), tt(M.FilledInput, "disabledBg", "rgba(255, 255, 255, 0.12)"), tt(M.LinearProgress, "primaryBg", L(de, M.primary.main, 0.5)), tt(M.LinearProgress, "secondaryBg", L(de, M.secondary.main, 0.5)), tt(M.LinearProgress, "errorBg", L(de, M.error.main, 0.5)), tt(M.LinearProgress, "infoBg", L(de, M.info.main, 0.5)), tt(M.LinearProgress, "successBg", L(de, M.success.main, 0.5)), tt(M.LinearProgress, "warningBg", L(de, M.warning.main, 0.5)), tt(M.Skeleton, "bg", E ? L(Ts, M.text.primary, 0.13) : `rgba(${Y("palette-text-primaryChannel")} / 0.13)`), tt(M.Slider, "primaryTrack", L(de, M.primary.main, 0.5)), tt(M.Slider, "secondaryTrack", L(de, M.secondary.main, 0.5)), tt(M.Slider, "errorTrack", L(de, M.error.main, 0.5)), tt(M.Slider, "infoTrack", L(de, M.info.main, 0.5)), tt(M.Slider, "successTrack", L(de, M.success.main, 0.5)), tt(M.Slider, "warningTrack", L(de, M.warning.main, 0.5));
      const Q = E ? L(fe, M.background.default, 0.985) : Nc(M.background.default, 0.98);
      tt(M.SnackbarContent, "bg", Q), tt(M.SnackbarContent, "color", Di(() => E ? OC.text.primary : M.getContrastText(Q))), tt(M.SpeedDialAction, "fabHoverBg", Nc(M.background.paper, 0.15)), tt(M.StepConnector, "border", Y("palette-grey-600")), tt(M.StepContent, "border", Y("palette-grey-600")), tt(M.Switch, "defaultColor", Y("palette-grey-300")), tt(M.Switch, "defaultDisabledColor", Y("palette-grey-600")), tt(M.Switch, "primaryDisabledColor", L(de, M.primary.main, 0.55)), tt(M.Switch, "secondaryDisabledColor", L(de, M.secondary.main, 0.55)), tt(M.Switch, "errorDisabledColor", L(de, M.error.main, 0.55)), tt(M.Switch, "infoDisabledColor", L(de, M.info.main, 0.55)), tt(M.Switch, "successDisabledColor", L(de, M.success.main, 0.55)), tt(M.Switch, "warningDisabledColor", L(de, M.warning.main, 0.55)), tt(M.TableCell, "border", L(de, L(Ts, M.divider, 1), 0.68)), tt(M.Tooltip, "bg", L(Ts, M.grey[700], 0.92));
    }
    ur(M.background, "default"), ur(M.background, "paper"), ur(M.common, "background"), ur(M.common, "onBackground"), ur(M, "divider"), Object.keys(M).forEach((Q) => {
      const B = M[Q];
      Q !== "tonalOffset" && B && typeof B == "object" && (B.main && tt(M[Q], "mainChannel", _l(Sl(B.main))), B.light && tt(M[Q], "lightChannel", _l(Sl(B.light))), B.dark && tt(M[Q], "darkChannel", _l(Sl(B.dark))), B.contrastText && tt(M[Q], "contrastTextChannel", _l(Sl(B.contrastText))), Q === "text" && (ur(M[Q], "primary"), ur(M[Q], "secondary")), Q === "action" && (B.active && ur(M[Q], "active"), B.selected && ur(M[Q], "selected")));
    });
  }), k = t.reduce((H, M) => wn(H, M), k);
  const G = {
    prefix: o,
    disableCssColorScheme: s,
    shouldSkipGeneratingVar: c,
    getSelector: IU(k),
    enableContrastVars: l
  }, {
    vars: $,
    generateThemeVars: F,
    generateStyleSheets: j
  } = uU(k, G);
  return k.vars = $, Object.entries(k.colorSchemes[k.defaultColorScheme]).forEach(([H, M]) => {
    k[H] = M;
  }), k.generateThemeVars = F, k.generateStyleSheets = j, k.generateSpacing = function() {
    return CC(m.spacing, jg(this));
  }, k.getColorSchemeSelector = cU(d), k.spacing = k.generateSpacing(), k.shouldSkipGeneratingVar = c, k.unstable_sxConfig = {
    ...Ih,
    ...m?.unstable_sxConfig
  }, k.unstable_sx = function(M) {
    return Qa({
      sx: M,
      theme: this
    });
  }, k.toRuntimeSource = GC, k;
}
function vS(n, t, e) {
  n.colorSchemes && e && (n.colorSchemes[t] = {
    ...e !== !0 && e,
    palette: Zg({
      ...e === !0 ? {} : e.palette,
      mode: t
    })
    // cast type to skip module augmentation test
  });
}
function $U(n = {}, ...t) {
  const {
    palette: e,
    cssVariables: i = !1,
    colorSchemes: s = e ? void 0 : {
      light: !0
    },
    defaultColorScheme: o = e?.mode,
    ...l
  } = n, c = o || "light", d = s?.[c], f = {
    ...s,
    ...e ? {
      [c]: {
        ...typeof d != "boolean" && d,
        palette: e
      }
    } : void 0
  };
  if (i === !1) {
    if (!("colorSchemes" in n))
      return zm(n, ...t);
    let m = e;
    "palette" in n || f[c] && (f[c] !== !0 ? m = f[c].palette : c === "dark" && (m = {
      mode: "dark"
    }));
    const y = zm({
      ...n,
      palette: m
    }, ...t);
    return y.defaultColorScheme = c, y.colorSchemes = f, y.palette.mode === "light" && (y.colorSchemes.light = {
      ...f.light !== !0 && f.light,
      palette: y.palette
    }, vS(y, "dark", f.dark)), y.palette.mode === "dark" && (y.colorSchemes.dark = {
      ...f.dark !== !0 && f.dark,
      palette: y.palette
    }, vS(y, "light", f.light)), y;
  }
  return !e && !("light" in f) && c === "light" && (f.light = !0), HU({
    ...l,
    colorSchemes: f,
    defaultColorScheme: c,
    ...typeof i != "boolean" && i
  }, ...t);
}
const Qg = $U();
function Jg() {
  const n = EC(Qg);
  return n[Gg] || n;
}
function Hh(n) {
  return n !== "ownerState" && n !== "theme" && n !== "sx" && n !== "as";
}
const Mi = (n) => Hh(n) && n !== "classes", vt = WG({
  themeId: Gg,
  defaultTheme: Qg,
  rootShouldForwardProp: Mi
});
function xS(...n) {
  return n.reduce((t, e) => e == null ? t : function(...s) {
    t.apply(this, s), e.apply(this, s);
  }, () => {
  });
}
function WU(n) {
  return /* @__PURE__ */ et.jsx(NG, {
    ...n,
    defaultTheme: Qg,
    themeId: Gg
  });
}
function VU(n) {
  return function(e) {
    return (
      // Pigment CSS `globalCss` support callback with theme inside an object but `GlobalStyles` support theme as a callback value.
      /* @__PURE__ */ et.jsx(WU, {
        styles: typeof n == "function" ? (i) => n({
          theme: i,
          ...e
        }) : n
      })
    );
  };
}
const Te = sU;
function Ne(n) {
  return nU(n);
}
function jU(n) {
  return Be("MuiSvgIcon", n);
}
ke("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
const YU = (n) => {
  const {
    color: t,
    fontSize: e,
    classes: i
  } = n, s = {
    root: ["root", t !== "inherit" && `color${St(t)}`, `fontSize${St(e)}`]
  };
  return Oe(s, jU, i);
}, XU = vt("svg", {
  name: "MuiSvgIcon",
  slot: "Root",
  overridesResolver: (n, t) => {
    const {
      ownerState: e
    } = n;
    return [t.root, e.color !== "inherit" && t[`color${St(e.color)}`], t[`fontSize${St(e.fontSize)}`]];
  }
})(Te(({
  theme: n
}) => ({
  userSelect: "none",
  width: "1em",
  height: "1em",
  display: "inline-block",
  flexShrink: 0,
  transition: n.transitions?.create?.("fill", {
    duration: (n.vars ?? n).transitions?.duration?.shorter
  }),
  variants: [
    {
      props: (t) => !t.hasSvgAsChild,
      style: {
        // the <svg> will define the property that has `currentColor`
        // for example heroicons uses fill="none" and stroke="currentColor"
        fill: "currentColor"
      }
    },
    {
      props: {
        fontSize: "inherit"
      },
      style: {
        fontSize: "inherit"
      }
    },
    {
      props: {
        fontSize: "small"
      },
      style: {
        fontSize: n.typography?.pxToRem?.(20) || "1.25rem"
      }
    },
    {
      props: {
        fontSize: "medium"
      },
      style: {
        fontSize: n.typography?.pxToRem?.(24) || "1.5rem"
      }
    },
    {
      props: {
        fontSize: "large"
      },
      style: {
        fontSize: n.typography?.pxToRem?.(35) || "2.1875rem"
      }
    },
    // TODO v5 deprecate color prop, v6 remove for sx
    ...Object.entries((n.vars ?? n).palette).filter(([, t]) => t && t.main).map(([t]) => ({
      props: {
        color: t
      },
      style: {
        color: (n.vars ?? n).palette?.[t]?.main
      }
    })),
    {
      props: {
        color: "action"
      },
      style: {
        color: (n.vars ?? n).palette?.action?.active
      }
    },
    {
      props: {
        color: "disabled"
      },
      style: {
        color: (n.vars ?? n).palette?.action?.disabled
      }
    },
    {
      props: {
        color: "inherit"
      },
      style: {
        color: void 0
      }
    }
  ]
}))), Fm = /* @__PURE__ */ O.forwardRef(function(t, e) {
  const i = Ne({
    props: t,
    name: "MuiSvgIcon"
  }), {
    children: s,
    className: o,
    color: l = "inherit",
    component: c = "svg",
    fontSize: d = "medium",
    htmlColor: f,
    inheritViewBox: m = !1,
    titleAccess: y,
    viewBox: b = "0 0 24 24",
    ...v
  } = i, x = /* @__PURE__ */ O.isValidElement(s) && s.type === "svg", S = {
    ...i,
    color: l,
    component: c,
    fontSize: d,
    instanceFontSize: t.fontSize,
    inheritViewBox: m,
    viewBox: b,
    hasSvgAsChild: x
  }, _ = {};
  m || (_.viewBox = b);
  const C = YU(S);
  return /* @__PURE__ */ et.jsxs(XU, {
    as: c,
    className: Lt(C.root, o),
    focusable: "false",
    color: f,
    "aria-hidden": y ? void 0 : !0,
    role: y ? "img" : void 0,
    ref: e,
    ..._,
    ...v,
    ...x && s.props,
    ownerState: S,
    children: [x ? s.props.children : s, y ? /* @__PURE__ */ et.jsx("title", {
      children: y
    }) : null]
  });
});
Fm.muiName = "SvgIcon";
function qU(n, t) {
  function e(i, s) {
    return /* @__PURE__ */ et.jsx(Fm, {
      "data-testid": void 0,
      ref: s,
      ...i,
      children: n
    });
  }
  return e.muiName = Fm.muiName, /* @__PURE__ */ O.memo(/* @__PURE__ */ O.forwardRef(e));
}
function IC(n, t = 166) {
  let e;
  function i(...s) {
    const o = () => {
      n.apply(this, s);
    };
    clearTimeout(e), e = setTimeout(o, t);
  }
  return i.clear = () => {
    clearTimeout(e);
  }, i;
}
function An(n) {
  return n && n.ownerDocument || document;
}
function Tr(n) {
  return An(n).defaultView || window;
}
function _S(n, t) {
  typeof n == "function" ? n(t) : n && (n.current = t);
}
function Hm(n) {
  const {
    controlled: t,
    default: e,
    name: i,
    state: s = "value"
  } = n, {
    current: o
  } = O.useRef(t !== void 0), [l, c] = O.useState(e), d = o ? t : l, f = O.useCallback((m) => {
    o || c(m);
  }, []);
  return [d, f];
}
function $i(n) {
  const t = O.useRef(n);
  return ts(() => {
    t.current = n;
  }), O.useRef((...e) => (
    // @ts-expect-error hide `this`
    (0, t.current)(...e)
  )).current;
}
function Bn(...n) {
  const t = O.useRef(void 0), e = O.useCallback((i) => {
    const s = n.map((o) => {
      if (o == null)
        return null;
      if (typeof o == "function") {
        const l = o, c = l(i);
        return typeof c == "function" ? c : () => {
          l(null);
        };
      }
      return o.current = i, () => {
        o.current = null;
      };
    });
    return () => {
      s.forEach((o) => o?.());
    };
  }, n);
  return O.useMemo(() => n.every((i) => i == null) ? null : (i) => {
    t.current && (t.current(), t.current = void 0), i != null && (t.current = e(i));
  }, n);
}
function KU(n, t) {
  const e = n.charCodeAt(2);
  return n[0] === "o" && n[1] === "n" && e >= 65 && e <= 90 && typeof t == "function";
}
function ZU(n, t) {
  if (!n)
    return t;
  function e(l, c) {
    const d = {};
    return Object.keys(c).forEach((f) => {
      KU(f, c[f]) && typeof l[f] == "function" && (d[f] = (...m) => {
        l[f](...m), c[f](...m);
      });
    }), d;
  }
  if (typeof n == "function" || typeof t == "function")
    return (l) => {
      const c = typeof t == "function" ? t(l) : t, d = typeof n == "function" ? n({
        ...l,
        ...c
      }) : n, f = Lt(l?.className, c?.className, d?.className), m = e(d, c);
      return {
        ...c,
        ...d,
        ...m,
        ...!!f && {
          className: f
        },
        ...c?.style && d?.style && {
          style: {
            ...c.style,
            ...d.style
          }
        },
        ...c?.sx && d?.sx && {
          sx: [...Array.isArray(c.sx) ? c.sx : [c.sx], ...Array.isArray(d.sx) ? d.sx : [d.sx]]
        }
      };
    };
  const i = t, s = e(n, i), o = Lt(i?.className, n?.className);
  return {
    ...t,
    ...n,
    ...s,
    ...!!o && {
      className: o
    },
    ...i?.style && n?.style && {
      style: {
        ...i.style,
        ...n.style
      }
    },
    ...i?.sx && n?.sx && {
      sx: [...Array.isArray(i.sx) ? i.sx : [i.sx], ...Array.isArray(n.sx) ? n.sx : [n.sx]]
    }
  };
}
function zC(n, t) {
  if (n == null) return {};
  var e = {};
  for (var i in n) if ({}.hasOwnProperty.call(n, i)) {
    if (t.indexOf(i) !== -1) continue;
    e[i] = n[i];
  }
  return e;
}
function $m(n, t) {
  return $m = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e, i) {
    return e.__proto__ = i, e;
  }, $m(n, t);
}
function LC(n, t) {
  n.prototype = Object.create(t.prototype), n.prototype.constructor = n, $m(n, t);
}
var FC = YS();
const Ic = /* @__PURE__ */ xh(FC), SS = {
  disabled: !1
}, ph = Fi.createContext(null);
var QU = function(t) {
  return t.scrollTop;
}, Tl = "unmounted", Ps = "exited", Bs = "entering", za = "entered", Wm = "exiting", Wi = /* @__PURE__ */ (function(n) {
  LC(t, n);
  function t(i, s) {
    var o;
    o = n.call(this, i, s) || this;
    var l = s, c = l && !l.isMounting ? i.enter : i.appear, d;
    return o.appearStatus = null, i.in ? c ? (d = Ps, o.appearStatus = Bs) : d = za : i.unmountOnExit || i.mountOnEnter ? d = Tl : d = Ps, o.state = {
      status: d
    }, o.nextCallback = null, o;
  }
  t.getDerivedStateFromProps = function(s, o) {
    var l = s.in;
    return l && o.status === Tl ? {
      status: Ps
    } : null;
  };
  var e = t.prototype;
  return e.componentDidMount = function() {
    this.updateStatus(!0, this.appearStatus);
  }, e.componentDidUpdate = function(s) {
    var o = null;
    if (s !== this.props) {
      var l = this.state.status;
      this.props.in ? l !== Bs && l !== za && (o = Bs) : (l === Bs || l === za) && (o = Wm);
    }
    this.updateStatus(!1, o);
  }, e.componentWillUnmount = function() {
    this.cancelNextCallback();
  }, e.getTimeouts = function() {
    var s = this.props.timeout, o, l, c;
    return o = l = c = s, s != null && typeof s != "number" && (o = s.exit, l = s.enter, c = s.appear !== void 0 ? s.appear : l), {
      exit: o,
      enter: l,
      appear: c
    };
  }, e.updateStatus = function(s, o) {
    if (s === void 0 && (s = !1), o !== null)
      if (this.cancelNextCallback(), o === Bs) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var l = this.props.nodeRef ? this.props.nodeRef.current : Ic.findDOMNode(this);
          l && QU(l);
        }
        this.performEnter(s);
      } else
        this.performExit();
    else this.props.unmountOnExit && this.state.status === Ps && this.setState({
      status: Tl
    });
  }, e.performEnter = function(s) {
    var o = this, l = this.props.enter, c = this.context ? this.context.isMounting : s, d = this.props.nodeRef ? [c] : [Ic.findDOMNode(this), c], f = d[0], m = d[1], y = this.getTimeouts(), b = c ? y.appear : y.enter;
    if (!s && !l || SS.disabled) {
      this.safeSetState({
        status: za
      }, function() {
        o.props.onEntered(f);
      });
      return;
    }
    this.props.onEnter(f, m), this.safeSetState({
      status: Bs
    }, function() {
      o.props.onEntering(f, m), o.onTransitionEnd(b, function() {
        o.safeSetState({
          status: za
        }, function() {
          o.props.onEntered(f, m);
        });
      });
    });
  }, e.performExit = function() {
    var s = this, o = this.props.exit, l = this.getTimeouts(), c = this.props.nodeRef ? void 0 : Ic.findDOMNode(this);
    if (!o || SS.disabled) {
      this.safeSetState({
        status: Ps
      }, function() {
        s.props.onExited(c);
      });
      return;
    }
    this.props.onExit(c), this.safeSetState({
      status: Wm
    }, function() {
      s.props.onExiting(c), s.onTransitionEnd(l.exit, function() {
        s.safeSetState({
          status: Ps
        }, function() {
          s.props.onExited(c);
        });
      });
    });
  }, e.cancelNextCallback = function() {
    this.nextCallback !== null && (this.nextCallback.cancel(), this.nextCallback = null);
  }, e.safeSetState = function(s, o) {
    o = this.setNextCallback(o), this.setState(s, o);
  }, e.setNextCallback = function(s) {
    var o = this, l = !0;
    return this.nextCallback = function(c) {
      l && (l = !1, o.nextCallback = null, s(c));
    }, this.nextCallback.cancel = function() {
      l = !1;
    }, this.nextCallback;
  }, e.onTransitionEnd = function(s, o) {
    this.setNextCallback(o);
    var l = this.props.nodeRef ? this.props.nodeRef.current : Ic.findDOMNode(this), c = s == null && !this.props.addEndListener;
    if (!l || c) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var d = this.props.nodeRef ? [this.nextCallback] : [l, this.nextCallback], f = d[0], m = d[1];
      this.props.addEndListener(f, m);
    }
    s != null && setTimeout(this.nextCallback, s);
  }, e.render = function() {
    var s = this.state.status;
    if (s === Tl)
      return null;
    var o = this.props, l = o.children;
    o.in, o.mountOnEnter, o.unmountOnExit, o.appear, o.enter, o.exit, o.timeout, o.addEndListener, o.onEnter, o.onEntering, o.onEntered, o.onExit, o.onExiting, o.onExited, o.nodeRef;
    var c = zC(o, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return (
      // allows for nested Transitions
      /* @__PURE__ */ Fi.createElement(ph.Provider, {
        value: null
      }, typeof l == "function" ? l(s, c) : Fi.cloneElement(Fi.Children.only(l), c))
    );
  }, t;
})(Fi.Component);
Wi.contextType = ph;
Wi.propTypes = {};
function Oa() {
}
Wi.defaultProps = {
  in: !1,
  mountOnEnter: !1,
  unmountOnExit: !1,
  appear: !1,
  enter: !0,
  exit: !0,
  onEnter: Oa,
  onEntering: Oa,
  onEntered: Oa,
  onExit: Oa,
  onExiting: Oa,
  onExited: Oa
};
Wi.UNMOUNTED = Tl;
Wi.EXITED = Ps;
Wi.ENTERING = Bs;
Wi.ENTERED = za;
Wi.EXITING = Wm;
function JU(n) {
  if (n === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return n;
}
function ty(n, t) {
  var e = function(o) {
    return t && O.isValidElement(o) ? t(o) : o;
  }, i = /* @__PURE__ */ Object.create(null);
  return n && O.Children.map(n, function(s) {
    return s;
  }).forEach(function(s) {
    i[s.key] = e(s);
  }), i;
}
function t4(n, t) {
  n = n || {}, t = t || {};
  function e(m) {
    return m in t ? t[m] : n[m];
  }
  var i = /* @__PURE__ */ Object.create(null), s = [];
  for (var o in n)
    o in t ? s.length && (i[o] = s, s = []) : s.push(o);
  var l, c = {};
  for (var d in t) {
    if (i[d])
      for (l = 0; l < i[d].length; l++) {
        var f = i[d][l];
        c[i[d][l]] = e(f);
      }
    c[d] = e(d);
  }
  for (l = 0; l < s.length; l++)
    c[s[l]] = e(s[l]);
  return c;
}
function Gs(n, t, e) {
  return e[t] != null ? e[t] : n.props[t];
}
function e4(n, t) {
  return ty(n.children, function(e) {
    return O.cloneElement(e, {
      onExited: t.bind(null, e),
      in: !0,
      appear: Gs(e, "appear", n),
      enter: Gs(e, "enter", n),
      exit: Gs(e, "exit", n)
    });
  });
}
function n4(n, t, e) {
  var i = ty(n.children), s = t4(t, i);
  return Object.keys(s).forEach(function(o) {
    var l = s[o];
    if (O.isValidElement(l)) {
      var c = o in t, d = o in i, f = t[o], m = O.isValidElement(f) && !f.props.in;
      d && (!c || m) ? s[o] = O.cloneElement(l, {
        onExited: e.bind(null, l),
        in: !0,
        exit: Gs(l, "exit", n),
        enter: Gs(l, "enter", n)
      }) : !d && c && !m ? s[o] = O.cloneElement(l, {
        in: !1
      }) : d && c && O.isValidElement(f) && (s[o] = O.cloneElement(l, {
        onExited: e.bind(null, l),
        in: f.props.in,
        exit: Gs(l, "exit", n),
        enter: Gs(l, "enter", n)
      }));
    }
  }), s;
}
var i4 = Object.values || function(n) {
  return Object.keys(n).map(function(t) {
    return n[t];
  });
}, r4 = {
  component: "div",
  childFactory: function(t) {
    return t;
  }
}, ey = /* @__PURE__ */ (function(n) {
  LC(t, n);
  function t(i, s) {
    var o;
    o = n.call(this, i, s) || this;
    var l = o.handleExited.bind(JU(o));
    return o.state = {
      contextValue: {
        isMounting: !0
      },
      handleExited: l,
      firstRender: !0
    }, o;
  }
  var e = t.prototype;
  return e.componentDidMount = function() {
    this.mounted = !0, this.setState({
      contextValue: {
        isMounting: !1
      }
    });
  }, e.componentWillUnmount = function() {
    this.mounted = !1;
  }, t.getDerivedStateFromProps = function(s, o) {
    var l = o.children, c = o.handleExited, d = o.firstRender;
    return {
      children: d ? e4(s, c) : n4(s, l, c),
      firstRender: !1
    };
  }, e.handleExited = function(s, o) {
    var l = ty(this.props.children);
    s.key in l || (s.props.onExited && s.props.onExited(o), this.mounted && this.setState(function(c) {
      var d = uh({}, c.children);
      return delete d[s.key], {
        children: d
      };
    }));
  }, e.render = function() {
    var s = this.props, o = s.component, l = s.childFactory, c = zC(s, ["component", "childFactory"]), d = this.state.contextValue, f = i4(this.state.children).map(l);
    return delete c.appear, delete c.enter, delete c.exit, o === null ? /* @__PURE__ */ Fi.createElement(ph.Provider, {
      value: d
    }, f) : /* @__PURE__ */ Fi.createElement(ph.Provider, {
      value: d
    }, /* @__PURE__ */ Fi.createElement(o, c, f));
  }, t;
})(Fi.Component);
ey.propTypes = {};
ey.defaultProps = r4;
const TS = {};
function HC(n, t) {
  const e = O.useRef(TS);
  return e.current === TS && (e.current = n(t)), e;
}
const s4 = [];
function a4(n) {
  O.useEffect(n, s4);
}
class ny {
  static create() {
    return new ny();
  }
  currentId = null;
  /**
   * Executes `fn` after `delay`, clearing any previously scheduled call.
   */
  start(t, e) {
    this.clear(), this.currentId = setTimeout(() => {
      this.currentId = null, e();
    }, t);
  }
  clear = () => {
    this.currentId !== null && (clearTimeout(this.currentId), this.currentId = null);
  };
  disposeEffect = () => this.clear;
}
function $C() {
  const n = HC(ny.create).current;
  return a4(n.disposeEffect), n;
}
const WC = (n) => n.scrollTop;
function mh(n, t) {
  const {
    timeout: e,
    easing: i,
    style: s = {}
  } = n;
  return {
    duration: s.transitionDuration ?? (typeof e == "number" ? e : e[t.mode] || 0),
    easing: s.transitionTimingFunction ?? (typeof i == "object" ? i[t.mode] : i),
    delay: s.transitionDelay
  };
}
function o4(n) {
  return Be("MuiPaper", n);
}
ke("MuiPaper", ["root", "rounded", "outlined", "elevation", "elevation0", "elevation1", "elevation2", "elevation3", "elevation4", "elevation5", "elevation6", "elevation7", "elevation8", "elevation9", "elevation10", "elevation11", "elevation12", "elevation13", "elevation14", "elevation15", "elevation16", "elevation17", "elevation18", "elevation19", "elevation20", "elevation21", "elevation22", "elevation23", "elevation24"]);
const l4 = (n) => {
  const {
    square: t,
    elevation: e,
    variant: i,
    classes: s
  } = n, o = {
    root: ["root", i, !t && "rounded", i === "elevation" && `elevation${e}`]
  };
  return Oe(o, o4, s);
}, u4 = vt("div", {
  name: "MuiPaper",
  slot: "Root",
  overridesResolver: (n, t) => {
    const {
      ownerState: e
    } = n;
    return [t.root, t[e.variant], !e.square && t.rounded, e.variant === "elevation" && t[`elevation${e.elevation}`]];
  }
})(Te(({
  theme: n
}) => ({
  backgroundColor: (n.vars || n).palette.background.paper,
  color: (n.vars || n).palette.text.primary,
  transition: n.transitions.create("box-shadow"),
  variants: [{
    props: ({
      ownerState: t
    }) => !t.square,
    style: {
      borderRadius: n.shape.borderRadius
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      border: `1px solid ${(n.vars || n).palette.divider}`
    }
  }, {
    props: {
      variant: "elevation"
    },
    style: {
      boxShadow: "var(--Paper-shadow)",
      backgroundImage: "var(--Paper-overlay)"
    }
  }]
}))), c4 = /* @__PURE__ */ O.forwardRef(function(t, e) {
  const i = Ne({
    props: t,
    name: "MuiPaper"
  }), s = Jg(), {
    className: o,
    component: l = "div",
    elevation: c = 1,
    square: d = !1,
    variant: f = "elevation",
    ...m
  } = i, y = {
    ...i,
    component: l,
    elevation: c,
    square: d,
    variant: f
  }, b = l4(y);
  return /* @__PURE__ */ et.jsx(u4, {
    as: l,
    ownerState: y,
    className: Lt(b.root, o),
    ref: e,
    ...m,
    style: {
      ...f === "elevation" && {
        "--Paper-shadow": (s.vars || s).shadows[c],
        ...s.vars && {
          "--Paper-overlay": s.vars.overlays?.[c]
        },
        ...!s.vars && s.palette.mode === "dark" && {
          "--Paper-overlay": `linear-gradient(${fh("#fff", Lm(c))}, ${fh("#fff", Lm(c))})`
        }
      },
      ...m.style
    }
  });
});
function Zr(n) {
  return typeof n == "string";
}
function VC(n, t, e) {
  return n === void 0 || Zr(n) ? t : {
    ...t,
    ownerState: {
      ...t.ownerState,
      ...e
    }
  };
}
function jC(n, t, e) {
  return typeof n == "function" ? n(t, e) : n;
}
function kl(n, t = []) {
  if (n === void 0)
    return {};
  const e = {};
  return Object.keys(n).filter((i) => i.match(/^on[A-Z]/) && typeof n[i] == "function" && !t.includes(i)).forEach((i) => {
    e[i] = n[i];
  }), e;
}
function wS(n) {
  if (n === void 0)
    return {};
  const t = {};
  return Object.keys(n).filter((e) => !(e.match(/^on[A-Z]/) && typeof n[e] == "function")).forEach((e) => {
    t[e] = n[e];
  }), t;
}
function YC(n) {
  const {
    getSlotProps: t,
    additionalProps: e,
    externalSlotProps: i,
    externalForwardedProps: s,
    className: o
  } = n;
  if (!t) {
    const v = Lt(e?.className, o, s?.className, i?.className), x = {
      ...e?.style,
      ...s?.style,
      ...i?.style
    }, S = {
      ...e,
      ...s,
      ...i
    };
    return v.length > 0 && (S.className = v), Object.keys(x).length > 0 && (S.style = x), {
      props: S,
      internalRef: void 0
    };
  }
  const l = kl({
    ...s,
    ...i
  }), c = wS(i), d = wS(s), f = t(l), m = Lt(f?.className, e?.className, o, s?.className, i?.className), y = {
    ...f?.style,
    ...e?.style,
    ...s?.style,
    ...i?.style
  }, b = {
    ...f,
    ...e,
    ...d,
    ...c
  };
  return m.length > 0 && (b.className = m), Object.keys(y).length > 0 && (b.style = y), {
    props: b,
    internalRef: f.ref
  };
}
function Tn(n, t) {
  const {
    className: e,
    elementType: i,
    ownerState: s,
    externalForwardedProps: o,
    internalForwardedProps: l,
    shouldForwardComponentProp: c = !1,
    ...d
  } = t, {
    component: f,
    slots: m = {
      [n]: void 0
    },
    slotProps: y = {
      [n]: void 0
    },
    ...b
  } = o, v = m[n] || i, x = jC(y[n], s), {
    props: {
      component: S,
      ..._
    },
    internalRef: C
  } = YC({
    className: e,
    ...d,
    externalForwardedProps: n === "root" ? b : void 0,
    externalSlotProps: x
  }), R = Bn(C, x?.ref, t.ref), w = n === "root" ? S || f : S, E = VC(v, {
    ...n === "root" && !f && !m[n] && l,
    ...n !== "root" && !m[n] && l,
    ..._,
    ...w && !c && {
      as: w
    },
    ...w && c && {
      component: w
    },
    ref: R
  }, s);
  return [v, E];
}
function gh(n) {
  try {
    return n.matches(":focus-visible");
  } catch {
  }
  return !1;
}
class yh {
  /** React ref to the ripple instance */
  /** If the ripple component should be mounted */
  /** Promise that resolves when the ripple component is mounted */
  /** If the ripple component has been mounted */
  /** React state hook setter */
  static create() {
    return new yh();
  }
  static use() {
    const t = HC(yh.create).current, [e, i] = O.useState(!1);
    return t.shouldMount = e, t.setShouldMount = i, O.useEffect(t.mountEffect, [e]), t;
  }
  constructor() {
    this.ref = {
      current: null
    }, this.mounted = null, this.didMount = !1, this.shouldMount = !1, this.setShouldMount = null;
  }
  mount() {
    return this.mounted || (this.mounted = d4(), this.shouldMount = !0, this.setShouldMount(this.shouldMount)), this.mounted;
  }
  mountEffect = () => {
    this.shouldMount && !this.didMount && this.ref.current !== null && (this.didMount = !0, this.mounted.resolve());
  };
  /* Ripple API */
  start(...t) {
    this.mount().then(() => this.ref.current?.start(...t));
  }
  stop(...t) {
    this.mount().then(() => this.ref.current?.stop(...t));
  }
  pulsate(...t) {
    this.mount().then(() => this.ref.current?.pulsate(...t));
  }
}
function h4() {
  return yh.use();
}
function d4() {
  let n, t;
  const e = new Promise((i, s) => {
    n = i, t = s;
  });
  return e.resolve = n, e.reject = t, e;
}
function f4(n) {
  const {
    className: t,
    classes: e,
    pulsate: i = !1,
    rippleX: s,
    rippleY: o,
    rippleSize: l,
    in: c,
    onExited: d,
    timeout: f
  } = n, [m, y] = O.useState(!1), b = Lt(t, e.ripple, e.rippleVisible, i && e.ripplePulsate), v = {
    width: l,
    height: l,
    top: -(l / 2) + o,
    left: -(l / 2) + s
  }, x = Lt(e.child, m && e.childLeaving, i && e.childPulsate);
  return !c && !m && y(!0), O.useEffect(() => {
    if (!c && d != null) {
      const S = setTimeout(d, f);
      return () => {
        clearTimeout(S);
      };
    }
  }, [d, c, f]), /* @__PURE__ */ et.jsx("span", {
    className: b,
    style: v,
    children: /* @__PURE__ */ et.jsx("span", {
      className: x
    })
  });
}
const ui = ke("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]), Vm = 550, p4 = 80, m4 = iu`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`, g4 = iu`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`, y4 = iu`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`, b4 = vt("span", {
  name: "MuiTouchRipple",
  slot: "Root"
})({
  overflow: "hidden",
  pointerEvents: "none",
  position: "absolute",
  zIndex: 0,
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  borderRadius: "inherit"
}), v4 = vt(f4, {
  name: "MuiTouchRipple",
  slot: "Ripple"
})`
  opacity: 0;
  position: absolute;

  &.${ui.rippleVisible} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${m4};
    animation-duration: ${Vm}ms;
    animation-timing-function: ${({
  theme: n
}) => n.transitions.easing.easeInOut};
  }

  &.${ui.ripplePulsate} {
    animation-duration: ${({
  theme: n
}) => n.transitions.duration.shorter}ms;
  }

  & .${ui.child} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${ui.childLeaving} {
    opacity: 0;
    animation-name: ${g4};
    animation-duration: ${Vm}ms;
    animation-timing-function: ${({
  theme: n
}) => n.transitions.easing.easeInOut};
  }

  & .${ui.childPulsate} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${y4};
    animation-duration: 2500ms;
    animation-timing-function: ${({
  theme: n
}) => n.transitions.easing.easeInOut};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`, x4 = /* @__PURE__ */ O.forwardRef(function(t, e) {
  const i = Ne({
    props: t,
    name: "MuiTouchRipple"
  }), {
    center: s = !1,
    classes: o = {},
    className: l,
    ...c
  } = i, [d, f] = O.useState([]), m = O.useRef(0), y = O.useRef(null);
  O.useEffect(() => {
    y.current && (y.current(), y.current = null);
  }, [d]);
  const b = O.useRef(!1), v = $C(), x = O.useRef(null), S = O.useRef(null), _ = O.useCallback((E) => {
    const {
      pulsate: P,
      rippleX: k,
      rippleY: G,
      rippleSize: $,
      cb: F
    } = E;
    f((j) => [...j, /* @__PURE__ */ et.jsx(v4, {
      classes: {
        ripple: Lt(o.ripple, ui.ripple),
        rippleVisible: Lt(o.rippleVisible, ui.rippleVisible),
        ripplePulsate: Lt(o.ripplePulsate, ui.ripplePulsate),
        child: Lt(o.child, ui.child),
        childLeaving: Lt(o.childLeaving, ui.childLeaving),
        childPulsate: Lt(o.childPulsate, ui.childPulsate)
      },
      timeout: Vm,
      pulsate: P,
      rippleX: k,
      rippleY: G,
      rippleSize: $
    }, m.current)]), m.current += 1, y.current = F;
  }, [o]), C = O.useCallback((E = {}, P = {}, k = () => {
  }) => {
    const {
      pulsate: G = !1,
      center: $ = s || P.pulsate,
      fakeElement: F = !1
      // For test purposes
    } = P;
    if (E?.type === "mousedown" && b.current) {
      b.current = !1;
      return;
    }
    E?.type === "touchstart" && (b.current = !0);
    const j = F ? null : S.current, H = j ? j.getBoundingClientRect() : {
      width: 0,
      height: 0,
      left: 0,
      top: 0
    };
    let M, Y, L;
    if ($ || E === void 0 || E.clientX === 0 && E.clientY === 0 || !E.clientX && !E.touches)
      M = Math.round(H.width / 2), Y = Math.round(H.height / 2);
    else {
      const {
        clientX: Q,
        clientY: B
      } = E.touches && E.touches.length > 0 ? E.touches[0] : E;
      M = Math.round(Q - H.left), Y = Math.round(B - H.top);
    }
    if ($)
      L = Math.sqrt((2 * H.width ** 2 + H.height ** 2) / 3), L % 2 === 0 && (L += 1);
    else {
      const Q = Math.max(Math.abs((j ? j.clientWidth : 0) - M), M) * 2 + 2, B = Math.max(Math.abs((j ? j.clientHeight : 0) - Y), Y) * 2 + 2;
      L = Math.sqrt(Q ** 2 + B ** 2);
    }
    E?.touches ? x.current === null && (x.current = () => {
      _({
        pulsate: G,
        rippleX: M,
        rippleY: Y,
        rippleSize: L,
        cb: k
      });
    }, v.start(p4, () => {
      x.current && (x.current(), x.current = null);
    })) : _({
      pulsate: G,
      rippleX: M,
      rippleY: Y,
      rippleSize: L,
      cb: k
    });
  }, [s, _, v]), R = O.useCallback(() => {
    C({}, {
      pulsate: !0
    });
  }, [C]), w = O.useCallback((E, P) => {
    if (v.clear(), E?.type === "touchend" && x.current) {
      x.current(), x.current = null, v.start(0, () => {
        w(E, P);
      });
      return;
    }
    x.current = null, f((k) => k.length > 0 ? k.slice(1) : k), y.current = P;
  }, [v]);
  return O.useImperativeHandle(e, () => ({
    pulsate: R,
    start: C,
    stop: w
  }), [R, C, w]), /* @__PURE__ */ et.jsx(b4, {
    className: Lt(ui.root, o.root, l),
    ref: S,
    ...c,
    children: /* @__PURE__ */ et.jsx(ey, {
      component: null,
      exit: !0,
      children: d
    })
  });
});
function _4(n) {
  return Be("MuiButtonBase", n);
}
const S4 = ke("MuiButtonBase", ["root", "disabled", "focusVisible"]), T4 = (n) => {
  const {
    disabled: t,
    focusVisible: e,
    focusVisibleClassName: i,
    classes: s
  } = n, l = Oe({
    root: ["root", t && "disabled", e && "focusVisible"]
  }, _4, s);
  return e && i && (l.root += ` ${i}`), l;
}, w4 = vt("button", {
  name: "MuiButtonBase",
  slot: "Root"
})({
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  position: "relative",
  boxSizing: "border-box",
  WebkitTapHighlightColor: "transparent",
  backgroundColor: "transparent",
  // Reset default value
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  border: 0,
  margin: 0,
  // Remove the margin in Safari
  borderRadius: 0,
  padding: 0,
  // Remove the padding in Firefox
  cursor: "pointer",
  userSelect: "none",
  verticalAlign: "middle",
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // Reset
  textDecoration: "none",
  // So we take precedent over the style of a native <a /> element.
  color: "inherit",
  "&::-moz-focus-inner": {
    borderStyle: "none"
    // Remove Firefox dotted outline.
  },
  [`&.${S4.disabled}`]: {
    pointerEvents: "none",
    // Disable link interactions
    cursor: "default"
  },
  "@media print": {
    colorAdjust: "exact"
  }
}), C4 = /* @__PURE__ */ O.forwardRef(function(t, e) {
  const i = Ne({
    props: t,
    name: "MuiButtonBase"
  }), {
    action: s,
    centerRipple: o = !1,
    children: l,
    className: c,
    component: d = "button",
    disabled: f = !1,
    disableRipple: m = !1,
    disableTouchRipple: y = !1,
    focusRipple: b = !1,
    focusVisibleClassName: v,
    LinkComponent: x = "a",
    onBlur: S,
    onClick: _,
    onContextMenu: C,
    onDragLeave: R,
    onFocus: w,
    onFocusVisible: E,
    onKeyDown: P,
    onKeyUp: k,
    onMouseDown: G,
    onMouseLeave: $,
    onMouseUp: F,
    onTouchEnd: j,
    onTouchMove: H,
    onTouchStart: M,
    tabIndex: Y = 0,
    TouchRippleProps: L,
    touchRippleRef: Q,
    type: B,
    ...I
  } = i, rt = O.useRef(null), J = h4(), D = Bn(J.ref, Q), [q, ot] = O.useState(!1);
  f && q && ot(!1), O.useImperativeHandle(s, () => ({
    focusVisible: () => {
      ot(!0), rt.current.focus();
    }
  }), []);
  const at = J.shouldMount && !m && !f;
  O.useEffect(() => {
    q && b && !m && J.pulsate();
  }, [m, b, q, J]);
  const lt = cr(J, "start", G, y), dt = cr(J, "stop", C, y), ht = cr(J, "stop", R, y), Vt = cr(J, "stop", F, y), Rt = cr(J, "stop", (xt) => {
    q && xt.preventDefault(), $ && $(xt);
  }, y), Dt = cr(J, "start", M, y), gt = cr(J, "stop", j, y), Pt = cr(J, "stop", H, y), Et = cr(J, "stop", (xt) => {
    gh(xt.target) || ot(!1), S && S(xt);
  }, !1), It = $i((xt) => {
    rt.current || (rt.current = xt.currentTarget), gh(xt.target) && (ot(!0), E && E(xt)), w && w(xt);
  }), wt = () => {
    const xt = rt.current;
    return d && d !== "button" && !(xt.tagName === "A" && xt.href);
  }, Yt = $i((xt) => {
    b && !xt.repeat && q && xt.key === " " && J.stop(xt, () => {
      J.start(xt);
    }), xt.target === xt.currentTarget && wt() && xt.key === " " && xt.preventDefault(), P && P(xt), xt.target === xt.currentTarget && wt() && xt.key === "Enter" && !f && (xt.preventDefault(), _ && _(xt));
  }), Ie = $i((xt) => {
    b && xt.key === " " && q && !xt.defaultPrevented && J.stop(xt, () => {
      J.pulsate(xt);
    }), k && k(xt), _ && xt.target === xt.currentTarget && wt() && xt.key === " " && !xt.defaultPrevented && _(xt);
  });
  let Gt = d;
  Gt === "button" && (I.href || I.to) && (Gt = x);
  const pe = {};
  Gt === "button" ? (pe.type = B === void 0 ? "button" : B, pe.disabled = f) : (!I.href && !I.to && (pe.role = "button"), f && (pe["aria-disabled"] = f));
  const Je = Bn(e, rt), De = {
    ...i,
    centerRipple: o,
    component: d,
    disabled: f,
    disableRipple: m,
    disableTouchRipple: y,
    focusRipple: b,
    tabIndex: Y,
    focusVisible: q
  }, le = T4(De);
  return /* @__PURE__ */ et.jsxs(w4, {
    as: Gt,
    className: Lt(le.root, c),
    ownerState: De,
    onBlur: Et,
    onClick: _,
    onContextMenu: dt,
    onFocus: It,
    onKeyDown: Yt,
    onKeyUp: Ie,
    onMouseDown: lt,
    onMouseLeave: Rt,
    onMouseUp: Vt,
    onDragLeave: ht,
    onTouchEnd: gt,
    onTouchMove: Pt,
    onTouchStart: Dt,
    ref: Je,
    tabIndex: f ? -1 : Y,
    type: B,
    ...pe,
    ...I,
    children: [l, at ? /* @__PURE__ */ et.jsx(x4, {
      ref: D,
      center: o,
      ...L
    }) : null]
  });
});
function cr(n, t, e, i = !1) {
  return $i((s) => (e && e(s), i || n[t](s), !0));
}
function E4(n) {
  return typeof n.main == "string";
}
function M4(n, t = []) {
  if (!E4(n))
    return !1;
  for (const e of t)
    if (!n.hasOwnProperty(e) || typeof n[e] != "string")
      return !1;
  return !0;
}
function Ci(n = []) {
  return ([, t]) => t && M4(t, n);
}
function A4(n) {
  return Be("MuiCircularProgress", n);
}
ke("MuiCircularProgress", ["root", "determinate", "indeterminate", "colorPrimary", "colorSecondary", "svg", "track", "circle", "circleDeterminate", "circleIndeterminate", "circleDisableShrink"]);
const xi = 44, jm = iu`
  0% {
    transform: rotate(0deg);
  }

  100% {
    transform: rotate(360deg);
  }
`, Ym = iu`
  0% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: 0;
  }

  50% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -15px;
  }

  100% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: -126px;
  }
`, R4 = typeof jm != "string" ? $g`
        animation: ${jm} 1.4s linear infinite;
      ` : null, P4 = typeof Ym != "string" ? $g`
        animation: ${Ym} 1.4s ease-in-out infinite;
      ` : null, B4 = (n) => {
  const {
    classes: t,
    variant: e,
    color: i,
    disableShrink: s
  } = n, o = {
    root: ["root", e, `color${St(i)}`],
    svg: ["svg"],
    track: ["track"],
    circle: ["circle", `circle${St(e)}`, s && "circleDisableShrink"]
  };
  return Oe(o, A4, t);
}, k4 = vt("span", {
  name: "MuiCircularProgress",
  slot: "Root",
  overridesResolver: (n, t) => {
    const {
      ownerState: e
    } = n;
    return [t.root, t[e.variant], t[`color${St(e.color)}`]];
  }
})(Te(({
  theme: n
}) => ({
  display: "inline-block",
  variants: [{
    props: {
      variant: "determinate"
    },
    style: {
      transition: n.transitions.create("transform")
    }
  }, {
    props: {
      variant: "indeterminate"
    },
    style: R4 || {
      animation: `${jm} 1.4s linear infinite`
    }
  }, ...Object.entries(n.palette).filter(Ci()).map(([t]) => ({
    props: {
      color: t
    },
    style: {
      color: (n.vars || n).palette[t].main
    }
  }))]
}))), O4 = vt("svg", {
  name: "MuiCircularProgress",
  slot: "Svg"
})({
  display: "block"
  // Keeps the progress centered
}), D4 = vt("circle", {
  name: "MuiCircularProgress",
  slot: "Circle",
  overridesResolver: (n, t) => {
    const {
      ownerState: e
    } = n;
    return [t.circle, t[`circle${St(e.variant)}`], e.disableShrink && t.circleDisableShrink];
  }
})(Te(({
  theme: n
}) => ({
  stroke: "currentColor",
  variants: [{
    props: {
      variant: "determinate"
    },
    style: {
      transition: n.transitions.create("stroke-dashoffset")
    }
  }, {
    props: {
      variant: "indeterminate"
    },
    style: {
      // Some default value that looks fine waiting for the animation to kicks in.
      strokeDasharray: "80px, 200px",
      strokeDashoffset: 0
      // Add the unit to fix a Edge 16 and below bug.
    }
  }, {
    props: ({
      ownerState: t
    }) => t.variant === "indeterminate" && !t.disableShrink,
    style: P4 || {
      // At runtime for Pigment CSS, `bufferAnimation` will be null and the generated keyframe will be used.
      animation: `${Ym} 1.4s ease-in-out infinite`
    }
  }]
}))), G4 = vt("circle", {
  name: "MuiCircularProgress",
  slot: "Track"
})(Te(({
  theme: n
}) => ({
  stroke: "currentColor",
  opacity: (n.vars || n).palette.action.activatedOpacity
}))), U4 = /* @__PURE__ */ O.forwardRef(function(t, e) {
  const i = Ne({
    props: t,
    name: "MuiCircularProgress"
  }), {
    className: s,
    color: o = "primary",
    disableShrink: l = !1,
    enableTrackSlot: c = !1,
    size: d = 40,
    style: f,
    thickness: m = 3.6,
    value: y = 0,
    variant: b = "indeterminate",
    ...v
  } = i, x = {
    ...i,
    color: o,
    disableShrink: l,
    size: d,
    thickness: m,
    value: y,
    variant: b,
    enableTrackSlot: c
  }, S = B4(x), _ = {}, C = {}, R = {};
  if (b === "determinate") {
    const w = 2 * Math.PI * ((xi - m) / 2);
    _.strokeDasharray = w.toFixed(3), R["aria-valuenow"] = Math.round(y), _.strokeDashoffset = `${((100 - y) / 100 * w).toFixed(3)}px`, C.transform = "rotate(-90deg)";
  }
  return /* @__PURE__ */ et.jsx(k4, {
    className: Lt(S.root, s),
    style: {
      width: d,
      height: d,
      ...C,
      ...f
    },
    ownerState: x,
    ref: e,
    role: "progressbar",
    ...R,
    ...v,
    children: /* @__PURE__ */ et.jsxs(O4, {
      className: S.svg,
      ownerState: x,
      viewBox: `${xi / 2} ${xi / 2} ${xi} ${xi}`,
      children: [c ? /* @__PURE__ */ et.jsx(G4, {
        className: S.track,
        ownerState: x,
        cx: xi,
        cy: xi,
        r: (xi - m) / 2,
        fill: "none",
        strokeWidth: m,
        "aria-hidden": "true"
      }) : null, /* @__PURE__ */ et.jsx(D4, {
        className: S.circle,
        style: _,
        ownerState: x,
        cx: xi,
        cy: xi,
        r: (xi - m) / 2,
        fill: "none",
        strokeWidth: m
      })]
    })
  });
});
function hr(n) {
  const {
    elementType: t,
    externalSlotProps: e,
    ownerState: i,
    skipResolvingSlotProps: s = !1,
    ...o
  } = n, l = s ? {} : jC(e, i), {
    props: c,
    internalRef: d
  } = YC({
    ...o,
    externalSlotProps: l
  }), f = Bn(d, l?.ref, n.additionalProps?.ref);
  return VC(t, {
    ...c,
    ref: f
  }, i);
}
function au(n) {
  return parseInt(O.version, 10) >= 19 ? n?.props?.ref || null : n?.ref || null;
}
function N4(n) {
  return typeof n == "function" ? n() : n;
}
const I4 = /* @__PURE__ */ O.forwardRef(function(t, e) {
  const {
    children: i,
    container: s,
    disablePortal: o = !1
  } = t, [l, c] = O.useState(null), d = Bn(/* @__PURE__ */ O.isValidElement(i) ? au(i) : null, e);
  if (ts(() => {
    o || c(N4(s) || document.body);
  }, [s, o]), ts(() => {
    if (l && !o)
      return _S(e, l), () => {
        _S(e, null);
      };
  }, [e, l, o]), o) {
    if (/* @__PURE__ */ O.isValidElement(i)) {
      const f = {
        ref: d
      };
      return /* @__PURE__ */ O.cloneElement(i, f);
    }
    return i;
  }
  return l && /* @__PURE__ */ FC.createPortal(i, l);
});
function zc(n) {
  return parseInt(n, 10) || 0;
}
const z4 = {
  shadow: {
    // Visibility needed to hide the extra text area on iPads
    visibility: "hidden",
    // Remove from the content flow
    position: "absolute",
    // Ignore the scrollbar width
    overflow: "hidden",
    height: 0,
    top: 0,
    left: 0,
    // Create a new layer, increase the isolation of the computed values
    transform: "translateZ(0)"
  }
};
function L4(n) {
  for (const t in n)
    return !1;
  return !0;
}
function CS(n) {
  return L4(n) || n.outerHeightStyle === 0 && !n.overflowing;
}
const F4 = /* @__PURE__ */ O.forwardRef(function(t, e) {
  const {
    onChange: i,
    maxRows: s,
    minRows: o = 1,
    style: l,
    value: c,
    ...d
  } = t, {
    current: f
  } = O.useRef(c != null), m = O.useRef(null), y = Bn(e, m), b = O.useRef(null), v = O.useRef(null), x = O.useCallback(() => {
    const w = m.current, E = v.current;
    if (!w || !E)
      return;
    const k = Tr(w).getComputedStyle(w);
    if (k.width === "0px")
      return {
        outerHeightStyle: 0,
        overflowing: !1
      };
    E.style.width = k.width, E.value = w.value || t.placeholder || "x", E.value.slice(-1) === `
` && (E.value += " ");
    const G = k.boxSizing, $ = zc(k.paddingBottom) + zc(k.paddingTop), F = zc(k.borderBottomWidth) + zc(k.borderTopWidth), j = E.scrollHeight;
    E.value = "x";
    const H = E.scrollHeight;
    let M = j;
    o && (M = Math.max(Number(o) * H, M)), s && (M = Math.min(Number(s) * H, M)), M = Math.max(M, H);
    const Y = M + (G === "border-box" ? $ + F : 0), L = Math.abs(M - j) <= 1;
    return {
      outerHeightStyle: Y,
      overflowing: L
    };
  }, [s, o, t.placeholder]), S = $i(() => {
    const w = m.current, E = x();
    if (!w || !E || CS(E))
      return !1;
    const P = E.outerHeightStyle;
    return b.current != null && b.current !== P;
  }), _ = O.useCallback(() => {
    const w = m.current, E = x();
    if (!w || !E || CS(E))
      return;
    const P = E.outerHeightStyle;
    b.current !== P && (b.current = P, w.style.height = `${P}px`), w.style.overflow = E.overflowing ? "hidden" : "";
  }, [x]), C = O.useRef(-1);
  ts(() => {
    const w = IC(_), E = m?.current;
    if (!E)
      return;
    const P = Tr(E);
    P.addEventListener("resize", w);
    let k;
    return typeof ResizeObserver < "u" && (k = new ResizeObserver(() => {
      S() && (k.unobserve(E), cancelAnimationFrame(C.current), _(), C.current = requestAnimationFrame(() => {
        k.observe(E);
      }));
    }), k.observe(E)), () => {
      w.clear(), cancelAnimationFrame(C.current), P.removeEventListener("resize", w), k && k.disconnect();
    };
  }, [x, _, S]), ts(() => {
    _();
  });
  const R = (w) => {
    f || _();
    const E = w.target, P = E.value.length, k = E.value.endsWith(`
`), G = E.selectionStart === P;
    k && G && E.setSelectionRange(P, P), i && i(w);
  };
  return /* @__PURE__ */ et.jsxs(O.Fragment, {
    children: [/* @__PURE__ */ et.jsx("textarea", {
      value: c,
      onChange: R,
      ref: y,
      rows: o,
      style: l,
      ...d
    }), /* @__PURE__ */ et.jsx("textarea", {
      "aria-hidden": !0,
      className: t.className,
      readOnly: !0,
      ref: v,
      tabIndex: -1,
      style: {
        ...z4.shadow,
        ...l,
        paddingTop: 0,
        paddingBottom: 0
      }
    })]
  });
});
function io({
  props: n,
  states: t,
  muiFormControl: e
}) {
  return t.reduce((i, s) => (i[s] = n[s], e && typeof n[s] > "u" && (i[s] = e[s]), i), {});
}
const iy = /* @__PURE__ */ O.createContext(void 0);
function ro() {
  return O.useContext(iy);
}
function ES(n) {
  return n != null && !(Array.isArray(n) && n.length === 0);
}
function bh(n, t = !1) {
  return n && (ES(n.value) && n.value !== "" || t && ES(n.defaultValue) && n.defaultValue !== "");
}
function H4(n) {
  return n.startAdornment;
}
function $4(n) {
  return Be("MuiInputBase", n);
}
const Ja = ke("MuiInputBase", ["root", "formControl", "focused", "disabled", "adornedStart", "adornedEnd", "error", "sizeSmall", "multiline", "colorSecondary", "fullWidth", "hiddenLabel", "readOnly", "input", "inputSizeSmall", "inputMultiline", "inputTypeSearch", "inputAdornedStart", "inputAdornedEnd", "inputHiddenLabel"]);
var MS;
const $h = (n, t) => {
  const {
    ownerState: e
  } = n;
  return [t.root, e.formControl && t.formControl, e.startAdornment && t.adornedStart, e.endAdornment && t.adornedEnd, e.error && t.error, e.size === "small" && t.sizeSmall, e.multiline && t.multiline, e.color && t[`color${St(e.color)}`], e.fullWidth && t.fullWidth, e.hiddenLabel && t.hiddenLabel];
}, Wh = (n, t) => {
  const {
    ownerState: e
  } = n;
  return [t.input, e.size === "small" && t.inputSizeSmall, e.multiline && t.inputMultiline, e.type === "search" && t.inputTypeSearch, e.startAdornment && t.inputAdornedStart, e.endAdornment && t.inputAdornedEnd, e.hiddenLabel && t.inputHiddenLabel];
}, W4 = (n) => {
  const {
    classes: t,
    color: e,
    disabled: i,
    error: s,
    endAdornment: o,
    focused: l,
    formControl: c,
    fullWidth: d,
    hiddenLabel: f,
    multiline: m,
    readOnly: y,
    size: b,
    startAdornment: v,
    type: x
  } = n, S = {
    root: ["root", `color${St(e)}`, i && "disabled", s && "error", d && "fullWidth", l && "focused", c && "formControl", b && b !== "medium" && `size${St(b)}`, m && "multiline", v && "adornedStart", o && "adornedEnd", f && "hiddenLabel", y && "readOnly"],
    input: ["input", i && "disabled", x === "search" && "inputTypeSearch", m && "inputMultiline", b === "small" && "inputSizeSmall", f && "inputHiddenLabel", v && "inputAdornedStart", o && "inputAdornedEnd", y && "readOnly"]
  };
  return Oe(S, $4, t);
}, Vh = vt("div", {
  name: "MuiInputBase",
  slot: "Root",
  overridesResolver: $h
})(Te(({
  theme: n
}) => ({
  ...n.typography.body1,
  color: (n.vars || n).palette.text.primary,
  lineHeight: "1.4375em",
  // 23px
  boxSizing: "border-box",
  // Prevent padding issue with fullWidth.
  position: "relative",
  cursor: "text",
  display: "inline-flex",
  alignItems: "center",
  [`&.${Ja.disabled}`]: {
    color: (n.vars || n).palette.text.disabled,
    cursor: "default"
  },
  variants: [{
    props: ({
      ownerState: t
    }) => t.multiline,
    style: {
      padding: "4px 0 5px"
    }
  }, {
    props: ({
      ownerState: t,
      size: e
    }) => t.multiline && e === "small",
    style: {
      paddingTop: 1
    }
  }, {
    props: ({
      ownerState: t
    }) => t.fullWidth,
    style: {
      width: "100%"
    }
  }]
}))), jh = vt("input", {
  name: "MuiInputBase",
  slot: "Input",
  overridesResolver: Wh
})(Te(({
  theme: n
}) => {
  const t = n.palette.mode === "light", e = {
    color: "currentColor",
    ...n.vars ? {
      opacity: n.vars.opacity.inputPlaceholder
    } : {
      opacity: t ? 0.42 : 0.5
    },
    transition: n.transitions.create("opacity", {
      duration: n.transitions.duration.shorter
    })
  }, i = {
    opacity: "0 !important"
  }, s = n.vars ? {
    opacity: n.vars.opacity.inputPlaceholder
  } : {
    opacity: t ? 0.42 : 0.5
  };
  return {
    font: "inherit",
    letterSpacing: "inherit",
    color: "currentColor",
    padding: "4px 0 5px",
    border: 0,
    boxSizing: "content-box",
    background: "none",
    height: "1.4375em",
    // Reset 23pxthe native input line-height
    margin: 0,
    // Reset for Safari
    WebkitTapHighlightColor: "transparent",
    display: "block",
    // Make the flex item shrink with Firefox
    minWidth: 0,
    width: "100%",
    "&::-webkit-input-placeholder": e,
    "&::-moz-placeholder": e,
    // Firefox 19+
    "&::-ms-input-placeholder": e,
    // Edge
    "&:focus": {
      outline: 0
    },
    // Reset Firefox invalid required input style
    "&:invalid": {
      boxShadow: "none"
    },
    "&::-webkit-search-decoration": {
      // Remove the padding when type=search.
      WebkitAppearance: "none"
    },
    // Show and hide the placeholder logic
    [`label[data-shrink=false] + .${Ja.formControl} &`]: {
      "&::-webkit-input-placeholder": i,
      "&::-moz-placeholder": i,
      // Firefox 19+
      "&::-ms-input-placeholder": i,
      // Edge
      "&:focus::-webkit-input-placeholder": s,
      "&:focus::-moz-placeholder": s,
      // Firefox 19+
      "&:focus::-ms-input-placeholder": s
      // Edge
    },
    [`&.${Ja.disabled}`]: {
      opacity: 1,
      // Reset iOS opacity
      WebkitTextFillColor: (n.vars || n).palette.text.disabled
      // Fix opacity Safari bug
    },
    variants: [{
      props: ({
        ownerState: o
      }) => !o.disableInjectingGlobalStyles,
      style: {
        animationName: "mui-auto-fill-cancel",
        animationDuration: "10ms",
        "&:-webkit-autofill": {
          animationDuration: "5000s",
          animationName: "mui-auto-fill"
        }
      }
    }, {
      props: {
        size: "small"
      },
      style: {
        paddingTop: 1
      }
    }, {
      props: ({
        ownerState: o
      }) => o.multiline,
      style: {
        height: "auto",
        resize: "none",
        padding: 0,
        paddingTop: 0
      }
    }, {
      props: {
        type: "search"
      },
      style: {
        MozAppearance: "textfield"
        // Improve type search style.
      }
    }]
  };
})), AS = VU({
  "@keyframes mui-auto-fill": {
    from: {
      display: "block"
    }
  },
  "@keyframes mui-auto-fill-cancel": {
    from: {
      display: "block"
    }
  }
}), ry = /* @__PURE__ */ O.forwardRef(function(t, e) {
  const i = Ne({
    props: t,
    name: "MuiInputBase"
  }), {
    "aria-describedby": s,
    autoComplete: o,
    autoFocus: l,
    className: c,
    color: d,
    components: f = {},
    componentsProps: m = {},
    defaultValue: y,
    disabled: b,
    disableInjectingGlobalStyles: v,
    endAdornment: x,
    error: S,
    fullWidth: _ = !1,
    id: C,
    inputComponent: R = "input",
    inputProps: w = {},
    inputRef: E,
    margin: P,
    maxRows: k,
    minRows: G,
    multiline: $ = !1,
    name: F,
    onBlur: j,
    onChange: H,
    onClick: M,
    onFocus: Y,
    onKeyDown: L,
    onKeyUp: Q,
    placeholder: B,
    readOnly: I,
    renderSuffix: rt,
    rows: J,
    size: D,
    slotProps: q = {},
    slots: ot = {},
    startAdornment: at,
    type: lt = "text",
    value: dt,
    ...ht
  } = i, Vt = w.value != null ? w.value : dt, {
    current: Rt
  } = O.useRef(Vt != null), Dt = O.useRef(), gt = O.useCallback((Wt) => {
  }, []), Pt = Bn(Dt, E, w.ref, gt), [Et, It] = O.useState(!1), wt = ro(), Yt = io({
    props: i,
    muiFormControl: wt,
    states: ["color", "disabled", "error", "hiddenLabel", "size", "required", "filled"]
  });
  Yt.focused = wt ? wt.focused : Et, O.useEffect(() => {
    !wt && b && Et && (It(!1), j && j());
  }, [wt, b, Et, j]);
  const Ie = wt && wt.onFilled, Gt = wt && wt.onEmpty, pe = O.useCallback((Wt) => {
    bh(Wt) ? Ie && Ie() : Gt && Gt();
  }, [Ie, Gt]);
  ts(() => {
    Rt && pe({
      value: Vt
    });
  }, [Vt, pe, Rt]);
  const Je = (Wt) => {
    Y && Y(Wt), w.onFocus && w.onFocus(Wt), wt && wt.onFocus ? wt.onFocus(Wt) : It(!0);
  }, De = (Wt) => {
    j && j(Wt), w.onBlur && w.onBlur(Wt), wt && wt.onBlur ? wt.onBlur(Wt) : It(!1);
  }, le = (Wt, ...We) => {
    if (!Rt) {
      const ue = Wt.target || Dt.current;
      if (ue == null)
        throw new Error(_r(1));
      pe({
        value: ue.value
      });
    }
    w.onChange && w.onChange(Wt, ...We), H && H(Wt, ...We);
  };
  O.useEffect(() => {
    pe(Dt.current);
  }, []);
  const xt = (Wt) => {
    Dt.current && Wt.currentTarget === Wt.target && Dt.current.focus(), M && M(Wt);
  };
  let sn = R, Me = w;
  $ && sn === "input" && (J ? Me = {
    type: void 0,
    minRows: J,
    maxRows: J,
    ...Me
  } : Me = {
    type: void 0,
    maxRows: k,
    minRows: G,
    ...Me
  }, sn = F4);
  const ct = (Wt) => {
    pe(Wt.animationName === "mui-auto-fill-cancel" ? Dt.current : {
      value: "x"
    });
  };
  O.useEffect(() => {
    wt && wt.setAdornedStart(!!at);
  }, [wt, at]);
  const ut = {
    ...i,
    color: Yt.color || "primary",
    disabled: Yt.disabled,
    endAdornment: x,
    error: Yt.error,
    focused: Yt.focused,
    formControl: wt,
    fullWidth: _,
    hiddenLabel: Yt.hiddenLabel,
    multiline: $,
    size: Yt.size,
    startAdornment: at,
    type: lt
  }, yt = W4(ut), Bt = ot.root || f.Root || Vh, Ct = q.root || m.root || {}, kt = ot.input || f.Input || jh;
  return Me = {
    ...Me,
    ...q.input ?? m.input
  }, /* @__PURE__ */ et.jsxs(O.Fragment, {
    children: [!v && typeof AS == "function" && // For Emotion/Styled-components, InputGlobalStyles will be a function
    // For Pigment CSS, this has no effect because the InputGlobalStyles will be null.
    (MS || (MS = /* @__PURE__ */ et.jsx(AS, {}))), /* @__PURE__ */ et.jsxs(Bt, {
      ...Ct,
      ref: e,
      onClick: xt,
      ...ht,
      ...!Zr(Bt) && {
        ownerState: {
          ...ut,
          ...Ct.ownerState
        }
      },
      className: Lt(yt.root, Ct.className, c, I && "MuiInputBase-readOnly"),
      children: [at, /* @__PURE__ */ et.jsx(iy.Provider, {
        value: null,
        children: /* @__PURE__ */ et.jsx(kt, {
          "aria-invalid": Yt.error,
          "aria-describedby": s,
          autoComplete: o,
          autoFocus: l,
          defaultValue: y,
          disabled: Yt.disabled,
          id: C,
          onAnimationStart: ct,
          name: F,
          placeholder: B,
          readOnly: I,
          required: Yt.required,
          rows: J,
          value: Vt,
          onKeyDown: L,
          onKeyUp: Q,
          type: lt,
          ...Me,
          ...!Zr(kt) && {
            as: sn,
            ownerState: {
              ...ut,
              ...Me.ownerState
            }
          },
          ref: Pt,
          className: Lt(yt.input, Me.className, I && "MuiInputBase-readOnly"),
          onBlur: De,
          onChange: le,
          onFocus: Je
        })
      }), x, rt ? rt({
        ...Yt,
        startAdornment: at
      }) : null]
    })]
  });
});
function V4(n) {
  return Be("MuiInput", n);
}
const fl = {
  ...Ja,
  ...ke("MuiInput", ["root", "underline", "input"])
};
function j4(n) {
  return Be("MuiOutlinedInput", n);
}
const Gi = {
  ...Ja,
  ...ke("MuiOutlinedInput", ["root", "notchedOutline", "input"])
};
function Y4(n) {
  return Be("MuiFilledInput", n);
}
const ws = {
  ...Ja,
  ...ke("MuiFilledInput", ["root", "underline", "input", "adornedStart", "adornedEnd", "sizeSmall", "multiline", "hiddenLabel"])
}, X4 = qU(/* @__PURE__ */ et.jsx("path", {
  d: "M7 10l5 5 5-5z"
})), q4 = {
  entering: {
    opacity: 1
  },
  entered: {
    opacity: 1
  }
}, K4 = /* @__PURE__ */ O.forwardRef(function(t, e) {
  const i = Jg(), s = {
    enter: i.transitions.duration.enteringScreen,
    exit: i.transitions.duration.leavingScreen
  }, {
    addEndListener: o,
    appear: l = !0,
    children: c,
    easing: d,
    in: f,
    onEnter: m,
    onEntered: y,
    onEntering: b,
    onExit: v,
    onExited: x,
    onExiting: S,
    style: _,
    timeout: C = s,
    // eslint-disable-next-line react/prop-types
    TransitionComponent: R = Wi,
    ...w
  } = t, E = O.useRef(null), P = Bn(E, au(c), e), k = (L) => (Q) => {
    if (L) {
      const B = E.current;
      Q === void 0 ? L(B) : L(B, Q);
    }
  }, G = k(b), $ = k((L, Q) => {
    WC(L);
    const B = mh({
      style: _,
      timeout: C,
      easing: d
    }, {
      mode: "enter"
    });
    L.style.webkitTransition = i.transitions.create("opacity", B), L.style.transition = i.transitions.create("opacity", B), m && m(L, Q);
  }), F = k(y), j = k(S), H = k((L) => {
    const Q = mh({
      style: _,
      timeout: C,
      easing: d
    }, {
      mode: "exit"
    });
    L.style.webkitTransition = i.transitions.create("opacity", Q), L.style.transition = i.transitions.create("opacity", Q), v && v(L);
  }), M = k(x), Y = (L) => {
    o && o(E.current, L);
  };
  return /* @__PURE__ */ et.jsx(R, {
    appear: l,
    in: f,
    nodeRef: E,
    onEnter: $,
    onEntered: F,
    onEntering: G,
    onExit: H,
    onExited: M,
    onExiting: j,
    addEndListener: Y,
    timeout: C,
    ...w,
    children: (L, {
      ownerState: Q,
      ...B
    }) => /* @__PURE__ */ O.cloneElement(c, {
      style: {
        opacity: 0,
        visibility: L === "exited" && !f ? "hidden" : void 0,
        ...q4[L],
        ..._,
        ...c.props.style
      },
      ref: P,
      ...B
    })
  });
});
function Z4(n) {
  return Be("MuiBackdrop", n);
}
ke("MuiBackdrop", ["root", "invisible"]);
const Q4 = (n) => {
  const {
    classes: t,
    invisible: e
  } = n;
  return Oe({
    root: ["root", e && "invisible"]
  }, Z4, t);
}, J4 = vt("div", {
  name: "MuiBackdrop",
  slot: "Root",
  overridesResolver: (n, t) => {
    const {
      ownerState: e
    } = n;
    return [t.root, e.invisible && t.invisible];
  }
})({
  position: "fixed",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  right: 0,
  bottom: 0,
  top: 0,
  left: 0,
  backgroundColor: "rgba(0, 0, 0, 0.5)",
  WebkitTapHighlightColor: "transparent",
  variants: [{
    props: {
      invisible: !0
    },
    style: {
      backgroundColor: "transparent"
    }
  }]
}), t5 = /* @__PURE__ */ O.forwardRef(function(t, e) {
  const i = Ne({
    props: t,
    name: "MuiBackdrop"
  }), {
    children: s,
    className: o,
    component: l = "div",
    invisible: c = !1,
    open: d,
    components: f = {},
    componentsProps: m = {},
    slotProps: y = {},
    slots: b = {},
    TransitionComponent: v,
    transitionDuration: x,
    ...S
  } = i, _ = {
    ...i,
    component: l,
    invisible: c
  }, C = Q4(_), R = {
    transition: v,
    root: f.Root,
    ...b
  }, w = {
    ...m,
    ...y
  }, E = {
    component: l,
    slots: R,
    slotProps: w
  }, [P, k] = Tn("root", {
    elementType: J4,
    externalForwardedProps: E,
    className: Lt(C.root, o),
    ownerState: _
  }), [G, $] = Tn("transition", {
    elementType: K4,
    externalForwardedProps: E,
    ownerState: _
  });
  return /* @__PURE__ */ et.jsx(G, {
    in: d,
    timeout: x,
    ...S,
    ...$,
    children: /* @__PURE__ */ et.jsx(P, {
      "aria-hidden": !0,
      ...k,
      classes: C,
      ref: e,
      children: s
    })
  });
});
function e5(n) {
  return Be("MuiButton", n);
}
const Cs = ke("MuiButton", ["root", "text", "textInherit", "textPrimary", "textSecondary", "textSuccess", "textError", "textInfo", "textWarning", "outlined", "outlinedInherit", "outlinedPrimary", "outlinedSecondary", "outlinedSuccess", "outlinedError", "outlinedInfo", "outlinedWarning", "contained", "containedInherit", "containedPrimary", "containedSecondary", "containedSuccess", "containedError", "containedInfo", "containedWarning", "disableElevation", "focusVisible", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorSuccess", "colorError", "colorInfo", "colorWarning", "textSizeSmall", "textSizeMedium", "textSizeLarge", "outlinedSizeSmall", "outlinedSizeMedium", "outlinedSizeLarge", "containedSizeSmall", "containedSizeMedium", "containedSizeLarge", "sizeMedium", "sizeSmall", "sizeLarge", "fullWidth", "startIcon", "endIcon", "icon", "iconSizeSmall", "iconSizeMedium", "iconSizeLarge", "loading", "loadingWrapper", "loadingIconPlaceholder", "loadingIndicator", "loadingPositionCenter", "loadingPositionStart", "loadingPositionEnd"]), XC = /* @__PURE__ */ O.createContext({}), qC = /* @__PURE__ */ O.createContext(void 0), n5 = (n) => {
  const {
    color: t,
    disableElevation: e,
    fullWidth: i,
    size: s,
    variant: o,
    loading: l,
    loadingPosition: c,
    classes: d
  } = n, f = {
    root: ["root", l && "loading", o, `${o}${St(t)}`, `size${St(s)}`, `${o}Size${St(s)}`, `color${St(t)}`, e && "disableElevation", i && "fullWidth", l && `loadingPosition${St(c)}`],
    startIcon: ["icon", "startIcon", `iconSize${St(s)}`],
    endIcon: ["icon", "endIcon", `iconSize${St(s)}`],
    loadingIndicator: ["loadingIndicator"],
    loadingWrapper: ["loadingWrapper"]
  }, m = Oe(f, e5, d);
  return {
    ...d,
    // forward the focused, disabled, etc. classes to the ButtonBase
    ...m
  };
}, KC = [{
  props: {
    size: "small"
  },
  style: {
    "& > *:nth-of-type(1)": {
      fontSize: 18
    }
  }
}, {
  props: {
    size: "medium"
  },
  style: {
    "& > *:nth-of-type(1)": {
      fontSize: 20
    }
  }
}, {
  props: {
    size: "large"
  },
  style: {
    "& > *:nth-of-type(1)": {
      fontSize: 22
    }
  }
}], i5 = vt(C4, {
  shouldForwardProp: (n) => Mi(n) || n === "classes",
  name: "MuiButton",
  slot: "Root",
  overridesResolver: (n, t) => {
    const {
      ownerState: e
    } = n;
    return [t.root, t[e.variant], t[`${e.variant}${St(e.color)}`], t[`size${St(e.size)}`], t[`${e.variant}Size${St(e.size)}`], e.color === "inherit" && t.colorInherit, e.disableElevation && t.disableElevation, e.fullWidth && t.fullWidth, e.loading && t.loading];
  }
})(Te(({
  theme: n
}) => {
  const t = n.palette.mode === "light" ? n.palette.grey[300] : n.palette.grey[800], e = n.palette.mode === "light" ? n.palette.grey.A100 : n.palette.grey[700];
  return {
    ...n.typography.button,
    minWidth: 64,
    padding: "6px 16px",
    border: 0,
    borderRadius: (n.vars || n).shape.borderRadius,
    transition: n.transitions.create(["background-color", "box-shadow", "border-color", "color"], {
      duration: n.transitions.duration.short
    }),
    "&:hover": {
      textDecoration: "none"
    },
    [`&.${Cs.disabled}`]: {
      color: (n.vars || n).palette.action.disabled
    },
    variants: [{
      props: {
        variant: "contained"
      },
      style: {
        color: "var(--variant-containedColor)",
        backgroundColor: "var(--variant-containedBg)",
        boxShadow: (n.vars || n).shadows[2],
        "&:hover": {
          boxShadow: (n.vars || n).shadows[4],
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            boxShadow: (n.vars || n).shadows[2]
          }
        },
        "&:active": {
          boxShadow: (n.vars || n).shadows[8]
        },
        [`&.${Cs.focusVisible}`]: {
          boxShadow: (n.vars || n).shadows[6]
        },
        [`&.${Cs.disabled}`]: {
          color: (n.vars || n).palette.action.disabled,
          boxShadow: (n.vars || n).shadows[0],
          backgroundColor: (n.vars || n).palette.action.disabledBackground
        }
      }
    }, {
      props: {
        variant: "outlined"
      },
      style: {
        padding: "5px 15px",
        border: "1px solid currentColor",
        borderColor: "var(--variant-outlinedBorder, currentColor)",
        backgroundColor: "var(--variant-outlinedBg)",
        color: "var(--variant-outlinedColor)",
        [`&.${Cs.disabled}`]: {
          border: `1px solid ${(n.vars || n).palette.action.disabledBackground}`
        }
      }
    }, {
      props: {
        variant: "text"
      },
      style: {
        padding: "6px 8px",
        color: "var(--variant-textColor)",
        backgroundColor: "var(--variant-textBg)"
      }
    }, ...Object.entries(n.palette).filter(Ci()).map(([i]) => ({
      props: {
        color: i
      },
      style: {
        "--variant-textColor": (n.vars || n).palette[i].main,
        "--variant-outlinedColor": (n.vars || n).palette[i].main,
        "--variant-outlinedBorder": n.alpha((n.vars || n).palette[i].main, 0.5),
        "--variant-containedColor": (n.vars || n).palette[i].contrastText,
        "--variant-containedBg": (n.vars || n).palette[i].main,
        "@media (hover: hover)": {
          "&:hover": {
            "--variant-containedBg": (n.vars || n).palette[i].dark,
            "--variant-textBg": n.alpha((n.vars || n).palette[i].main, (n.vars || n).palette.action.hoverOpacity),
            "--variant-outlinedBorder": (n.vars || n).palette[i].main,
            "--variant-outlinedBg": n.alpha((n.vars || n).palette[i].main, (n.vars || n).palette.action.hoverOpacity)
          }
        }
      }
    })), {
      props: {
        color: "inherit"
      },
      style: {
        color: "inherit",
        borderColor: "currentColor",
        "--variant-containedBg": n.vars ? n.vars.palette.Button.inheritContainedBg : t,
        "@media (hover: hover)": {
          "&:hover": {
            "--variant-containedBg": n.vars ? n.vars.palette.Button.inheritContainedHoverBg : e,
            "--variant-textBg": n.alpha((n.vars || n).palette.text.primary, (n.vars || n).palette.action.hoverOpacity),
            "--variant-outlinedBg": n.alpha((n.vars || n).palette.text.primary, (n.vars || n).palette.action.hoverOpacity)
          }
        }
      }
    }, {
      props: {
        size: "small",
        variant: "text"
      },
      style: {
        padding: "4px 5px",
        fontSize: n.typography.pxToRem(13)
      }
    }, {
      props: {
        size: "large",
        variant: "text"
      },
      style: {
        padding: "8px 11px",
        fontSize: n.typography.pxToRem(15)
      }
    }, {
      props: {
        size: "small",
        variant: "outlined"
      },
      style: {
        padding: "3px 9px",
        fontSize: n.typography.pxToRem(13)
      }
    }, {
      props: {
        size: "large",
        variant: "outlined"
      },
      style: {
        padding: "7px 21px",
        fontSize: n.typography.pxToRem(15)
      }
    }, {
      props: {
        size: "small",
        variant: "contained"
      },
      style: {
        padding: "4px 10px",
        fontSize: n.typography.pxToRem(13)
      }
    }, {
      props: {
        size: "large",
        variant: "contained"
      },
      style: {
        padding: "8px 22px",
        fontSize: n.typography.pxToRem(15)
      }
    }, {
      props: {
        disableElevation: !0
      },
      style: {
        boxShadow: "none",
        "&:hover": {
          boxShadow: "none"
        },
        [`&.${Cs.focusVisible}`]: {
          boxShadow: "none"
        },
        "&:active": {
          boxShadow: "none"
        },
        [`&.${Cs.disabled}`]: {
          boxShadow: "none"
        }
      }
    }, {
      props: {
        fullWidth: !0
      },
      style: {
        width: "100%"
      }
    }, {
      props: {
        loadingPosition: "center"
      },
      style: {
        transition: n.transitions.create(["background-color", "box-shadow", "border-color"], {
          duration: n.transitions.duration.short
        }),
        [`&.${Cs.loading}`]: {
          color: "transparent"
        }
      }
    }]
  };
})), r5 = vt("span", {
  name: "MuiButton",
  slot: "StartIcon",
  overridesResolver: (n, t) => {
    const {
      ownerState: e
    } = n;
    return [t.startIcon, e.loading && t.startIconLoadingStart, t[`iconSize${St(e.size)}`]];
  }
})(({
  theme: n
}) => ({
  display: "inherit",
  marginRight: 8,
  marginLeft: -4,
  variants: [{
    props: {
      size: "small"
    },
    style: {
      marginLeft: -2
    }
  }, {
    props: {
      loadingPosition: "start",
      loading: !0
    },
    style: {
      transition: n.transitions.create(["opacity"], {
        duration: n.transitions.duration.short
      }),
      opacity: 0
    }
  }, {
    props: {
      loadingPosition: "start",
      loading: !0,
      fullWidth: !0
    },
    style: {
      marginRight: -8
    }
  }, ...KC]
})), s5 = vt("span", {
  name: "MuiButton",
  slot: "EndIcon",
  overridesResolver: (n, t) => {
    const {
      ownerState: e
    } = n;
    return [t.endIcon, e.loading && t.endIconLoadingEnd, t[`iconSize${St(e.size)}`]];
  }
})(({
  theme: n
}) => ({
  display: "inherit",
  marginRight: -4,
  marginLeft: 8,
  variants: [{
    props: {
      size: "small"
    },
    style: {
      marginRight: -2
    }
  }, {
    props: {
      loadingPosition: "end",
      loading: !0
    },
    style: {
      transition: n.transitions.create(["opacity"], {
        duration: n.transitions.duration.short
      }),
      opacity: 0
    }
  }, {
    props: {
      loadingPosition: "end",
      loading: !0,
      fullWidth: !0
    },
    style: {
      marginLeft: -8
    }
  }, ...KC]
})), a5 = vt("span", {
  name: "MuiButton",
  slot: "LoadingIndicator"
})(({
  theme: n
}) => ({
  display: "none",
  position: "absolute",
  visibility: "visible",
  variants: [{
    props: {
      loading: !0
    },
    style: {
      display: "flex"
    }
  }, {
    props: {
      loadingPosition: "start"
    },
    style: {
      left: 14
    }
  }, {
    props: {
      loadingPosition: "start",
      size: "small"
    },
    style: {
      left: 10
    }
  }, {
    props: {
      variant: "text",
      loadingPosition: "start"
    },
    style: {
      left: 6
    }
  }, {
    props: {
      loadingPosition: "center"
    },
    style: {
      left: "50%",
      transform: "translate(-50%)",
      color: (n.vars || n).palette.action.disabled
    }
  }, {
    props: {
      loadingPosition: "end"
    },
    style: {
      right: 14
    }
  }, {
    props: {
      loadingPosition: "end",
      size: "small"
    },
    style: {
      right: 10
    }
  }, {
    props: {
      variant: "text",
      loadingPosition: "end"
    },
    style: {
      right: 6
    }
  }, {
    props: {
      loadingPosition: "start",
      fullWidth: !0
    },
    style: {
      position: "relative",
      left: -10
    }
  }, {
    props: {
      loadingPosition: "end",
      fullWidth: !0
    },
    style: {
      position: "relative",
      right: -10
    }
  }]
})), RS = vt("span", {
  name: "MuiButton",
  slot: "LoadingIconPlaceholder"
})({
  display: "inline-block",
  width: "1em",
  height: "1em"
}), pl = /* @__PURE__ */ O.forwardRef(function(t, e) {
  const i = O.useContext(XC), s = O.useContext(qC), o = dh(i, t), l = Ne({
    props: o,
    name: "MuiButton"
  }), {
    children: c,
    color: d = "primary",
    component: f = "button",
    className: m,
    disabled: y = !1,
    disableElevation: b = !1,
    disableFocusRipple: v = !1,
    endIcon: x,
    focusVisibleClassName: S,
    fullWidth: _ = !1,
    id: C,
    loading: R = null,
    loadingIndicator: w,
    loadingPosition: E = "center",
    size: P = "medium",
    startIcon: k,
    type: G,
    variant: $ = "text",
    ...F
  } = l, j = Kg(C), H = w ?? /* @__PURE__ */ et.jsx(U4, {
    "aria-labelledby": j,
    color: "inherit",
    size: 16
  }), M = {
    ...l,
    color: d,
    component: f,
    disabled: y,
    disableElevation: b,
    disableFocusRipple: v,
    fullWidth: _,
    loading: R,
    loadingIndicator: H,
    loadingPosition: E,
    size: P,
    type: G,
    variant: $
  }, Y = n5(M), L = (k || R && E === "start") && /* @__PURE__ */ et.jsx(r5, {
    className: Y.startIcon,
    ownerState: M,
    children: k || /* @__PURE__ */ et.jsx(RS, {
      className: Y.loadingIconPlaceholder,
      ownerState: M
    })
  }), Q = (x || R && E === "end") && /* @__PURE__ */ et.jsx(s5, {
    className: Y.endIcon,
    ownerState: M,
    children: x || /* @__PURE__ */ et.jsx(RS, {
      className: Y.loadingIconPlaceholder,
      ownerState: M
    })
  }), B = s || "", I = typeof R == "boolean" ? (
    // use plain HTML span to minimize the runtime overhead
    /* @__PURE__ */ et.jsx("span", {
      className: Y.loadingWrapper,
      style: {
        display: "contents"
      },
      children: R && /* @__PURE__ */ et.jsx(a5, {
        className: Y.loadingIndicator,
        ownerState: M,
        children: H
      })
    })
  ) : null;
  return /* @__PURE__ */ et.jsxs(i5, {
    ownerState: M,
    className: Lt(i.className, Y.root, m, B),
    component: f,
    disabled: y || R,
    focusRipple: !v,
    focusVisibleClassName: Lt(Y.focusVisible, S),
    ref: e,
    type: G,
    id: R ? j : C,
    ...F,
    classes: Y,
    children: [L, E !== "end" && I, c, E === "end" && I, Q]
  });
});
function o5(n) {
  return O.Children.toArray(n).filter((t) => /* @__PURE__ */ O.isValidElement(t));
}
function l5(n) {
  return Be("MuiButtonGroup", n);
}
const Ht = ke("MuiButtonGroup", ["root", "contained", "outlined", "text", "disableElevation", "disabled", "firstButton", "fullWidth", "horizontal", "vertical", "colorPrimary", "colorSecondary", "grouped", "groupedHorizontal", "groupedVertical", "groupedText", "groupedTextHorizontal", "groupedTextVertical", "groupedTextPrimary", "groupedTextSecondary", "groupedOutlined", "groupedOutlinedHorizontal", "groupedOutlinedVertical", "groupedOutlinedPrimary", "groupedOutlinedSecondary", "groupedContained", "groupedContainedHorizontal", "groupedContainedVertical", "groupedContainedPrimary", "groupedContainedSecondary", "lastButton", "middleButton"]), u5 = (n, t) => {
  const {
    ownerState: e
  } = n;
  return [{
    [`& .${Ht.grouped}`]: t.grouped
  }, {
    [`& .${Ht.grouped}`]: t[`grouped${St(e.orientation)}`]
  }, {
    [`& .${Ht.grouped}`]: t[`grouped${St(e.variant)}`]
  }, {
    [`& .${Ht.grouped}`]: t[`grouped${St(e.variant)}${St(e.orientation)}`]
  }, {
    [`& .${Ht.grouped}`]: t[`grouped${St(e.variant)}${St(e.color)}`]
  }, {
    [`& .${Ht.firstButton}`]: t.firstButton
  }, {
    [`& .${Ht.lastButton}`]: t.lastButton
  }, {
    [`& .${Ht.middleButton}`]: t.middleButton
  }, t.root, t[e.variant], e.disableElevation === !0 && t.disableElevation, e.fullWidth && t.fullWidth, e.orientation === "vertical" && t.vertical];
}, c5 = (n) => {
  const {
    classes: t,
    color: e,
    disabled: i,
    disableElevation: s,
    fullWidth: o,
    orientation: l,
    variant: c
  } = n, d = {
    root: ["root", c, l, o && "fullWidth", s && "disableElevation", `color${St(e)}`],
    grouped: ["grouped", `grouped${St(l)}`, `grouped${St(c)}`, `grouped${St(c)}${St(l)}`, `grouped${St(c)}${St(e)}`, i && "disabled"],
    firstButton: ["firstButton"],
    lastButton: ["lastButton"],
    middleButton: ["middleButton"]
  };
  return Oe(d, l5, t);
}, h5 = vt("div", {
  name: "MuiButtonGroup",
  slot: "Root",
  overridesResolver: u5
})(Te(({
  theme: n
}) => ({
  display: "inline-flex",
  borderRadius: (n.vars || n).shape.borderRadius,
  variants: [{
    props: {
      variant: "contained"
    },
    style: {
      boxShadow: (n.vars || n).shadows[2]
    }
  }, {
    props: {
      disableElevation: !0
    },
    style: {
      boxShadow: "none"
    }
  }, {
    props: {
      fullWidth: !0
    },
    style: {
      width: "100%"
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      flexDirection: "column",
      [`& .${Ht.lastButton},& .${Ht.middleButton}`]: {
        borderTopRightRadius: 0,
        borderTopLeftRadius: 0
      },
      [`& .${Ht.firstButton},& .${Ht.middleButton}`]: {
        borderBottomRightRadius: 0,
        borderBottomLeftRadius: 0
      }
    }
  }, {
    props: {
      orientation: "horizontal"
    },
    style: {
      [`& .${Ht.firstButton},& .${Ht.middleButton}`]: {
        borderTopRightRadius: 0,
        borderBottomRightRadius: 0
      },
      [`& .${Ht.lastButton},& .${Ht.middleButton}`]: {
        borderTopLeftRadius: 0,
        borderBottomLeftRadius: 0
      }
    }
  }, {
    props: {
      variant: "text",
      orientation: "horizontal"
    },
    style: {
      [`& .${Ht.firstButton},& .${Ht.middleButton}`]: {
        borderRight: n.vars ? `1px solid ${n.alpha(n.vars.palette.common.onBackground, 0.23)}` : `1px solid ${n.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)"}`,
        [`&.${Ht.disabled}`]: {
          borderRight: `1px solid ${(n.vars || n).palette.action.disabled}`
        }
      }
    }
  }, {
    props: {
      variant: "text",
      orientation: "vertical"
    },
    style: {
      [`& .${Ht.firstButton},& .${Ht.middleButton}`]: {
        borderBottom: n.vars ? `1px solid ${n.alpha(n.vars.palette.common.onBackground, 0.23)}` : `1px solid ${n.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)"}`,
        [`&.${Ht.disabled}`]: {
          borderBottom: `1px solid ${(n.vars || n).palette.action.disabled}`
        }
      }
    }
  }, ...Object.entries(n.palette).filter(Ci()).flatMap(([t]) => [{
    props: {
      variant: "text",
      color: t
    },
    style: {
      [`& .${Ht.firstButton},& .${Ht.middleButton}`]: {
        borderColor: n.alpha((n.vars || n).palette[t].main, 0.5)
      }
    }
  }]), {
    props: {
      variant: "outlined",
      orientation: "horizontal"
    },
    style: {
      [`& .${Ht.firstButton},& .${Ht.middleButton}`]: {
        borderRightColor: "transparent",
        "&:hover": {
          borderRightColor: "currentColor"
        }
      },
      [`& .${Ht.lastButton},& .${Ht.middleButton}`]: {
        marginLeft: -1
      }
    }
  }, {
    props: {
      variant: "outlined",
      orientation: "vertical"
    },
    style: {
      [`& .${Ht.firstButton},& .${Ht.middleButton}`]: {
        borderBottomColor: "transparent",
        "&:hover": {
          borderBottomColor: "currentColor"
        }
      },
      [`& .${Ht.lastButton},& .${Ht.middleButton}`]: {
        marginTop: -1
      }
    }
  }, {
    props: {
      variant: "contained",
      orientation: "horizontal"
    },
    style: {
      [`& .${Ht.firstButton},& .${Ht.middleButton}`]: {
        borderRight: `1px solid ${(n.vars || n).palette.grey[400]}`,
        [`&.${Ht.disabled}`]: {
          borderRight: `1px solid ${(n.vars || n).palette.action.disabled}`
        }
      }
    }
  }, {
    props: {
      variant: "contained",
      orientation: "vertical"
    },
    style: {
      [`& .${Ht.firstButton},& .${Ht.middleButton}`]: {
        borderBottom: `1px solid ${(n.vars || n).palette.grey[400]}`,
        [`&.${Ht.disabled}`]: {
          borderBottom: `1px solid ${(n.vars || n).palette.action.disabled}`
        }
      }
    }
  }, ...Object.entries(n.palette).filter(Ci(["dark"])).map(([t]) => ({
    props: {
      variant: "contained",
      color: t
    },
    style: {
      [`& .${Ht.firstButton},& .${Ht.middleButton}`]: {
        borderColor: (n.vars || n).palette[t].dark
      }
    }
  }))],
  [`& .${Ht.grouped}`]: {
    minWidth: 40,
    boxShadow: "none",
    props: {
      variant: "contained"
    },
    style: {
      "&:hover": {
        boxShadow: "none"
      }
    }
  }
}))), PS = /* @__PURE__ */ O.forwardRef(function(t, e) {
  const i = Ne({
    props: t,
    name: "MuiButtonGroup"
  }), {
    children: s,
    className: o,
    color: l = "primary",
    component: c = "div",
    disabled: d = !1,
    disableElevation: f = !1,
    disableFocusRipple: m = !1,
    disableRipple: y = !1,
    fullWidth: b = !1,
    orientation: v = "horizontal",
    size: x = "medium",
    variant: S = "outlined",
    ..._
  } = i, C = {
    ...i,
    color: l,
    component: c,
    disabled: d,
    disableElevation: f,
    disableFocusRipple: m,
    disableRipple: y,
    fullWidth: b,
    orientation: v,
    size: x,
    variant: S
  }, R = c5(C), w = O.useMemo(() => ({
    className: R.grouped,
    color: l,
    disabled: d,
    disableElevation: f,
    disableFocusRipple: m,
    disableRipple: y,
    fullWidth: b,
    size: x,
    variant: S
  }), [l, d, f, m, y, b, x, S, R.grouped]), E = o5(s), P = E.length, k = (G) => {
    const $ = G === 0, F = G === P - 1;
    return $ && F ? "" : $ ? R.firstButton : F ? R.lastButton : R.middleButton;
  };
  return /* @__PURE__ */ et.jsx(h5, {
    as: c,
    role: "group",
    className: Lt(R.root, o),
    ref: e,
    ownerState: C,
    ..._,
    children: /* @__PURE__ */ et.jsx(XC.Provider, {
      value: w,
      children: E.map((G, $) => /* @__PURE__ */ et.jsx(qC.Provider, {
        value: k($),
        children: G
      }, $))
    })
  });
});
function ZC(n = window) {
  const t = n.document.documentElement.clientWidth;
  return n.innerWidth - t;
}
function d5(n) {
  const t = An(n);
  return t.body === n ? Tr(n).innerWidth > t.documentElement.clientWidth : n.scrollHeight > n.clientHeight;
}
function Ol(n, t) {
  t ? n.setAttribute("aria-hidden", "true") : n.removeAttribute("aria-hidden");
}
function BS(n) {
  return parseInt(Tr(n).getComputedStyle(n).paddingRight, 10) || 0;
}
function f5(n) {
  const e = ["TEMPLATE", "SCRIPT", "STYLE", "LINK", "MAP", "META", "NOSCRIPT", "PICTURE", "COL", "COLGROUP", "PARAM", "SLOT", "SOURCE", "TRACK"].includes(n.tagName), i = n.tagName === "INPUT" && n.getAttribute("type") === "hidden";
  return e || i;
}
function kS(n, t, e, i, s) {
  const o = [t, e, ...i];
  [].forEach.call(n.children, (l) => {
    const c = !o.includes(l), d = !f5(l);
    c && d && Ol(l, s);
  });
}
function im(n, t) {
  let e = -1;
  return n.some((i, s) => t(i) ? (e = s, !0) : !1), e;
}
function p5(n, t) {
  const e = [], i = n.container;
  if (!t.disableScrollLock) {
    if (d5(i)) {
      const l = ZC(Tr(i));
      e.push({
        value: i.style.paddingRight,
        property: "padding-right",
        el: i
      }), i.style.paddingRight = `${BS(i) + l}px`;
      const c = An(i).querySelectorAll(".mui-fixed");
      [].forEach.call(c, (d) => {
        e.push({
          value: d.style.paddingRight,
          property: "padding-right",
          el: d
        }), d.style.paddingRight = `${BS(d) + l}px`;
      });
    }
    let o;
    if (i.parentNode instanceof DocumentFragment)
      o = An(i).body;
    else {
      const l = i.parentElement, c = Tr(i);
      o = l?.nodeName === "HTML" && c.getComputedStyle(l).overflowY === "scroll" ? l : i;
    }
    e.push({
      value: o.style.overflow,
      property: "overflow",
      el: o
    }, {
      value: o.style.overflowX,
      property: "overflow-x",
      el: o
    }, {
      value: o.style.overflowY,
      property: "overflow-y",
      el: o
    }), o.style.overflow = "hidden";
  }
  return () => {
    e.forEach(({
      value: o,
      el: l,
      property: c
    }) => {
      o ? l.style.setProperty(c, o) : l.style.removeProperty(c);
    });
  };
}
function m5(n) {
  const t = [];
  return [].forEach.call(n.children, (e) => {
    e.getAttribute("aria-hidden") === "true" && t.push(e);
  }), t;
}
class g5 {
  constructor() {
    this.modals = [], this.containers = [];
  }
  add(t, e) {
    let i = this.modals.indexOf(t);
    if (i !== -1)
      return i;
    i = this.modals.length, this.modals.push(t), t.modalRef && Ol(t.modalRef, !1);
    const s = m5(e);
    kS(e, t.mount, t.modalRef, s, !0);
    const o = im(this.containers, (l) => l.container === e);
    return o !== -1 ? (this.containers[o].modals.push(t), i) : (this.containers.push({
      modals: [t],
      container: e,
      restore: null,
      hiddenSiblings: s
    }), i);
  }
  mount(t, e) {
    const i = im(this.containers, (o) => o.modals.includes(t)), s = this.containers[i];
    s.restore || (s.restore = p5(s, e));
  }
  remove(t, e = !0) {
    const i = this.modals.indexOf(t);
    if (i === -1)
      return i;
    const s = im(this.containers, (l) => l.modals.includes(t)), o = this.containers[s];
    if (o.modals.splice(o.modals.indexOf(t), 1), this.modals.splice(i, 1), o.modals.length === 0)
      o.restore && o.restore(), t.modalRef && Ol(t.modalRef, e), kS(o.container, t.mount, t.modalRef, o.hiddenSiblings, !1), this.containers.splice(s, 1);
    else {
      const l = o.modals[o.modals.length - 1];
      l.modalRef && Ol(l.modalRef, !1);
    }
    return i;
  }
  isTopModal(t) {
    return this.modals.length > 0 && this.modals[this.modals.length - 1] === t;
  }
}
const y5 = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(",");
function b5(n) {
  const t = parseInt(n.getAttribute("tabindex") || "", 10);
  return Number.isNaN(t) ? n.contentEditable === "true" || (n.nodeName === "AUDIO" || n.nodeName === "VIDEO" || n.nodeName === "DETAILS") && n.getAttribute("tabindex") === null ? 0 : n.tabIndex : t;
}
function v5(n) {
  if (n.tagName !== "INPUT" || n.type !== "radio" || !n.name)
    return !1;
  const t = (i) => n.ownerDocument.querySelector(`input[type="radio"]${i}`);
  let e = t(`[name="${n.name}"]:checked`);
  return e || (e = t(`[name="${n.name}"]`)), e !== n;
}
function x5(n) {
  return !(n.disabled || n.tagName === "INPUT" && n.type === "hidden" || v5(n));
}
function _5(n) {
  const t = [], e = [];
  return Array.from(n.querySelectorAll(y5)).forEach((i, s) => {
    const o = b5(i);
    o === -1 || !x5(i) || (o === 0 ? t.push(i) : e.push({
      documentOrder: s,
      tabIndex: o,
      node: i
    }));
  }), e.sort((i, s) => i.tabIndex === s.tabIndex ? i.documentOrder - s.documentOrder : i.tabIndex - s.tabIndex).map((i) => i.node).concat(t);
}
function S5() {
  return !0;
}
function T5(n) {
  const {
    children: t,
    disableAutoFocus: e = !1,
    disableEnforceFocus: i = !1,
    disableRestoreFocus: s = !1,
    getTabbable: o = _5,
    isEnabled: l = S5,
    open: c
  } = n, d = O.useRef(!1), f = O.useRef(null), m = O.useRef(null), y = O.useRef(null), b = O.useRef(null), v = O.useRef(!1), x = O.useRef(null), S = Bn(au(t), x), _ = O.useRef(null);
  O.useEffect(() => {
    !c || !x.current || (v.current = !e);
  }, [e, c]), O.useEffect(() => {
    if (!c || !x.current)
      return;
    const w = An(x.current);
    return x.current.contains(w.activeElement) || (x.current.hasAttribute("tabIndex") || x.current.setAttribute("tabIndex", "-1"), v.current && x.current.focus()), () => {
      s || (y.current && y.current.focus && (d.current = !0, y.current.focus()), y.current = null);
    };
  }, [c]), O.useEffect(() => {
    if (!c || !x.current)
      return;
    const w = An(x.current), E = (G) => {
      _.current = G, !(i || !l() || G.key !== "Tab") && w.activeElement === x.current && G.shiftKey && (d.current = !0, m.current && m.current.focus());
    }, P = () => {
      const G = x.current;
      if (G === null)
        return;
      if (!w.hasFocus() || !l() || d.current) {
        d.current = !1;
        return;
      }
      if (G.contains(w.activeElement) || i && w.activeElement !== f.current && w.activeElement !== m.current)
        return;
      if (w.activeElement !== b.current)
        b.current = null;
      else if (b.current !== null)
        return;
      if (!v.current)
        return;
      let $ = [];
      if ((w.activeElement === f.current || w.activeElement === m.current) && ($ = o(x.current)), $.length > 0) {
        const F = !!(_.current?.shiftKey && _.current?.key === "Tab"), j = $[0], H = $[$.length - 1];
        typeof j != "string" && typeof H != "string" && (F ? H.focus() : j.focus());
      } else
        G.focus();
    };
    w.addEventListener("focusin", P), w.addEventListener("keydown", E, !0);
    const k = setInterval(() => {
      w.activeElement && w.activeElement.tagName === "BODY" && P();
    }, 50);
    return () => {
      clearInterval(k), w.removeEventListener("focusin", P), w.removeEventListener("keydown", E, !0);
    };
  }, [e, i, s, l, c, o]);
  const C = (w) => {
    y.current === null && (y.current = w.relatedTarget), v.current = !0, b.current = w.target;
    const E = t.props.onFocus;
    E && E(w);
  }, R = (w) => {
    y.current === null && (y.current = w.relatedTarget), v.current = !0;
  };
  return /* @__PURE__ */ et.jsxs(O.Fragment, {
    children: [/* @__PURE__ */ et.jsx("div", {
      tabIndex: c ? 0 : -1,
      onFocus: R,
      ref: f,
      "data-testid": "sentinelStart"
    }), /* @__PURE__ */ O.cloneElement(t, {
      ref: S,
      onFocus: C
    }), /* @__PURE__ */ et.jsx("div", {
      tabIndex: c ? 0 : -1,
      onFocus: R,
      ref: m,
      "data-testid": "sentinelEnd"
    })]
  });
}
function w5(n) {
  return typeof n == "function" ? n() : n;
}
function C5(n) {
  return n ? n.props.hasOwnProperty("in") : !1;
}
const OS = () => {
}, Lc = new g5();
function E5(n) {
  const {
    container: t,
    disableEscapeKeyDown: e = !1,
    disableScrollLock: i = !1,
    closeAfterTransition: s = !1,
    onTransitionEnter: o,
    onTransitionExited: l,
    children: c,
    onClose: d,
    open: f,
    rootRef: m
  } = n, y = O.useRef({}), b = O.useRef(null), v = O.useRef(null), x = Bn(v, m), [S, _] = O.useState(!f), C = C5(c);
  let R = !0;
  (n["aria-hidden"] === "false" || n["aria-hidden"] === !1) && (R = !1);
  const w = () => An(b.current), E = () => (y.current.modalRef = v.current, y.current.mount = b.current, y.current), P = () => {
    Lc.mount(E(), {
      disableScrollLock: i
    }), v.current && (v.current.scrollTop = 0);
  }, k = $i(() => {
    const Q = w5(t) || w().body;
    Lc.add(E(), Q), v.current && P();
  }), G = () => Lc.isTopModal(E()), $ = $i((Q) => {
    b.current = Q, Q && (f && G() ? P() : v.current && Ol(v.current, R));
  }), F = O.useCallback(() => {
    Lc.remove(E(), R);
  }, [R]);
  O.useEffect(() => () => {
    F();
  }, [F]), O.useEffect(() => {
    f ? k() : (!C || !s) && F();
  }, [f, F, C, s, k]);
  const j = (Q) => (B) => {
    Q.onKeyDown?.(B), !(B.key !== "Escape" || B.which === 229 || // Wait until IME is settled.
    !G()) && (e || (B.stopPropagation(), d && d(B, "escapeKeyDown")));
  }, H = (Q) => (B) => {
    Q.onClick?.(B), B.target === B.currentTarget && d && d(B, "backdropClick");
  };
  return {
    getRootProps: (Q = {}) => {
      const B = kl(n);
      delete B.onTransitionEnter, delete B.onTransitionExited;
      const I = {
        ...B,
        ...Q
      };
      return {
        /*
         * Marking an element with the role presentation indicates to assistive technology
         * that this element should be ignored; it exists to support the web application and
         * is not meant for humans to interact with directly.
         * https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/no-static-element-interactions.md
         */
        role: "presentation",
        ...I,
        onKeyDown: j(I),
        ref: x
      };
    },
    getBackdropProps: (Q = {}) => {
      const B = Q;
      return {
        "aria-hidden": !0,
        ...B,
        onClick: H(B),
        open: f
      };
    },
    getTransitionProps: () => {
      const Q = () => {
        _(!1), o && o();
      }, B = () => {
        _(!0), l && l(), s && F();
      };
      return {
        onEnter: xS(Q, c?.props.onEnter ?? OS),
        onExited: xS(B, c?.props.onExited ?? OS)
      };
    },
    rootRef: x,
    portalRef: $,
    isTopModal: G,
    exited: S,
    hasTransition: C
  };
}
function M5(n) {
  return Be("MuiModal", n);
}
ke("MuiModal", ["root", "hidden", "backdrop"]);
const A5 = (n) => {
  const {
    open: t,
    exited: e,
    classes: i
  } = n;
  return Oe({
    root: ["root", !t && e && "hidden"],
    backdrop: ["backdrop"]
  }, M5, i);
}, R5 = vt("div", {
  name: "MuiModal",
  slot: "Root",
  overridesResolver: (n, t) => {
    const {
      ownerState: e
    } = n;
    return [t.root, !e.open && e.exited && t.hidden];
  }
})(Te(({
  theme: n
}) => ({
  position: "fixed",
  zIndex: (n.vars || n).zIndex.modal,
  right: 0,
  bottom: 0,
  top: 0,
  left: 0,
  variants: [{
    props: ({
      ownerState: t
    }) => !t.open && t.exited,
    style: {
      visibility: "hidden"
    }
  }]
}))), P5 = vt(t5, {
  name: "MuiModal",
  slot: "Backdrop"
})({
  zIndex: -1
}), B5 = /* @__PURE__ */ O.forwardRef(function(t, e) {
  const i = Ne({
    name: "MuiModal",
    props: t
  }), {
    BackdropComponent: s = P5,
    BackdropProps: o,
    classes: l,
    className: c,
    closeAfterTransition: d = !1,
    children: f,
    container: m,
    component: y,
    components: b = {},
    componentsProps: v = {},
    disableAutoFocus: x = !1,
    disableEnforceFocus: S = !1,
    disableEscapeKeyDown: _ = !1,
    disablePortal: C = !1,
    disableRestoreFocus: R = !1,
    disableScrollLock: w = !1,
    hideBackdrop: E = !1,
    keepMounted: P = !1,
    onClose: k,
    onTransitionEnter: G,
    onTransitionExited: $,
    open: F,
    slotProps: j = {},
    slots: H = {},
    // eslint-disable-next-line react/prop-types
    theme: M,
    ...Y
  } = i, L = {
    ...i,
    closeAfterTransition: d,
    disableAutoFocus: x,
    disableEnforceFocus: S,
    disableEscapeKeyDown: _,
    disablePortal: C,
    disableRestoreFocus: R,
    disableScrollLock: w,
    hideBackdrop: E,
    keepMounted: P
  }, {
    getRootProps: Q,
    getBackdropProps: B,
    getTransitionProps: I,
    portalRef: rt,
    isTopModal: J,
    exited: D,
    hasTransition: q
  } = E5({
    ...L,
    rootRef: e
  }), ot = {
    ...L,
    exited: D
  }, at = A5(ot), lt = {};
  if (f.props.tabIndex === void 0 && (lt.tabIndex = "-1"), q) {
    const {
      onEnter: gt,
      onExited: Pt
    } = I();
    lt.onEnter = gt, lt.onExited = Pt;
  }
  const dt = {
    slots: {
      root: b.Root,
      backdrop: b.Backdrop,
      ...H
    },
    slotProps: {
      ...v,
      ...j
    }
  }, [ht, Vt] = Tn("root", {
    ref: e,
    elementType: R5,
    externalForwardedProps: {
      ...dt,
      ...Y,
      component: y
    },
    getSlotProps: Q,
    ownerState: ot,
    className: Lt(c, at?.root, !ot.open && ot.exited && at?.hidden)
  }), [Rt, Dt] = Tn("backdrop", {
    ref: o?.ref,
    elementType: s,
    externalForwardedProps: dt,
    shouldForwardComponentProp: !0,
    additionalProps: o,
    getSlotProps: (gt) => B({
      ...gt,
      onClick: (Pt) => {
        gt?.onClick && gt.onClick(Pt);
      }
    }),
    className: Lt(o?.className, at?.backdrop),
    ownerState: ot
  });
  return !P && !F && (!q || D) ? null : /* @__PURE__ */ et.jsx(I4, {
    ref: rt,
    container: m,
    disablePortal: C,
    children: /* @__PURE__ */ et.jsxs(ht, {
      ...Vt,
      children: [!E && s ? /* @__PURE__ */ et.jsx(Rt, {
        ...Dt
      }) : null, /* @__PURE__ */ et.jsx(T5, {
        disableEnforceFocus: S,
        disableAutoFocus: x,
        disableRestoreFocus: R,
        isEnabled: J,
        open: F,
        children: /* @__PURE__ */ O.cloneElement(f, lt)
      })]
    })
  });
}), k5 = (n) => {
  const {
    classes: t,
    disableUnderline: e,
    startAdornment: i,
    endAdornment: s,
    size: o,
    hiddenLabel: l,
    multiline: c
  } = n, d = {
    root: ["root", !e && "underline", i && "adornedStart", s && "adornedEnd", o === "small" && `size${St(o)}`, l && "hiddenLabel", c && "multiline"],
    input: ["input"]
  }, f = Oe(d, Y4, t);
  return {
    ...t,
    // forward classes to the InputBase
    ...f
  };
}, O5 = vt(Vh, {
  shouldForwardProp: (n) => Mi(n) || n === "classes",
  name: "MuiFilledInput",
  slot: "Root",
  overridesResolver: (n, t) => {
    const {
      ownerState: e
    } = n;
    return [...$h(n, t), !e.disableUnderline && t.underline];
  }
})(Te(({
  theme: n
}) => {
  const t = n.palette.mode === "light", e = t ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)", i = t ? "rgba(0, 0, 0, 0.06)" : "rgba(255, 255, 255, 0.09)", s = t ? "rgba(0, 0, 0, 0.09)" : "rgba(255, 255, 255, 0.13)", o = t ? "rgba(0, 0, 0, 0.12)" : "rgba(255, 255, 255, 0.12)";
  return {
    position: "relative",
    backgroundColor: n.vars ? n.vars.palette.FilledInput.bg : i,
    borderTopLeftRadius: (n.vars || n).shape.borderRadius,
    borderTopRightRadius: (n.vars || n).shape.borderRadius,
    transition: n.transitions.create("background-color", {
      duration: n.transitions.duration.shorter,
      easing: n.transitions.easing.easeOut
    }),
    "&:hover": {
      backgroundColor: n.vars ? n.vars.palette.FilledInput.hoverBg : s,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: n.vars ? n.vars.palette.FilledInput.bg : i
      }
    },
    [`&.${ws.focused}`]: {
      backgroundColor: n.vars ? n.vars.palette.FilledInput.bg : i
    },
    [`&.${ws.disabled}`]: {
      backgroundColor: n.vars ? n.vars.palette.FilledInput.disabledBg : o
    },
    variants: [{
      props: ({
        ownerState: l
      }) => !l.disableUnderline,
      style: {
        "&::after": {
          left: 0,
          bottom: 0,
          content: '""',
          position: "absolute",
          right: 0,
          transform: "scaleX(0)",
          transition: n.transitions.create("transform", {
            duration: n.transitions.duration.shorter,
            easing: n.transitions.easing.easeOut
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&.${ws.focused}:after`]: {
          // translateX(0) is a workaround for Safari transform scale bug
          // See https://github.com/mui/material-ui/issues/31766
          transform: "scaleX(1) translateX(0)"
        },
        [`&.${ws.error}`]: {
          "&::before, &::after": {
            borderBottomColor: (n.vars || n).palette.error.main
          }
        },
        "&::before": {
          borderBottom: `1px solid ${n.vars ? n.alpha(n.vars.palette.common.onBackground, n.vars.opacity.inputUnderline) : e}`,
          left: 0,
          bottom: 0,
          content: '"\\00a0"',
          position: "absolute",
          right: 0,
          transition: n.transitions.create("border-bottom-color", {
            duration: n.transitions.duration.shorter
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&:hover:not(.${ws.disabled}, .${ws.error}):before`]: {
          borderBottom: `1px solid ${(n.vars || n).palette.text.primary}`
        },
        [`&.${ws.disabled}:before`]: {
          borderBottomStyle: "dotted"
        }
      }
    }, ...Object.entries(n.palette).filter(Ci()).map(([l]) => ({
      props: {
        disableUnderline: !1,
        color: l
      },
      style: {
        "&::after": {
          borderBottom: `2px solid ${(n.vars || n).palette[l]?.main}`
        }
      }
    })), {
      props: ({
        ownerState: l
      }) => l.startAdornment,
      style: {
        paddingLeft: 12
      }
    }, {
      props: ({
        ownerState: l
      }) => l.endAdornment,
      style: {
        paddingRight: 12
      }
    }, {
      props: ({
        ownerState: l
      }) => l.multiline,
      style: {
        padding: "25px 12px 8px"
      }
    }, {
      props: ({
        ownerState: l,
        size: c
      }) => l.multiline && c === "small",
      style: {
        paddingTop: 21,
        paddingBottom: 4
      }
    }, {
      props: ({
        ownerState: l
      }) => l.multiline && l.hiddenLabel,
      style: {
        paddingTop: 16,
        paddingBottom: 17
      }
    }, {
      props: ({
        ownerState: l
      }) => l.multiline && l.hiddenLabel && l.size === "small",
      style: {
        paddingTop: 8,
        paddingBottom: 9
      }
    }]
  };
})), D5 = vt(jh, {
  name: "MuiFilledInput",
  slot: "Input",
  overridesResolver: Wh
})(Te(({
  theme: n
}) => ({
  paddingTop: 25,
  paddingRight: 12,
  paddingBottom: 8,
  paddingLeft: 12,
  ...!n.vars && {
    "&:-webkit-autofill": {
      WebkitBoxShadow: n.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
      WebkitTextFillColor: n.palette.mode === "light" ? null : "#fff",
      caretColor: n.palette.mode === "light" ? null : "#fff",
      borderTopLeftRadius: "inherit",
      borderTopRightRadius: "inherit"
    }
  },
  ...n.vars && {
    "&:-webkit-autofill": {
      borderTopLeftRadius: "inherit",
      borderTopRightRadius: "inherit"
    },
    [n.getColorSchemeSelector("dark")]: {
      "&:-webkit-autofill": {
        WebkitBoxShadow: "0 0 0 100px #266798 inset",
        WebkitTextFillColor: "#fff",
        caretColor: "#fff"
      }
    }
  },
  variants: [{
    props: {
      size: "small"
    },
    style: {
      paddingTop: 21,
      paddingBottom: 4
    }
  }, {
    props: ({
      ownerState: t
    }) => t.hiddenLabel,
    style: {
      paddingTop: 16,
      paddingBottom: 17
    }
  }, {
    props: ({
      ownerState: t
    }) => t.startAdornment,
    style: {
      paddingLeft: 0
    }
  }, {
    props: ({
      ownerState: t
    }) => t.endAdornment,
    style: {
      paddingRight: 0
    }
  }, {
    props: ({
      ownerState: t
    }) => t.hiddenLabel && t.size === "small",
    style: {
      paddingTop: 8,
      paddingBottom: 9
    }
  }, {
    props: ({
      ownerState: t
    }) => t.multiline,
    style: {
      paddingTop: 0,
      paddingBottom: 0,
      paddingLeft: 0,
      paddingRight: 0
    }
  }]
}))), sy = /* @__PURE__ */ O.forwardRef(function(t, e) {
  const i = Ne({
    props: t,
    name: "MuiFilledInput"
  }), {
    disableUnderline: s = !1,
    components: o = {},
    componentsProps: l,
    fullWidth: c = !1,
    hiddenLabel: d,
    // declare here to prevent spreading to DOM
    inputComponent: f = "input",
    multiline: m = !1,
    slotProps: y,
    slots: b = {},
    type: v = "text",
    ...x
  } = i, S = {
    ...i,
    disableUnderline: s,
    fullWidth: c,
    inputComponent: f,
    multiline: m,
    type: v
  }, _ = k5(i), C = {
    root: {
      ownerState: S
    },
    input: {
      ownerState: S
    }
  }, R = y ?? l ? wn(C, y ?? l) : C, w = b.root ?? o.Root ?? O5, E = b.input ?? o.Input ?? D5;
  return /* @__PURE__ */ et.jsx(ry, {
    slots: {
      root: w,
      input: E
    },
    slotProps: R,
    fullWidth: c,
    inputComponent: f,
    multiline: m,
    ref: e,
    type: v,
    ...x,
    classes: _
  });
});
sy.muiName = "Input";
function G5(n) {
  return Be("MuiFormControl", n);
}
ke("MuiFormControl", ["root", "marginNone", "marginNormal", "marginDense", "fullWidth", "disabled"]);
const U5 = (n) => {
  const {
    classes: t,
    margin: e,
    fullWidth: i
  } = n, s = {
    root: ["root", e !== "none" && `margin${St(e)}`, i && "fullWidth"]
  };
  return Oe(s, G5, t);
}, N5 = vt("div", {
  name: "MuiFormControl",
  slot: "Root",
  overridesResolver: (n, t) => {
    const {
      ownerState: e
    } = n;
    return [t.root, t[`margin${St(e.margin)}`], e.fullWidth && t.fullWidth];
  }
})({
  display: "inline-flex",
  flexDirection: "column",
  position: "relative",
  // Reset fieldset default style.
  minWidth: 0,
  padding: 0,
  margin: 0,
  border: 0,
  verticalAlign: "top",
  // Fix alignment issue on Safari.
  variants: [{
    props: {
      margin: "normal"
    },
    style: {
      marginTop: 16,
      marginBottom: 8
    }
  }, {
    props: {
      margin: "dense"
    },
    style: {
      marginTop: 8,
      marginBottom: 4
    }
  }, {
    props: {
      fullWidth: !0
    },
    style: {
      width: "100%"
    }
  }]
}), I5 = /* @__PURE__ */ O.forwardRef(function(t, e) {
  const i = Ne({
    props: t,
    name: "MuiFormControl"
  }), {
    children: s,
    className: o,
    color: l = "primary",
    component: c = "div",
    disabled: d = !1,
    error: f = !1,
    focused: m,
    fullWidth: y = !1,
    hiddenLabel: b = !1,
    margin: v = "none",
    required: x = !1,
    size: S = "medium",
    variant: _ = "outlined",
    ...C
  } = i, R = {
    ...i,
    color: l,
    component: c,
    disabled: d,
    error: f,
    fullWidth: y,
    hiddenLabel: b,
    margin: v,
    required: x,
    size: S,
    variant: _
  }, w = U5(R), [E, P] = O.useState(() => {
    let Q = !1;
    return s && O.Children.forEach(s, (B) => {
      if (!em(B, ["Input", "Select"]))
        return;
      const I = em(B, ["Select"]) ? B.props.input : B;
      I && H4(I.props) && (Q = !0);
    }), Q;
  }), [k, G] = O.useState(() => {
    let Q = !1;
    return s && O.Children.forEach(s, (B) => {
      em(B, ["Input", "Select"]) && (bh(B.props, !0) || bh(B.props.inputProps, !0)) && (Q = !0);
    }), Q;
  }), [$, F] = O.useState(!1);
  d && $ && F(!1);
  const j = m !== void 0 && !d ? m : $;
  let H;
  O.useRef(!1);
  const M = O.useCallback(() => {
    G(!0);
  }, []), Y = O.useCallback(() => {
    G(!1);
  }, []), L = O.useMemo(() => ({
    adornedStart: E,
    setAdornedStart: P,
    color: l,
    disabled: d,
    error: f,
    filled: k,
    focused: j,
    fullWidth: y,
    hiddenLabel: b,
    size: S,
    onBlur: () => {
      F(!1);
    },
    onFocus: () => {
      F(!0);
    },
    onEmpty: Y,
    onFilled: M,
    registerEffect: H,
    required: x,
    variant: _
  }), [E, l, d, f, k, j, y, b, H, Y, M, x, S, _]);
  return /* @__PURE__ */ et.jsx(iy.Provider, {
    value: L,
    children: /* @__PURE__ */ et.jsx(N5, {
      as: c,
      ownerState: R,
      className: Lt(w.root, o),
      ref: e,
      ...C,
      children: s
    })
  });
});
function z5(n) {
  return Be("MuiFormHelperText", n);
}
const DS = ke("MuiFormHelperText", ["root", "error", "disabled", "sizeSmall", "sizeMedium", "contained", "focused", "filled", "required"]);
var GS;
const L5 = (n) => {
  const {
    classes: t,
    contained: e,
    size: i,
    disabled: s,
    error: o,
    filled: l,
    focused: c,
    required: d
  } = n, f = {
    root: ["root", s && "disabled", o && "error", i && `size${St(i)}`, e && "contained", c && "focused", l && "filled", d && "required"]
  };
  return Oe(f, z5, t);
}, F5 = vt("p", {
  name: "MuiFormHelperText",
  slot: "Root",
  overridesResolver: (n, t) => {
    const {
      ownerState: e
    } = n;
    return [t.root, e.size && t[`size${St(e.size)}`], e.contained && t.contained, e.filled && t.filled];
  }
})(Te(({
  theme: n
}) => ({
  color: (n.vars || n).palette.text.secondary,
  ...n.typography.caption,
  textAlign: "left",
  marginTop: 3,
  marginRight: 0,
  marginBottom: 0,
  marginLeft: 0,
  [`&.${DS.disabled}`]: {
    color: (n.vars || n).palette.text.disabled
  },
  [`&.${DS.error}`]: {
    color: (n.vars || n).palette.error.main
  },
  variants: [{
    props: {
      size: "small"
    },
    style: {
      marginTop: 4
    }
  }, {
    props: ({
      ownerState: t
    }) => t.contained,
    style: {
      marginLeft: 14,
      marginRight: 14
    }
  }]
}))), H5 = /* @__PURE__ */ O.forwardRef(function(t, e) {
  const i = Ne({
    props: t,
    name: "MuiFormHelperText"
  }), {
    children: s,
    className: o,
    component: l = "p",
    disabled: c,
    error: d,
    filled: f,
    focused: m,
    margin: y,
    required: b,
    variant: v,
    ...x
  } = i, S = ro(), _ = io({
    props: i,
    muiFormControl: S,
    states: ["variant", "size", "disabled", "error", "filled", "focused", "required"]
  }), C = {
    ...i,
    component: l,
    contained: _.variant === "filled" || _.variant === "outlined",
    variant: _.variant,
    size: _.size,
    disabled: _.disabled,
    error: _.error,
    filled: _.filled,
    focused: _.focused,
    required: _.required
  };
  delete C.ownerState;
  const R = L5(C);
  return /* @__PURE__ */ et.jsx(F5, {
    as: l,
    className: Lt(R.root, o),
    ref: e,
    ...x,
    ownerState: C,
    children: s === " " ? (
      // notranslate needed while Google Translate will not fix zero-width space issue
      GS || (GS = /* @__PURE__ */ et.jsx("span", {
        className: "notranslate",
        "aria-hidden": !0,
        children: ""
      }))
    ) : s
  });
});
function $5(n) {
  return Be("MuiFormLabel", n);
}
const Dl = ke("MuiFormLabel", ["root", "colorSecondary", "focused", "disabled", "error", "filled", "required", "asterisk"]), W5 = (n) => {
  const {
    classes: t,
    color: e,
    focused: i,
    disabled: s,
    error: o,
    filled: l,
    required: c
  } = n, d = {
    root: ["root", `color${St(e)}`, s && "disabled", o && "error", l && "filled", i && "focused", c && "required"],
    asterisk: ["asterisk", o && "error"]
  };
  return Oe(d, $5, t);
}, V5 = vt("label", {
  name: "MuiFormLabel",
  slot: "Root",
  overridesResolver: (n, t) => {
    const {
      ownerState: e
    } = n;
    return [t.root, e.color === "secondary" && t.colorSecondary, e.filled && t.filled];
  }
})(Te(({
  theme: n
}) => ({
  color: (n.vars || n).palette.text.secondary,
  ...n.typography.body1,
  lineHeight: "1.4375em",
  padding: 0,
  position: "relative",
  variants: [...Object.entries(n.palette).filter(Ci()).map(([t]) => ({
    props: {
      color: t
    },
    style: {
      [`&.${Dl.focused}`]: {
        color: (n.vars || n).palette[t].main
      }
    }
  })), {
    props: {},
    style: {
      [`&.${Dl.disabled}`]: {
        color: (n.vars || n).palette.text.disabled
      },
      [`&.${Dl.error}`]: {
        color: (n.vars || n).palette.error.main
      }
    }
  }]
}))), j5 = vt("span", {
  name: "MuiFormLabel",
  slot: "Asterisk"
})(Te(({
  theme: n
}) => ({
  [`&.${Dl.error}`]: {
    color: (n.vars || n).palette.error.main
  }
}))), Y5 = /* @__PURE__ */ O.forwardRef(function(t, e) {
  const i = Ne({
    props: t,
    name: "MuiFormLabel"
  }), {
    children: s,
    className: o,
    color: l,
    component: c = "label",
    disabled: d,
    error: f,
    filled: m,
    focused: y,
    required: b,
    ...v
  } = i, x = ro(), S = io({
    props: i,
    muiFormControl: x,
    states: ["color", "required", "focused", "disabled", "error", "filled"]
  }), _ = {
    ...i,
    color: S.color || "primary",
    component: c,
    disabled: S.disabled,
    error: S.error,
    filled: S.filled,
    focused: S.focused,
    required: S.required
  }, C = W5(_);
  return /* @__PURE__ */ et.jsxs(V5, {
    as: c,
    ownerState: _,
    className: Lt(C.root, o),
    ref: e,
    ...v,
    children: [s, S.required && /* @__PURE__ */ et.jsxs(j5, {
      ownerState: _,
      "aria-hidden": !0,
      className: C.asterisk,
      children: ["", "*"]
    })]
  });
});
function Xm(n) {
  return `scale(${n}, ${n ** 2})`;
}
const X5 = {
  entering: {
    opacity: 1,
    transform: Xm(1)
  },
  entered: {
    opacity: 1,
    transform: "none"
  }
}, rm = typeof navigator < "u" && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent), qm = /* @__PURE__ */ O.forwardRef(function(t, e) {
  const {
    addEndListener: i,
    appear: s = !0,
    children: o,
    easing: l,
    in: c,
    onEnter: d,
    onEntered: f,
    onEntering: m,
    onExit: y,
    onExited: b,
    onExiting: v,
    style: x,
    timeout: S = "auto",
    // eslint-disable-next-line react/prop-types
    TransitionComponent: _ = Wi,
    ...C
  } = t, R = $C(), w = O.useRef(), E = Jg(), P = O.useRef(null), k = Bn(P, au(o), e), G = (Q) => (B) => {
    if (Q) {
      const I = P.current;
      B === void 0 ? Q(I) : Q(I, B);
    }
  }, $ = G(m), F = G((Q, B) => {
    WC(Q);
    const {
      duration: I,
      delay: rt,
      easing: J
    } = mh({
      style: x,
      timeout: S,
      easing: l
    }, {
      mode: "enter"
    });
    let D;
    S === "auto" ? (D = E.transitions.getAutoHeightDuration(Q.clientHeight), w.current = D) : D = I, Q.style.transition = [E.transitions.create("opacity", {
      duration: D,
      delay: rt
    }), E.transitions.create("transform", {
      duration: rm ? D : D * 0.666,
      delay: rt,
      easing: J
    })].join(","), d && d(Q, B);
  }), j = G(f), H = G(v), M = G((Q) => {
    const {
      duration: B,
      delay: I,
      easing: rt
    } = mh({
      style: x,
      timeout: S,
      easing: l
    }, {
      mode: "exit"
    });
    let J;
    S === "auto" ? (J = E.transitions.getAutoHeightDuration(Q.clientHeight), w.current = J) : J = B, Q.style.transition = [E.transitions.create("opacity", {
      duration: J,
      delay: I
    }), E.transitions.create("transform", {
      duration: rm ? J : J * 0.666,
      delay: rm ? I : I || J * 0.333,
      easing: rt
    })].join(","), Q.style.opacity = 0, Q.style.transform = Xm(0.75), y && y(Q);
  }), Y = G(b), L = (Q) => {
    S === "auto" && R.start(w.current || 0, Q), i && i(P.current, Q);
  };
  return /* @__PURE__ */ et.jsx(_, {
    appear: s,
    in: c,
    nodeRef: P,
    onEnter: F,
    onEntered: j,
    onEntering: $,
    onExit: M,
    onExited: Y,
    onExiting: H,
    addEndListener: L,
    timeout: S === "auto" ? null : S,
    ...C,
    children: (Q, {
      ownerState: B,
      ...I
    }) => /* @__PURE__ */ O.cloneElement(o, {
      style: {
        opacity: 0,
        transform: Xm(0.75),
        visibility: Q === "exited" && !c ? "hidden" : void 0,
        ...X5[Q],
        ...x,
        ...o.props.style
      },
      ref: k,
      ...I
    })
  });
});
qm && (qm.muiSupportAuto = !0);
const q5 = (n) => {
  const {
    classes: t,
    disableUnderline: e
  } = n, s = Oe({
    root: ["root", !e && "underline"],
    input: ["input"]
  }, V4, t);
  return {
    ...t,
    // forward classes to the InputBase
    ...s
  };
}, K5 = vt(Vh, {
  shouldForwardProp: (n) => Mi(n) || n === "classes",
  name: "MuiInput",
  slot: "Root",
  overridesResolver: (n, t) => {
    const {
      ownerState: e
    } = n;
    return [...$h(n, t), !e.disableUnderline && t.underline];
  }
})(Te(({
  theme: n
}) => {
  let e = n.palette.mode === "light" ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
  return n.vars && (e = n.alpha(n.vars.palette.common.onBackground, n.vars.opacity.inputUnderline)), {
    position: "relative",
    variants: [{
      props: ({
        ownerState: i
      }) => i.formControl,
      style: {
        "label + &": {
          marginTop: 16
        }
      }
    }, {
      props: ({
        ownerState: i
      }) => !i.disableUnderline,
      style: {
        "&::after": {
          left: 0,
          bottom: 0,
          content: '""',
          position: "absolute",
          right: 0,
          transform: "scaleX(0)",
          transition: n.transitions.create("transform", {
            duration: n.transitions.duration.shorter,
            easing: n.transitions.easing.easeOut
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&.${fl.focused}:after`]: {
          // translateX(0) is a workaround for Safari transform scale bug
          // See https://github.com/mui/material-ui/issues/31766
          transform: "scaleX(1) translateX(0)"
        },
        [`&.${fl.error}`]: {
          "&::before, &::after": {
            borderBottomColor: (n.vars || n).palette.error.main
          }
        },
        "&::before": {
          borderBottom: `1px solid ${e}`,
          left: 0,
          bottom: 0,
          content: '"\\00a0"',
          position: "absolute",
          right: 0,
          transition: n.transitions.create("border-bottom-color", {
            duration: n.transitions.duration.shorter
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&:hover:not(.${fl.disabled}, .${fl.error}):before`]: {
          borderBottom: `2px solid ${(n.vars || n).palette.text.primary}`,
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            borderBottom: `1px solid ${e}`
          }
        },
        [`&.${fl.disabled}:before`]: {
          borderBottomStyle: "dotted"
        }
      }
    }, ...Object.entries(n.palette).filter(Ci()).map(([i]) => ({
      props: {
        color: i,
        disableUnderline: !1
      },
      style: {
        "&::after": {
          borderBottom: `2px solid ${(n.vars || n).palette[i].main}`
        }
      }
    }))]
  };
})), Z5 = vt(jh, {
  name: "MuiInput",
  slot: "Input",
  overridesResolver: Wh
})({}), ay = /* @__PURE__ */ O.forwardRef(function(t, e) {
  const i = Ne({
    props: t,
    name: "MuiInput"
  }), {
    disableUnderline: s = !1,
    components: o = {},
    componentsProps: l,
    fullWidth: c = !1,
    inputComponent: d = "input",
    multiline: f = !1,
    slotProps: m,
    slots: y = {},
    type: b = "text",
    ...v
  } = i, x = q5(i), _ = {
    root: {
      ownerState: {
        disableUnderline: s
      }
    }
  }, C = m ?? l ? wn(m ?? l, _) : _, R = y.root ?? o.Root ?? K5, w = y.input ?? o.Input ?? Z5;
  return /* @__PURE__ */ et.jsx(ry, {
    slots: {
      root: R,
      input: w
    },
    slotProps: C,
    fullWidth: c,
    inputComponent: d,
    multiline: f,
    ref: e,
    type: b,
    ...v,
    classes: x
  });
});
ay.muiName = "Input";
function Q5(n) {
  return Be("MuiInputLabel", n);
}
ke("MuiInputLabel", ["root", "focused", "disabled", "error", "required", "asterisk", "formControl", "sizeSmall", "shrink", "animated", "standard", "filled", "outlined"]);
const J5 = (n) => {
  const {
    classes: t,
    formControl: e,
    size: i,
    shrink: s,
    disableAnimation: o,
    variant: l,
    required: c
  } = n, d = {
    root: ["root", e && "formControl", !o && "animated", s && "shrink", i && i !== "medium" && `size${St(i)}`, l],
    asterisk: [c && "asterisk"]
  }, f = Oe(d, Q5, t);
  return {
    ...t,
    // forward the focused, disabled, etc. classes to the FormLabel
    ...f
  };
}, tN = vt(Y5, {
  shouldForwardProp: (n) => Mi(n) || n === "classes",
  name: "MuiInputLabel",
  slot: "Root",
  overridesResolver: (n, t) => {
    const {
      ownerState: e
    } = n;
    return [{
      [`& .${Dl.asterisk}`]: t.asterisk
    }, t.root, e.formControl && t.formControl, e.size === "small" && t.sizeSmall, e.shrink && t.shrink, !e.disableAnimation && t.animated, e.focused && t.focused, t[e.variant]];
  }
})(Te(({
  theme: n
}) => ({
  display: "block",
  transformOrigin: "top left",
  whiteSpace: "nowrap",
  overflow: "hidden",
  textOverflow: "ellipsis",
  maxWidth: "100%",
  variants: [{
    props: ({
      ownerState: t
    }) => t.formControl,
    style: {
      position: "absolute",
      left: 0,
      top: 0,
      // slight alteration to spec spacing to match visual spec result
      transform: "translate(0, 20px) scale(1)"
    }
  }, {
    props: {
      size: "small"
    },
    style: {
      // Compensation for the `Input.inputSizeSmall` style.
      transform: "translate(0, 17px) scale(1)"
    }
  }, {
    props: ({
      ownerState: t
    }) => t.shrink,
    style: {
      transform: "translate(0, -1.5px) scale(0.75)",
      transformOrigin: "top left",
      maxWidth: "133%"
    }
  }, {
    props: ({
      ownerState: t
    }) => !t.disableAnimation,
    style: {
      transition: n.transitions.create(["color", "transform", "max-width"], {
        duration: n.transitions.duration.shorter,
        easing: n.transitions.easing.easeOut
      })
    }
  }, {
    props: {
      variant: "filled"
    },
    style: {
      // Chrome's autofill feature gives the input field a yellow background.
      // Since the input field is behind the label in the HTML tree,
      // the input field is drawn last and hides the label with an opaque background color.
      // zIndex: 1 will raise the label above opaque background-colors of input.
      zIndex: 1,
      pointerEvents: "none",
      transform: "translate(12px, 16px) scale(1)",
      maxWidth: "calc(100% - 24px)"
    }
  }, {
    props: {
      variant: "filled",
      size: "small"
    },
    style: {
      transform: "translate(12px, 13px) scale(1)"
    }
  }, {
    props: ({
      variant: t,
      ownerState: e
    }) => t === "filled" && e.shrink,
    style: {
      userSelect: "none",
      pointerEvents: "auto",
      transform: "translate(12px, 7px) scale(0.75)",
      maxWidth: "calc(133% - 24px)"
    }
  }, {
    props: ({
      variant: t,
      ownerState: e,
      size: i
    }) => t === "filled" && e.shrink && i === "small",
    style: {
      transform: "translate(12px, 4px) scale(0.75)"
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      // see comment above on filled.zIndex
      zIndex: 1,
      pointerEvents: "none",
      transform: "translate(14px, 16px) scale(1)",
      maxWidth: "calc(100% - 24px)"
    }
  }, {
    props: {
      variant: "outlined",
      size: "small"
    },
    style: {
      transform: "translate(14px, 9px) scale(1)"
    }
  }, {
    props: ({
      variant: t,
      ownerState: e
    }) => t === "outlined" && e.shrink,
    style: {
      userSelect: "none",
      pointerEvents: "auto",
      // Theoretically, we should have (8+5)*2/0.75 = 34px
      // but it feels a better when it bleeds a bit on the left, so 32px.
      maxWidth: "calc(133% - 32px)",
      transform: "translate(14px, -9px) scale(0.75)"
    }
  }]
}))), eN = /* @__PURE__ */ O.forwardRef(function(t, e) {
  const i = Ne({
    name: "MuiInputLabel",
    props: t
  }), {
    disableAnimation: s = !1,
    margin: o,
    shrink: l,
    variant: c,
    className: d,
    ...f
  } = i, m = ro();
  let y = l;
  typeof y > "u" && m && (y = m.filled || m.focused || m.adornedStart);
  const b = io({
    props: i,
    muiFormControl: m,
    states: ["size", "variant", "required", "focused"]
  }), v = {
    ...i,
    disableAnimation: s,
    formControl: m,
    shrink: y,
    size: b.size,
    variant: b.variant,
    required: b.required,
    focused: b.focused
  }, x = J5(v);
  return /* @__PURE__ */ et.jsx(tN, {
    "data-shrink": y,
    ref: e,
    className: Lt(x.root, d),
    ...f,
    ownerState: v,
    classes: x
  });
}), nN = /* @__PURE__ */ O.createContext({});
function iN(n) {
  return Be("MuiList", n);
}
ke("MuiList", ["root", "padding", "dense", "subheader"]);
const rN = (n) => {
  const {
    classes: t,
    disablePadding: e,
    dense: i,
    subheader: s
  } = n;
  return Oe({
    root: ["root", !e && "padding", i && "dense", s && "subheader"]
  }, iN, t);
}, sN = vt("ul", {
  name: "MuiList",
  slot: "Root",
  overridesResolver: (n, t) => {
    const {
      ownerState: e
    } = n;
    return [t.root, !e.disablePadding && t.padding, e.dense && t.dense, e.subheader && t.subheader];
  }
})({
  listStyle: "none",
  margin: 0,
  padding: 0,
  position: "relative",
  variants: [{
    props: ({
      ownerState: n
    }) => !n.disablePadding,
    style: {
      paddingTop: 8,
      paddingBottom: 8
    }
  }, {
    props: ({
      ownerState: n
    }) => n.subheader,
    style: {
      paddingTop: 0
    }
  }]
}), aN = /* @__PURE__ */ O.forwardRef(function(t, e) {
  const i = Ne({
    props: t,
    name: "MuiList"
  }), {
    children: s,
    className: o,
    component: l = "ul",
    dense: c = !1,
    disablePadding: d = !1,
    subheader: f,
    ...m
  } = i, y = O.useMemo(() => ({
    dense: c
  }), [c]), b = {
    ...i,
    component: l,
    dense: c,
    disablePadding: d
  }, v = rN(b);
  return /* @__PURE__ */ et.jsx(nN.Provider, {
    value: y,
    children: /* @__PURE__ */ et.jsxs(sN, {
      as: l,
      className: Lt(v.root, o),
      ref: e,
      ownerState: b,
      ...m,
      children: [f, s]
    })
  });
});
function sm(n, t, e) {
  return n === t ? n.firstChild : t && t.nextElementSibling ? t.nextElementSibling : e ? null : n.firstChild;
}
function US(n, t, e) {
  return n === t ? e ? n.firstChild : n.lastChild : t && t.previousElementSibling ? t.previousElementSibling : e ? null : n.lastChild;
}
function QC(n, t) {
  if (t === void 0)
    return !0;
  let e = n.innerText;
  return e === void 0 && (e = n.textContent), e = e.trim().toLowerCase(), e.length === 0 ? !1 : t.repeating ? e[0] === t.keys[0] : e.startsWith(t.keys.join(""));
}
function ml(n, t, e, i, s, o) {
  let l = !1, c = s(n, t, t ? e : !1);
  for (; c; ) {
    if (c === n.firstChild) {
      if (l)
        return !1;
      l = !0;
    }
    const d = i ? !1 : c.disabled || c.getAttribute("aria-disabled") === "true";
    if (!c.hasAttribute("tabindex") || !QC(c, o) || d)
      c = s(n, c, e);
    else
      return c.focus(), !0;
  }
  return !1;
}
const oN = /* @__PURE__ */ O.forwardRef(function(t, e) {
  const {
    // private
    // eslint-disable-next-line react/prop-types
    actions: i,
    autoFocus: s = !1,
    autoFocusItem: o = !1,
    children: l,
    className: c,
    disabledItemsFocusable: d = !1,
    disableListWrap: f = !1,
    onKeyDown: m,
    variant: y = "selectedMenu",
    ...b
  } = t, v = O.useRef(null), x = O.useRef({
    keys: [],
    repeating: !0,
    previousKeyMatched: !0,
    lastTime: null
  });
  ts(() => {
    s && v.current.focus();
  }, [s]), O.useImperativeHandle(i, () => ({
    adjustStyleForScrollbar: (w, {
      direction: E
    }) => {
      const P = !v.current.style.width;
      if (w.clientHeight < v.current.clientHeight && P) {
        const k = `${ZC(Tr(w))}px`;
        v.current.style[E === "rtl" ? "paddingLeft" : "paddingRight"] = k, v.current.style.width = `calc(100% + ${k})`;
      }
      return v.current;
    }
  }), []);
  const S = (w) => {
    const E = v.current, P = w.key;
    if (w.ctrlKey || w.metaKey || w.altKey) {
      m && m(w);
      return;
    }
    const G = An(E).activeElement;
    if (P === "ArrowDown")
      w.preventDefault(), ml(E, G, f, d, sm);
    else if (P === "ArrowUp")
      w.preventDefault(), ml(E, G, f, d, US);
    else if (P === "Home")
      w.preventDefault(), ml(E, null, f, d, sm);
    else if (P === "End")
      w.preventDefault(), ml(E, null, f, d, US);
    else if (P.length === 1) {
      const $ = x.current, F = P.toLowerCase(), j = performance.now();
      $.keys.length > 0 && (j - $.lastTime > 500 ? ($.keys = [], $.repeating = !0, $.previousKeyMatched = !0) : $.repeating && F !== $.keys[0] && ($.repeating = !1)), $.lastTime = j, $.keys.push(F);
      const H = G && !$.repeating && QC(G, $);
      $.previousKeyMatched && (H || ml(E, G, !1, d, sm, $)) ? w.preventDefault() : $.previousKeyMatched = !1;
    }
    m && m(w);
  }, _ = Bn(v, e);
  let C = -1;
  O.Children.forEach(l, (w, E) => {
    if (!/* @__PURE__ */ O.isValidElement(w)) {
      C === E && (C += 1, C >= l.length && (C = -1));
      return;
    }
    w.props.disabled || (y === "selectedMenu" && w.props.selected || C === -1) && (C = E), C === E && (w.props.disabled || w.props.muiSkipListHighlight || w.type.muiSkipListHighlight) && (C += 1, C >= l.length && (C = -1));
  });
  const R = O.Children.map(l, (w, E) => {
    if (E === C) {
      const P = {};
      return o && (P.autoFocus = !0), w.props.tabIndex === void 0 && y === "selectedMenu" && (P.tabIndex = 0), /* @__PURE__ */ O.cloneElement(w, P);
    }
    return w;
  });
  return /* @__PURE__ */ et.jsx(aN, {
    role: "menu",
    ref: _,
    className: c,
    onKeyDown: S,
    tabIndex: s ? 0 : -1,
    ...b,
    children: R
  });
});
function lN(n) {
  return Be("MuiPopover", n);
}
ke("MuiPopover", ["root", "paper"]);
function NS(n, t) {
  let e = 0;
  return typeof t == "number" ? e = t : t === "center" ? e = n.height / 2 : t === "bottom" && (e = n.height), e;
}
function IS(n, t) {
  let e = 0;
  return typeof t == "number" ? e = t : t === "center" ? e = n.width / 2 : t === "right" && (e = n.width), e;
}
function zS(n) {
  return [n.horizontal, n.vertical].map((t) => typeof t == "number" ? `${t}px` : t).join(" ");
}
function Fc(n) {
  return typeof n == "function" ? n() : n;
}
const uN = (n) => {
  const {
    classes: t
  } = n;
  return Oe({
    root: ["root"],
    paper: ["paper"]
  }, lN, t);
}, cN = vt(B5, {
  name: "MuiPopover",
  slot: "Root"
})({}), JC = vt(c4, {
  name: "MuiPopover",
  slot: "Paper"
})({
  position: "absolute",
  overflowY: "auto",
  overflowX: "hidden",
  // So we see the popover when it's empty.
  // It's most likely on issue on userland.
  minWidth: 16,
  minHeight: 16,
  maxWidth: "calc(100% - 32px)",
  maxHeight: "calc(100% - 32px)",
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
}), hN = /* @__PURE__ */ O.forwardRef(function(t, e) {
  const i = Ne({
    props: t,
    name: "MuiPopover"
  }), {
    action: s,
    anchorEl: o,
    anchorOrigin: l = {
      vertical: "top",
      horizontal: "left"
    },
    anchorPosition: c,
    anchorReference: d = "anchorEl",
    children: f,
    className: m,
    container: y,
    elevation: b = 8,
    marginThreshold: v = 16,
    open: x,
    PaperProps: S = {},
    // TODO: remove in v7
    slots: _ = {},
    slotProps: C = {},
    transformOrigin: R = {
      vertical: "top",
      horizontal: "left"
    },
    TransitionComponent: w,
    // TODO: remove in v7
    transitionDuration: E = "auto",
    TransitionProps: P = {},
    // TODO: remove in v7
    disableScrollLock: k = !1,
    ...G
  } = i, $ = O.useRef(), F = {
    ...i,
    anchorOrigin: l,
    anchorReference: d,
    elevation: b,
    marginThreshold: v,
    transformOrigin: R,
    TransitionComponent: w,
    transitionDuration: E,
    TransitionProps: P
  }, j = uN(F), H = O.useCallback(() => {
    if (d === "anchorPosition")
      return c;
    const gt = Fc(o), Et = (gt && gt.nodeType === 1 ? gt : An($.current).body).getBoundingClientRect();
    return {
      top: Et.top + NS(Et, l.vertical),
      left: Et.left + IS(Et, l.horizontal)
    };
  }, [o, l.horizontal, l.vertical, c, d]), M = O.useCallback((gt) => ({
    vertical: NS(gt, R.vertical),
    horizontal: IS(gt, R.horizontal)
  }), [R.horizontal, R.vertical]), Y = O.useCallback((gt) => {
    const Pt = {
      width: gt.offsetWidth,
      height: gt.offsetHeight
    }, Et = M(Pt);
    if (d === "none")
      return {
        top: null,
        left: null,
        transformOrigin: zS(Et)
      };
    const It = H();
    let wt = It.top - Et.vertical, Yt = It.left - Et.horizontal;
    const Ie = wt + Pt.height, Gt = Yt + Pt.width, pe = Tr(Fc(o)), Je = pe.innerHeight - v, De = pe.innerWidth - v;
    if (v !== null && wt < v) {
      const le = wt - v;
      wt -= le, Et.vertical += le;
    } else if (v !== null && Ie > Je) {
      const le = Ie - Je;
      wt -= le, Et.vertical += le;
    }
    if (v !== null && Yt < v) {
      const le = Yt - v;
      Yt -= le, Et.horizontal += le;
    } else if (Gt > De) {
      const le = Gt - De;
      Yt -= le, Et.horizontal += le;
    }
    return {
      top: `${Math.round(wt)}px`,
      left: `${Math.round(Yt)}px`,
      transformOrigin: zS(Et)
    };
  }, [o, d, H, M, v]), [L, Q] = O.useState(x), B = O.useCallback(() => {
    const gt = $.current;
    if (!gt)
      return;
    const Pt = Y(gt);
    Pt.top !== null && gt.style.setProperty("top", Pt.top), Pt.left !== null && (gt.style.left = Pt.left), gt.style.transformOrigin = Pt.transformOrigin, Q(!0);
  }, [Y]);
  O.useEffect(() => (k && window.addEventListener("scroll", B), () => window.removeEventListener("scroll", B)), [o, k, B]);
  const I = () => {
    B();
  }, rt = () => {
    Q(!1);
  };
  O.useEffect(() => {
    x && B();
  }), O.useImperativeHandle(s, () => x ? {
    updatePosition: () => {
      B();
    }
  } : null, [x, B]), O.useEffect(() => {
    if (!x)
      return;
    const gt = IC(() => {
      B();
    }), Pt = Tr(Fc(o));
    return Pt.addEventListener("resize", gt), () => {
      gt.clear(), Pt.removeEventListener("resize", gt);
    };
  }, [o, x, B]);
  let J = E;
  const D = {
    slots: {
      transition: w,
      ..._
    },
    slotProps: {
      transition: P,
      paper: S,
      ...C
    }
  }, [q, ot] = Tn("transition", {
    elementType: qm,
    externalForwardedProps: D,
    ownerState: F,
    getSlotProps: (gt) => ({
      ...gt,
      onEntering: (Pt, Et) => {
        gt.onEntering?.(Pt, Et), I();
      },
      onExited: (Pt) => {
        gt.onExited?.(Pt), rt();
      }
    }),
    additionalProps: {
      appear: !0,
      in: x
    }
  });
  E === "auto" && !q.muiSupportAuto && (J = void 0);
  const at = y || (o ? An(Fc(o)).body : void 0), [lt, {
    slots: dt,
    slotProps: ht,
    ...Vt
  }] = Tn("root", {
    ref: e,
    elementType: cN,
    externalForwardedProps: {
      ...D,
      ...G
    },
    shouldForwardComponentProp: !0,
    additionalProps: {
      slots: {
        backdrop: _.backdrop
      },
      slotProps: {
        backdrop: ZU(typeof C.backdrop == "function" ? C.backdrop(F) : C.backdrop, {
          invisible: !0
        })
      },
      container: at,
      open: x
    },
    ownerState: F,
    className: Lt(j.root, m)
  }), [Rt, Dt] = Tn("paper", {
    ref: $,
    className: j.paper,
    elementType: JC,
    externalForwardedProps: D,
    shouldForwardComponentProp: !0,
    additionalProps: {
      elevation: b,
      style: L ? void 0 : {
        opacity: 0
      }
    },
    ownerState: F
  });
  return /* @__PURE__ */ et.jsx(lt, {
    ...Vt,
    ...!Zr(lt) && {
      slots: dt,
      slotProps: ht,
      disableScrollLock: k
    },
    children: /* @__PURE__ */ et.jsx(q, {
      ...ot,
      timeout: J,
      children: /* @__PURE__ */ et.jsx(Rt, {
        ...Dt,
        children: f
      })
    })
  });
});
function dN(n) {
  return Be("MuiMenu", n);
}
ke("MuiMenu", ["root", "paper", "list"]);
const fN = {
  vertical: "top",
  horizontal: "right"
}, pN = {
  vertical: "top",
  horizontal: "left"
}, mN = (n) => {
  const {
    classes: t
  } = n;
  return Oe({
    root: ["root"],
    paper: ["paper"],
    list: ["list"]
  }, dN, t);
}, gN = vt(hN, {
  shouldForwardProp: (n) => Mi(n) || n === "classes",
  name: "MuiMenu",
  slot: "Root"
})({}), yN = vt(JC, {
  name: "MuiMenu",
  slot: "Paper"
})({
  // specZ: The maximum height of a simple menu should be one or more rows less than the view
  // height. This ensures a tappable area outside of the simple menu with which to dismiss
  // the menu.
  maxHeight: "calc(100% - 96px)",
  // Add iOS momentum scrolling for iOS < 13.0
  WebkitOverflowScrolling: "touch"
}), bN = vt(oN, {
  name: "MuiMenu",
  slot: "List"
})({
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
}), vN = /* @__PURE__ */ O.forwardRef(function(t, e) {
  const i = Ne({
    props: t,
    name: "MuiMenu"
  }), {
    autoFocus: s = !0,
    children: o,
    className: l,
    disableAutoFocusItem: c = !1,
    MenuListProps: d = {},
    onClose: f,
    open: m,
    PaperProps: y = {},
    PopoverClasses: b,
    transitionDuration: v = "auto",
    TransitionProps: {
      onEntering: x,
      ...S
    } = {},
    variant: _ = "selectedMenu",
    slots: C = {},
    slotProps: R = {},
    ...w
  } = i, E = BC(), P = {
    ...i,
    autoFocus: s,
    disableAutoFocusItem: c,
    MenuListProps: d,
    onEntering: x,
    PaperProps: y,
    transitionDuration: v,
    TransitionProps: S,
    variant: _
  }, k = mN(P), G = s && !c && m, $ = O.useRef(null), F = (J, D) => {
    $.current && $.current.adjustStyleForScrollbar(J, {
      direction: E ? "rtl" : "ltr"
    }), x && x(J, D);
  }, j = (J) => {
    J.key === "Tab" && (J.preventDefault(), f && f(J, "tabKeyDown"));
  };
  let H = -1;
  O.Children.map(o, (J, D) => {
    /* @__PURE__ */ O.isValidElement(J) && (J.props.disabled || (_ === "selectedMenu" && J.props.selected || H === -1) && (H = D));
  });
  const M = {
    slots: C,
    slotProps: {
      list: d,
      transition: S,
      paper: y,
      ...R
    }
  }, Y = hr({
    elementType: C.root,
    externalSlotProps: R.root,
    ownerState: P,
    className: [k.root, l]
  }), [L, Q] = Tn("paper", {
    className: k.paper,
    elementType: yN,
    externalForwardedProps: M,
    shouldForwardComponentProp: !0,
    ownerState: P
  }), [B, I] = Tn("list", {
    className: Lt(k.list, d.className),
    elementType: bN,
    shouldForwardComponentProp: !0,
    externalForwardedProps: M,
    getSlotProps: (J) => ({
      ...J,
      onKeyDown: (D) => {
        j(D), J.onKeyDown?.(D);
      }
    }),
    ownerState: P
  }), rt = typeof M.slotProps.transition == "function" ? M.slotProps.transition(P) : M.slotProps.transition;
  return /* @__PURE__ */ et.jsx(gN, {
    onClose: f,
    anchorOrigin: {
      vertical: "bottom",
      horizontal: E ? "right" : "left"
    },
    transformOrigin: E ? fN : pN,
    slots: {
      root: C.root,
      paper: L,
      backdrop: C.backdrop,
      ...C.transition && {
        // TODO: pass `slots.transition` directly once `TransitionComponent` is removed from Popover
        transition: C.transition
      }
    },
    slotProps: {
      root: Y,
      paper: Q,
      backdrop: typeof R.backdrop == "function" ? R.backdrop(P) : R.backdrop,
      transition: {
        ...rt,
        onEntering: (...J) => {
          F(...J), rt?.onEntering?.(...J);
        }
      }
    },
    open: m,
    ref: e,
    transitionDuration: v,
    ownerState: P,
    ...w,
    classes: b,
    children: /* @__PURE__ */ et.jsx(B, {
      actions: $,
      autoFocus: s && (H === -1 || c),
      autoFocusItem: G,
      variant: _,
      ...I,
      children: o
    })
  });
});
function xN(n) {
  return Be("MuiNativeSelect", n);
}
const oy = ke("MuiNativeSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]), _N = (n) => {
  const {
    classes: t,
    variant: e,
    disabled: i,
    multiple: s,
    open: o,
    error: l
  } = n, c = {
    select: ["select", e, i && "disabled", s && "multiple", l && "error"],
    icon: ["icon", `icon${St(e)}`, o && "iconOpen", i && "disabled"]
  };
  return Oe(c, xN, t);
}, tE = vt("select", {
  name: "MuiNativeSelect"
})(({
  theme: n
}) => ({
  // Reset
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // When interacting quickly, the text can end up selected.
  // Native select can't be selected either.
  userSelect: "none",
  // Reset
  borderRadius: 0,
  cursor: "pointer",
  "&:focus": {
    // Reset Chrome style
    borderRadius: 0
  },
  [`&.${oy.disabled}`]: {
    cursor: "default"
  },
  "&[multiple]": {
    height: "auto"
  },
  "&:not([multiple]) option, &:not([multiple]) optgroup": {
    backgroundColor: (n.vars || n).palette.background.paper
  },
  variants: [{
    props: ({
      ownerState: t
    }) => t.variant !== "filled" && t.variant !== "outlined",
    style: {
      // Bump specificity to allow extending custom inputs
      "&&&": {
        paddingRight: 24,
        minWidth: 16
        // So it doesn't collapse.
      }
    }
  }, {
    props: {
      variant: "filled"
    },
    style: {
      "&&&": {
        paddingRight: 32
      }
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      borderRadius: (n.vars || n).shape.borderRadius,
      "&:focus": {
        borderRadius: (n.vars || n).shape.borderRadius
        // Reset the reset for Chrome style
      },
      "&&&": {
        paddingRight: 32
      }
    }
  }]
})), SN = vt(tE, {
  name: "MuiNativeSelect",
  slot: "Select",
  shouldForwardProp: Mi,
  overridesResolver: (n, t) => {
    const {
      ownerState: e
    } = n;
    return [t.select, t[e.variant], e.error && t.error, {
      [`&.${oy.multiple}`]: t.multiple
    }];
  }
})({}), eE = vt("svg", {
  name: "MuiNativeSelect"
})(({
  theme: n
}) => ({
  // We use a position absolute over a flexbox in order to forward the pointer events
  // to the input and to support wrapping tags..
  position: "absolute",
  right: 0,
  // Center vertically, height is 1em
  top: "calc(50% - .5em)",
  // Don't block pointer events on the select under the icon.
  pointerEvents: "none",
  color: (n.vars || n).palette.action.active,
  [`&.${oy.disabled}`]: {
    color: (n.vars || n).palette.action.disabled
  },
  variants: [{
    props: ({
      ownerState: t
    }) => t.open,
    style: {
      transform: "rotate(180deg)"
    }
  }, {
    props: {
      variant: "filled"
    },
    style: {
      right: 7
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      right: 7
    }
  }]
})), TN = vt(eE, {
  name: "MuiNativeSelect",
  slot: "Icon",
  overridesResolver: (n, t) => {
    const {
      ownerState: e
    } = n;
    return [t.icon, e.variant && t[`icon${St(e.variant)}`], e.open && t.iconOpen];
  }
})({}), wN = /* @__PURE__ */ O.forwardRef(function(t, e) {
  const {
    className: i,
    disabled: s,
    error: o,
    IconComponent: l,
    inputRef: c,
    variant: d = "standard",
    ...f
  } = t, m = {
    ...t,
    disabled: s,
    variant: d,
    error: o
  }, y = _N(m);
  return /* @__PURE__ */ et.jsxs(O.Fragment, {
    children: [/* @__PURE__ */ et.jsx(SN, {
      ownerState: m,
      className: Lt(y.select, i),
      disabled: s,
      ref: c || e,
      ...f
    }), t.multiple ? null : /* @__PURE__ */ et.jsx(TN, {
      as: l,
      ownerState: m,
      className: y.icon
    })]
  });
});
var LS;
const CN = vt("fieldset", {
  name: "MuiNotchedOutlined",
  shouldForwardProp: Mi
})({
  textAlign: "left",
  position: "absolute",
  bottom: 0,
  right: 0,
  top: -5,
  left: 0,
  margin: 0,
  padding: "0 8px",
  pointerEvents: "none",
  borderRadius: "inherit",
  borderStyle: "solid",
  borderWidth: 1,
  overflow: "hidden",
  minWidth: "0%"
}), EN = vt("legend", {
  name: "MuiNotchedOutlined",
  shouldForwardProp: Mi
})(Te(({
  theme: n
}) => ({
  float: "unset",
  // Fix conflict with bootstrap
  width: "auto",
  // Fix conflict with bootstrap
  overflow: "hidden",
  // Fix Horizontal scroll when label too long
  variants: [{
    props: ({
      ownerState: t
    }) => !t.withLabel,
    style: {
      padding: 0,
      lineHeight: "11px",
      // sync with `height` in `legend` styles
      transition: n.transitions.create("width", {
        duration: 150,
        easing: n.transitions.easing.easeOut
      })
    }
  }, {
    props: ({
      ownerState: t
    }) => t.withLabel,
    style: {
      display: "block",
      // Fix conflict with normalize.css and sanitize.css
      padding: 0,
      height: 11,
      // sync with `lineHeight` in `legend` styles
      fontSize: "0.75em",
      visibility: "hidden",
      maxWidth: 0.01,
      transition: n.transitions.create("max-width", {
        duration: 50,
        easing: n.transitions.easing.easeOut
      }),
      whiteSpace: "nowrap",
      "& > span": {
        paddingLeft: 5,
        paddingRight: 5,
        display: "inline-block",
        opacity: 0,
        visibility: "visible"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.withLabel && t.notched,
    style: {
      maxWidth: "100%",
      transition: n.transitions.create("max-width", {
        duration: 100,
        easing: n.transitions.easing.easeOut,
        delay: 50
      })
    }
  }]
})));
function MN(n) {
  const {
    children: t,
    classes: e,
    className: i,
    label: s,
    notched: o,
    ...l
  } = n, c = s != null && s !== "", d = {
    ...n,
    notched: o,
    withLabel: c
  };
  return /* @__PURE__ */ et.jsx(CN, {
    "aria-hidden": !0,
    className: i,
    ownerState: d,
    ...l,
    children: /* @__PURE__ */ et.jsx(EN, {
      ownerState: d,
      children: c ? /* @__PURE__ */ et.jsx("span", {
        children: s
      }) : (
        // notranslate needed while Google Translate will not fix zero-width space issue
        LS || (LS = /* @__PURE__ */ et.jsx("span", {
          className: "notranslate",
          "aria-hidden": !0,
          children: ""
        }))
      )
    })
  });
}
const AN = (n) => {
  const {
    classes: t
  } = n, i = Oe({
    root: ["root"],
    notchedOutline: ["notchedOutline"],
    input: ["input"]
  }, j4, t);
  return {
    ...t,
    // forward classes to the InputBase
    ...i
  };
}, RN = vt(Vh, {
  shouldForwardProp: (n) => Mi(n) || n === "classes",
  name: "MuiOutlinedInput",
  slot: "Root",
  overridesResolver: $h
})(Te(({
  theme: n
}) => {
  const t = n.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
  return {
    position: "relative",
    borderRadius: (n.vars || n).shape.borderRadius,
    [`&:hover .${Gi.notchedOutline}`]: {
      borderColor: (n.vars || n).palette.text.primary
    },
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      [`&:hover .${Gi.notchedOutline}`]: {
        borderColor: n.vars ? n.alpha(n.vars.palette.common.onBackground, 0.23) : t
      }
    },
    [`&.${Gi.focused} .${Gi.notchedOutline}`]: {
      borderWidth: 2
    },
    variants: [...Object.entries(n.palette).filter(Ci()).map(([e]) => ({
      props: {
        color: e
      },
      style: {
        [`&.${Gi.focused} .${Gi.notchedOutline}`]: {
          borderColor: (n.vars || n).palette[e].main
        }
      }
    })), {
      props: {},
      // to override the above style
      style: {
        [`&.${Gi.error} .${Gi.notchedOutline}`]: {
          borderColor: (n.vars || n).palette.error.main
        },
        [`&.${Gi.disabled} .${Gi.notchedOutline}`]: {
          borderColor: (n.vars || n).palette.action.disabled
        }
      }
    }, {
      props: ({
        ownerState: e
      }) => e.startAdornment,
      style: {
        paddingLeft: 14
      }
    }, {
      props: ({
        ownerState: e
      }) => e.endAdornment,
      style: {
        paddingRight: 14
      }
    }, {
      props: ({
        ownerState: e
      }) => e.multiline,
      style: {
        padding: "16.5px 14px"
      }
    }, {
      props: ({
        ownerState: e,
        size: i
      }) => e.multiline && i === "small",
      style: {
        padding: "8.5px 14px"
      }
    }]
  };
})), PN = vt(MN, {
  name: "MuiOutlinedInput",
  slot: "NotchedOutline"
})(Te(({
  theme: n
}) => {
  const t = n.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
  return {
    borderColor: n.vars ? n.alpha(n.vars.palette.common.onBackground, 0.23) : t
  };
})), BN = vt(jh, {
  name: "MuiOutlinedInput",
  slot: "Input",
  overridesResolver: Wh
})(Te(({
  theme: n
}) => ({
  padding: "16.5px 14px",
  ...!n.vars && {
    "&:-webkit-autofill": {
      WebkitBoxShadow: n.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
      WebkitTextFillColor: n.palette.mode === "light" ? null : "#fff",
      caretColor: n.palette.mode === "light" ? null : "#fff",
      borderRadius: "inherit"
    }
  },
  ...n.vars && {
    "&:-webkit-autofill": {
      borderRadius: "inherit"
    },
    [n.getColorSchemeSelector("dark")]: {
      "&:-webkit-autofill": {
        WebkitBoxShadow: "0 0 0 100px #266798 inset",
        WebkitTextFillColor: "#fff",
        caretColor: "#fff"
      }
    }
  },
  variants: [{
    props: {
      size: "small"
    },
    style: {
      padding: "8.5px 14px"
    }
  }, {
    props: ({
      ownerState: t
    }) => t.multiline,
    style: {
      padding: 0
    }
  }, {
    props: ({
      ownerState: t
    }) => t.startAdornment,
    style: {
      paddingLeft: 0
    }
  }, {
    props: ({
      ownerState: t
    }) => t.endAdornment,
    style: {
      paddingRight: 0
    }
  }]
}))), ly = /* @__PURE__ */ O.forwardRef(function(t, e) {
  const i = Ne({
    props: t,
    name: "MuiOutlinedInput"
  }), {
    components: s = {},
    fullWidth: o = !1,
    inputComponent: l = "input",
    label: c,
    multiline: d = !1,
    notched: f,
    slots: m = {},
    slotProps: y = {},
    type: b = "text",
    ...v
  } = i, x = AN(i), S = ro(), _ = io({
    props: i,
    muiFormControl: S,
    states: ["color", "disabled", "error", "focused", "hiddenLabel", "size", "required"]
  }), C = {
    ...i,
    color: _.color || "primary",
    disabled: _.disabled,
    error: _.error,
    focused: _.focused,
    formControl: S,
    fullWidth: o,
    hiddenLabel: _.hiddenLabel,
    multiline: d,
    size: _.size,
    type: b
  }, R = m.root ?? s.Root ?? RN, w = m.input ?? s.Input ?? BN, [E, P] = Tn("notchedOutline", {
    elementType: PN,
    className: x.notchedOutline,
    shouldForwardComponentProp: !0,
    ownerState: C,
    externalForwardedProps: {
      slots: m,
      slotProps: y
    },
    additionalProps: {
      label: c != null && c !== "" && _.required ? /* @__PURE__ */ et.jsxs(O.Fragment, {
        children: [c, "", "*"]
      }) : c
    }
  });
  return /* @__PURE__ */ et.jsx(ry, {
    slots: {
      root: R,
      input: w
    },
    slotProps: y,
    renderSuffix: (k) => /* @__PURE__ */ et.jsx(E, {
      ...P,
      notched: typeof f < "u" ? f : !!(k.startAdornment || k.filled || k.focused)
    }),
    fullWidth: o,
    inputComponent: l,
    multiline: d,
    ref: e,
    type: b,
    ...v,
    classes: {
      ...x,
      notchedOutline: null
    }
  });
});
ly.muiName = "Input";
const kN = {
  border: 0,
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: 0,
  position: "absolute",
  whiteSpace: "nowrap",
  width: "1px"
};
function nE(n) {
  return Be("MuiSelect", n);
}
const gl = ke("MuiSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "focused", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]);
var FS;
const ON = vt(tE, {
  name: "MuiSelect",
  slot: "Select",
  overridesResolver: (n, t) => {
    const {
      ownerState: e
    } = n;
    return [
      // Win specificity over the input base
      {
        [`&.${gl.select}`]: t.select
      },
      {
        [`&.${gl.select}`]: t[e.variant]
      },
      {
        [`&.${gl.error}`]: t.error
      },
      {
        [`&.${gl.multiple}`]: t.multiple
      }
    ];
  }
})({
  // Win specificity over the input base
  [`&.${gl.select}`]: {
    height: "auto",
    // Resets for multiple select with chips
    minHeight: "1.4375em",
    // Required for select\text-field height consistency
    textOverflow: "ellipsis",
    whiteSpace: "nowrap",
    overflow: "hidden"
  }
}), DN = vt(eE, {
  name: "MuiSelect",
  slot: "Icon",
  overridesResolver: (n, t) => {
    const {
      ownerState: e
    } = n;
    return [t.icon, e.variant && t[`icon${St(e.variant)}`], e.open && t.iconOpen];
  }
})({}), GN = vt("input", {
  shouldForwardProp: (n) => Hh(n) && n !== "classes",
  name: "MuiSelect",
  slot: "NativeInput"
})({
  bottom: 0,
  left: 0,
  position: "absolute",
  opacity: 0,
  pointerEvents: "none",
  width: "100%",
  boxSizing: "border-box"
});
function HS(n, t) {
  return typeof t == "object" && t !== null ? n === t : String(n) === String(t);
}
function UN(n) {
  return n == null || typeof n == "string" && !n.trim();
}
const NN = (n) => {
  const {
    classes: t,
    variant: e,
    disabled: i,
    multiple: s,
    open: o,
    error: l
  } = n, c = {
    select: ["select", e, i && "disabled", s && "multiple", l && "error"],
    icon: ["icon", `icon${St(e)}`, o && "iconOpen", i && "disabled"],
    nativeInput: ["nativeInput"]
  };
  return Oe(c, nE, t);
}, IN = /* @__PURE__ */ O.forwardRef(function(t, e) {
  const {
    "aria-describedby": i,
    "aria-label": s,
    autoFocus: o,
    autoWidth: l,
    children: c,
    className: d,
    defaultOpen: f,
    defaultValue: m,
    disabled: y,
    displayEmpty: b,
    error: v = !1,
    IconComponent: x,
    inputRef: S,
    labelId: _,
    MenuProps: C = {},
    multiple: R,
    name: w,
    onBlur: E,
    onChange: P,
    onClose: k,
    onFocus: G,
    onOpen: $,
    open: F,
    readOnly: j,
    renderValue: H,
    required: M,
    SelectDisplayProps: Y = {},
    tabIndex: L,
    // catching `type` from Input which makes no sense for SelectInput
    type: Q,
    value: B,
    variant: I = "standard",
    ...rt
  } = t, [J, D] = Hm({
    controlled: B,
    default: m,
    name: "Select"
  }), [q, ot] = Hm({
    controlled: F,
    default: f,
    name: "Select"
  }), at = O.useRef(null), lt = O.useRef(null), [dt, ht] = O.useState(null), {
    current: Vt
  } = O.useRef(F != null), [Rt, Dt] = O.useState(), gt = Bn(e, S), Pt = O.useCallback((pt) => {
    lt.current = pt, pt && ht(pt);
  }, []), Et = dt?.parentNode;
  O.useImperativeHandle(gt, () => ({
    focus: () => {
      lt.current.focus();
    },
    node: at.current,
    value: J
  }), [J]), O.useEffect(() => {
    f && q && dt && !Vt && (Dt(l ? null : Et.clientWidth), lt.current.focus());
  }, [dt, l]), O.useEffect(() => {
    o && lt.current.focus();
  }, [o]), O.useEffect(() => {
    if (!_)
      return;
    const pt = An(lt.current).getElementById(_);
    if (pt) {
      const Jt = () => {
        getSelection().isCollapsed && lt.current.focus();
      };
      return pt.addEventListener("click", Jt), () => {
        pt.removeEventListener("click", Jt);
      };
    }
  }, [_]);
  const It = (pt, Jt) => {
    pt ? $ && $(Jt) : k && k(Jt), Vt || (Dt(l ? null : Et.clientWidth), ot(pt));
  }, wt = (pt) => {
    pt.button === 0 && (pt.preventDefault(), lt.current.focus(), It(!0, pt));
  }, Yt = (pt) => {
    It(!1, pt);
  }, Ie = O.Children.toArray(c), Gt = (pt) => {
    const Jt = Ie.find((xe) => xe.props.value === pt.target.value);
    Jt !== void 0 && (D(Jt.props.value), P && P(pt, Jt));
  }, pe = (pt) => (Jt) => {
    let xe;
    if (Jt.currentTarget.hasAttribute("tabindex")) {
      if (R) {
        xe = Array.isArray(J) ? J.slice() : [];
        const Ai = J.indexOf(pt.props.value);
        Ai === -1 ? xe.push(pt.props.value) : xe.splice(Ai, 1);
      } else
        xe = pt.props.value;
      if (pt.props.onClick && pt.props.onClick(Jt), J !== xe && (D(xe), P)) {
        const Ai = Jt.nativeEvent || Jt, Vi = new Ai.constructor(Ai.type, Ai);
        Object.defineProperty(Vi, "target", {
          writable: !0,
          value: {
            value: xe,
            name: w
          }
        }), P(Vi, pt);
      }
      R || It(!1, Jt);
    }
  }, Je = (pt) => {
    j || [
      " ",
      "ArrowUp",
      "ArrowDown",
      // The native select doesn't respond to enter on macOS, but it's recommended by
      // https://www.w3.org/WAI/ARIA/apg/patterns/combobox/examples/combobox-select-only/
      "Enter"
    ].includes(pt.key) && (pt.preventDefault(), It(!0, pt));
  }, De = dt !== null && q, le = (pt) => {
    !De && E && (Object.defineProperty(pt, "target", {
      writable: !0,
      value: {
        value: J,
        name: w
      }
    }), E(pt));
  };
  delete rt["aria-invalid"];
  let xt, sn;
  const Me = [];
  let ct = !1;
  (bh({
    value: J
  }) || b) && (H ? xt = H(J) : ct = !0);
  const ut = Ie.map((pt) => {
    if (!/* @__PURE__ */ O.isValidElement(pt))
      return null;
    let Jt;
    if (R) {
      if (!Array.isArray(J))
        throw new Error(_r(2));
      Jt = J.some((xe) => HS(xe, pt.props.value)), Jt && ct && Me.push(pt.props.children);
    } else
      Jt = HS(J, pt.props.value), Jt && ct && (sn = pt.props.children);
    return /* @__PURE__ */ O.cloneElement(pt, {
      "aria-selected": Jt ? "true" : "false",
      onClick: pe(pt),
      onKeyUp: (xe) => {
        xe.key === " " && xe.preventDefault(), pt.props.onKeyUp && pt.props.onKeyUp(xe);
      },
      role: "option",
      selected: Jt,
      value: void 0,
      // The value is most likely not a valid HTML attribute.
      "data-value": pt.props.value
      // Instead, we provide it as a data attribute.
    });
  });
  ct && (R ? Me.length === 0 ? xt = null : xt = Me.reduce((pt, Jt, xe) => (pt.push(Jt), xe < Me.length - 1 && pt.push(", "), pt), []) : xt = sn);
  let yt = Rt;
  !l && Vt && dt && (yt = Et.clientWidth);
  let Bt;
  typeof L < "u" ? Bt = L : Bt = y ? null : 0;
  const Ct = Y.id || (w ? `mui-component-select-${w}` : void 0), kt = {
    ...t,
    variant: I,
    value: J,
    open: De,
    error: v
  }, Wt = NN(kt), We = {
    ...C.PaperProps,
    ...typeof C.slotProps?.paper == "function" ? C.slotProps.paper(kt) : C.slotProps?.paper
  }, ue = {
    ...C.MenuListProps,
    ...typeof C.slotProps?.list == "function" ? C.slotProps.list(kt) : C.slotProps?.list
  }, an = Kg();
  return /* @__PURE__ */ et.jsxs(O.Fragment, {
    children: [/* @__PURE__ */ et.jsx(ON, {
      as: "div",
      ref: Pt,
      tabIndex: Bt,
      role: "combobox",
      "aria-controls": De ? an : void 0,
      "aria-disabled": y ? "true" : void 0,
      "aria-expanded": De ? "true" : "false",
      "aria-haspopup": "listbox",
      "aria-label": s,
      "aria-labelledby": [_, Ct].filter(Boolean).join(" ") || void 0,
      "aria-describedby": i,
      "aria-required": M ? "true" : void 0,
      "aria-invalid": v ? "true" : void 0,
      onKeyDown: Je,
      onMouseDown: y || j ? null : wt,
      onBlur: le,
      onFocus: G,
      ...Y,
      ownerState: kt,
      className: Lt(Y.className, Wt.select, d),
      id: Ct,
      children: UN(xt) ? (
        // notranslate needed while Google Translate will not fix zero-width space issue
        FS || (FS = /* @__PURE__ */ et.jsx("span", {
          className: "notranslate",
          "aria-hidden": !0,
          children: ""
        }))
      ) : xt
    }), /* @__PURE__ */ et.jsx(GN, {
      "aria-invalid": v,
      value: Array.isArray(J) ? J.join(",") : J,
      name: w,
      ref: at,
      "aria-hidden": !0,
      onChange: Gt,
      tabIndex: -1,
      disabled: y,
      className: Wt.nativeInput,
      autoFocus: o,
      required: M,
      ...rt,
      ownerState: kt
    }), /* @__PURE__ */ et.jsx(DN, {
      as: x,
      className: Wt.icon,
      ownerState: kt
    }), /* @__PURE__ */ et.jsx(vN, {
      id: `menu-${w || ""}`,
      anchorEl: Et,
      open: De,
      onClose: Yt,
      anchorOrigin: {
        vertical: "bottom",
        horizontal: "center"
      },
      transformOrigin: {
        vertical: "top",
        horizontal: "center"
      },
      ...C,
      slotProps: {
        ...C.slotProps,
        list: {
          "aria-labelledby": _,
          role: "listbox",
          "aria-multiselectable": R ? "true" : void 0,
          disableListWrap: !0,
          id: an,
          ...ue
        },
        paper: {
          ...We,
          style: {
            minWidth: yt,
            ...We != null ? We.style : null
          }
        }
      },
      children: ut
    })]
  });
}), zN = (n) => {
  const {
    classes: t
  } = n, i = Oe({
    root: ["root"]
  }, nE, t);
  return {
    ...t,
    ...i
  };
}, uy = {
  name: "MuiSelect",
  slot: "Root",
  shouldForwardProp: (n) => Mi(n) && n !== "variant"
}, LN = vt(ay, uy)(""), FN = vt(ly, uy)(""), HN = vt(sy, uy)(""), iE = /* @__PURE__ */ O.forwardRef(function(t, e) {
  const i = Ne({
    name: "MuiSelect",
    props: t
  }), {
    autoWidth: s = !1,
    children: o,
    classes: l = {},
    className: c,
    defaultOpen: d = !1,
    displayEmpty: f = !1,
    IconComponent: m = X4,
    id: y,
    input: b,
    inputProps: v,
    label: x,
    labelId: S,
    MenuProps: _,
    multiple: C = !1,
    native: R = !1,
    onClose: w,
    onOpen: E,
    open: P,
    renderValue: k,
    SelectDisplayProps: G,
    variant: $ = "outlined",
    ...F
  } = i, j = R ? wN : IN, H = ro(), M = io({
    props: i,
    muiFormControl: H,
    states: ["variant", "error"]
  }), Y = M.variant || $, L = {
    ...i,
    variant: Y,
    classes: l
  }, Q = zN(L), {
    root: B,
    ...I
  } = Q, rt = b || {
    standard: /* @__PURE__ */ et.jsx(LN, {
      ownerState: L
    }),
    outlined: /* @__PURE__ */ et.jsx(FN, {
      label: x,
      ownerState: L
    }),
    filled: /* @__PURE__ */ et.jsx(HN, {
      ownerState: L
    })
  }[Y], J = Bn(e, au(rt));
  return /* @__PURE__ */ et.jsx(O.Fragment, {
    children: /* @__PURE__ */ O.cloneElement(rt, {
      // Most of the logic is implemented in `SelectInput`.
      // The `Select` component is a simple API wrapper to expose something better to play with.
      inputComponent: j,
      inputProps: {
        children: o,
        error: M.error,
        IconComponent: m,
        variant: Y,
        type: void 0,
        // We render a select. We can ignore the type provided by the `Input`.
        multiple: C,
        ...R ? {
          id: y
        } : {
          autoWidth: s,
          defaultOpen: d,
          displayEmpty: f,
          labelId: S,
          MenuProps: _,
          onClose: w,
          onOpen: E,
          open: P,
          renderValue: k,
          SelectDisplayProps: {
            id: y,
            ...G
          }
        },
        ...v,
        classes: v ? wn(I, v.classes) : I,
        ...b ? b.props.inputProps : {}
      },
      ...(C && R || f) && Y === "outlined" ? {
        notched: !0
      } : {},
      ref: J,
      className: Lt(rt.props.className, c, Q.root),
      // If a custom input is provided via 'input' prop, do not allow 'variant' to be propagated to it's root element. See https://github.com/mui/material-ui/issues/33894.
      ...!b && {
        variant: Y
      },
      ...F
    })
  });
});
iE.muiName = "Select";
function $N(n, t, e = (i, s) => i === s) {
  return n.length === t.length && n.every((i, s) => e(i, t[s]));
}
const WN = 2;
function Da(n, t, e, i, s) {
  return e === 1 ? Math.min(n + t, s) : Math.max(n - t, i);
}
function rE(n, t) {
  return n - t;
}
function $S(n, t) {
  const {
    index: e
  } = n.reduce((i, s, o) => {
    const l = Math.abs(t - s);
    return i === null || l < i.distance || l === i.distance ? {
      distance: l,
      index: o
    } : i;
  }, null) ?? {};
  return e;
}
function Hc(n, t) {
  if (t.current !== void 0 && n.changedTouches) {
    const e = n;
    for (let i = 0; i < e.changedTouches.length; i += 1) {
      const s = e.changedTouches[i];
      if (s.identifier === t.current)
        return {
          x: s.clientX,
          y: s.clientY
        };
    }
    return !1;
  }
  return {
    x: n.clientX,
    y: n.clientY
  };
}
function vh(n, t, e) {
  return (n - t) * 100 / (e - t);
}
function VN(n, t, e) {
  return (e - t) * n + t;
}
function jN(n) {
  if (Math.abs(n) < 1) {
    const e = n.toExponential().split("e-"), i = e[0].split(".")[1];
    return (i ? i.length : 0) + parseInt(e[1], 10);
  }
  const t = n.toString().split(".")[1];
  return t ? t.length : 0;
}
function YN(n, t, e) {
  const i = Math.round((n - e) / t) * t + e;
  return Number(i.toFixed(jN(t)));
}
function WS({
  values: n,
  newValue: t,
  index: e
}) {
  const i = n.slice();
  return i[e] = t, i.sort(rE);
}
function $c({
  sliderRef: n,
  activeIndex: t,
  setActive: e
}) {
  const i = An(n.current);
  (!n.current?.contains(i.activeElement) || Number(i?.activeElement?.getAttribute("data-index")) !== t) && n.current?.querySelector(`[type="range"][data-index="${t}"]`).focus(), e && e(t);
}
function Wc(n, t) {
  return typeof n == "number" && typeof t == "number" ? n === t : typeof n == "object" && typeof t == "object" ? $N(n, t) : !1;
}
const XN = {
  horizontal: {
    offset: (n) => ({
      left: `${n}%`
    }),
    leap: (n) => ({
      width: `${n}%`
    })
  },
  "horizontal-reverse": {
    offset: (n) => ({
      right: `${n}%`
    }),
    leap: (n) => ({
      width: `${n}%`
    })
  },
  vertical: {
    offset: (n) => ({
      bottom: `${n}%`
    }),
    leap: (n) => ({
      height: `${n}%`
    })
  }
}, qN = (n) => n;
let Vc;
function VS() {
  return Vc === void 0 && (typeof CSS < "u" && typeof CSS.supports == "function" ? Vc = CSS.supports("touch-action", "none") : Vc = !0), Vc;
}
function KN(n) {
  const {
    "aria-labelledby": t,
    defaultValue: e,
    disabled: i = !1,
    disableSwap: s = !1,
    isRtl: o = !1,
    marks: l = !1,
    max: c = 100,
    min: d = 0,
    name: f,
    onChange: m,
    onChangeCommitted: y,
    orientation: b = "horizontal",
    rootRef: v,
    scale: x = qN,
    step: S = 1,
    shiftStep: _ = 10,
    tabIndex: C,
    value: R
  } = n, w = O.useRef(void 0), [E, P] = O.useState(-1), [k, G] = O.useState(-1), [$, F] = O.useState(!1), j = O.useRef(0), H = O.useRef(null), [M, Y] = Hm({
    controlled: R,
    default: e ?? d,
    name: "Slider"
  }), L = m && ((ct, ut, yt) => {
    const Bt = ct.nativeEvent || ct, Ct = new Bt.constructor(Bt.type, Bt);
    Object.defineProperty(Ct, "target", {
      writable: !0,
      value: {
        value: ut,
        name: f
      }
    }), H.current = ut, m(Ct, ut, yt);
  }), Q = Array.isArray(M);
  let B = Q ? M.slice().sort(rE) : [M];
  B = B.map((ct) => ct == null ? d : Ia(ct, d, c));
  const I = l === !0 && S !== null ? [...Array(Math.floor((c - d) / S) + 1)].map((ct, ut) => ({
    value: d + S * ut
  })) : l || [], rt = I.map((ct) => ct.value), [J, D] = O.useState(-1), q = O.useRef(null), ot = Bn(v, q), at = (ct) => (ut) => {
    const yt = Number(ut.currentTarget.getAttribute("data-index"));
    gh(ut.target) && D(yt), G(yt), ct?.onFocus?.(ut);
  }, lt = (ct) => (ut) => {
    gh(ut.target) || D(-1), G(-1), ct?.onBlur?.(ut);
  }, dt = (ct, ut) => {
    const yt = Number(ct.currentTarget.getAttribute("data-index")), Bt = B[yt], Ct = rt.indexOf(Bt);
    let kt = ut;
    if (I && S == null) {
      const Wt = rt[rt.length - 1];
      kt >= Wt ? kt = Wt : kt <= rt[0] ? kt = rt[0] : kt = kt < Bt ? rt[Ct - 1] : rt[Ct + 1];
    }
    if (kt = Ia(kt, d, c), Q) {
      s && (kt = Ia(kt, B[yt - 1] || -1 / 0, B[yt + 1] || 1 / 0));
      const Wt = kt;
      kt = WS({
        values: B,
        newValue: kt,
        index: yt
      });
      let We = yt;
      s || (We = kt.indexOf(Wt)), $c({
        sliderRef: q,
        activeIndex: We
      });
    }
    Y(kt), D(yt), L && !Wc(kt, M) && L(ct, kt, yt), y && y(ct, H.current ?? kt);
  }, ht = (ct) => (ut) => {
    if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "PageUp", "PageDown", "Home", "End"].includes(ut.key)) {
      ut.preventDefault();
      const yt = Number(ut.currentTarget.getAttribute("data-index")), Bt = B[yt];
      let Ct = null;
      if (S != null) {
        const kt = ut.shiftKey ? _ : S;
        switch (ut.key) {
          case "ArrowUp":
            Ct = Da(Bt, kt, 1, d, c);
            break;
          case "ArrowRight":
            Ct = Da(Bt, kt, o ? -1 : 1, d, c);
            break;
          case "ArrowDown":
            Ct = Da(Bt, kt, -1, d, c);
            break;
          case "ArrowLeft":
            Ct = Da(Bt, kt, o ? 1 : -1, d, c);
            break;
          case "PageUp":
            Ct = Da(Bt, _, 1, d, c);
            break;
          case "PageDown":
            Ct = Da(Bt, _, -1, d, c);
            break;
          case "Home":
            Ct = d;
            break;
          case "End":
            Ct = c;
            break;
        }
      } else if (I) {
        const kt = rt[rt.length - 1], Wt = rt.indexOf(Bt), We = [o ? "ArrowRight" : "ArrowLeft", "ArrowDown", "PageDown", "Home"], ue = [o ? "ArrowLeft" : "ArrowRight", "ArrowUp", "PageUp", "End"];
        We.includes(ut.key) ? Wt === 0 ? Ct = rt[0] : Ct = rt[Wt - 1] : ue.includes(ut.key) && (Wt === rt.length - 1 ? Ct = kt : Ct = rt[Wt + 1]);
      }
      Ct != null && dt(ut, Ct);
    }
    ct?.onKeyDown?.(ut);
  };
  ts(() => {
    i && q.current.contains(document.activeElement) && document.activeElement?.blur();
  }, [i]), i && E !== -1 && P(-1), i && J !== -1 && D(-1);
  const Vt = (ct) => (ut) => {
    ct.onChange?.(ut), dt(ut, ut.target.valueAsNumber);
  }, Rt = O.useRef(void 0);
  let Dt = b;
  o && b === "horizontal" && (Dt += "-reverse");
  const gt = ({
    finger: ct,
    move: ut = !1
  }) => {
    const {
      current: yt
    } = q, {
      width: Bt,
      height: Ct,
      bottom: kt,
      left: Wt
    } = yt.getBoundingClientRect();
    let We;
    Dt.startsWith("vertical") ? We = (kt - ct.y) / Ct : We = (ct.x - Wt) / Bt, Dt.includes("-reverse") && (We = 1 - We);
    let ue;
    if (ue = VN(We, d, c), S)
      ue = YN(ue, S, d);
    else {
      const pt = $S(rt, ue);
      ue = rt[pt];
    }
    ue = Ia(ue, d, c);
    let an = 0;
    if (Q) {
      ut ? an = Rt.current : an = $S(B, ue), s && (ue = Ia(ue, B[an - 1] || -1 / 0, B[an + 1] || 1 / 0));
      const pt = ue;
      ue = WS({
        values: B,
        newValue: ue,
        index: an
      }), s && ut || (an = ue.indexOf(pt), Rt.current = an);
    }
    return {
      newValue: ue,
      activeIndex: an
    };
  }, Pt = $i((ct) => {
    const ut = Hc(ct, w);
    if (!ut)
      return;
    if (j.current += 1, ct.type === "mousemove" && ct.buttons === 0) {
      Et(ct);
      return;
    }
    const {
      newValue: yt,
      activeIndex: Bt
    } = gt({
      finger: ut,
      move: !0
    });
    $c({
      sliderRef: q,
      activeIndex: Bt,
      setActive: P
    }), Y(yt), !$ && j.current > WN && F(!0), L && !Wc(yt, M) && L(ct, yt, Bt);
  }), Et = $i((ct) => {
    const ut = Hc(ct, w);
    if (F(!1), !ut)
      return;
    const {
      newValue: yt
    } = gt({
      finger: ut,
      move: !0
    });
    P(-1), ct.type === "touchend" && G(-1), y && y(ct, H.current ?? yt), w.current = void 0, wt();
  }), It = $i((ct) => {
    if (i)
      return;
    VS() || ct.preventDefault();
    const ut = ct.changedTouches[0];
    ut != null && (w.current = ut.identifier);
    const yt = Hc(ct, w);
    if (yt !== !1) {
      const {
        newValue: Ct,
        activeIndex: kt
      } = gt({
        finger: yt
      });
      $c({
        sliderRef: q,
        activeIndex: kt,
        setActive: P
      }), Y(Ct), L && !Wc(Ct, M) && L(ct, Ct, kt);
    }
    j.current = 0;
    const Bt = An(q.current);
    Bt.addEventListener("touchmove", Pt, {
      passive: !0
    }), Bt.addEventListener("touchend", Et, {
      passive: !0
    });
  }), wt = O.useCallback(() => {
    const ct = An(q.current);
    ct.removeEventListener("mousemove", Pt), ct.removeEventListener("mouseup", Et), ct.removeEventListener("touchmove", Pt), ct.removeEventListener("touchend", Et);
  }, [Et, Pt]);
  O.useEffect(() => {
    const {
      current: ct
    } = q;
    return ct.addEventListener("touchstart", It, {
      passive: VS()
    }), () => {
      ct.removeEventListener("touchstart", It), wt();
    };
  }, [wt, It]), O.useEffect(() => {
    i && wt();
  }, [i, wt]);
  const Yt = (ct) => (ut) => {
    if (ct.onMouseDown?.(ut), i || ut.defaultPrevented || ut.button !== 0)
      return;
    ut.preventDefault();
    const yt = Hc(ut, w);
    if (yt !== !1) {
      const {
        newValue: Ct,
        activeIndex: kt
      } = gt({
        finger: yt
      });
      $c({
        sliderRef: q,
        activeIndex: kt,
        setActive: P
      }), Y(Ct), L && !Wc(Ct, M) && L(ut, Ct, kt);
    }
    j.current = 0;
    const Bt = An(q.current);
    Bt.addEventListener("mousemove", Pt, {
      passive: !0
    }), Bt.addEventListener("mouseup", Et);
  }, Ie = vh(Q ? B[0] : d, d, c), Gt = vh(B[B.length - 1], d, c) - Ie, pe = (ct = {}) => {
    const ut = kl(ct), yt = {
      onMouseDown: Yt(ut || {})
    }, Bt = {
      ...ut,
      ...yt
    };
    return {
      ...ct,
      ref: ot,
      ...Bt
    };
  }, Je = (ct) => (ut) => {
    ct.onMouseOver?.(ut);
    const yt = Number(ut.currentTarget.getAttribute("data-index"));
    G(yt);
  }, De = (ct) => (ut) => {
    ct.onMouseLeave?.(ut), G(-1);
  }, le = (ct = {}) => {
    const ut = kl(ct), yt = {
      onMouseOver: Je(ut || {}),
      onMouseLeave: De(ut || {})
    };
    return {
      ...ct,
      ...ut,
      ...yt
    };
  }, xt = (ct) => ({
    // So the non active thumb doesn't show its label on hover.
    pointerEvents: E !== -1 && E !== ct ? "none" : void 0
  });
  let sn;
  return b === "vertical" && (sn = o ? "vertical-rl" : "vertical-lr"), {
    active: E,
    axis: Dt,
    axisProps: XN,
    dragging: $,
    focusedThumbIndex: J,
    getHiddenInputProps: (ct = {}) => {
      const ut = kl(ct), yt = {
        onChange: Vt(ut || {}),
        onFocus: at(ut || {}),
        onBlur: lt(ut || {}),
        onKeyDown: ht(ut || {})
      }, Bt = {
        ...ut,
        ...yt
      };
      return {
        tabIndex: C,
        "aria-labelledby": t,
        "aria-orientation": b,
        "aria-valuemax": x(c),
        "aria-valuemin": x(d),
        name: f,
        type: "range",
        min: n.min,
        max: n.max,
        step: n.step === null && n.marks ? "any" : n.step ?? void 0,
        disabled: i,
        ...ct,
        ...Bt,
        style: {
          ...kN,
          direction: o ? "rtl" : "ltr",
          // So that VoiceOver's focus indicator matches the thumb's dimensions
          width: "100%",
          height: "100%",
          writingMode: sn
        }
      };
    },
    getRootProps: pe,
    getThumbProps: le,
    marks: I,
    open: k,
    range: Q,
    rootRef: ot,
    trackLeap: Gt,
    trackOffset: Ie,
    values: B,
    getThumbStyle: xt
  };
}
const ZN = (n) => !n || !Zr(n);
function QN(n) {
  return Be("MuiSlider", n);
}
const di = ke("MuiSlider", ["root", "active", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "disabled", "dragging", "focusVisible", "mark", "markActive", "marked", "markLabel", "markLabelActive", "rail", "sizeSmall", "thumb", "thumbColorPrimary", "thumbColorSecondary", "thumbColorError", "thumbColorSuccess", "thumbColorInfo", "thumbColorWarning", "track", "trackInverted", "trackFalse", "thumbSizeSmall", "valueLabel", "valueLabelOpen", "valueLabelCircle", "valueLabelLabel", "vertical"]), JN = (n) => {
  const {
    open: t
  } = n;
  return {
    offset: Lt(t && di.valueLabelOpen),
    circle: di.valueLabelCircle,
    label: di.valueLabelLabel
  };
};
function tI(n) {
  const {
    children: t,
    className: e,
    value: i
  } = n, s = JN(n);
  return t ? /* @__PURE__ */ O.cloneElement(t, {
    className: t.props.className
  }, /* @__PURE__ */ et.jsxs(O.Fragment, {
    children: [t.props.children, /* @__PURE__ */ et.jsx("span", {
      className: Lt(s.offset, e),
      "aria-hidden": !0,
      children: /* @__PURE__ */ et.jsx("span", {
        className: s.circle,
        children: /* @__PURE__ */ et.jsx("span", {
          className: s.label,
          children: i
        })
      })
    })]
  })) : null;
}
function jS(n) {
  return n;
}
const eI = vt("span", {
  name: "MuiSlider",
  slot: "Root",
  overridesResolver: (n, t) => {
    const {
      ownerState: e
    } = n;
    return [t.root, t[`color${St(e.color)}`], e.size !== "medium" && t[`size${St(e.size)}`], e.marked && t.marked, e.orientation === "vertical" && t.vertical, e.track === "inverted" && t.trackInverted, e.track === !1 && t.trackFalse];
  }
})(Te(({
  theme: n
}) => ({
  borderRadius: 12,
  boxSizing: "content-box",
  display: "inline-block",
  position: "relative",
  cursor: "pointer",
  touchAction: "none",
  WebkitTapHighlightColor: "transparent",
  "@media print": {
    colorAdjust: "exact"
  },
  [`&.${di.disabled}`]: {
    pointerEvents: "none",
    cursor: "default",
    color: (n.vars || n).palette.grey[400]
  },
  [`&.${di.dragging}`]: {
    [`& .${di.thumb}, & .${di.track}`]: {
      transition: "none"
    }
  },
  variants: [...Object.entries(n.palette).filter(Ci()).map(([t]) => ({
    props: {
      color: t
    },
    style: {
      color: (n.vars || n).palette[t].main
    }
  })), {
    props: {
      orientation: "horizontal"
    },
    style: {
      height: 4,
      width: "100%",
      padding: "13px 0",
      // The primary input mechanism of the device includes a pointing device of limited accuracy.
      "@media (pointer: coarse)": {
        // Reach 42px touch target, about ~8mm on screen.
        padding: "20px 0"
      }
    }
  }, {
    props: {
      orientation: "horizontal",
      size: "small"
    },
    style: {
      height: 2
    }
  }, {
    props: {
      orientation: "horizontal",
      marked: !0
    },
    style: {
      marginBottom: 20
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      height: "100%",
      width: 4,
      padding: "0 13px",
      // The primary input mechanism of the device includes a pointing device of limited accuracy.
      "@media (pointer: coarse)": {
        // Reach 42px touch target, about ~8mm on screen.
        padding: "0 20px"
      }
    }
  }, {
    props: {
      orientation: "vertical",
      size: "small"
    },
    style: {
      width: 2
    }
  }, {
    props: {
      orientation: "vertical",
      marked: !0
    },
    style: {
      marginRight: 44
    }
  }]
}))), nI = vt("span", {
  name: "MuiSlider",
  slot: "Rail"
})({
  display: "block",
  position: "absolute",
  borderRadius: "inherit",
  backgroundColor: "currentColor",
  opacity: 0.38,
  variants: [{
    props: {
      orientation: "horizontal"
    },
    style: {
      width: "100%",
      height: "inherit",
      top: "50%",
      transform: "translateY(-50%)"
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      height: "100%",
      width: "inherit",
      left: "50%",
      transform: "translateX(-50%)"
    }
  }, {
    props: {
      track: "inverted"
    },
    style: {
      opacity: 1
    }
  }]
}), iI = vt("span", {
  name: "MuiSlider",
  slot: "Track"
})(Te(({
  theme: n
}) => ({
  display: "block",
  position: "absolute",
  borderRadius: "inherit",
  border: "1px solid currentColor",
  backgroundColor: "currentColor",
  transition: n.transitions.create(["left", "width", "bottom", "height"], {
    duration: n.transitions.duration.shortest
  }),
  variants: [{
    props: {
      size: "small"
    },
    style: {
      border: "none"
    }
  }, {
    props: {
      orientation: "horizontal"
    },
    style: {
      height: "inherit",
      top: "50%",
      transform: "translateY(-50%)"
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      width: "inherit",
      left: "50%",
      transform: "translateX(-50%)"
    }
  }, {
    props: {
      track: !1
    },
    style: {
      display: "none"
    }
  }, ...Object.entries(n.palette).filter(Ci()).map(([t]) => ({
    props: {
      color: t,
      track: "inverted"
    },
    style: {
      ...n.vars ? {
        backgroundColor: n.vars.palette.Slider[`${t}Track`],
        borderColor: n.vars.palette.Slider[`${t}Track`]
      } : {
        backgroundColor: n.lighten(n.palette[t].main, 0.62),
        borderColor: n.lighten(n.palette[t].main, 0.62),
        ...n.applyStyles("dark", {
          backgroundColor: n.darken(n.palette[t].main, 0.5)
        }),
        ...n.applyStyles("dark", {
          borderColor: n.darken(n.palette[t].main, 0.5)
        })
      }
    }
  }))]
}))), rI = vt("span", {
  name: "MuiSlider",
  slot: "Thumb",
  overridesResolver: (n, t) => {
    const {
      ownerState: e
    } = n;
    return [t.thumb, t[`thumbColor${St(e.color)}`], e.size !== "medium" && t[`thumbSize${St(e.size)}`]];
  }
})(Te(({
  theme: n
}) => ({
  position: "absolute",
  width: 20,
  height: 20,
  boxSizing: "border-box",
  borderRadius: "50%",
  outline: 0,
  backgroundColor: "currentColor",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  transition: n.transitions.create(["box-shadow", "left", "bottom"], {
    duration: n.transitions.duration.shortest
  }),
  "&::before": {
    position: "absolute",
    content: '""',
    borderRadius: "inherit",
    width: "100%",
    height: "100%",
    boxShadow: (n.vars || n).shadows[2]
  },
  "&::after": {
    position: "absolute",
    content: '""',
    borderRadius: "50%",
    // 42px is the hit target
    width: 42,
    height: 42,
    top: "50%",
    left: "50%",
    transform: "translate(-50%, -50%)"
  },
  [`&.${di.disabled}`]: {
    "&:hover": {
      boxShadow: "none"
    }
  },
  variants: [{
    props: {
      size: "small"
    },
    style: {
      width: 12,
      height: 12,
      "&::before": {
        boxShadow: "none"
      }
    }
  }, {
    props: {
      orientation: "horizontal"
    },
    style: {
      top: "50%",
      transform: "translate(-50%, -50%)"
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      left: "50%",
      transform: "translate(-50%, 50%)"
    }
  }, ...Object.entries(n.palette).filter(Ci()).map(([t]) => ({
    props: {
      color: t
    },
    style: {
      [`&:hover, &.${di.focusVisible}`]: {
        boxShadow: `0px 0px 0px 8px ${n.alpha((n.vars || n).palette[t].main, 0.16)}`,
        "@media (hover: none)": {
          boxShadow: "none"
        }
      },
      [`&.${di.active}`]: {
        boxShadow: `0px 0px 0px 14px ${n.alpha((n.vars || n).palette[t].main, 0.16)}`
      }
    }
  }))]
}))), sI = vt(tI, {
  name: "MuiSlider",
  slot: "ValueLabel"
})(Te(({
  theme: n
}) => ({
  zIndex: 1,
  whiteSpace: "nowrap",
  ...n.typography.body2,
  fontWeight: 500,
  transition: n.transitions.create(["transform"], {
    duration: n.transitions.duration.shortest
  }),
  position: "absolute",
  backgroundColor: (n.vars || n).palette.grey[600],
  borderRadius: 2,
  color: (n.vars || n).palette.common.white,
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  padding: "0.25rem 0.75rem",
  variants: [{
    props: {
      orientation: "horizontal"
    },
    style: {
      transform: "translateY(-100%) scale(0)",
      top: "-10px",
      transformOrigin: "bottom center",
      "&::before": {
        position: "absolute",
        content: '""',
        width: 8,
        height: 8,
        transform: "translate(-50%, 50%) rotate(45deg)",
        backgroundColor: "inherit",
        bottom: 0,
        left: "50%"
      },
      [`&.${di.valueLabelOpen}`]: {
        transform: "translateY(-100%) scale(1)"
      }
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      transform: "translateY(-50%) scale(0)",
      right: "30px",
      top: "50%",
      transformOrigin: "right center",
      "&::before": {
        position: "absolute",
        content: '""',
        width: 8,
        height: 8,
        transform: "translate(-50%, -50%) rotate(45deg)",
        backgroundColor: "inherit",
        right: -8,
        top: "50%"
      },
      [`&.${di.valueLabelOpen}`]: {
        transform: "translateY(-50%) scale(1)"
      }
    }
  }, {
    props: {
      size: "small"
    },
    style: {
      fontSize: n.typography.pxToRem(12),
      padding: "0.25rem 0.5rem"
    }
  }, {
    props: {
      orientation: "vertical",
      size: "small"
    },
    style: {
      right: "20px"
    }
  }]
}))), aI = vt("span", {
  name: "MuiSlider",
  slot: "Mark",
  shouldForwardProp: (n) => Hh(n) && n !== "markActive",
  overridesResolver: (n, t) => {
    const {
      markActive: e
    } = n;
    return [t.mark, e && t.markActive];
  }
})(Te(({
  theme: n
}) => ({
  position: "absolute",
  width: 2,
  height: 2,
  borderRadius: 1,
  backgroundColor: "currentColor",
  variants: [{
    props: {
      orientation: "horizontal"
    },
    style: {
      top: "50%",
      transform: "translate(-1px, -50%)"
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      left: "50%",
      transform: "translate(-50%, 1px)"
    }
  }, {
    props: {
      markActive: !0
    },
    style: {
      backgroundColor: (n.vars || n).palette.background.paper,
      opacity: 0.8
    }
  }]
}))), oI = vt("span", {
  name: "MuiSlider",
  slot: "MarkLabel",
  shouldForwardProp: (n) => Hh(n) && n !== "markLabelActive"
})(Te(({
  theme: n
}) => ({
  ...n.typography.body2,
  color: (n.vars || n).palette.text.secondary,
  position: "absolute",
  whiteSpace: "nowrap",
  variants: [{
    props: {
      orientation: "horizontal"
    },
    style: {
      top: 30,
      transform: "translateX(-50%)",
      "@media (pointer: coarse)": {
        top: 40
      }
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      left: 36,
      transform: "translateY(50%)",
      "@media (pointer: coarse)": {
        left: 44
      }
    }
  }, {
    props: {
      markLabelActive: !0
    },
    style: {
      color: (n.vars || n).palette.text.primary
    }
  }]
}))), lI = (n) => {
  const {
    disabled: t,
    dragging: e,
    marked: i,
    orientation: s,
    track: o,
    classes: l,
    color: c,
    size: d
  } = n, f = {
    root: ["root", t && "disabled", e && "dragging", i && "marked", s === "vertical" && "vertical", o === "inverted" && "trackInverted", o === !1 && "trackFalse", c && `color${St(c)}`, d && `size${St(d)}`],
    rail: ["rail"],
    track: ["track"],
    mark: ["mark"],
    markActive: ["markActive"],
    markLabel: ["markLabel"],
    markLabelActive: ["markLabelActive"],
    valueLabel: ["valueLabel"],
    thumb: ["thumb", t && "disabled", d && `thumbSize${St(d)}`, c && `thumbColor${St(c)}`],
    active: ["active"],
    disabled: ["disabled"],
    focusVisible: ["focusVisible"]
  };
  return Oe(f, QN, l);
}, uI = ({
  children: n
}) => n, cI = /* @__PURE__ */ O.forwardRef(function(t, e) {
  const i = Ne({
    props: t,
    name: "MuiSlider"
  }), s = BC(), {
    "aria-label": o,
    "aria-valuetext": l,
    "aria-labelledby": c,
    // eslint-disable-next-line react/prop-types
    component: d = "span",
    components: f = {},
    componentsProps: m = {},
    color: y = "primary",
    classes: b,
    className: v,
    disableSwap: x = !1,
    disabled: S = !1,
    getAriaLabel: _,
    getAriaValueText: C,
    marks: R = !1,
    max: w = 100,
    min: E = 0,
    name: P,
    onChange: k,
    onChangeCommitted: G,
    orientation: $ = "horizontal",
    shiftStep: F = 10,
    size: j = "medium",
    step: H = 1,
    scale: M = jS,
    slotProps: Y,
    slots: L,
    tabIndex: Q,
    track: B = "normal",
    value: I,
    valueLabelDisplay: rt = "off",
    valueLabelFormat: J = jS,
    ...D
  } = i, q = {
    ...i,
    isRtl: s,
    max: w,
    min: E,
    classes: b,
    disabled: S,
    disableSwap: x,
    orientation: $,
    marks: R,
    color: y,
    size: j,
    step: H,
    shiftStep: F,
    scale: M,
    track: B,
    valueLabelDisplay: rt,
    valueLabelFormat: J
  }, {
    axisProps: ot,
    getRootProps: at,
    getHiddenInputProps: lt,
    getThumbProps: dt,
    open: ht,
    active: Vt,
    axis: Rt,
    focusedThumbIndex: Dt,
    range: gt,
    dragging: Pt,
    marks: Et,
    values: It,
    trackOffset: wt,
    trackLeap: Yt,
    getThumbStyle: Ie
  } = KN({
    ...q,
    rootRef: e
  });
  q.marked = Et.length > 0 && Et.some((we) => we.label), q.dragging = Pt, q.focusedThumbIndex = Dt;
  const Gt = lI(q), pe = L?.root ?? f.Root ?? eI, Je = L?.rail ?? f.Rail ?? nI, De = L?.track ?? f.Track ?? iI, le = L?.thumb ?? f.Thumb ?? rI, xt = L?.valueLabel ?? f.ValueLabel ?? sI, sn = L?.mark ?? f.Mark ?? aI, Me = L?.markLabel ?? f.MarkLabel ?? oI, ct = L?.input ?? f.Input ?? "input", ut = Y?.root ?? m.root, yt = Y?.rail ?? m.rail, Bt = Y?.track ?? m.track, Ct = Y?.thumb ?? m.thumb, kt = Y?.valueLabel ?? m.valueLabel, Wt = Y?.mark ?? m.mark, We = Y?.markLabel ?? m.markLabel, ue = Y?.input ?? m.input, an = hr({
    elementType: pe,
    getSlotProps: at,
    externalSlotProps: ut,
    externalForwardedProps: D,
    additionalProps: {
      ...ZN(pe) && {
        as: d
      }
    },
    ownerState: {
      ...q,
      ...ut?.ownerState
    },
    className: [Gt.root, v]
  }), pt = hr({
    elementType: Je,
    externalSlotProps: yt,
    ownerState: q,
    className: Gt.rail
  }), Jt = hr({
    elementType: De,
    externalSlotProps: Bt,
    additionalProps: {
      style: {
        ...ot[Rt].offset(wt),
        ...ot[Rt].leap(Yt)
      }
    },
    ownerState: {
      ...q,
      ...Bt?.ownerState
    },
    className: Gt.track
  }), xe = hr({
    elementType: le,
    getSlotProps: dt,
    externalSlotProps: Ct,
    ownerState: {
      ...q,
      ...Ct?.ownerState
    },
    className: Gt.thumb
  }), Ai = hr({
    elementType: xt,
    externalSlotProps: kt,
    ownerState: {
      ...q,
      ...kt?.ownerState
    },
    className: Gt.valueLabel
  }), Vi = hr({
    elementType: sn,
    externalSlotProps: Wt,
    ownerState: q,
    className: Gt.mark
  }), Is = hr({
    elementType: Me,
    externalSlotProps: We,
    ownerState: q,
    className: Gt.markLabel
  }), so = hr({
    elementType: ct,
    getSlotProps: lt,
    externalSlotProps: ue,
    ownerState: q
  });
  return /* @__PURE__ */ et.jsxs(pe, {
    ...an,
    children: [/* @__PURE__ */ et.jsx(Je, {
      ...pt
    }), /* @__PURE__ */ et.jsx(De, {
      ...Jt
    }), Et.filter((we) => we.value >= E && we.value <= w).map((we, tn) => {
      const zs = vh(we.value, E, w), is = ot[Rt].offset(zs);
      let zn;
      return B === !1 ? zn = It.includes(we.value) : zn = B === "normal" && (gt ? we.value >= It[0] && we.value <= It[It.length - 1] : we.value <= It[0]) || B === "inverted" && (gt ? we.value <= It[0] || we.value >= It[It.length - 1] : we.value >= It[0]), /* @__PURE__ */ et.jsxs(O.Fragment, {
        children: [/* @__PURE__ */ et.jsx(sn, {
          "data-index": tn,
          ...Vi,
          ...!Zr(sn) && {
            markActive: zn
          },
          style: {
            ...is,
            ...Vi.style
          },
          className: Lt(Vi.className, zn && Gt.markActive)
        }), we.label != null ? /* @__PURE__ */ et.jsx(Me, {
          "aria-hidden": !0,
          "data-index": tn,
          ...Is,
          ...!Zr(Me) && {
            markLabelActive: zn
          },
          style: {
            ...is,
            ...Is.style
          },
          className: Lt(Gt.markLabel, Is.className, zn && Gt.markLabelActive),
          children: we.label
        }) : null]
      }, tn);
    }), It.map((we, tn) => {
      const zs = vh(we, E, w), is = ot[Rt].offset(zs), zn = rt === "off" ? uI : xt;
      return (
        /* TODO v6: Change component structure. It will help in avoiding the complicated React.cloneElement API added in SliderValueLabel component. Should be: Thumb -> Input, ValueLabel. Follow Joy UI's Slider structure. */
        /* @__PURE__ */ et.jsx(zn, {
          ...!Zr(zn) && {
            valueLabelFormat: J,
            valueLabelDisplay: rt,
            value: typeof J == "function" ? J(M(we), tn) : J,
            index: tn,
            open: ht === tn || Vt === tn || rt === "on",
            disabled: S
          },
          ...Ai,
          children: /* @__PURE__ */ et.jsx(le, {
            "data-index": tn,
            ...xe,
            className: Lt(Gt.thumb, xe.className, Vt === tn && Gt.active, Dt === tn && Gt.focusVisible),
            style: {
              ...is,
              ...Ie(tn),
              ...xe.style
            },
            children: /* @__PURE__ */ et.jsx(ct, {
              "data-index": tn,
              "aria-label": _ ? _(tn) : o,
              "aria-valuenow": M(we),
              "aria-labelledby": c,
              "aria-valuetext": C ? C(M(we), tn) : l,
              value: It[tn],
              ...so
            })
          })
        }, tn)
      );
    })]
  });
});
function hI(n) {
  return Be("MuiTextField", n);
}
ke("MuiTextField", ["root"]);
const dI = {
  standard: ay,
  filled: sy,
  outlined: ly
}, fI = (n) => {
  const {
    classes: t
  } = n;
  return Oe({
    root: ["root"]
  }, hI, t);
}, pI = vt(I5, {
  name: "MuiTextField",
  slot: "Root"
})({}), mI = /* @__PURE__ */ O.forwardRef(function(t, e) {
  const i = Ne({
    props: t,
    name: "MuiTextField"
  }), {
    autoComplete: s,
    autoFocus: o = !1,
    children: l,
    className: c,
    color: d = "primary",
    defaultValue: f,
    disabled: m = !1,
    error: y = !1,
    FormHelperTextProps: b,
    fullWidth: v = !1,
    helperText: x,
    id: S,
    InputLabelProps: _,
    inputProps: C,
    InputProps: R,
    inputRef: w,
    label: E,
    maxRows: P,
    minRows: k,
    multiline: G = !1,
    name: $,
    onBlur: F,
    onChange: j,
    onFocus: H,
    placeholder: M,
    required: Y = !1,
    rows: L,
    select: Q = !1,
    SelectProps: B,
    slots: I = {},
    slotProps: rt = {},
    type: J,
    value: D,
    variant: q = "outlined",
    ...ot
  } = i, at = {
    ...i,
    autoFocus: o,
    color: d,
    disabled: m,
    error: y,
    fullWidth: v,
    multiline: G,
    required: Y,
    select: Q,
    variant: q
  }, lt = fI(at), dt = Kg(S), ht = x && dt ? `${dt}-helper-text` : void 0, Vt = E && dt ? `${dt}-label` : void 0, Rt = dI[q], Dt = {
    slots: I,
    slotProps: {
      input: R,
      inputLabel: _,
      htmlInput: C,
      formHelperText: b,
      select: B,
      ...rt
    }
  }, gt = {}, Pt = Dt.slotProps.inputLabel;
  q === "outlined" && (Pt && typeof Pt.shrink < "u" && (gt.notched = Pt.shrink), gt.label = E), Q && ((!B || !B.native) && (gt.id = void 0), gt["aria-describedby"] = void 0);
  const [Et, It] = Tn("root", {
    elementType: pI,
    shouldForwardComponentProp: !0,
    externalForwardedProps: {
      ...Dt,
      ...ot
    },
    ownerState: at,
    className: Lt(lt.root, c),
    ref: e,
    additionalProps: {
      disabled: m,
      error: y,
      fullWidth: v,
      required: Y,
      color: d,
      variant: q
    }
  }), [wt, Yt] = Tn("input", {
    elementType: Rt,
    externalForwardedProps: Dt,
    additionalProps: gt,
    ownerState: at
  }), [Ie, Gt] = Tn("inputLabel", {
    elementType: eN,
    externalForwardedProps: Dt,
    ownerState: at
  }), [pe, Je] = Tn("htmlInput", {
    elementType: "input",
    externalForwardedProps: Dt,
    ownerState: at
  }), [De, le] = Tn("formHelperText", {
    elementType: H5,
    externalForwardedProps: Dt,
    ownerState: at
  }), [xt, sn] = Tn("select", {
    elementType: iE,
    externalForwardedProps: Dt,
    ownerState: at
  }), Me = /* @__PURE__ */ et.jsx(wt, {
    "aria-describedby": ht,
    autoComplete: s,
    autoFocus: o,
    defaultValue: f,
    fullWidth: v,
    multiline: G,
    name: $,
    rows: L,
    maxRows: P,
    minRows: k,
    type: J,
    value: D,
    id: dt,
    inputRef: w,
    onBlur: F,
    onChange: j,
    onFocus: H,
    placeholder: M,
    inputProps: Je,
    slots: {
      input: I.htmlInput ? pe : void 0
    },
    ...Yt
  });
  return /* @__PURE__ */ et.jsxs(Et, {
    ...It,
    children: [E != null && E !== "" && /* @__PURE__ */ et.jsx(Ie, {
      htmlFor: dt,
      id: Vt,
      ...Gt,
      children: E
    }), Q ? /* @__PURE__ */ et.jsx(xt, {
      "aria-describedby": ht,
      id: dt,
      labelId: Vt,
      value: D,
      input: Me,
      ...sn,
      children: l
    }) : Me, x && /* @__PURE__ */ et.jsx(De, {
      id: ht,
      ...le,
      children: x
    })]
  });
});
function gI() {
  const {
    cells: n,
    rows: t,
    cols: e,
    frames: i,
    createGrid: s,
    toggleCell: o,
    clearGrid: l,
    getCellStates: c,
    updateCellStates: d,
    setFrames: f
  } = EM(), [m, y] = O.useState({
    width: 10,
    height: 10
  }), [b, v] = O.useState(!1), [x, S] = O.useState(0), [_, C] = O.useState([]);
  O.useEffect(() => {
    window.addEventListener("message", ($) => {
      const F = $.data, j = F.data;
      if (console.log("Data from host:", j), F.action === "UPDATE_TABLE") {
        const { table: H } = j;
        console.log("Updating table with:", H), d(H), S((M) => M + 1), f((M) => [...M, H]);
      }
      if (F.action === "PARAMETERS") {
        const { parameters: H } = j;
        console.log(j), console.log("Updating parameters with:", H);
      }
      if (F.action === "IMPORTED_DATA") {
        const { table: H, parameters: M } = j;
        console.log("Importing data:", H, M), y((Y) => (Object.entries(M).forEach(([L, Q]) => {
          L in Y && (console.log(`Setting parameter ${L} to ${Q} (was ${Y[L]})`), Y[L] = Q);
        }), { ...Y })), C(H), S(0);
      }
    });
  }, []), O.useEffect(() => {
    _.length <= 0 || n.length !== _.length || (d(_), f([_]), S(1), C([]));
  }, [_, n.length]), O.useEffect(() => {
    s(m.width, m.height);
  }, [s]), O.useEffect(() => {
    m.width <= 0 || m.height <= 0 || !m.width || !m.height || s(m.width, m.height);
  }, [m.width, m.height]), O.useEffect(() => {
    x <= 0 || x > i.length || d(i[x - 1]);
  }, [x]);
  const R = ($) => {
    o($);
  }, w = () => {
    l();
  }, E = () => {
    const $ = c(), F = {};
    Object.entries(m).forEach(([j, H]) => {
      F[j] = {
        value: H,
        type: typeof H
      };
    }), window.electronAPI.sendToHost({
      action: "EXPORT",
      data: {
        table: $,
        parameters: F
      }
    });
  }, P = () => {
    window.electronAPI.sendToHost({
      action: "IMPORT"
    });
  }, k = () => {
    v(!0), S(1), f([]), f(($) => [...$, c()]), window.electronAPI.sendToHost({
      action: "PLAY_SIMULATION",
      data: {
        parameters: m,
        table: c()
      }
    });
  }, G = () => {
    v(!1), window.electronAPI.sendToHost({
      action: "PAUSE_SIMULATION"
    });
  };
  return /* @__PURE__ */ et.jsxs("div", { className: "h-full w-full relative", children: [
    /* @__PURE__ */ et.jsxs("div", { id: "parameters-panel", className: "absolute text-black top-1/2 right-2 transform -translate-y-1/2 min-w-80 w-1/5 z-10 bg-white/80 backdrop-blur-md rounded-md p-2 shadow-md", children: [
      /* @__PURE__ */ et.jsx("div", { className: "mb-2 font-bold text-center text-2xl", children: "Parameters" }),
      /* @__PURE__ */ et.jsx("div", { className: "flex flex-col gap-4 mb-4", children: Object.entries(m).map(([$, F]) => /* @__PURE__ */ et.jsx(
        mI,
        {
          disabled: b,
          label: $.charAt(0).toUpperCase() + $.slice(1),
          value: F,
          type: "number",
          slotProps: { htmlInput: { min: 1, max: 100 } },
          onChange: (j) => {
            let H = j.target.value;
            Number(H) > 100 && (H = "100"), Number(H) < 1 && (H = "1"), H.length > 3 && (H = H.slice(0, 3)), y({ ...m, [$]: H });
          },
          className: "mb-2 text-white border-white"
        },
        $
      )) }),
      /* @__PURE__ */ et.jsxs("div", { className: "w-full flex flex-col justify-center gap-2", children: [
        /* @__PURE__ */ et.jsx(pl, { variant: "contained", className: "w-full", onClick: w, disabled: b, children: "Clear" }),
        /* @__PURE__ */ et.jsxs(PS, { className: "w-full", children: [
          /* @__PURE__ */ et.jsx(pl, { variant: "contained", onClick: E, className: "w-full", disabled: b, children: "Export Data" }),
          /* @__PURE__ */ et.jsx(pl, { variant: "contained", onClick: P, className: "w-full", disabled: b, children: "Import Data" })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ et.jsxs(
      "div",
      {
        id: "player-panel",
        className: `absolute flex flex-col bottom-4 left-1/2 transform -translate-x-1/2 text-black
                        min-w-80 w-1/2 z-10 bg-white/80 backdrop-blur-md rounded-md
                        py-2 px-5 shadow-md justify-center items-center gap-2`,
        children: [
          /* @__PURE__ */ et.jsxs(PS, { className: "justify-center w-1/5", children: [
            /* @__PURE__ */ et.jsx(pl, { variant: "contained", className: "w-full", disabled: b, onClick: k, children: "Play" }),
            /* @__PURE__ */ et.jsx(pl, { variant: "contained", className: "w-full", disabled: !b, onClick: G, children: "Pause" })
          ] }),
          /* @__PURE__ */ et.jsxs("div", { className: "w-full flex flex-col", children: [
            /* @__PURE__ */ et.jsx("label", { className: "flex w-full font-bold justify-start", children: "Frames" }),
            /* @__PURE__ */ et.jsx(
              cI,
              {
                className: "w-1/2",
                disabled: b,
                value: x,
                onChange: ($, F) => S(F),
                "aria-labelledby": "continuous-slider",
                min: 1,
                max: i.length
              }
            ),
            /* @__PURE__ */ et.jsxs("span", { className: "flex w-full justify-end", children: [
              x,
              " / ",
              i.length
            ] })
          ] })
        ]
      }
    ),
    /* @__PURE__ */ et.jsx(
      GO,
      {
        cells: n,
        rows: t,
        cols: e,
        onCellClick: R
      }
    )
  ] });
}
CM.createRoot(document.getElementById("root")).render(
  /* @__PURE__ */ et.jsx(gI, {})
);
Nt.add(IA);
Nt.mixin(Rn, zA);
Nt.add(X1);
Nt.add(q1);
Nt.add(yT);
Nt.mixin(Rn, wB);
Nt.add(gT);
Nt.add(Vw);
Nt.add(gg);
Nt.add(Xw);
Nt.add(Kw);
Nt.add(Zw);
Nt.add(oC);
Nt.add(aC);
Nt.add(nC);
Nt.add(sC);
Nt.add(iC);
Nt.add(eC);
Nt.add(tC);
Nt.add(vT);
Nt.add(bT);
const yI = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), bI = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" }));
